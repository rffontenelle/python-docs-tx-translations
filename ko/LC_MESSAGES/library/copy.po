# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# seungho, kim <raccoonyy@gmail.com>, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:03+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Korean (https://app.transifex.com/python-doc/teams/5390/ko/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/copy.rst:2
msgid ":mod:`!copy` --- Shallow and deep copy operations"
msgstr ""

#: ../../library/copy.rst:7
msgid "**Source code:** :source:`Lib/copy.py`"
msgstr "**소스 코드:** :source:`Lib/copy.py`"

#: ../../library/copy.rst:11
msgid ""
"Assignment statements in Python do not copy objects, they create bindings "
"between a target and an object. For collections that are mutable or contain "
"mutable items, a copy is sometimes needed so one can change one copy without "
"changing the other. This module provides generic shallow and deep copy "
"operations (explained below)."
msgstr ""
"파이썬의 대입문은 객체를 복사하지 않고, 복사 대상과 객체 사이의 연결을 생성한"
"다. 변경 가능하거나 변경 가능한 항목을 포함하는 컬렉션의 경우, 때때로 원본 컬"
"렉션의 변경 되지 않도록 사본이 필요하다. 이 모듈은 얕은 복사와 깊은 복사 작업"
"을 제공한다(아래 설명된다)."

#: ../../library/copy.rst:18
msgid "Interface summary:"
msgstr "인터페이스 요약:"

#: ../../library/copy.rst:22
msgid "Return a shallow copy of *obj*."
msgstr ""

#: ../../library/copy.rst:27
msgid "Return a deep copy of *obj*."
msgstr ""

#: ../../library/copy.rst:32
msgid ""
"Creates a new object of the same type as *obj*, replacing fields with values "
"from *changes*."
msgstr ""

#: ../../library/copy.rst:40
msgid "Raised for module specific errors."
msgstr "모듈의 특정 에러들을 발생시킨다."

#: ../../library/copy.rst:44
msgid ""
"The difference between shallow and deep copying is only relevant for "
"compound objects (objects that contain other objects, like lists or class "
"instances):"
msgstr ""
"얕은 복사와 깊은 복사의 차이점은 오직 복합 객체(리스트나 클래스 인스턴스와 같"
"은 다른 객체를 포함하는 객체)에서만 관련이 있다:"

#: ../../library/copy.rst:47
msgid ""
"A *shallow copy* constructs a new compound object and then (to the extent "
"possible) inserts *references* into it to the objects found in the original."
msgstr ""
"*얕은 복사*는 신규 복합 객체를 구성하고, (가능한 범위 내에서) 원본에서 찾은 "
"객체의 *참조*를 신규 복합 객체에 삽입한다."

#: ../../library/copy.rst:50
msgid ""
"A *deep copy* constructs a new compound object and then, recursively, "
"inserts *copies* into it of the objects found in the original."
msgstr ""
"*깊은 복사*는 신규 복합 객체를 구성하고, 재귀적으로 원본에서 찾은 객체의 *복"
"사본*을 신규 복합 객체에 삽입한다. "

#: ../../library/copy.rst:53
msgid ""
"Two problems often exist with deep copy operations that don't exist with "
"shallow copy operations:"
msgstr "얕은 복사에서 없지만, 깊은 복사에서는 두 가지 문제들이 존재한다."

#: ../../library/copy.rst:56
msgid ""
"Recursive objects (compound objects that, directly or indirectly, contain a "
"reference to themselves) may cause a recursive loop."
msgstr ""
"재귀 객체(직접적/간접적으로 자기 자신 참조를 포함하는 복합 객체)는 재귀 루프"
"를 야기할 수 있다. "

#: ../../library/copy.rst:59
msgid ""
"Because deep copy copies everything it may copy too much, such as data which "
"is intended to be shared between copies."
msgstr ""
"깊은 복사는 모든 것을 복사 하기 때문에, 복사본 간에 공유되어야 할 데이터까지"
"도 과도하게 복사 될 수 있다. "

#: ../../library/copy.rst:62
msgid "The :func:`deepcopy` function avoids these problems by:"
msgstr ":func:`deepcopy` 함수는 다음을 통해 이러한 문제를 방지한다:"

#: ../../library/copy.rst:64
msgid ""
"keeping a ``memo`` dictionary of objects already copied during the current "
"copying pass; and"
msgstr ""
"현재 복사가 진행되는 동안 이미 복사 된 항목들을 객체에 ``memo`` 사전에 보관한"
"다; 그리고"

#: ../../library/copy.rst:67
msgid ""
"letting user-defined classes override the copying operation or the set of "
"components copied."
msgstr ""
"사용자 정의 클래스가 복사 작업이나 복사 된 구성 요소 집합을 재정의 할 수 있도"
"록 허용한다."

#: ../../library/copy.rst:70
msgid ""
"This module does not copy types like module, method, stack trace, stack "
"frame, file, socket, window, or any similar types.  It does \"copy\" "
"functions and classes (shallow and deeply), by returning the original object "
"unchanged; this is compatible with the way these are treated by the :mod:"
"`pickle` module."
msgstr ""
" 이 모듈은 모듈, 메소드, 스택 트레이스, 스택 프레임, 파일, 소켓, 윈도우 또는 "
"비슷한 유형에 대해 복사하지 않는다. 원래 객체를 변경하지 않고 반환하여, 함수"
"와 클래스를 (얕고 깊게) \"복사\"한다; 이것은 :mod:`pickle` 모듈에서 다루는 방"
"식과 호환 가능하다."

#: ../../library/copy.rst:75
msgid ""
"Shallow copies of dictionaries can be made using :meth:`dict.copy`, and of "
"lists by assigning a slice of the entire list, for example, ``copied_list = "
"original_list[:]``."
msgstr ""
":meth:`dict.copy`를 이용해 사전의 얕은 복사본을 만들 수 있다. 그리고 전체 리"
"스트의 슬라이스를 할당하는 방식을 통해 리스트의 얕은 복사본을 만들 수 있다. "
"예시:``copied_list = original_list[:]``"

#: ../../library/copy.rst:81
msgid ""
"Classes can use the same interfaces to control copying that they use to "
"control pickling.  See the description of module :mod:`pickle` for "
"information on these methods.  In fact, the :mod:`copy` module uses the "
"registered pickle functions from the :mod:`copyreg` module."
msgstr ""
"클래스는 피클링을 제어하는 데 사용하는 것과 동일한 인터페이스를 사용하여 복사"
"를 제어할 수 있다. 이 메소드의 정보를 확인하기 위해 :mod:`pickle` 모듈의 설명"
"을 참조해라. 실제,  :mod:`copy` 모듈은 :mod:`copyreg` 모듈에 등록된 피클 함수"
"들을 사용한다."

#: ../../library/copy.rst:92
msgid ""
"In order for a class to define its own copy implementation, it can define "
"special methods :meth:`~object.__copy__` and :meth:`~object.__deepcopy__`."
msgstr ""

#: ../../library/copy.rst:98
msgid ""
"Called to implement the shallow copy operation; no additional arguments are "
"passed."
msgstr ""

#: ../../library/copy.rst:104
msgid ""
"Called to implement the deep copy operation; it is passed one argument, the "
"*memo* dictionary.  If the ``__deepcopy__`` implementation needs to make a "
"deep copy of a component, it should call the :func:`~copy.deepcopy` function "
"with the component as first argument and the *memo* dictionary as second "
"argument. The *memo* dictionary should be treated as an opaque object."
msgstr ""

#: ../../library/copy.rst:114
msgid ""
"Function :func:`!copy.replace` is more limited than :func:`~copy.copy` and :"
"func:`~copy.deepcopy`, and only supports named tuples created by :func:"
"`~collections.namedtuple`, :mod:`dataclasses`, and other classes which "
"define method :meth:`~object.__replace__`."
msgstr ""

#: ../../library/copy.rst:122
msgid ""
"This method should create a new object of the same type, replacing fields "
"with values from *changes*."
msgstr ""

#: ../../library/copy.rst:128
msgid "Module :mod:`pickle`"
msgstr ":mod:`pickle` 모듈"

#: ../../library/copy.rst:129
msgid ""
"Discussion of the special methods used to support object state retrieval and "
"restoration."
msgstr "객체 상태 검색 및 복원을 지원하는데 사용되는 특별한 메소드에 대한 논의"

#: ../../library/copy.rst:79
msgid "module"
msgstr "모듈"

#: ../../library/copy.rst:79
msgid "pickle"
msgstr ""

#: ../../library/copy.rst:86
msgid "__copy__() (copy protocol)"
msgstr ""

#: ../../library/copy.rst:86
msgid "__deepcopy__() (copy protocol)"
msgstr ""

#: ../../library/copy.rst:111
msgid "__replace__() (replace protocol)"
msgstr ""
