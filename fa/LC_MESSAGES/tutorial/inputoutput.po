# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Alireza Shabani <theRevisto@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-21 17:04+0000\n"
"PO-Revision-Date: 2017-02-16 23:40+0000\n"
"Last-Translator: Alireza Shabani <theRevisto@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/inputoutput.rst:5
msgid "Input and Output"
msgstr "Input and Output"

#: ../../tutorial/inputoutput.rst:7
msgid ""
"There are several ways to present the output of a program; data can be "
"printed in a human-readable form, or written to a file for future use. This "
"chapter will discuss some of the possibilities."
msgstr ""
"راه های مختلفی برای ارائه خروجی یک برنامه وجود دارد. داده ها را می توان به "
"شکل قابل خواندن توسط انسان چاپ کرد یا برای استفاده در آینده در یک فایل نوشت."
" این فصل برخی از احتمالات را مورد بحث قرار خواهد داد."

#: ../../tutorial/inputoutput.rst:15
msgid "Fancier Output Formatting"
msgstr "قالب بندی خروجی فانتزی"

#: ../../tutorial/inputoutput.rst:17
msgid ""
"So far we've encountered two ways of writing values: *expression statements*"
" and the :func:`print` function.  (A third way is using the :meth:`write` "
"method of file objects; the standard output file can be referenced as "
"``sys.stdout``. See the Library Reference for more information on this.)"
msgstr ""

#: ../../tutorial/inputoutput.rst:22
msgid ""
"Often you'll want more control over the formatting of your output than "
"simply printing space-separated values. There are several ways to format "
"output."
msgstr ""
"اغلب شما می خواهید کنترل بیشتری بر قالب بندی خروجی خود داشته باشید تا صرفاً "
"چاپ مقادیر جدا شده از فضا. روش های مختلفی برای فرمت کردن خروجی وجود دارد."

#: ../../tutorial/inputoutput.rst:25
msgid ""
"To use :ref:`formatted string literals <tut-f-strings>`, begin a string with"
" ``f`` or ``F`` before the opening quotation mark or triple quotation mark. "
"Inside this string, you can write a Python expression between ``{`` and "
"``}`` characters that can refer to variables or literal values."
msgstr ""
"برای استفاده از :ref:`formatted string literals <tut-f-strings>`، یک رشته را"
" با ``f`` یا ``F`` قبل از گیومه آغازین یا علامت نقل قول سه گانه شروع کنید. "
"در داخل این رشته، می‌توانید یک عبارت پایتون بین کاراکترهای ``{`` و ``}`` "
"بنویسید که می‌تواند به متغیرها یا مقادیر واقعی اشاره کند."

#: ../../tutorial/inputoutput.rst:37
msgid ""
"The :meth:`str.format` method of strings requires more manual effort.  "
"You'll still use ``{`` and ``}`` to mark where a variable will be "
"substituted and can provide detailed formatting directives, but you'll also "
"need to provide the information to be formatted."
msgstr ""

#: ../../tutorial/inputoutput.rst:50
msgid ""
"Finally, you can do all the string handling yourself by using string slicing"
" and concatenation operations to create any layout you can imagine.  The "
"string type has some methods that perform useful operations for padding "
"strings to a given column width."
msgstr ""
"در نهایت، می‌توانید با استفاده از عملیات برش و الحاق رشته‌ها برای ایجاد هر "
"طرحی که می‌توانید تصور کنید، تمام مدیریت رشته را خودتان انجام دهید.  نوع "
"رشته دارای روش‌هایی است که عملیات مفیدی را برای قرار دادن رشته‌ها به عرض "
"ستون معین انجام می‌دهد."

#: ../../tutorial/inputoutput.rst:55
msgid ""
"When you don't need fancy output but just want a quick display of some "
"variables for debugging purposes, you can convert any value to a string with"
" the :func:`repr` or :func:`str` functions."
msgstr ""
"هنگامی که به خروجی فانتزی نیاز ندارید اما فقط می خواهید یک نمایش سریع از "
"برخی متغیرها برای اهداف اشکال زدایی داشته باشید، می توانید هر مقداری را با "
"توابع :func:`repr` یا :func:`str` به رشته ای تبدیل کنید."

#: ../../tutorial/inputoutput.rst:59
msgid ""
"The :func:`str` function is meant to return representations of values which "
"are fairly human-readable, while :func:`repr` is meant to generate "
"representations which can be read by the interpreter (or will force a "
":exc:`SyntaxError` if there is no equivalent syntax).  For objects which "
"don't have a particular representation for human consumption, :func:`str` "
"will return the same value as :func:`repr`.  Many values, such as numbers or"
" structures like lists and dictionaries, have the same representation using "
"either function.  Strings, in particular, have two distinct representations."
msgstr ""
"تابع :func:`str` برای برگرداندن نمایش‌هایی از مقادیری است که نسبتاً قابل "
"خواندن توسط انسان هستند، در حالی که :func:`repr` برای تولید نمایش‌هایی است "
"که می‌توانند توسط مفسر خوانده شوند (یا اگر دستوری معادل وجود نداشته باشد "
":exc:`SyntaxError` را مجبور می‌کند).  برای اشیایی که نمایش خاصی برای مصرف "
"انسان ندارند، :func:`str` همان مقدار :func:`repr` را برمی‌گرداند.  بسیاری از"
" مقادیر، مانند اعداد یا ساختارهایی مانند لیست ها و فرهنگ لغت ها، با استفاده "
"از هر یک از تابع ها نمایش یکسانی دارند.  رشته ها، به ویژه، دو نمایش مجزا "
"دارند."

#: ../../tutorial/inputoutput.rst:68
msgid "Some examples::"
msgstr "چند نمونه::"

#: ../../tutorial/inputoutput.rst:91
msgid ""
"The :mod:`string` module contains a :class:`~string.Template` class that "
"offers yet another way to substitute values into strings, using placeholders"
" like ``$x`` and replacing them with values from a dictionary, but offers "
"much less control of the formatting."
msgstr ""
"ماژول :mod:`string` شامل یک کلاس :class:`~string.Template` است که راه دیگری "
"را برای جایگزینی مقادیر به رشته ها، با استفاده از متغیرهایی مانند ``$x`` و "
"جایگزینی آنها با مقادیر یک فرهنگ لغت ارائه می دهد، اما کنترل بسیار کمتری بر "
"قالب بندی ارائه می دهد."

#: ../../tutorial/inputoutput.rst:100
msgid "Formatted String Literals"
msgstr "رشته های قالب بندی شده"

#: ../../tutorial/inputoutput.rst:102
msgid ""
":ref:`Formatted string literals <f-strings>` (also called f-strings for "
"short) let you include the value of Python expressions inside a string by "
"prefixing the string with ``f`` or ``F`` and writing expressions as "
"``{expression}``."
msgstr ""
":ref:`Formatted string literals <f-strings>` (که به اختصار رشته‌های f نیز "
"نامیده می‌شود) به شما امکان می‌دهد با پیشوند رشته با ``f`` یا ``F`` و نوشتن "
"عبارات به‌عنوان ``{expression}``، مقدار عبارات پایتون را در داخل یک رشته "
"قرار دهید."

#: ../../tutorial/inputoutput.rst:107
msgid ""
"An optional format specifier can follow the expression. This allows greater "
"control over how the value is formatted. The following example rounds pi to "
"three places after the decimal::"
msgstr ""
"یک مشخص کننده فرمت اختیاری می تواند عبارت را دنبال کند. این اجازه می دهد تا "
"کنترل بیشتری بر نحوه قالب بندی مقدار داشته باشید. مثال زیر پی را به سه مکان "
"بعد از اعشار گرد می کند:"

#: ../../tutorial/inputoutput.rst:115
msgid ""
"Passing an integer after the ``':'`` will cause that field to be a minimum "
"number of characters wide.  This is useful for making columns line up. ::"
msgstr ""
"عبور یک عدد صحیح بعد از ``':'`` باعث می شود که آن فیلد حداقل تعداد کاراکترها"
" را داشته باشد.  این برای ایجاد ردیف ستون ها مفید است. ::"

#: ../../tutorial/inputoutput.rst:126
msgid ""
"Other modifiers can be used to convert the value before it is formatted. "
"``'!a'`` applies :func:`ascii`, ``'!s'`` applies :func:`str`, and ``'!r'`` "
"applies :func:`repr`::"
msgstr ""
"برای تبدیل مقدار قبل از قالب بندی می توان از اصلاح کننده های دیگر استفاده "
"کرد. ``'!a'`` :func:`ascii` را اعمال می کند، ``'!s'`` :func:`str` را اعمال "
"می کند و ``'!r'`` :func:`repr` را اعمال می کند::"

#: ../../tutorial/inputoutput.rst:136
msgid ""
"For a reference on these format specifications, see the reference guide for "
"the :ref:`formatspec`."
msgstr ""

#: ../../tutorial/inputoutput.rst:142
msgid "The String format() Method"
msgstr "روش String format()."

#: ../../tutorial/inputoutput.rst:144
msgid "Basic usage of the :meth:`str.format` method looks like this::"
msgstr "استفاده اصلی از روش :meth:`str.format` به این صورت است:"

#: ../../tutorial/inputoutput.rst:149
msgid ""
"The brackets and characters within them (called format fields) are replaced "
"with the objects passed into the :meth:`str.format` method.  A number in the"
" brackets can be used to refer to the position of the object passed into the"
" :meth:`str.format` method. ::"
msgstr ""
"براکت ها و کاراکترهای درون آنها (که فیلدهای قالب نامیده می شوند) با اشیاء "
"ارسال شده به روش :meth:`str.format` جایگزین می شوند.  می توان از یک عدد در "
"براکت ها برای اشاره به موقعیت شیء ارسال شده به روش :meth:`str.format` "
"استفاده کرد. ::"

#: ../../tutorial/inputoutput.rst:159
msgid ""
"If keyword arguments are used in the :meth:`str.format` method, their values"
" are referred to by using the name of the argument. ::"
msgstr ""
"اگر از آرگومان های کلیدواژه در روش :meth:`str.format` استفاده شود، مقادیر "
"آنها با استفاده از نام آرگومان ارجاع داده می شود. ::"

#: ../../tutorial/inputoutput.rst:166
msgid "Positional and keyword arguments can be arbitrarily combined::"
msgstr ""
"آرگومان های موقعیت و کلمه کلیدی را می توان به صورت دلخواه با هم ترکیب کرد:"

#: ../../tutorial/inputoutput.rst:172
msgid ""
"If you have a really long format string that you don't want to split up, it "
"would be nice if you could reference the variables to be formatted by name "
"instead of by position.  This can be done by simply passing the dict and "
"using square brackets ``'[]'`` to access the keys. ::"
msgstr ""
"اگر رشته‌ای با فرمت بسیار طولانی دارید که نمی‌خواهید آن را از هم جدا کنید، "
"خوب است اگر بتوانید به متغیرها اشاره کنید که با نام قالب‌بندی شوند به جای "
"موقعیت.  این کار را می توان با عبور دادن دستور و استفاده از براکت های مربع "
"``'[]'`` برای دسترسی به کلیدها انجام داد. ::"

#: ../../tutorial/inputoutput.rst:182
msgid ""
"This could also be done by passing the table as keyword arguments with the "
"'**' notation. ::"
msgstr ""

#: ../../tutorial/inputoutput.rst:189
msgid ""
"This is particularly useful in combination with the built-in function "
":func:`vars`, which returns a dictionary containing all local variables."
msgstr ""

#: ../../tutorial/inputoutput.rst:192
msgid ""
"As an example, the following lines produce a tidily-aligned set of columns "
"giving integers and their squares and cubes::"
msgstr ""

#: ../../tutorial/inputoutput.rst:209
msgid ""
"For a complete overview of string formatting with :meth:`str.format`, see "
":ref:`formatstrings`."
msgstr ""
"برای یک نمای کلی از قالب بندی رشته با :meth:`str.format`، به "
":ref:`formatstrings` مراجعه کنید."

#: ../../tutorial/inputoutput.rst:214
msgid "Manual String Formatting"
msgstr "قالب بندی رشته های دستی"

#: ../../tutorial/inputoutput.rst:216
msgid "Here's the same table of squares and cubes, formatted manually::"
msgstr "در اینجا همان جدول مربع و مکعب است که به صورت دستی فرمت شده است:"

#: ../../tutorial/inputoutput.rst:234
msgid ""
"(Note that the one space between each column was added by the way "
":func:`print` works: it always adds spaces between its arguments.)"
msgstr ""
"(توجه داشته باشید که یک فاصله بین هر ستون با روش کار :func:`print` اضافه شده"
" است: همیشه بین آرگومان های خود فاصله اضافه می کند.)"

#: ../../tutorial/inputoutput.rst:237
msgid ""
"The :meth:`str.rjust` method of string objects right-justifies a string in a"
" field of a given width by padding it with spaces on the left. There are "
"similar methods :meth:`str.ljust` and :meth:`str.center`. These methods do "
"not write anything, they just return a new string. If the input string is "
"too long, they don't truncate it, but return it unchanged; this will mess up"
" your column lay-out but that's usually better than the alternative, which "
"would be lying about a value. (If you really want truncation you can always "
"add a slice operation, as in ``x.ljust(n)[:n]``.)"
msgstr ""
"روش :meth:`str.rjust` برای اشیاء رشته‌ای، رشته‌ای را در یک میدان با عرض معین"
" با پر کردن آن با فاصله‌های سمت چپ توجیه می‌کند. روش های مشابه "
":meth:`str.ljust` و :meth:`str.center` وجود دارد. این متدها چیزی نمی نویسند،"
" فقط یک رشته جدید برمی گردانند. اگر رشته ورودی خیلی طولانی باشد، آن را کوتاه"
" نمی‌کنند، بلکه آن را بدون تغییر برمی‌گردانند. این طرح بندی ستون شما را به "
"هم می زند، اما معمولاً بهتر از گزینه جایگزین است که در مورد یک مقدار دروغ می"
" گوید. (اگر واقعاً می‌خواهید کوتاه‌سازی کنید, همیشه می‌توانید عملیات برش را "
"مانند ``x.ljust(n)[:n]`` اضافه کنید.)"

#: ../../tutorial/inputoutput.rst:246
msgid ""
"There is another method, :meth:`str.zfill`, which pads a numeric string on "
"the left with zeros.  It understands about plus and minus signs::"
msgstr ""
"روش دیگری به نام :meth:`str.zfill` وجود دارد که یک رشته عددی را در سمت چپ با"
" صفر قرار می دهد.  علائم مثبت و منفی را درک می کند:"

#: ../../tutorial/inputoutput.rst:258
msgid "Old string formatting"
msgstr "قالب بندی رشته های قدیمی"

#: ../../tutorial/inputoutput.rst:260
msgid ""
"The % operator (modulo) can also be used for string formatting. Given "
"``'string' % values``, instances of ``%`` in ``string`` are replaced with "
"zero or more elements of ``values``. This operation is commonly known as "
"string interpolation. For example::"
msgstr ""

#: ../../tutorial/inputoutput.rst:269
msgid ""
"More information can be found in the :ref:`old-string-formatting` section."
msgstr ""
"اطلاعات بیشتر را می توانید در بخش :ref:`old-string-formatting` بیابید."

#: ../../tutorial/inputoutput.rst:275
msgid "Reading and Writing Files"
msgstr "خواندن و نوشتن فایل ها"

#: ../../tutorial/inputoutput.rst:281
msgid ""
":func:`open` returns a :term:`file object`, and is most commonly used with "
"two positional arguments and one keyword argument: ``open(filename, mode, "
"encoding=None)``"
msgstr ""
":func:`open` یک :term:`file object` برمی گرداند و بیشتر با دو آرگومان "
"موقعیتی و یک آرگومان کلمه کلیدی استفاده می شود: ``open(filename, mode, "
"encoding=None)``"

#: ../../tutorial/inputoutput.rst:294
msgid ""
"The first argument is a string containing the filename.  The second argument"
" is another string containing a few characters describing the way in which "
"the file will be used.  *mode* can be ``'r'`` when the file will only be "
"read, ``'w'`` for only writing (an existing file with the same name will be "
"erased), and ``'a'`` opens the file for appending; any data written to the "
"file is automatically added to the end.  ``'r+'`` opens the file for both "
"reading and writing. The *mode* argument is optional; ``'r'`` will be "
"assumed if it's omitted."
msgstr ""
"آرگومان اول رشته ای است که نام فایل را در خود دارد.  آرگومان دوم رشته دیگری "
"است که حاوی چند کاراکتر است که نحوه استفاده از فایل را توصیف می کند.  *mode*"
" می تواند ``'r'`` باشد زمانی که فایل فقط خوانده شود، ``'w'`` فقط برای نوشتن "
"(فایل موجود با همین نام پاک می شود) و ``'a'`` فایل را برای الحاق باز می کند."
" هر داده ای که در فایل نوشته شده است به طور خودکار به انتها اضافه می شود.  "
"``'r+'`` فایل را برای خواندن و نوشتن باز می کند. آرگومان *mode* اختیاری است."
" در صورت حذف ``'r'`` فرض می شود."

#: ../../tutorial/inputoutput.rst:303
msgid ""
"Normally, files are opened in :dfn:`text mode`, that means, you read and "
"write strings from and to the file, which are encoded in a specific "
"*encoding*. If *encoding* is not specified, the default is platform "
"dependent (see :func:`open`). Because UTF-8 is the modern de-facto standard,"
" ``encoding=\"utf-8\"`` is recommended unless you know that you need to use "
"a different encoding. Appending a ``'b'`` to the mode opens the file in "
":dfn:`binary mode`. Binary mode data is read and written as :class:`bytes` "
"objects. You can not specify *encoding* when opening file in binary mode."
msgstr ""
"معمولاً فایل‌ها در حالت :dfn:`text mode` باز می‌شوند، به این معنی که شما "
"رشته‌هایی را از و به فایل می‌خوانید و می‌نویسید که در یک *encoding* کدگذاری "
"شده‌اند. اگر *encoding* مشخص نشده باشد، پیش‌فرض به پلتفرم وابسته است (به "
":func:`open` مراجعه کنید). از آنجایی که UTF-8 استاندارد واقعی مدرن است، "
"``encoding=\"utf-8\"`` توصیه می‌شود مگر اینکه بدانید که باید از رمزگذاری "
"دیگری استفاده کنید. با افزودن یک ``'b'`` به حالت، فایل در :dfn:`حالت باینری`"
" باز می‌شود. داده‌های حالت باینری به صورت اشیاء :class:`bytes` خوانده و "
"نوشته می‌شوند. هنگام باز کردن فایل در حالت باینری نمی‌توانید *encoding* را "
"مشخص کنید."

#: ../../tutorial/inputoutput.rst:313
msgid ""
"In text mode, the default when reading is to convert platform-specific line "
"endings (``\\n`` on Unix, ``\\r\\n`` on Windows) to just ``\\n``.  When "
"writing in text mode, the default is to convert occurrences of ``\\n`` back "
"to platform-specific line endings.  This behind-the-scenes modification to "
"file data is fine for text files, but will corrupt binary data like that in "
":file:`JPEG` or :file:`EXE` files.  Be very careful to use binary mode when "
"reading and writing such files."
msgstr ""
"در حالت متنی، پیش‌فرض هنگام خواندن، تبدیل انتهای خطوط مخصوص پلتفرم (``\\n`` "
"در یونیکس, ``\\r\\n`` در ویندوز) فقط به ``\\n`` است.  هنگام نوشتن در حالت "
"متنی، پیش‌فرض این است که رخدادهای ``\\n`` را به انتهای خط‌های مخصوص پلتفرم "
"تبدیل کنید.  این تغییر پشت صحنه برای داده های فایل برای فایل های متنی مناسب "
"است، اما داده های باینری مانند فایل های :file:`JPEG` یا :file:`EXE` را خراب "
"می کند.  هنگام خواندن و نوشتن چنین فایل هایی بسیار مراقب باشید که از حالت "
"باینری استفاده کنید."

#: ../../tutorial/inputoutput.rst:321
msgid ""
"It is good practice to use the :keyword:`with` keyword when dealing with "
"file objects.  The advantage is that the file is properly closed after its "
"suite finishes, even if an exception is raised at some point.  Using "
":keyword:`!with` is also much shorter than writing equivalent "
":keyword:`try`\\ -\\ :keyword:`finally` blocks::"
msgstr ""
"استفاده از کلمه کلیدی :keyword:`with` هنگام برخورد با اشیاء فایل تمرین خوبی "
"است.  مزیت این است که فایل پس از اتمام مجموعه به درستی بسته می شود، حتی اگر "
"در نقطه ای استثنا مطرح شود.  استفاده از :keyword:`!with` نیز بسیار کوتاهتر "
"از نوشتن بلوک های معادل :keyword:`try`\\ -\\ :keyword:`finally` است::"

#: ../../tutorial/inputoutput.rst:334
msgid ""
"If you're not using the :keyword:`with` keyword, then you should call "
"``f.close()`` to close the file and immediately free up any system resources"
" used by it."
msgstr ""
"اگر از کلمه کلیدی :keyword:`with` استفاده نمی کنید، باید با ``f.close()`` "
"تماس بگیرید تا فایل را ببندید و فوراً منابع سیستمی که توسط آن استفاده می شود"
" آزاد کنید."

#: ../../tutorial/inputoutput.rst:339
msgid ""
"Calling ``f.write()`` without using the :keyword:`!with` keyword or calling "
"``f.close()`` **might** result in the arguments of ``f.write()`` not being "
"completely written to the disk, even if the program exits successfully."
msgstr ""
"فراخوانی ``f.write()`` بدون استفاده از کلمه کلیدی :keyword:`!with` یا "
"فراخوانی ``f.close()`` **might** باعث می شود که آرگومان های ``f.write()`` به"
" طور کامل روی دیسک نوشته نشود، حتی اگر برنامه با موفقیت خارج شود."

#: ../../tutorial/inputoutput.rst:347
msgid ""
"After a file object is closed, either by a :keyword:`with` statement or by "
"calling ``f.close()``, attempts to use the file object will automatically "
"fail. ::"
msgstr ""
"پس از بسته شدن یک شی فایل، یا با دستور :keyword:`with` یا با فراخوانی "
"``f.close()``، تلاش برای استفاده از شی فایل به طور خودکار شکست خواهد خورد. "
"::"

#: ../../tutorial/inputoutput.rst:361
msgid "Methods of File Objects"
msgstr "روش های فایل اشیاء"

#: ../../tutorial/inputoutput.rst:363
msgid ""
"The rest of the examples in this section will assume that a file object "
"called ``f`` has already been created."
msgstr ""
"بقیه مثال های این بخش فرض می کنند که یک شی فایل به نام ``f`` قبلا ایجاد شده "
"است."

#: ../../tutorial/inputoutput.rst:366
msgid ""
"To read a file's contents, call ``f.read(size)``, which reads some quantity "
"of data and returns it as a string (in text mode) or bytes object (in binary"
" mode). *size* is an optional numeric argument.  When *size* is omitted or "
"negative, the entire contents of the file will be read and returned; it's "
"your problem if the file is twice as large as your machine's memory. "
"Otherwise, at most *size* characters (in text mode) or *size* bytes (in "
"binary mode) are read and returned. If the end of the file has been reached,"
" ``f.read()`` will return an empty string (``''``).  ::"
msgstr ""
"برای خواندن محتویات یک فایل، با ``f.read(size)`` تماس بگیرید، که مقداری از "
"داده را می خواند و آن را به صورت رشته (در حالت متنی) یا شی بایت (در حالت "
"باینری) برمی گرداند. *size* یک آرگومان عددی اختیاری است.  هنگامی که *size* "
"حذف یا منفی باشد، کل محتویات فایل خوانده شده و برگردانده می شود. اگر حجم "
"فایل دو برابر حافظه دستگاه شما باشد، مشکل شماست. در غیر این صورت، حداکثر "
"کاراکترهای *size* (در حالت متنی) یا *size* بایت (در حالت باینری) خوانده و "
"برگردانده می شوند. اگر به پایان فایل رسیده باشد، ``f.read()`` یک رشته خالی "
"(``''``) برمی گرداند.  ::"

#: ../../tutorial/inputoutput.rst:380
msgid ""
"``f.readline()`` reads a single line from the file; a newline character "
"(``\\n``) is left at the end of the string, and is only omitted on the last "
"line of the file if the file doesn't end in a newline.  This makes the "
"return value unambiguous; if ``f.readline()`` returns an empty string, the "
"end of the file has been reached, while a blank line is represented by "
"``'\\n'``, a string containing only a single newline.  ::"
msgstr ""
"``f.readline()`` یک خط از فایل را می خواند. یک کاراکتر خط جدید (``\\n``) در "
"انتهای رشته باقی می‌ماند و تنها در صورتی که فایل به خط جدید ختم نشود، در "
"آخرین خط فایل حذف می‌شود.  این باعث می شود مقدار بازگشتی مبهم باشد. اگر "
"``f.readline()`` یک رشته خالی را برگرداند، به انتهای فایل رسیده است، در حالی"
" که یک خط خالی با ``'\\n'`` نشان داده می شود، رشته ای که فقط یک خط جدید "
"دارد.  ::"

#: ../../tutorial/inputoutput.rst:394
msgid ""
"For reading lines from a file, you can loop over the file object. This is "
"memory efficient, fast, and leads to simple code::"
msgstr ""
"برای خواندن خطوط از یک فایل، می توانید روی شی فایل حلقه بزنید. این حافظه "
"کارآمد، سریع است و منجر به کدهای ساده می شود:"

#: ../../tutorial/inputoutput.rst:403
msgid ""
"If you want to read all the lines of a file in a list you can also use "
"``list(f)`` or ``f.readlines()``."
msgstr ""
"اگر می خواهید تمام خطوط یک فایل را در یک لیست بخوانید، می توانید از "
"``list(f)`` یا ``f.readlines()`` نیز استفاده کنید."

#: ../../tutorial/inputoutput.rst:406
msgid ""
"``f.write(string)`` writes the contents of *string* to the file, returning "
"the number of characters written. ::"
msgstr ""
"``f.write(string)`` محتویات *string* را در فایل می نویسد و تعداد کاراکترهای "
"نوشته شده را برمی گرداند. ::"

#: ../../tutorial/inputoutput.rst:412
msgid ""
"Other types of objects need to be converted -- either to a string (in text "
"mode) or a bytes object (in binary mode) -- before writing them::"
msgstr ""
"انواع دیگر اشیاء باید قبل از نوشتن آنها تبدیل شوند - یا به یک رشته (در حالت "
"متنی) یا یک شی بایت (در حالت باینری) -"

#: ../../tutorial/inputoutput.rst:420
msgid ""
"``f.tell()`` returns an integer giving the file object's current position in"
" the file represented as number of bytes from the beginning of the file when"
" in binary mode and an opaque number when in text mode."
msgstr ""
"``f.tell()`` یک عدد صحیح را برمی گرداند که موقعیت فعلی شی فایل را در فایل "
"نشان می دهد که به صورت تعداد بایت از ابتدای فایل در حالت باینری و یک عدد مات"
" در حالت متنی نمایش داده می شود."

#: ../../tutorial/inputoutput.rst:424
msgid ""
"To change the file object's position, use ``f.seek(offset, whence)``.  The "
"position is computed from adding *offset* to a reference point; the "
"reference point is selected by the *whence* argument.  A *whence* value of 0"
" measures from the beginning of the file, 1 uses the current file position, "
"and 2 uses the end of the file as the reference point.  *whence* can be "
"omitted and defaults to 0, using the beginning of the file as the reference "
"point. ::"
msgstr ""
"برای تغییر موقعیت شی فایل، از ``f.seek(offset, whence)`` استفاده کنید.  "
"موقعیت از اضافه کردن *offset* به یک نقطه مرجع محاسبه می شود. نقطه مرجع توسط "
"آرگومان *whence* انتخاب می شود.  مقدار *whence* 0 از ابتدای فایل اندازه گیری"
" می شود، 1 از موقعیت فعلی فایل استفاده می کند، و 2 از انتهای فایل به عنوان "
"نقطه مرجع استفاده می کند.  *whence* را می توان حذف کرد و با استفاده از "
"ابتدای فایل به عنوان نقطه مرجع، 0 را پیش فرض قرار داد. ::"

#: ../../tutorial/inputoutput.rst:443
msgid ""
"In text files (those opened without a ``b`` in the mode string), only seeks "
"relative to the beginning of the file are allowed (the exception being "
"seeking to the very file end with ``seek(0, 2)``) and the only valid "
"*offset* values are those returned from the ``f.tell()``, or zero. Any other"
" *offset* value produces undefined behaviour."
msgstr ""
"در فایل‌های متنی (آنهایی که بدون ``b`` در رشته حالت باز می‌شوند), فقط "
"جستجوهای مربوط به ابتدای فایل مجاز هستند (به استثنای جستجو تا انتهای فایل با"
" ``seek(0, 2)``) و تنها مقادیر معتبر *offset* آنهایی هستند که از "
"``f.tell()`` یا صفر برگردانده می‌شوند. هر مقدار دیگر *offset* رفتار نامشخصی "
"ایجاد می کند."

#: ../../tutorial/inputoutput.rst:449
msgid ""
"File objects have some additional methods, such as :meth:`~file.isatty` and "
":meth:`~file.truncate` which are less frequently used; consult the Library "
"Reference for a complete guide to file objects."
msgstr ""

#: ../../tutorial/inputoutput.rst:457
msgid "Saving structured data with :mod:`json`"
msgstr "ذخیره داده های ساخت یافته با :mod:`json`"

#: ../../tutorial/inputoutput.rst:461
msgid ""
"Strings can easily be written to and read from a file.  Numbers take a bit "
"more effort, since the :meth:`read` method only returns strings, which will "
"have to be passed to a function like :func:`int`, which takes a string like "
"``'123'`` and returns its numeric value 123.  When you want to save more "
"complex data types like nested lists and dictionaries, parsing and "
"serializing by hand becomes complicated."
msgstr ""

#: ../../tutorial/inputoutput.rst:468
msgid ""
"Rather than having users constantly writing and debugging code to save "
"complicated data types to files, Python allows you to use the popular data "
"interchange format called `JSON (JavaScript Object Notation) "
"<http://json.org>`_.  The standard module called :mod:`json` can take Python"
" data hierarchies, and convert them to string representations; this process "
"is called :dfn:`serializing`.  Reconstructing the data from the string "
"representation is called :dfn:`deserializing`.  Between serializing and "
"deserializing, the string representing the object may have been stored in a "
"file or data, or sent over a network connection to some distant machine."
msgstr ""

#: ../../tutorial/inputoutput.rst:479
msgid ""
"The JSON format is commonly used by modern applications to allow for data "
"exchange.  Many programmers are already familiar with it, which makes it a "
"good choice for interoperability."
msgstr ""
"فرمت JSON معمولاً توسط برنامه های مدرن استفاده می شود تا امکان تبادل داده ها"
" را فراهم کند.  بسیاری از برنامه نویسان در حال حاضر با آن آشنا هستند، که آن "
"را به گزینه خوبی برای قابلیت همکاری تبدیل می کند."

#: ../../tutorial/inputoutput.rst:483
msgid ""
"If you have an object ``x``, you can view its JSON string representation "
"with a simple line of code::"
msgstr ""
"اگر یک شی ``x`` دارید، می توانید نمایش رشته JSON آن را با یک خط کد ساده "
"مشاهده کنید:"

#: ../../tutorial/inputoutput.rst:491
msgid ""
"Another variant of the :func:`~json.dumps` function, called "
":func:`~json.dump`, simply serializes the object to a :term:`text file`.  So"
" if ``f`` is a :term:`text file` object opened for writing, we can do this::"
msgstr ""
"نوع دیگری از تابع :func:`~json.dumps`، به نام :func:`~json.dump`، به سادگی "
"شی را به یک :term:`text file` سریال می کند.  بنابراین اگر ``f`` یک شی "
":term:`text file` است که برای نوشتن باز شده است، می توانیم این کار را انجام "
"دهیم:"

#: ../../tutorial/inputoutput.rst:497
msgid ""
"To decode the object again, if ``f`` is a :term:`binary file` or :term:`text"
" file` object which has been opened for reading::"
msgstr ""
"برای رمزگشایی مجدد شیء، اگر ``f`` یک شیء :term:`binary file` یا :term:`text "
"file` باشد که برای خواندن باز شده است:"

#: ../../tutorial/inputoutput.rst:503
msgid ""
"JSON files must be encoded in UTF-8. Use ``encoding=\"utf-8\"`` when opening"
" JSON file as a :term:`text file` for both of reading and writing."
msgstr ""
"فایل های JSON باید در UTF-8 کدگذاری شوند. هنگام باز کردن فایل JSON به عنوان "
":term:`text file` برای خواندن و نوشتن از ``encoding=\"utf-8\"`` استفاده "
"کنید."

#: ../../tutorial/inputoutput.rst:506
msgid ""
"This simple serialization technique can handle lists and dictionaries, but "
"serializing arbitrary class instances in JSON requires a bit of extra "
"effort. The reference for the :mod:`json` module contains an explanation of "
"this."
msgstr ""
"این تکنیک سریال‌سازی ساده می‌تواند فهرست‌ها و دیکشنری‌ها را مدیریت کند، اما "
"سریال‌سازی نمونه‌های کلاس دلخواه در JSON به کمی تلاش اضافی نیاز دارد. مرجع "
"ماژول :mod:`json` توضیحی در این باره دارد."

#: ../../tutorial/inputoutput.rst:512
msgid ":mod:`pickle` - the pickle module"
msgstr ":mod:`pickle` - ماژول ترشی"

#: ../../tutorial/inputoutput.rst:514
msgid ""
"Contrary to :ref:`JSON <tut-json>`, *pickle* is a protocol which allows the "
"serialization of arbitrarily complex Python objects.  As such, it is "
"specific to Python and cannot be used to communicate with applications "
"written in other languages.  It is also insecure by default: deserializing "
"pickle data coming from an untrusted source can execute arbitrary code, if "
"the data was crafted by a skilled attacker."
msgstr ""
"برخلاف :ref:`JSON <tut-json>`، *pickle* پروتکلی است که امکان سریال سازی "
"اشیاء پیچیده پایتون را می دهد.  به این ترتیب، مخصوص پایتون است و نمی توان از"
" آن برای برقراری ارتباط با برنامه هایی که به زبان های دیگر نوشته شده اند "
"استفاده کرد.  همچنین به‌طور پیش‌فرض ناامن است: اگر داده‌ها توسط یک مهاجم "
"ماهر ساخته شده باشند، داده‌های ترشی که از منبع نامعتبر به دست می‌آیند "
"می‌توانند کد دلخواه را اجرا کنند."
