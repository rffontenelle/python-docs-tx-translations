# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Alireza Shabani <theRevisto@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-21 17:04+0000\n"
"PO-Revision-Date: 2017-02-16 23:39+0000\n"
"Last-Translator: Alireza Shabani <theRevisto@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "کلاس ها"

#: ../../tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"کلاس‌ها وسیله‌ای برای جمع‌کردن داده‌ها و عملکرد با هم فراهم می‌کنند.  ایجاد "
"یک کلاس جدید، یک شیء *type* جدید ایجاد می کند، که اجازه می دهد *instances* "
"جدید از آن نوع ساخته شود.  هر نمونه کلاس می تواند ویژگی هایی را برای حفظ "
"حالت خود به آن متصل کند.  نمونه‌های کلاس همچنین می‌توانند متدهایی (که توسط "
"کلاس آن تعریف می‌شوند) برای تغییر حالت آن داشته باشند."

#: ../../tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"در مقایسه با سایر زبان‌های برنامه‌نویسی، مکانیسم کلاس پایتون کلاس‌هایی را با"
" حداقل نحو و معنای جدید اضافه می‌کند.  این ترکیبی از مکانیسم‌های کلاس موجود "
"در C++ و Modula-3 است.  کلاس‌های پایتون تمام ویژگی‌های استاندارد "
"برنامه‌نویسی شی‌گرا را ارائه می‌کنند: مکانیسم وراثت کلاس به چندین کلاس پایه "
"اجازه می‌دهد، یک کلاس مشتق شده می‌تواند هر روشی از کلاس یا کلاس‌های پایه خود"
" را لغو کند، و یک متد می‌تواند متد یک کلاس پایه را با همان نام فراخوانی کند."
"  اشیاء می توانند حاوی مقادیر دلخواه و انواع داده باشند.  همانطور که برای "
"ماژول ها صدق می کند، کلاس ها از ماهیت پویای پایتون سهیم هستند: آنها در زمان "
"اجرا ایجاد می شوند و می توانند بعد از ایجاد تغییرات بیشتری داشته باشند."

#: ../../tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are"
" *virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"در اصطلاحات C++، معمولاً اعضای کلاس (شامل اعضای داده) *public* هستند (به جز "
"نگاه کنید به زیر :ref:`tut-private`), و همه توابع عضو *virtual* هستند.  "
"همانطور که در Modula-3، هیچ کوتاه نویسی برای ارجاع اعضای شی از متدهای آن "
"وجود ندارد: تابع متد با اولین آرگومان صریح که نشان دهنده شیء است، اعلام می "
"شود که به طور ضمنی توسط فراخوانی ارائه می شود.  همانطور که در Smalltalk، "
"کلاس ها خود شی هستند.  این امر معنایی را برای وارد کردن و تغییر نام فراهم می"
" کند.  برخلاف C++ و Modula-3، انواع داخلی می توانند به عنوان کلاس های پایه "
"برای توسعه توسط کاربر استفاده شوند.  همچنین، مانند C++، اکثر عملگرهای داخلی "
"با نحو خاص (عملگرهای حسابی, اشتراک و غیره) می‌توانند برای نمونه‌های کلاس "
"دوباره تعریف شوند."

#: ../../tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make"
" occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(به دلیل نداشتن اصطلاحات پذیرفته شده جهانی برای صحبت در مورد کلاس ها, من "
"گهگاه از اصطلاحات Smalltalk و C++ استفاده می کنم. از اصطلاحات Modula-3 "
"استفاده می کنم, زیرا معنایی شی گرا آن به زبان پایتون نزدیکتر از C++ است, اما"
" انتظار دارم که تعداد کمی از خوانندگان درباره آن چیزی شنیده باشند.)"

#: ../../tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "سخنی در مورد نام ها و اشیاء"

#: ../../tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"اشیاء دارای فردیت هستند و نام های متعدد (در حوزه های متعدد) را می توان به یک"
" شی محدود کرد.  این در زبان های دیگر به نام مستعار شناخته می شود.  معمولاً "
"در نگاه اول پایتون به این موضوع توجهی نمی‌شود، و می‌توان با خیال راحت از "
"انواع اولیه تغییرناپذیر (اعداد, رشته‌ها, تاپل‌ها) صرف نظر کرد.  با این حال، "
"نام مستعار یک اثر احتمالاً شگفت‌انگیز بر معنایی کد پایتون شامل اشیاء قابل "
"تغییر مانند فهرست‌ها، دیکشنری‌ها و بسیاری از انواع دیگر دارد. این معمولاً به"
" نفع برنامه استفاده می شود، زیرا نام مستعار در برخی موارد مانند اشاره گر عمل"
" می کنند.  به عنوان مثال، ارسال یک شی ارزان است زیرا تنها یک اشاره گر توسط "
"پیاده سازی ارسال می شود. و اگر تابعی شیء ارسال شده به عنوان آرگومان را تغییر"
" دهد، فراخواننده این تغییر را مشاهده خواهد کرد --- این امر نیاز به دو "
"مکانیسم مختلف ارسال آرگومان مانند پاسکال را از بین می برد."

#: ../../tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "دامنه ها و فضاهای نام پایتون"

#: ../../tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"قبل از معرفی کلاس ها، ابتدا باید چیزی در مورد قوانین محدوده پایتون به شما "
"بگویم.  تعاریف کلاس‌ها چند ترفند ساده با فضاهای نام بازی می‌کنند، و شما باید"
" بدانید که دامنه‌ها و فضاهای نام چگونه کار می‌کنند تا به طور کامل بفهمید که "
"چه اتفاقی می‌افتد. اتفاقاً دانش این موضوع برای هر برنامه نویس پیشرفته پایتون"
" مفید است."

#: ../../tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "بیایید با برخی از تعاریف شروع کنیم."

#: ../../tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense"
" the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"*namespace* یک نقشه برداری از نام ها به اشیاء است.  اکثر فضاهای نام در حال "
"حاضر به عنوان فرهنگ لغت پایتون پیاده سازی می شوند، اما معمولاً به هیچ وجه "
"(به جز عملکرد) قابل توجه نیست و ممکن است در آینده تغییر کند.  نمونه هایی از "
"فضاهای نام عبارتند از: مجموعه ای از نام های داخلی (شامل توابعی مانند "
":func:`abs` و نام های استثنای داخلی). نام های جهانی در یک ماژول؛ و نام های "
"محلی در فراخوانی تابع.  به یک معنا مجموعه صفات یک شی نیز یک فضای نام را "
"تشکیل می دهد.  نکته مهمی که باید در مورد فضاهای نام بدانید این است که مطلقاً"
" هیچ رابطه ای بین نام ها در فضای نام های مختلف وجود ندارد. به عنوان مثال، دو"
" ماژول مختلف ممکن است هر دو یک تابع ``maximize`` را بدون سردرگمی تعریف کنند "
"--- کاربران ماژول ها باید آن را با نام ماژول پیشوند کنند."

#: ../../tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is"
" a module object and ``funcname`` is an attribute of it.  In this case there"
" happens to be a straightforward mapping between the module's attributes and"
" the global names defined in the module: they share the same namespace!  "
"[#]_"
msgstr ""
"به هر حال، من از کلمه *attribute* برای هر نامی به دنبال نقطه استفاده می کنم "
"--- به عنوان مثال، در عبارت ``z.real``، ``real`` یک ویژگی شی ``z`` است.  به "
"طور دقیق، ارجاع به نام ها در ماژول ها ارجاعات ویژگی هستند: در عبارت "
"``modname.funcname``، ``modname`` یک شی ماژول و ``funcname`` یک ویژگی آن "
"است.  در این مورد، نگاشت مستقیمی بین ویژگی‌های ماژول و نام‌های کلی تعریف‌شده"
" در ماژول وجود دارد: آنها فضای نام یکسانی دارند!  [#]_"

#: ../../tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`the_answer` from the object named by "
"``modname``."
msgstr ""

#: ../../tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called "
":mod:`__main__`, so they have their own global namespace.  (The built-in "
"names actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"فضاهای نام در لحظات مختلف ایجاد می شوند و طول عمر متفاوتی دارند.  فضای نام "
"حاوی نام‌های داخلی با راه‌اندازی مفسر پایتون ایجاد می‌شود و هرگز حذف "
"نمی‌شود.  فضای نام جهانی برای یک ماژول زمانی ایجاد می شود که تعریف ماژول در "
"آن خوانده شود. به طور معمول، فضاهای نام ماژول نیز تا زمانی که مفسر خارج شود "
"باقی می ماند.  عباراتی که توسط فراخوانی سطح بالای مفسر اجرا می شوند، چه از "
"یک فایل اسکریپت خوانده شوند و چه به صورت تعاملی، بخشی از یک ماژول به نام "
":mod:`__main__` در نظر گرفته می شوند، بنابراین فضای نام جهانی خود را دارند."
"  (نام های داخلی در واقع در یک ماژول نیز زندگی می کنند؛ این :mod:`builtins` "
"نامیده می شود.)"

#: ../../tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to"
" describe what actually happens.)  Of course, recursive invocations each "
"have their own local namespace."
msgstr ""
"فضای نام محلی برای یک تابع هنگام فراخوانی تابع ایجاد می‌شود و زمانی که تابع "
"استثنایی را که در تابع مدیریت نمی‌شود برمی‌گرداند یا ایجاد می‌کند، حذف "
"می‌شود.  (در واقع, فراموش کردن راه بهتری برای توصیف آنچه در واقع اتفاق "
"می‌افتد خواهد بود.) البته، فراخوان‌های بازگشتی هر کدام فضای نام محلی خود را "
"دارند."

#: ../../tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified"
" reference to a name attempts to find the name in the namespace."
msgstr ""
"*scope* یک منطقه متنی از یک برنامه پایتون است که در آن فضای نام مستقیماً "
"قابل دسترسی است.  \"دسترسی مستقیم\" در اینجا به این معنی است که یک ارجاع "
"غیرمجاز به یک نام سعی می کند نام را در فضای نام پیدا کند."

#: ../../tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any"
" time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""
"اگرچه دامنه ها به صورت استاتیک تعیین می شوند، اما به صورت پویا مورد استفاده "
"قرار می گیرند. در هر زمان در طول اجرا، 3 یا 4 محدوده تو در تو وجود دارد که "
"فضای نام آنها مستقیماً قابل دسترسی است:"

#: ../../tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr "درونی‌ترین محدوده، که ابتدا جستجو می‌شود، حاوی نام‌های محلی است"

#: ../../tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contains non-local, but also non-global names"
msgstr ""

#: ../../tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "دامنه بعدی تا آخر شامل نام های سراسری ماژول فعلی است"

#: ../../tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"بیرونی ترین محدوده (آخرین جستجو شده) فضای نامی است که شامل نام های داخلی است"

#: ../../tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the middle scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the "
":keyword:`nonlocal` statement can be used; if not declared nonlocal, those "
"variables are read-only (an attempt to write to such a variable will simply "
"create a *new* local variable in the innermost scope, leaving the "
"identically named outer variable unchanged)."
msgstr ""

#: ../../tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"معمولاً محدوده محلی به نام های محلی تابع فعلی (از نظر متنی) ارجاع می دهد.  "
"خارج از توابع، محدوده محلی به فضای نامی مشابه با دامنه جهانی ارجاع می دهد: "
"فضای نام ماژول. تعاریف کلاس ها فضای نام دیگری را در محدوده محلی قرار می "
"دهند."

#: ../../tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution,"
" at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"مهم است که بدانیم دامنه ها به صورت متنی تعیین می شوند: محدوده جهانی یک تابع "
"تعریف شده در یک ماژول، فضای نام آن ماژول است، مهم نیست که از کجا یا با چه "
"نام مستعار تابع نامیده می شود.  از سوی دیگر، جستجوی واقعی نام ها به صورت "
"پویا و در زمان اجرا انجام می شود --- با این حال، تعریف زبان به سمت وضوح نام "
"ثابت در زمان \"کامپایل\" در حال تکامل است، بنابراین به وضوح نام پویا تکیه "
"نکنید!  (در واقع, متغیرهای محلی قبلاً به صورت ایستا تعیین شده اند.)"

#: ../../tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or "
":keyword:`nonlocal` statement is in effect -- assignments to names always go"
" into the innermost scope. Assignments do not copy data --- they just bind "
"names to objects.  The same is true for deletions: the statement ``del x`` "
"removes the binding of ``x`` from the namespace referenced by the local "
"scope.  In fact, all operations that introduce new names use the local "
"scope: in particular, :keyword:`import` statements and function definitions "
"bind the module or function name in the local scope."
msgstr ""
"یک ویژگی خاص پایتون این است که -- اگر هیچ دستور :keyword:`global` یا "
":keyword:`nonlocal` در کار نباشد -- انتساب به نام ها همیشه در درونی ترین "
"محدوده قرار می گیرد. تکالیف داده ها را کپی نمی کنند --- آنها فقط نام ها را "
"به اشیا متصل می کنند.  همین امر در مورد حذف ها نیز صادق است: عبارت ``del x``"
" اتصال ``x`` را از فضای نامی که توسط محدوده محلی ارجاع داده شده است حذف می "
"کند.  در واقع، تمام عملیاتی که نام‌های جدید معرفی می‌کنند، از محدوده محلی "
"استفاده می‌کنند: به ویژه، عبارات :keyword:`import` و تعاریف تابع، نام ماژول "
"یا تابع را در محدوده محلی متصل می‌کنند."

#: ../../tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the "
":keyword:`nonlocal` statement indicates that particular variables live in an"
" enclosing scope and should be rebound there."
msgstr ""
"دستور :keyword:`global` را می توان برای نشان دادن اینکه متغیرهای خاص در "
"محدوده جهانی زندگی می کنند و باید در آنجا بازگردند استفاده شود. عبارت "
":keyword:`nonlocal` نشان می دهد که متغیرهای خاص در یک محدوده محصور زندگی می "
"کنند و باید در آنجا بازگردند."

#: ../../tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "مثال محدوده ها و فضاهای نام"

#: ../../tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"این مثالی است که نشان می‌دهد چگونه به دامنه‌ها و فضاهای نام مختلف ارجاع داده"
" شود و چگونه :keyword:`global` و :keyword:`nonlocal` بر اتصال متغیر تأثیر "
"می‌گذارند:"

#: ../../tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "خروجی کد مثال به صورت زیر است:"

#: ../../tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"توجه داشته باشید که چگونه تخصیص *local* (که پیش‌فرض است) پیوند *scope_test* "
"را تغییر نداد.  تخصیص :keyword:`nonlocal` اتصال *scope_test* به *spam* را "
"تغییر داد و تخصیص :keyword:`global` اتصال سطح ماژول را تغییر داد."

#: ../../tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the "
":keyword:`global` assignment."
msgstr ""
"همچنین می توانید ببینید که قبل از تخصیص :keyword:`global`، هیچ اتصال قبلی "
"برای *spam* وجود نداشت."

#: ../../tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "نگاه اول به کلاس ها"

#: ../../tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"کلاس ها کمی نحو جدید، سه نوع شیء جدید و برخی از معناشناسی جدید را معرفی می "
"کنند."

#: ../../tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "نحو تعریف کلاس"

#: ../../tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "ساده ترین شکل تعریف کلاس به صورت زیر است:"

#: ../../tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"تعاریف کلاس، مانند تعاریف تابع (عبارات :keyword:`def`) باید قبل از اینکه "
"اثری داشته باشند، اجرا شوند.  (شما می توانید یک تعریف کلاس را در شاخه ای از "
"دستور :keyword:`if` یا داخل یک تابع قرار دهید.)"

#: ../../tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful"
" --- we'll come back to this later.  The function definitions inside a class"
" normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"در عمل، عبارات داخل تعریف کلاس معمولاً تعاریف تابع هستند، اما عبارات دیگر "
"مجاز هستند و گاهی اوقات مفید هستند --- بعداً به این موضوع باز خواهیم گشت.  "
"تعاریف تابع در داخل یک کلاس معمولاً یک شکل خاص از فهرست آرگومان دارند که "
"توسط قراردادهای فراخوانی متدها دیکته می شود --- دوباره، این بعداً توضیح داده"
" می شود."

#: ../../tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new"
" function here."
msgstr ""
"هنگامی که یک تعریف کلاس وارد می شود، یک فضای نام جدید ایجاد می شود، و به "
"عنوان محدوده محلی استفاده می شود --- بنابراین، تمام انتساب به متغیرهای محلی "
"به این فضای نام جدید می رود.  به طور خاص، تعاریف تابع نام تابع جدید را در "
"اینجا پیوند می دهد."

#: ../../tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the"
" next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header "
"(:class:`ClassName` in the example)."
msgstr ""

#: ../../tutorial/classes.rst:259
msgid "Class Objects"
msgstr "اشیاء کلاس"

#: ../../tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"اشیاء کلاس از دو نوع عملیات پشتیبانی می کنند: ارجاعات مشخصه و نمونه سازی."

#: ../../tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names"
" that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"*Attribute references* از نحو استاندارد مورد استفاده برای همه ارجاعات ویژگی "
"در پایتون استفاده می کند: ``obj.name``.  نام‌های مشخصه معتبر همه نام‌هایی "
"هستند که در هنگام ایجاد شی کلاس در فضای نام کلاس وجود داشتند.  بنابراین، اگر"
" تعریف کلاس به این صورت بود:"

#: ../../tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""

#: ../../tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class."
" For example (assuming the above class)::"
msgstr ""
"کلاس *instantiation* از نشانه گذاری تابع استفاده می کند.  فقط وانمود کنید که"
" شی کلاس یک تابع بدون پارامتر است که نمونه جدیدی از کلاس را برمی گرداند. به "
"عنوان مثال (با فرض کلاس بالا):"

#: ../../tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"یک *instance* جدید از کلاس ایجاد می کند و این شی را به متغیر محلی ``x`` "
"اختصاص می دهد."

#: ../../tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named "
":meth:`__init__`, like this::"
msgstr ""

#: ../../tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`__init__` method, class instantiation "
"automatically invokes :meth:`__init__` for the newly-created class instance."
"  So in this example, a new, initialized instance can be obtained by::"
msgstr ""

#: ../../tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`__init__` method may have arguments for greater "
"flexibility.  In that case, arguments given to the class instantiation "
"operator are passed on to :meth:`__init__`.  For example, ::"
msgstr ""

#: ../../tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "اشیاء نمونه"

#: ../../tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by"
" instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"حالا با اشیاء نمونه چه کنیم؟  تنها عملیات درک شده توسط اشیاء نمونه، ارجاعات "
"ویژگی هستند.  دو نوع نام مشخصه معتبر وجود دارد: ویژگی های داده و روش ها."

#: ../../tutorial/classes.rst:328
msgid ""
"*Data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""

#: ../../tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For"
" example, list objects have methods called append, insert, remove, sort, and"
" so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""

#: ../../tutorial/classes.rst:349
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"نام متدهای معتبر یک شیء نمونه به کلاس آن بستگی دارد.  طبق تعریف، تمام "
"ویژگی‌های یک کلاس که شی تابع هستند، متدهای مربوط به نمونه‌های آن را تعریف "
"می‌کنند.  بنابراین در مثال ما، ``x.f`` یک مرجع متد معتبر است، زیرا "
"``MyClass.f`` یک تابع است، اما ``x.i`` نیست، زیرا ``MyClass.i`` نیست.  اما "
"``x.f`` مشابه ``MyClass.f`` نیست --- یک *method object* است نه یک شی تابع."

#: ../../tutorial/classes.rst:360
msgid "Method Objects"
msgstr "اشیاء روش"

#: ../../tutorial/classes.rst:362
msgid "Usually, a method is called right after it is bound::"
msgstr "معمولاً یک متد بلافاصله پس از محدود شدن فراخوانی می شود:"

#: ../../tutorial/classes.rst:366
msgid ""
"In the :class:`MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""

#: ../../tutorial/classes.rst:374
msgid "will continue to print ``hello world`` until the end of time."
msgstr "چاپ ``hello world`` تا پایان زمان ادامه خواهد داشت."

#: ../../tutorial/classes.rst:376
msgid ""
"What exactly happens when a method is called?  You may have noticed that "
"``x.f()`` was called without an argument above, even though the function "
"definition for :meth:`f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an"
" argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""

#: ../../tutorial/classes.rst:382
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the function."
"  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments"
" is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"در واقع، ممکن است پاسخ را حدس زده باشید: نکته ویژه در مورد متدها این است که "
"شی نمونه به عنوان اولین آرگومان تابع ارسال می شود.  در مثال ما، فراخوانی "
"``x.f()`` دقیقاً معادل ``MyClass.f(x)`` است.  به طور کلی، فراخوانی یک متد با"
" لیستی از آرگومان های *n* معادل فراخوانی تابع مربوطه با یک لیست آرگومان است "
"که با قرار دادن شی نمونه متد قبل از اولین آرگومان ایجاد می شود."

#: ../../tutorial/classes.rst:389
msgid ""
"If you still don't understand how methods work, a look at the implementation"
" can perhaps clarify matters.  When a non-data attribute of an instance is "
"referenced, the instance's class is searched.  If the name denotes a valid "
"class attribute that is a function object, a method object is created by "
"packing (pointers to) the instance object and the function object just found"
" together in an abstract object: this is the method object.  When the method"
" object is called with an argument list, a new argument list is constructed "
"from the instance object and the argument list, and the function object is "
"called with this new argument list."
msgstr ""

#: ../../tutorial/classes.rst:403
msgid "Class and Instance Variables"
msgstr "متغیرهای کلاس و نمونه"

#: ../../tutorial/classes.rst:405
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"به طور کلی، متغیرهای نمونه برای داده‌های منحصر به فرد برای هر نمونه و "
"متغیرهای کلاس برای ویژگی‌ها و روش‌هایی هستند که توسط همه نمونه‌های کلاس به "
"اشتراک گذاشته می‌شوند:"

#: ../../tutorial/classes.rst:427
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"همانطور که در :ref:`tut-object` بحث شد، داده های به اشتراک گذاشته شده می "
"توانند اثرات شگفت انگیزی با درگیر کردن اشیاء :term:`mutable` مانند لیست ها و"
" فرهنگ لغت داشته باشند. به عنوان مثال، لیست *tricks* در کد زیر نباید به "
"عنوان یک متغیر کلاس استفاده شود زیرا فقط یک لیست تنها توسط تمام نمونه های "
"*Dog* به اشتراک گذاشته می شود:"

#: ../../tutorial/classes.rst:450
msgid "Correct design of the class should use an instance variable instead::"
msgstr "در طراحی صحیح کلاس باید از یک متغیر نمونه استفاده شود:"

#: ../../tutorial/classes.rst:474
msgid "Random Remarks"
msgstr "اظهارات تصادفی"

#: ../../tutorial/classes.rst:478
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"اگر نام مشخصه یکسانی هم در یک نمونه و هم در یک کلاس وجود داشته باشد، جستجوی "
"ویژگی، نمونه را اولویت بندی می کند::"

#: ../../tutorial/classes.rst:493
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide"
" implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"ویژگی های داده ممکن است توسط روش ها و همچنین توسط کاربران عادی (\"مشتریان\")"
" یک شی ارجاع داده شوند.  به عبارت دیگر، کلاس ها برای پیاده سازی انواع داده "
"های انتزاعی خالص قابل استفاده نیستند.  در واقع، هیچ چیز در پایتون امکان "
"اعمال مخفی کردن داده ها را فراهم نمی کند --- همه اینها بر اساس قرارداد است."
"  (از سوی دیگر, پیاده‌سازی پایتون که به زبان C نوشته شده است, می‌تواند "
"جزئیات پیاده‌سازی را کاملاً مخفی کند و در صورت لزوم دسترسی به یک شی را کنترل"
" کند؛ این می‌تواند توسط پسوندهای پایتون نوشته شده در C استفاده شود.)"

#: ../../tutorial/classes.rst:501
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object"
" without affecting the validity of the methods, as long as name conflicts "
"are avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"مشتریان باید با احتیاط از ویژگی های داده استفاده کنند --- مشتریان ممکن است "
"با مهر زدن بر روی ویژگی های داده خود، متغیرهای حفظ شده توسط روش ها را خراب "
"کنند.  توجه داشته باشید که کلاینت‌ها ممکن است ویژگی‌های داده خود را به یک "
"شیء نمونه اضافه کنند، بدون اینکه بر اعتبار روش‌ها تأثیر بگذارد، تا زمانی که "
"از تضاد نام اجتناب شود --- باز هم، یک قرارداد نام‌گذاری می‌تواند در اینجا "
"سردردهای زیادی را نجات دهد."

#: ../../tutorial/classes.rst:507
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of"
" methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"هیچ مختصری برای ارجاع ویژگی های داده (یا روش های دیگر!) از درون متدها وجود "
"ندارد.  من متوجه شدم که این در واقع خوانایی روش ها را افزایش می دهد: هیچ "
"شانسی برای اشتباه گرفتن متغیرهای محلی و متغیرهای نمونه در هنگام نگاه کردن به"
" یک روش وجود ندارد."

#: ../../tutorial/classes.rst:512
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable"
" that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"اغلب، اولین آرگومان یک متد ``self`` نامیده می شود.  این چیزی بیش از یک "
"قرارداد نیست: نام ``self`` مطلقاً معنای خاصی برای پایتون ندارد.  البته توجه "
"داشته باشید که با رعایت نکردن قرارداد ممکن است کد شما برای سایر برنامه "
"نویسان پایتون کمتر قابل خواندن باشد و همچنین می توان تصور کرد که یک برنامه "
"*class browser* ممکن است نوشته شود که بر چنین قراردادی متکی باشد."

#: ../../tutorial/classes.rst:518
msgid ""
"Any function object that is a class attribute defines a method for instances"
" of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a"
" local variable in the class is also ok.  For example::"
msgstr ""
"هر شیء تابعی که یک ویژگی کلاس است، متدی را برای نمونه هایی از آن کلاس تعریف "
"می کند.  لزومی ندارد که تعریف تابع به صورت متنی در تعریف کلاس باشد: تخصیص یک"
" شی تابع به یک متغیر محلی در کلاس نیز مشکلی ندارد.  به عنوان مثال::"

#: ../../tutorial/classes.rst:535
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`C` that refer"
" to function objects, and consequently they are all methods of instances of "
":class:`C` --- ``h`` being exactly equivalent to ``g``.  Note that this "
"practice usually only serves to confuse the reader of a program."
msgstr ""

#: ../../tutorial/classes.rst:540
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"متدها ممکن است با استفاده از ویژگی های متد آرگومان ``self`` متدهای دیگر را "
"فراخوانی کنند:"

#: ../../tutorial/classes.rst:554
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some"
" good reasons why a method would want to reference its own class."
msgstr ""
"متدها ممکن است مانند توابع معمولی به نام های سراسری ارجاع دهند.  دامنه جهانی"
" مرتبط با یک روش، ماژول حاوی تعریف آن است.  (یک کلاس هرگز به عنوان یک دامنه "
"جهانی استفاده نمی شود.) در حالی که به ندرت با دلیل موجهی برای استفاده از "
"داده های سراسری در یک متد مواجه می شوید، استفاده های قانونی زیادی از دامنه "
"جهانی وجود دارد: برای یک چیز، توابع و ماژول های وارد شده به دامنه جهانی را "
"می توان توسط روش ها و همچنین توابع و کلاس های تعریف شده در آن استفاده کرد.  "
"معمولاً کلاسی که متد را در بر می گیرد، خود در این محدوده جهانی تعریف می شود،"
" و در بخش بعدی دلایل خوبی برای اینکه یک متد بخواهد به کلاس خود ارجاع دهد، "
"خواهیم یافت."

#: ../../tutorial/classes.rst:564
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"هر مقدار یک شی است و بنابراین دارای یک *class* است (که *type* آن نیز نامیده "
"می شود). به عنوان ``object.__class__`` ذخیره می شود."

#: ../../tutorial/classes.rst:571
msgid "Inheritance"
msgstr "ارث"

#: ../../tutorial/classes.rst:573
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"البته، یک ویژگی زبان بدون پشتیبانی از وراثت شایسته نام \"کلاس\" نخواهد بود."
"  نحو برای تعریف کلاس مشتق شده به صورت زیر است:"

#: ../../tutorial/classes.rst:584
msgid ""
"The name :class:`BaseClassName` must be defined in a scope containing the "
"derived class definition.  In place of a base class name, other arbitrary "
"expressions are also allowed.  This can be useful, for example, when the "
"base class is defined in another module::"
msgstr ""

#: ../../tutorial/classes.rst:591
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is"
" not found in the class, the search proceeds to look in the base class.  "
"This rule is applied recursively if the base class itself is derived from "
"some other class."
msgstr ""
"اجرای تعریف کلاس مشتق شده مانند کلاس پایه پیش می رود. هنگامی که شی کلاس "
"ساخته می شود، کلاس پایه به خاطر سپرده می شود.  این برای حل و فصل ارجاعات "
"ویژگی استفاده می شود: اگر ویژگی درخواستی در کلاس یافت نشد، جستجو برای جستجو "
"در کلاس پایه ادامه می یابد.  اگر خود کلاس پایه از کلاس دیگری مشتق شده باشد، "
"این قانون به صورت بازگشتی اعمال می شود."

#: ../../tutorial/classes.rst:597
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"هیچ چیز خاصی در مورد نمونه سازی کلاس های مشتق شده وجود ندارد: "
"``DerivedClassName()`` یک نمونه جدید از کلاس ایجاد می کند.  ارجاعات روش به "
"صورت زیر حل می‌شوند: ویژگی کلاس مربوطه جستجو می‌شود، در صورت لزوم از زنجیره "
"کلاس‌های پایه پایین می‌آید، و مرجع متد در صورتی معتبر است که یک شی تابع را "
"به دست آورد."

#: ../../tutorial/classes.rst:603
msgid ""
"Derived classes may override methods of their base classes.  Because methods"
" have no special privileges when calling other methods of the same object, a"
" method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"کلاس های مشتق شده ممکن است روش های کلاس های پایه خود را لغو کنند.  از آنجایی"
" که متدها هنگام فراخوانی متدهای دیگر یک شی، امتیاز خاصی ندارند، متدی از یک "
"کلاس پایه که متد دیگری را که در همان کلاس پایه تعریف شده است فراخوانی "
"می‌کند، ممکن است در نهایت متدی از یک کلاس مشتق شده را فراخوانی کند که آن را "
"لغو می‌کند.  (برای برنامه نویسان ++C: همه روش ها در پایتون به طور موثر "
"``virtual`` هستند.)"

#: ../../tutorial/classes.rst:609
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call "
"``BaseClassName.methodname(self, arguments)``.  This is occasionally useful "
"to clients as well.  (Note that this only works if the base class is "
"accessible as ``BaseClassName`` in the global scope.)"
msgstr ""
"یک متد overriding در یک کلاس مشتق شده ممکن است در واقع بخواهد به جای "
"جایگزینی ساده متد کلاس پایه با همان نام، گسترش یابد. یک راه ساده برای "
"فراخوانی مستقیم متد کلاس پایه وجود دارد: فقط "
"``BaseClassName.methodname(self, arguments)`` را فراخوانی کنید.  این گاهی "
"اوقات برای مشتریان نیز مفید است.  (توجه داشته باشید که این فقط در صورتی کار "
"می کند که کلاس پایه به عنوان ``BaseClassName`` در محدوده جهانی قابل دسترسی "
"باشد.)"

#: ../../tutorial/classes.rst:616
msgid "Python has two built-in functions that work with inheritance:"
msgstr "پایتون دو تابع داخلی دارد که با وراثت کار می کنند:"

#: ../../tutorial/classes.rst:618
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)``"
" will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"از :func:`isinstance` برای بررسی نوع نمونه استفاده کنید: ``isinstance(obj, "
"int)`` فقط در صورتی ``True`` خواهد بود که ``obj.__class__`` :class:`int` یا "
"کلاسی مشتق شده از :class:`int` باشد."

#: ../../tutorial/classes.rst:622
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)``"
" is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"از :func:`issubclass` برای بررسی وراثت کلاس استفاده کنید: ``issubclass(bool,"
" int)`` ``True`` است زیرا :class:`bool` زیر کلاس :class:`int` است.  با این "
"حال، ``issubclass(float, int)`` ``False`` است زیرا :class:`float` زیر کلاس "
":class:`int` نیست."

#: ../../tutorial/classes.rst:632
msgid "Multiple Inheritance"
msgstr "ارث چندگانه"

#: ../../tutorial/classes.rst:634
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"پایتون از فرمی از وراثت چندگانه نیز پشتیبانی می کند.  یک تعریف کلاس با چندین"
" کلاس پایه به صورت زیر است:"

#: ../../tutorial/classes.rst:644
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`DerivedClassName`, "
"it is searched for in :class:`Base1`, then (recursively) in the base classes"
" of :class:`Base1`, and if it was not found there, it was searched for in "
":class:`Base2`, and so on."
msgstr ""

#: ../../tutorial/classes.rst:651
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"در واقع، کمی پیچیده تر از آن است. ترتیب تفکیک روش به صورت پویا تغییر می کند "
"تا از فراخوان های مشارکتی به :func:`super` پشتیبانی کند.  این رویکرد در برخی"
" دیگر از زبان‌های ارثی چندگانه به روش فراخوانی بعدی معروف است و قدرتمندتر از"
" فراخوانی موجود در زبان‌های ارثی تک است."

#: ../../tutorial/classes.rst:657
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see "
"https://www.python.org/download/releases/2.3/mro/."
msgstr ""

#: ../../tutorial/classes.rst:674
msgid "Private Variables"
msgstr "متغیرهای خصوصی"

#: ../../tutorial/classes.rst:676
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an"
" object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"متغیرهای نمونه \"خصوصی\" که جز از داخل یک شی قابل دسترسی نیستند، در پایتون "
"وجود ندارند.  با این حال، قراردادی وجود دارد که اکثر کدهای پایتون از آن "
"پیروی می کنند: نامی که پیشوند آن زیرخط است (مثلاً ``_spam``) باید به عنوان "
"بخشی غیرعمومی از API در نظر گرفته شود (خواه یک تابع, یک متد یا یک عضو داده "
"باشد).  باید جزییات اجرایی در نظر گرفته شود و بدون اطلاع قبلی قابل تغییر "
"باشد."

#: ../../tutorial/classes.rst:686
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) stripped."
"  This mangling is done without regard to the syntactic position of the "
"identifier, as long as it occurs within the definition of a class."
msgstr ""
"از آنجایی که یک مورد استفاده معتبر برای اعضای کلاس خصوصی وجود دارد (یعنی "
"برای جلوگیری از تداخل نام نام‌ها با نام‌هایی که توسط کلاس‌های فرعی تعریف "
"شده‌اند), پشتیبانی محدودی از چنین مکانیزمی به نام :dfn:`name mangling` وجود "
"دارد.  هر شناسه ای از فرم ``__spam`` (حداقل دو زیرخط اصلی, حداکثر یک زیرخط "
"آخر) به صورت متنی با ``_classname__spam`` جایگزین می شود، که در آن "
"``classname`` نام کلاس فعلی با زیرخط(های) ابتدایی حذف شده است.  این اختلاط "
"بدون توجه به موقعیت نحوی شناسه انجام می شود، تا زمانی که در تعریف یک کلاس رخ"
" دهد."

#: ../../tutorial/classes.rst:695
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"مخفی کردن نام برای اجازه دادن به زیر کلاس‌ها بدون شکستن فراخوانی‌های متد "
"درون‌کلاسی، نادیده گرفته می‌شود.  به عنوان مثال::"

#: ../../tutorial/classes.rst:717
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a"
" ``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"مثال بالا حتی اگر ``MappingSubclass`` یک شناسه ``__update`` معرفی کند کار می"
" کند زیرا به ترتیب با ``_Mapping__update`` در کلاس ``Mapping`` و "
"``_MappingSubclass__update`` در کلاس ``MappingSubclass`` جایگزین شده است."

#: ../../tutorial/classes.rst:722
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered private."
"  This can even be useful in special circumstances, such as in the debugger."
msgstr ""
"توجه داشته باشید که قوانین انحراف بیشتر برای جلوگیری از حوادث طراحی شده اند."
" هنوز هم می توان به متغیری که خصوصی در نظر گرفته می شود دسترسی پیدا کرد یا "
"تغییر داد.  این حتی می‌تواند در شرایط خاص، مانند دیباگر، مفید باشد."

#: ../../tutorial/classes.rst:726
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"توجه داشته باشید که کد ارسال شده به ``exec()`` یا ``eval()`` نام کلاس کلاس "
"فراخوانی را کلاس فعلی در نظر نمی گیرد. این شبیه به اثر دستور ``global`` است،"
" که اثر آن نیز محدود به کدهایی است که با هم کامپایل شده اند.  همین محدودیت "
"برای ``getattr()``، ``setattr()`` و ``delattr()``، و همچنین هنگام ارجاع "
"مستقیم به ``__dict__`` اعمال می شود."

#: ../../tutorial/classes.rst:737
msgid "Odds and Ends"
msgstr "Odds and Ends"

#: ../../tutorial/classes.rst:739
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items.  An empty class "
"definition will do nicely::"
msgstr ""

#: ../../tutorial/classes.rst:753
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type instead."
"  For instance, if you have a function that formats some data from a file "
"object, you can define a class with methods :meth:`read` and "
":meth:`!readline` that get the data from a string buffer instead, and pass "
"it as an argument."
msgstr ""

#: ../../tutorial/classes.rst:764
msgid ""
"Instance method objects have attributes, too: ``m.__self__`` is the instance"
" object with the method :meth:`m`, and ``m.__func__`` is the function object"
" corresponding to the method."
msgstr ""

#: ../../tutorial/classes.rst:772
msgid "Iterators"
msgstr "تکرار کننده ها"

#: ../../tutorial/classes.rst:774
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"احتمالاً تا به حال متوجه شده اید که بیشتر اشیاء کانتینر را می توان با "
"استفاده از دستور :keyword:`for` حلقه کرد:"

#: ../../tutorial/classes.rst:788
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the "
":keyword:`for` statement calls :func:`iter` on the container object.  The "
"function returns an iterator object that defines the method "
":meth:`~iterator.__next__` which accesses elements in the container one at a"
" time.  When there are no more elements, :meth:`~iterator.__next__` raises a"
" :exc:`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the "
":func:`next` built-in function; this example shows how it all works::"
msgstr ""
"این سبک دسترسی واضح، مختصر و راحت است.  استفاده از تکرار کننده ها پایتون را "
"فرا گرفته و یکپارچه می کند.  در پشت صحنه، دستور :keyword:`for` :func:`iter` "
"را روی شی کانتینر فراخوانی می کند.  تابع یک شی تکرار کننده را برمی گرداند که"
" متد :meth:`~iterator.__next__` را تعریف می کند که به عناصر موجود در کانتینر"
" در یک زمان دسترسی پیدا می کند.  هنگامی که هیچ عنصر دیگری وجود ندارد، "
":meth:`~iterator.__next__` یک استثنای :exc:`StopIteration` را ایجاد می کند "
"که به حلقه :keyword:`!for` می گوید خاتمه یابد.  با استفاده از تابع داخلی "
":func:`next` می توانید روش :meth:`~iterator.__next__` را فراخوانی کنید. این "
"مثال نشان می دهد که چگونه همه چیز کار می کند::"

#: ../../tutorial/classes.rst:813
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`__iter__` method which "
"returns an object with a :meth:`~iterator.__next__` method.  If the class "
"defines :meth:`__next__`, then :meth:`__iter__` can just return ``self``::"
msgstr ""

#: ../../tutorial/classes.rst:850
msgid "Generators"
msgstr "ژنراتورها"

#: ../../tutorial/classes.rst:852
msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the "
":keyword:`yield` statement whenever they want to return data.  Each time "
":func:`next` is called on it, the generator resumes where it left off (it "
"remembers all the data values and which statement was last executed).  An "
"example shows that generators can be trivially easy to create::"
msgstr ""
":term:`Generators <generator>` یک ابزار ساده و قدرتمند برای ایجاد تکرار "
"کننده است.  آنها مانند توابع معمولی نوشته می شوند اما هر زمان که بخواهند "
"داده را برگردانند از دستور :keyword:`yield` استفاده می کنند.  هر بار که "
":func:`next` بر روی آن فراخوانی می شود، ژنراتور از همان جایی که متوقف شده "
"بود از سر گرفته می شود (همه مقادیر داده را به خاطر می آورد و آخرین دستوری که"
" اجرا شده است).  یک مثال نشان می دهد که ایجاد ژنراتورها بسیار ساده است:"

#: ../../tutorial/classes.rst:873
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`__iter__` and :meth:`~generator.__next__` methods"
" are created automatically."
msgstr ""

#: ../../tutorial/classes.rst:878
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like "
"``self.index`` and ``self.data``."
msgstr ""
"یکی دیگر از ویژگی های کلیدی این است که متغیرهای محلی و وضعیت اجرا به طور "
"خودکار بین تماس ها ذخیره می شوند.  این کار نوشتن تابع را آسان‌تر و واضح‌تر "
"از رویکردی با استفاده از متغیرهای نمونه مانند ``self.index`` و ``self.data``"
" کرد."

#: ../../tutorial/classes.rst:883
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"علاوه بر ایجاد روش خودکار و ذخیره وضعیت برنامه، هنگامی که ژنراتورها خاتمه می"
" یابند، به طور خودکار :exc:`StopIteration` را افزایش می دهند. در ترکیب، این "
"ویژگی ها ایجاد تکرار کننده ها را بدون تلاش بیشتر از نوشتن یک تابع معمولی "
"آسان می کند."

#: ../../tutorial/classes.rst:892
msgid "Generator Expressions"
msgstr "عبارات ژنراتور"

#: ../../tutorial/classes.rst:894
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax"
" similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more"
" compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"برخی از مولدهای ساده را می توان به طور خلاصه به عنوان عبارات با استفاده از "
"نحوی شبیه به درک لیست اما با پرانتز به جای پرانتز کدگذاری کرد. این عبارات "
"برای موقعیت هایی طراحی شده اند که ژنراتور بلافاصله توسط یک تابع محصور کننده "
"استفاده می شود.  عبارات ژنراتور نسبت به تعاریف کامل مولد فشرده تر اما تطبیق "
"پذیری کمتری دارند و نسبت به درک لیست های معادل، حافظه دوستانه بیشتری دارند."

#: ../../tutorial/classes.rst:901
msgid "Examples::"
msgstr "مثال ها::"

#: ../../tutorial/classes.rst:922
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../tutorial/classes.rst:923
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""
