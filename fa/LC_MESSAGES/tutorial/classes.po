# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Alireza Shabani <theRevisto@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-21 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:49+0000\n"
"Last-Translator: Alireza Shabani <theRevisto@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "کلاس ها"

#: ../../tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"کلاس‌ها وسیله‌ای برای جمع‌کردن داده‌ها و عملکرد با هم فراهم می‌کنند.  ایجاد "
"یک کلاس جدید، یک شیء *type* جدید ایجاد می کند، که اجازه می دهد *instances* "
"جدید از آن نوع ساخته شود.  هر نمونه کلاس می تواند ویژگی هایی را برای حفظ "
"حالت خود به آن متصل کند.  نمونه‌های کلاس همچنین می‌توانند متدهایی (که توسط "
"کلاس آن تعریف می‌شوند) برای تغییر حالت آن داشته باشند."

#: ../../tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"در مقایسه با سایر زبان‌های برنامه‌نویسی، مکانیسم کلاس پایتون کلاس‌هایی را با"
" حداقل نحو و معنای جدید اضافه می‌کند.  این ترکیبی از مکانیسم‌های کلاس موجود "
"در C++ و Modula-3 است.  کلاس‌های پایتون تمام ویژگی‌های استاندارد "
"برنامه‌نویسی شی‌گرا را ارائه می‌کنند: مکانیسم وراثت کلاس به چندین کلاس پایه "
"اجازه می‌دهد، یک کلاس مشتق شده می‌تواند هر روشی از کلاس یا کلاس‌های پایه خود"
" را لغو کند، و یک متد می‌تواند متد یک کلاس پایه را با همان نام فراخوانی کند."
"  اشیاء می توانند حاوی مقادیر دلخواه و انواع داده باشند.  همانطور که برای "
"ماژول ها صدق می کند، کلاس ها از ماهیت پویای پایتون سهیم هستند: آنها در زمان "
"اجرا ایجاد می شوند و می توانند بعد از ایجاد تغییرات بیشتری داشته باشند."

#: ../../tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are"
" *virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"در اصطلاحات C++، معمولاً اعضای کلاس (شامل اعضای داده) *public* هستند (به جز "
"نگاه کنید به زیر :ref:`tut-private`), و همه توابع عضو *virtual* هستند.  "
"همانطور که در Modula-3، هیچ کوتاه نویسی برای ارجاع اعضای شی از متدهای آن "
"وجود ندارد: تابع متد با اولین آرگومان صریح که نشان دهنده شیء است، اعلام می "
"شود که به طور ضمنی توسط فراخوانی ارائه می شود.  همانطور که در Smalltalk، "
"کلاس ها خود شی هستند.  این امر معنایی را برای وارد کردن و تغییر نام فراهم می"
" کند.  برخلاف C++ و Modula-3، انواع داخلی می توانند به عنوان کلاس های پایه "
"برای توسعه توسط کاربر استفاده شوند.  همچنین، مانند C++، اکثر عملگرهای داخلی "
"با نحو خاص (عملگرهای حسابی, اشتراک و غیره) می‌توانند برای نمونه‌های کلاس "
"دوباره تعریف شوند."

#: ../../tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make"
" occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(به دلیل نداشتن اصطلاحات پذیرفته شده جهانی برای صحبت در مورد کلاس ها, من "
"گهگاه از اصطلاحات Smalltalk و C++ استفاده می کنم. از اصطلاحات Modula-3 "
"استفاده می کنم, زیرا معنایی شی گرا آن به زبان پایتون نزدیکتر از C++ است, اما"
" انتظار دارم که تعداد کمی از خوانندگان درباره آن چیزی شنیده باشند.)"

#: ../../tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "سخنی در مورد نام ها و اشیاء"

#: ../../tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"اشیاء دارای فردیت هستند و نام های متعدد (در حوزه های متعدد) را می توان به یک"
" شی محدود کرد.  این در زبان های دیگر به نام مستعار شناخته می شود.  معمولاً "
"در نگاه اول پایتون به این موضوع توجهی نمی‌شود، و می‌توان با خیال راحت از "
"انواع اولیه تغییرناپذیر (اعداد, رشته‌ها, تاپل‌ها) صرف نظر کرد.  با این حال، "
"نام مستعار یک اثر احتمالاً شگفت‌انگیز بر معنایی کد پایتون شامل اشیاء قابل "
"تغییر مانند فهرست‌ها، دیکشنری‌ها و بسیاری از انواع دیگر دارد. این معمولاً به"
" نفع برنامه استفاده می شود، زیرا نام مستعار در برخی موارد مانند اشاره گر عمل"
" می کنند.  به عنوان مثال، ارسال یک شی ارزان است زیرا تنها یک اشاره گر توسط "
"پیاده سازی ارسال می شود. و اگر تابعی شیء ارسال شده به عنوان آرگومان را تغییر"
" دهد، فراخواننده این تغییر را مشاهده خواهد کرد --- این امر نیاز به دو "
"مکانیسم مختلف ارسال آرگومان مانند پاسکال را از بین می برد."

#: ../../tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "دامنه ها و فضاهای نام پایتون"

#: ../../tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"قبل از معرفی کلاس ها، ابتدا باید چیزی در مورد قوانین محدوده پایتون به شما "
"بگویم.  تعاریف کلاس‌ها چند ترفند ساده با فضاهای نام بازی می‌کنند، و شما باید"
" بدانید که دامنه‌ها و فضاهای نام چگونه کار می‌کنند تا به طور کامل بفهمید که "
"چه اتفاقی می‌افتد. اتفاقاً دانش این موضوع برای هر برنامه نویس پیشرفته پایتون"
" مفید است."

#: ../../tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "بیایید با برخی از تعاریف شروع کنیم."

#: ../../tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense"
" the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"*namespace* یک نقشه برداری از نام ها به اشیاء است.  اکثر فضاهای نام در حال "
"حاضر به عنوان فرهنگ لغت پایتون پیاده سازی می شوند، اما معمولاً به هیچ وجه "
"(به جز عملکرد) قابل توجه نیست و ممکن است در آینده تغییر کند.  نمونه هایی از "
"فضاهای نام عبارتند از: مجموعه ای از نام های داخلی (شامل توابعی مانند "
":func:`abs` و نام های استثنای داخلی). نام های جهانی در یک ماژول؛ و نام های "
"محلی در فراخوانی تابع.  به یک معنا مجموعه صفات یک شی نیز یک فضای نام را "
"تشکیل می دهد.  نکته مهمی که باید در مورد فضاهای نام بدانید این است که مطلقاً"
" هیچ رابطه ای بین نام ها در فضای نام های مختلف وجود ندارد. به عنوان مثال، دو"
" ماژول مختلف ممکن است هر دو یک تابع ``maximize`` را بدون سردرگمی تعریف کنند "
"--- کاربران ماژول ها باید آن را با نام ماژول پیشوند کنند."

#: ../../tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is"
" a module object and ``funcname`` is an attribute of it.  In this case there"
" happens to be a straightforward mapping between the module's attributes and"
" the global names defined in the module: they share the same namespace!  "
"[#]_"
msgstr ""
"به هر حال، من از کلمه *attribute* برای هر نامی به دنبال نقطه استفاده می کنم "
"--- به عنوان مثال، در عبارت ``z.real``، ``real`` یک ویژگی شی ``z`` است.  به "
"طور دقیق، ارجاع به نام ها در ماژول ها ارجاعات ویژگی هستند: در عبارت "
"``modname.funcname``، ``modname`` یک شی ماژول و ``funcname`` یک ویژگی آن "
"است.  در این مورد، نگاشت مستقیمی بین ویژگی‌های ماژول و نام‌های کلی تعریف‌شده"
" در ماژول وجود دارد: آنها فضای نام یکسانی دارند!  [#]_"

#: ../../tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`!the_answer` from the object named by "
"``modname``."
msgstr ""
"ویژگی ها ممکن است فقط خواندنی یا قابل نوشتن باشند.  در حالت دوم، انتساب به "
"صفات امکان پذیر است.  ویژگی های ماژول قابل نوشتن هستند: می توانید "
"``modname.the_answer = 42`` بنویسید.  ویژگی های قابل نوشتن نیز ممکن است با "
"دستور :keyword:`del` حذف شوند.  به عنوان مثال، ``del modname.the_answer`` "
"ویژگی :attr:`!the_answer` را از شیء نامگذاری شده توسط ``modname`` حذف می "
"کند."

#: ../../tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called "
":mod:`__main__`, so they have their own global namespace.  (The built-in "
"names actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"فضاهای نام در لحظات مختلف ایجاد می شوند و طول عمر متفاوتی دارند.  فضای نام "
"حاوی نام‌های داخلی با راه‌اندازی مفسر پایتون ایجاد می‌شود و هرگز حذف "
"نمی‌شود.  فضای نام جهانی برای یک ماژول زمانی ایجاد می شود که تعریف ماژول در "
"آن خوانده شود. به طور معمول، فضاهای نام ماژول نیز تا زمانی که مفسر خارج شود "
"باقی می ماند.  عباراتی که توسط فراخوانی سطح بالای مفسر اجرا می شوند، چه از "
"یک فایل اسکریپت خوانده شوند و چه به صورت تعاملی، بخشی از یک ماژول به نام "
":mod:`__main__` در نظر گرفته می شوند، بنابراین فضای نام جهانی خود را دارند."
"  (نام های داخلی در واقع در یک ماژول نیز زندگی می کنند؛ این :mod:`builtins` "
"نامیده می شود.)"

#: ../../tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to"
" describe what actually happens.)  Of course, recursive invocations each "
"have their own local namespace."
msgstr ""
"فضای نام محلی برای یک تابع هنگام فراخوانی تابع ایجاد می‌شود و زمانی که تابع "
"استثنایی را که در تابع مدیریت نمی‌شود برمی‌گرداند یا ایجاد می‌کند، حذف "
"می‌شود.  (در واقع, فراموش کردن راه بهتری برای توصیف آنچه در واقع اتفاق "
"می‌افتد خواهد بود.) البته، فراخوان‌های بازگشتی هر کدام فضای نام محلی خود را "
"دارند."

#: ../../tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified"
" reference to a name attempts to find the name in the namespace."
msgstr ""
"*scope* یک منطقه متنی از یک برنامه پایتون است که در آن فضای نام مستقیماً "
"قابل دسترسی است.  \"دسترسی مستقیم\" در اینجا به این معنی است که یک ارجاع "
"غیرمجاز به یک نام سعی می کند نام را در فضای نام پیدا کند."

#: ../../tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any"
" time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""
"اگرچه دامنه ها به صورت استاتیک تعیین می شوند، اما به صورت پویا مورد استفاده "
"قرار می گیرند. در هر زمان در طول اجرا، 3 یا 4 محدوده تو در تو وجود دارد که "
"فضای نام آنها مستقیماً قابل دسترسی است:"

#: ../../tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr "درونی‌ترین محدوده، که ابتدا جستجو می‌شود، حاوی نام‌های محلی است"

#: ../../tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contain non-local, but also non-global names"
msgstr ""
"دامنه هر توابع محصور کننده ای که با شروع با نزدیک ترین محدوده محصور جستجو می"
" شود، حاوی نام های غیر محلی، بلکه غیرکلی نیز می باشد."

#: ../../tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "دامنه بعدی تا آخر شامل نام های سراسری ماژول فعلی است"

#: ../../tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"بیرونی ترین محدوده (آخرین جستجو شده) فضای نامی است که شامل نام های داخلی است"

#: ../../tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the next-to-last scope containing the module's global names.  To"
" rebind variables found outside of the innermost scope, the "
":keyword:`nonlocal` statement can be used; if not declared nonlocal, those "
"variables are read-only (an attempt to write to such a variable will simply "
"create a *new* local variable in the innermost scope, leaving the "
"identically named outer variable unchanged)."
msgstr ""
"اگر نامی جهانی اعلام شود، آنگاه همه ارجاعات و تخصیص ها مستقیماً به محدوده "
"بعدی تا آخرین حاوی نام های جهانی ماژول می روند.  برای اتصال مجدد متغیرهایی "
"که خارج از درونی ترین محدوده یافت می شوند، می توان از دستور "
":keyword:`nonlocal` استفاده کرد. اگر غیرمحلی اعلام نشود، آن متغیرها فقط "
"خواندنی هستند (تلاش برای نوشتن روی چنین متغیری به سادگی یک متغیر محلی *new* "
"در درونی‌ترین محدوده ایجاد می‌کند و متغیر بیرونی با نام مشابه را بدون تغییر "
"می‌گذارد)."

#: ../../tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"معمولاً محدوده محلی به نام های محلی تابع فعلی (از نظر متنی) ارجاع می دهد.  "
"خارج از توابع، محدوده محلی به فضای نامی مشابه با دامنه جهانی ارجاع می دهد: "
"فضای نام ماژول. تعاریف کلاس ها فضای نام دیگری را در محدوده محلی قرار می "
"دهند."

#: ../../tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution,"
" at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"مهم است که بدانیم دامنه ها به صورت متنی تعیین می شوند: محدوده جهانی یک تابع "
"تعریف شده در یک ماژول، فضای نام آن ماژول است، مهم نیست که از کجا یا با چه "
"نام مستعار تابع نامیده می شود.  از سوی دیگر، جستجوی واقعی نام ها به صورت "
"پویا و در زمان اجرا انجام می شود --- با این حال، تعریف زبان به سمت وضوح نام "
"ثابت در زمان \"کامپایل\" در حال تکامل است، بنابراین به وضوح نام پویا تکیه "
"نکنید!  (در واقع, متغیرهای محلی قبلاً به صورت ایستا تعیین شده اند.)"

#: ../../tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or "
":keyword:`nonlocal` statement is in effect -- assignments to names always go"
" into the innermost scope. Assignments do not copy data --- they just bind "
"names to objects.  The same is true for deletions: the statement ``del x`` "
"removes the binding of ``x`` from the namespace referenced by the local "
"scope.  In fact, all operations that introduce new names use the local "
"scope: in particular, :keyword:`import` statements and function definitions "
"bind the module or function name in the local scope."
msgstr ""
"یک ویژگی خاص پایتون این است که -- اگر هیچ دستور :keyword:`global` یا "
":keyword:`nonlocal` در کار نباشد -- انتساب به نام ها همیشه در درونی ترین "
"محدوده قرار می گیرد. تکالیف داده ها را کپی نمی کنند --- آنها فقط نام ها را "
"به اشیا متصل می کنند.  همین امر در مورد حذف ها نیز صادق است: عبارت ``del x``"
" اتصال ``x`` را از فضای نامی که توسط محدوده محلی ارجاع داده شده است حذف می "
"کند.  در واقع، تمام عملیاتی که نام‌های جدید معرفی می‌کنند، از محدوده محلی "
"استفاده می‌کنند: به ویژه، عبارات :keyword:`import` و تعاریف تابع، نام ماژول "
"یا تابع را در محدوده محلی متصل می‌کنند."

#: ../../tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the "
":keyword:`nonlocal` statement indicates that particular variables live in an"
" enclosing scope and should be rebound there."
msgstr ""
"دستور :keyword:`global` را می توان برای نشان دادن اینکه متغیرهای خاص در "
"محدوده جهانی زندگی می کنند و باید در آنجا بازگردند استفاده شود. عبارت "
":keyword:`nonlocal` نشان می دهد که متغیرهای خاص در یک محدوده محصور زندگی می "
"کنند و باید در آنجا بازگردند."

#: ../../tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "مثال محدوده ها و فضاهای نام"

#: ../../tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"این مثالی است که نشان می‌دهد چگونه به دامنه‌ها و فضاهای نام مختلف ارجاع داده"
" شود و چگونه :keyword:`global` و :keyword:`nonlocal` بر اتصال متغیر تأثیر "
"می‌گذارند:"

#: ../../tutorial/classes.rst:168
msgid ""
"def scope_test():\n"
"    def do_local():\n"
"        spam = \"local spam\"\n"
"\n"
"    def do_nonlocal():\n"
"        nonlocal spam\n"
"        spam = \"nonlocal spam\"\n"
"\n"
"    def do_global():\n"
"        global spam\n"
"        spam = \"global spam\"\n"
"\n"
"    spam = \"test spam\"\n"
"    do_local()\n"
"    print(\"After local assignment:\", spam)\n"
"    do_nonlocal()\n"
"    print(\"After nonlocal assignment:\", spam)\n"
"    do_global()\n"
"    print(\"After global assignment:\", spam)\n"
"\n"
"scope_test()\n"
"print(\"In global scope:\", spam)"
msgstr ""
"def scope_test():\n"
"    def do_local():\n"
"        spam = \"local spam\"\n"
"\n"
"    def do_nonlocal():\n"
"        nonlocal spam\n"
"        spam = \"nonlocal spam\"\n"
"\n"
"    def do_global():\n"
"        global spam\n"
"        spam = \"global spam\"\n"
"\n"
"    spam = \"test spam\"\n"
"    do_local()\n"
"    print(\"After local assignment:\", spam)\n"
"    do_nonlocal()\n"
"    print(\"After nonlocal assignment:\", spam)\n"
"    do_global()\n"
"    print(\"After global assignment:\", spam)\n"
"\n"
"scope_test()\n"
"print(\"In global scope:\", spam)"

#: ../../tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "خروجی کد مثال به صورت زیر است:"

#: ../../tutorial/classes.rst:193
msgid ""
"After local assignment: test spam\n"
"After nonlocal assignment: nonlocal spam\n"
"After global assignment: nonlocal spam\n"
"In global scope: global spam"
msgstr ""
"پس از انتساب محلی: هرزنامه را آزمایش کنید\n"
"پس از تخصیص غیر محلی: هرزنامه غیرمحلی\n"
"پس از تخصیص جهانی: هرزنامه غیر محلی\n"
"در حوزه جهانی: هرزنامه جهانی"

#: ../../tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"توجه داشته باشید که چگونه تخصیص *local* (که پیش‌فرض است) پیوند *scope_test* "
"را تغییر نداد.  تخصیص :keyword:`nonlocal` اتصال *scope_test* به *spam* را "
"تغییر داد و تخصیص :keyword:`global` اتصال سطح ماژول را تغییر داد."

#: ../../tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the "
":keyword:`global` assignment."
msgstr ""
"همچنین می توانید ببینید که قبل از تخصیص :keyword:`global`، هیچ اتصال قبلی "
"برای *spam* وجود نداشت."

#: ../../tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "نگاه اول به کلاس ها"

#: ../../tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"کلاس ها کمی نحو جدید، سه نوع شیء جدید و برخی از معناشناسی جدید را معرفی می "
"کنند."

#: ../../tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "نحو تعریف کلاس"

#: ../../tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "ساده ترین شکل تعریف کلاس به صورت زیر است:"

#: ../../tutorial/classes.rst:225
msgid ""
"class ClassName:\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"نام کلاس:\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"

#: ../../tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"تعاریف کلاس، مانند تعاریف تابع (عبارات :keyword:`def`) باید قبل از اینکه "
"اثری داشته باشند، اجرا شوند.  (شما می توانید یک تعریف کلاس را در شاخه ای از "
"دستور :keyword:`if` یا داخل یک تابع قرار دهید.)"

#: ../../tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful"
" --- we'll come back to this later.  The function definitions inside a class"
" normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"در عمل، عبارات داخل تعریف کلاس معمولاً تعاریف تابع هستند، اما عبارات دیگر "
"مجاز هستند و گاهی اوقات مفید هستند --- بعداً به این موضوع باز خواهیم گشت.  "
"تعاریف تابع در داخل یک کلاس معمولاً یک شکل خاص از فهرست آرگومان دارند که "
"توسط قراردادهای فراخوانی متدها دیکته می شود --- دوباره، این بعداً توضیح داده"
" می شود."

#: ../../tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new"
" function here."
msgstr ""
"هنگامی که یک تعریف کلاس وارد می شود، یک فضای نام جدید ایجاد می شود، و به "
"عنوان محدوده محلی استفاده می شود --- بنابراین، تمام انتساب به متغیرهای محلی "
"به این فضای نام جدید می رود.  به طور خاص، تعاریف تابع نام تابع جدید را در "
"اینجا پیوند می دهد."

#: ../../tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the"
" next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header "
"(:class:`!ClassName` in the example)."
msgstr ""
"هنگامی که یک تعریف کلاس به طور معمول (از طریق انتهای) باقی می ماند، یک "
"*class object* ایجاد می شود.  این اساساً یک بسته بندی در اطراف محتویات فضای "
"نام ایجاد شده توسط تعریف کلاس است. در بخش بعدی در مورد اشیاء کلاس بیشتر "
"خواهیم آموخت.  محدوده محلی اصلی (محدوده ای که درست قبل از وارد کردن تعریف "
"کلاس وجود داشت) بازیابی می شود، و شی کلاس در اینجا به نام کلاس ارائه شده در "
"هدر تعریف کلاس (:class:`!ClassName` در مثال) محدود می شود."

#: ../../tutorial/classes.rst:259
msgid "Class Objects"
msgstr "اشیاء کلاس"

#: ../../tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"اشیاء کلاس از دو نوع عملیات پشتیبانی می کنند: ارجاعات مشخصه و نمونه سازی."

#: ../../tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names"
" that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"*Attribute references* از نحو استاندارد مورد استفاده برای همه ارجاعات ویژگی "
"در پایتون استفاده می کند: ``obj.name``.  نام‌های مشخصه معتبر همه نام‌هایی "
"هستند که در هنگام ایجاد شی کلاس در فضای نام کلاس وجود داشتند.  بنابراین، اگر"
" تعریف کلاس به این صورت بود:"

#: ../../tutorial/classes.rst:269
msgid ""
"class MyClass:\n"
"    \"\"\"A simple example class\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'hello world'"
msgstr ""
"class MyClass:\n"
"    \"\"\"A simple example class\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'hello world'"

#: ../../tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`~type.__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"سپس ``MyClass.i`` و ``MyClass.f`` مراجع مشخصه معتبری هستند که به ترتیب یک "
"عدد صحیح و یک شی تابع را برمی‌گردانند. ویژگی های کلاس را نیز می توان به آن "
"اختصاص داد، بنابراین می توانید مقدار ``MyClass.i`` را با انتساب تغییر دهید. "
":attr:`~type.__doc__` نیز یک ویژگی معتبر است که رشته مستند متعلق به کلاس: "
"``\"A simple example class\"`` را برمی گرداند."

#: ../../tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class."
" For example (assuming the above class)::"
msgstr ""
"کلاس *instantiation* از نشانه گذاری تابع استفاده می کند.  فقط وانمود کنید که"
" شی کلاس یک تابع بدون پارامتر است که نمونه جدیدی از کلاس را برمی گرداند. به "
"عنوان مثال (با فرض کلاس بالا):"

#: ../../tutorial/classes.rst:286 ../../tutorial/classes.rst:303
msgid "x = MyClass()"
msgstr "x = MyClass()"

#: ../../tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"یک *instance* جدید از کلاس ایجاد می کند و این شی را به متغیر محلی ``x`` "
"اختصاص می دهد."

#: ../../tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named "
":meth:`~object.__init__`, like this::"
msgstr ""
"عملیات نمونه سازی (\" فراخوانی \" یک شی کلاس) یک شی خالی ایجاد می کند. "
"بسیاری از کلاس ها دوست دارند اشیایی را با نمونه های سفارشی شده برای یک حالت "
"اولیه خاص ایجاد کنند. بنابراین یک کلاس ممکن است متد خاصی به نام "
":meth:`~object.__init__` را تعریف کند، مانند:"

#: ../../tutorial/classes.rst:296
msgid ""
"def __init__(self):\n"
"    self.data = []"
msgstr ""
"def __init__(self):\n"
"    self.data = []"

#: ../../tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`~object.__init__` method, class instantiation"
" automatically invokes :meth:`!__init__` for the newly created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"هنگامی که یک کلاس یک متد :meth:`~object.__init__` را تعریف می کند، نمونه "
"سازی کلاس به طور خودکار :meth:`!__init__` را برای نمونه کلاس تازه ایجاد شده "
"فراخوانی می کند.  بنابراین در این مثال، یک نمونه جدید و مقداردهی اولیه را می"
" توان با استفاده از:"

#: ../../tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`~object.__init__` method may have arguments for "
"greater flexibility.  In that case, arguments given to the class "
"instantiation operator are passed on to :meth:`!__init__`.  For example, ::"
msgstr ""
"البته روش :meth:`~object.__init__` ممکن است استدلال هایی برای انعطاف پذیری "
"بیشتر داشته باشد.  در آن صورت، آرگومان های داده شده به عملگر نمونه سازی کلاس"
" به :meth:`!__init__` منتقل می شود.  به عنوان مثال، ::"

#: ../../tutorial/classes.rst:309
msgid ""
">>> class Complex:\n"
"...     def __init__(self, realpart, imagpart):\n"
"...         self.r = realpart\n"
"...         self.i = imagpart\n"
"...\n"
">>> x = Complex(3.0, -4.5)\n"
">>> x.r, x.i\n"
"(3.0, -4.5)"
msgstr ""
">>> class Complex:\n"
"...     def __init__(self, realpart, imagpart):\n"
"...         self.r = realpart\n"
"...         self.i = imagpart\n"
"...\n"
">>> x = Complex(3.0, -4.5)\n"
">>> x.r, x.i\n"
"(3.0, -4.5)"

#: ../../tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "اشیاء نمونه"

#: ../../tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by"
" instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"حالا با اشیاء نمونه چه کنیم؟  تنها عملیات درک شده توسط اشیاء نمونه، ارجاعات "
"ویژگی هستند.  دو نوع نام مشخصه معتبر وجود دارد: ویژگی های داده و روش ها."

#: ../../tutorial/classes.rst:328
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`!MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"*data attributes* با \"متغیرهای نمونه\" در Smalltalk و به \"اعضای داده\" در "
"C++ مطابقت دارد.  ویژگی های داده نیازی به اعلان ندارند. مانند متغیرهای محلی،"
" زمانی که برای اولین بار به آنها اختصاص داده می شوند، به وجود می آیند.  به "
"عنوان مثال، اگر ``x`` نمونه ای از :class:`!MyClass` باشد که در بالا ایجاد "
"شده است، کد زیر مقدار ``16`` را بدون گذاشتن ردی چاپ می کند:"

#: ../../tutorial/classes.rst:334
msgid ""
"x.counter = 1\n"
"while x.counter < 10:\n"
"    x.counter = x.counter * 2\n"
"print(x.counter)\n"
"del x.counter"
msgstr ""
"x.counter = 1\n"
"while x.counter < 10:\n"
"    x.counter = x.counter * 2\n"
"print(x.counter)\n"
"del x.counter"

#: ../../tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object."
msgstr ""
"نوع دیگر مرجع ویژگی نمونه *method* است. متد تابعی است که «متعلق به» یک شی "
"است."

#: ../../tutorial/classes.rst:345
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"نام متدهای معتبر یک شیء نمونه به کلاس آن بستگی دارد.  طبق تعریف، تمام "
"ویژگی‌های یک کلاس که شی تابع هستند، متدهای مربوط به نمونه‌های آن را تعریف "
"می‌کنند.  بنابراین در مثال ما، ``x.f`` یک مرجع متد معتبر است، زیرا "
"``MyClass.f`` یک تابع است، اما ``x.i`` نیست، زیرا ``MyClass.i`` نیست.  اما "
"``x.f`` مشابه ``MyClass.f`` نیست --- یک *method object* است نه یک شی تابع."

#: ../../tutorial/classes.rst:356
msgid "Method Objects"
msgstr "اشیاء روش"

#: ../../tutorial/classes.rst:358
msgid "Usually, a method is called right after it is bound::"
msgstr "معمولاً یک متد بلافاصله پس از محدود شدن فراخوانی می شود:"

#: ../../tutorial/classes.rst:360
msgid "x.f()"
msgstr "x.f()"

#: ../../tutorial/classes.rst:362
msgid ""
"In the :class:`!MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"در مثال :class:`!MyClass`، این رشته ``'hello world'`` را برمی گرداند. با این"
" حال، لازم نیست فوراً یک متد را فراخوانی کنید: ``x.f`` یک شی متد است و "
"می‌توان آن را ذخیره کرد و در زمان دیگری فراخوانی کرد.  به عنوان مثال::"

#: ../../tutorial/classes.rst:366
msgid ""
"xf = x.f\n"
"while True:\n"
"    print(xf())"
msgstr ""
"xf = x.f\n"
"while True:\n"
"    print(xf())"

#: ../../tutorial/classes.rst:370
msgid "will continue to print ``hello world`` until the end of time."
msgstr "چاپ ``hello world`` تا پایان زمان ادامه خواهد داشت."

#: ../../tutorial/classes.rst:372
msgid ""
"What exactly happens when a method is called?  You may have noticed that "
"``x.f()`` was called without an argument above, even though the function "
"definition for :meth:`!f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an"
" argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"وقتی یک متد فراخوانی می شود دقیقا چه اتفاقی می افتد؟  ممکن است متوجه شده "
"باشید که ``x.f()`` بدون آرگومان در بالا فراخوانی شده است، حتی اگر تعریف تابع"
" برای :meth:`!f` یک آرگومان را مشخص کرده باشد.  بحث چه شد؟ مطمئنا پایتون یک "
"استثنا ایجاد می کند زمانی که تابعی که به آرگومان نیاز دارد بدون هیچ --- "
"فراخوانی شود، حتی اگر آرگومان در واقع استفاده نشده باشد..."

#: ../../tutorial/classes.rst:378
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the function."
"  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments"
" is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"در واقع، ممکن است پاسخ را حدس زده باشید: نکته ویژه در مورد متدها این است که "
"شی نمونه به عنوان اولین آرگومان تابع ارسال می شود.  در مثال ما، فراخوانی "
"``x.f()`` دقیقاً معادل ``MyClass.f(x)`` است.  به طور کلی، فراخوانی یک متد با"
" لیستی از آرگومان های *n* معادل فراخوانی تابع مربوطه با یک لیست آرگومان است "
"که با قرار دادن شی نمونه متد قبل از اولین آرگومان ایجاد می شود."

#: ../../tutorial/classes.rst:385
msgid ""
"In general, methods work as follows.  When a non-data attribute of an "
"instance is referenced, the instance's class is searched. If the name "
"denotes a valid class attribute that is a function object, references to "
"both the instance object and the function object are packed into a method "
"object.  When the method object is called with an argument list, a new "
"argument list is constructed from the instance object and the argument list,"
" and the function object is called with this new argument list."
msgstr ""
"به طور کلی روش ها به شرح زیر عمل می کنند.  هنگامی که یک ویژگی غیر داده ای از"
" یک نمونه ارجاع داده می شود، کلاس نمونه جستجو می شود. اگر نام یک ویژگی کلاس "
"معتبر را نشان می دهد که یک شی تابع است، ارجاعات به شی نمونه و شی تابع در یک "
"شی متد بسته بندی می شوند.  هنگامی که شی متد با یک لیست آرگومان فراخوانی می "
"شود، یک لیست آرگومان جدید از شی نمونه و لیست آرگومان ساخته می شود و شی تابع "
"با این لیست آرگومان جدید فراخوانی می شود."

#: ../../tutorial/classes.rst:398
msgid "Class and Instance Variables"
msgstr "متغیرهای کلاس و نمونه"

#: ../../tutorial/classes.rst:400
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"به طور کلی، متغیرهای نمونه برای داده‌های منحصر به فرد برای هر نمونه و "
"متغیرهای کلاس برای ویژگی‌ها و روش‌هایی هستند که توسط همه نمونه‌های کلاس به "
"اشتراک گذاشته می‌شوند:"

#: ../../tutorial/classes.rst:404
msgid ""
"class Dog:\n"
"\n"
"    kind = 'canine'         # class variable shared by all instances\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name    # instance variable unique to each instance\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.kind                  # shared by all dogs\n"
"'canine'\n"
">>> e.kind                  # shared by all dogs\n"
"'canine'\n"
">>> d.name                  # unique to d\n"
"'Fido'\n"
">>> e.name                  # unique to e\n"
"'Buddy'"
msgstr ""
"class Dog:\n"
"\n"
"    kind = 'canine'         # class variable shared by all instances\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name    # instance variable unique to each instance\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.kind                  # shared by all dogs\n"
"'canine'\n"
">>> e.kind                  # shared by all dogs\n"
"'canine'\n"
">>> d.name                  # unique to d\n"
"'Fido'\n"
">>> e.name                  # unique to e\n"
"'Buddy'"

#: ../../tutorial/classes.rst:422
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"همانطور که در :ref:`tut-object` بحث شد، داده های به اشتراک گذاشته شده می "
"توانند اثرات شگفت انگیزی با درگیر کردن اشیاء :term:`mutable` مانند لیست ها و"
" فرهنگ لغت داشته باشند. به عنوان مثال، لیست *tricks* در کد زیر نباید به "
"عنوان یک متغیر کلاس استفاده شود زیرا فقط یک لیست تنها توسط تمام نمونه های "
"*Dog* به اشتراک گذاشته می شود:"

#: ../../tutorial/classes.rst:428
msgid ""
"class Dog:\n"
"\n"
"    tricks = []             # mistaken use of a class variable\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks                # unexpectedly shared by all dogs\n"
"['roll over', 'play dead']"
msgstr ""
"class Dog:\n"
"\n"
"    tricks = []             # mistaken use of a class variable\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks                # unexpectedly shared by all dogs\n"
"['roll over', 'play dead']"

#: ../../tutorial/classes.rst:445
msgid "Correct design of the class should use an instance variable instead::"
msgstr "در طراحی صحیح کلاس باید از یک متغیر نمونه استفاده شود:"

#: ../../tutorial/classes.rst:447
msgid ""
"class Dog:\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        self.tricks = []    # creates a new empty list for each dog\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks\n"
"['roll over']\n"
">>> e.tricks\n"
"['play dead']"
msgstr ""
"class Dog:\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        self.tricks = []    # creates a new empty list for each dog\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks\n"
"['roll over']\n"
">>> e.tricks\n"
"['play dead']"

#: ../../tutorial/classes.rst:469
msgid "Random Remarks"
msgstr "اظهارات تصادفی"

#: ../../tutorial/classes.rst:473
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"اگر نام مشخصه یکسانی هم در یک نمونه و هم در یک کلاس وجود داشته باشد، جستجوی "
"ویژگی، نمونه را اولویت بندی می کند::"

#: ../../tutorial/classes.rst:476
msgid ""
">>> class Warehouse:\n"
"...    purpose = 'storage'\n"
"...    region = 'west'\n"
"...\n"
">>> w1 = Warehouse()\n"
">>> print(w1.purpose, w1.region)\n"
"storage west\n"
">>> w2 = Warehouse()\n"
">>> w2.region = 'east'\n"
">>> print(w2.purpose, w2.region)\n"
"storage east"
msgstr ""
">>> انبار کلاس:\n"
"... هدف = \"ذخیره سازی\"\n"
"... منطقه = \"غرب\"\n"
"...\n"
">>> w1 = انبار()\n"
">>> چاپ (w1.purpose, w1.region)\n"
"انباری غرب\n"
">>> w2 = انبار()\n"
">>> w2.region = 'شرق'\n"
">>> چاپ (w2.purpose, w2.region)\n"
"ذخیره سازی شرق"

#: ../../tutorial/classes.rst:488
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide"
" implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"ویژگی های داده ممکن است توسط روش ها و همچنین توسط کاربران عادی (\"مشتریان\")"
" یک شی ارجاع داده شوند.  به عبارت دیگر، کلاس ها برای پیاده سازی انواع داده "
"های انتزاعی خالص قابل استفاده نیستند.  در واقع، هیچ چیز در پایتون امکان "
"اعمال مخفی کردن داده ها را فراهم نمی کند --- همه اینها بر اساس قرارداد است."
"  (از سوی دیگر, پیاده‌سازی پایتون که به زبان C نوشته شده است, می‌تواند "
"جزئیات پیاده‌سازی را کاملاً مخفی کند و در صورت لزوم دسترسی به یک شی را کنترل"
" کند؛ این می‌تواند توسط پسوندهای پایتون نوشته شده در C استفاده شود.)"

#: ../../tutorial/classes.rst:496
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object"
" without affecting the validity of the methods, as long as name conflicts "
"are avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"مشتریان باید با احتیاط از ویژگی های داده استفاده کنند --- مشتریان ممکن است "
"با مهر زدن بر روی ویژگی های داده خود، متغیرهای حفظ شده توسط روش ها را خراب "
"کنند.  توجه داشته باشید که کلاینت‌ها ممکن است ویژگی‌های داده خود را به یک "
"شیء نمونه اضافه کنند، بدون اینکه بر اعتبار روش‌ها تأثیر بگذارد، تا زمانی که "
"از تضاد نام اجتناب شود --- باز هم، یک قرارداد نام‌گذاری می‌تواند در اینجا "
"سردردهای زیادی را نجات دهد."

#: ../../tutorial/classes.rst:502
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of"
" methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"هیچ مختصری برای ارجاع ویژگی های داده (یا روش های دیگر!) از درون متدها وجود "
"ندارد.  من متوجه شدم که این در واقع خوانایی روش ها را افزایش می دهد: هیچ "
"شانسی برای اشتباه گرفتن متغیرهای محلی و متغیرهای نمونه در هنگام نگاه کردن به"
" یک روش وجود ندارد."

#: ../../tutorial/classes.rst:507
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable"
" that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"اغلب، اولین آرگومان یک متد ``self`` نامیده می شود.  این چیزی بیش از یک "
"قرارداد نیست: نام ``self`` مطلقاً معنای خاصی برای پایتون ندارد.  البته توجه "
"داشته باشید که با رعایت نکردن قرارداد ممکن است کد شما برای سایر برنامه "
"نویسان پایتون کمتر قابل خواندن باشد و همچنین می توان تصور کرد که یک برنامه "
"*class browser* ممکن است نوشته شود که بر چنین قراردادی متکی باشد."

#: ../../tutorial/classes.rst:513
msgid ""
"Any function object that is a class attribute defines a method for instances"
" of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a"
" local variable in the class is also ok.  For example::"
msgstr ""
"هر شیء تابعی که یک ویژگی کلاس است، متدی را برای نمونه هایی از آن کلاس تعریف "
"می کند.  لزومی ندارد که تعریف تابع به صورت متنی در تعریف کلاس باشد: تخصیص یک"
" شی تابع به یک متغیر محلی در کلاس نیز مشکلی ندارد.  به عنوان مثال::"

#: ../../tutorial/classes.rst:518
msgid ""
"# Function defined outside the class\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"class C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'hello world'\n"
"\n"
"    h = g"
msgstr ""
"# Function defined outside the class\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"class C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'hello world'\n"
"\n"
"    h = g"

#: ../../tutorial/classes.rst:530
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`!C` that "
"refer to function objects, and consequently they are all methods of "
"instances of :class:`!C` --- ``h`` being exactly equivalent to ``g``.  Note "
"that this practice usually only serves to confuse the reader of a program."
msgstr ""
"اکنون ``f``، ``g`` و ``h`` همگی ویژگی‌های کلاس :class:`!C` هستند که به اشیاء"
" تابع اشاره می‌کنند، و در نتیجه همه روش‌هایی هستند که نمونه‌هایی از "
":class:`!C` --- ``h`` دقیقاً معادل ``g`` هستند.  توجه داشته باشید که این عمل"
" معمولا فقط باعث سردرگمی خواننده یک برنامه می شود."

#: ../../tutorial/classes.rst:535
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"متدها ممکن است با استفاده از ویژگی های متد آرگومان ``self`` متدهای دیگر را "
"فراخوانی کنند:"

#: ../../tutorial/classes.rst:538
msgid ""
"class Bag:\n"
"    def __init__(self):\n"
"        self.data = []\n"
"\n"
"    def add(self, x):\n"
"        self.data.append(x)\n"
"\n"
"    def addtwice(self, x):\n"
"        self.add(x)\n"
"        self.add(x)"
msgstr ""
"class Bag:\n"
"    def __init__(self):\n"
"        self.data = []\n"
"\n"
"    def add(self, x):\n"
"        self.data.append(x)\n"
"\n"
"    def addtwice(self, x):\n"
"        self.add(x)\n"
"        self.add(x)"

#: ../../tutorial/classes.rst:549
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some"
" good reasons why a method would want to reference its own class."
msgstr ""
"متدها ممکن است مانند توابع معمولی به نام های سراسری ارجاع دهند.  دامنه جهانی"
" مرتبط با یک روش، ماژول حاوی تعریف آن است.  (یک کلاس هرگز به عنوان یک دامنه "
"جهانی استفاده نمی شود.) در حالی که به ندرت با دلیل موجهی برای استفاده از "
"داده های سراسری در یک متد مواجه می شوید، استفاده های قانونی زیادی از دامنه "
"جهانی وجود دارد: برای یک چیز، توابع و ماژول های وارد شده به دامنه جهانی را "
"می توان توسط روش ها و همچنین توابع و کلاس های تعریف شده در آن استفاده کرد.  "
"معمولاً کلاسی که متد را در بر می گیرد، خود در این محدوده جهانی تعریف می شود،"
" و در بخش بعدی دلایل خوبی برای اینکه یک متد بخواهد به کلاس خود ارجاع دهد، "
"خواهیم یافت."

#: ../../tutorial/classes.rst:559
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"هر مقدار یک شی است و بنابراین دارای یک *class* است (که *type* آن نیز نامیده "
"می شود). به عنوان ``object.__class__`` ذخیره می شود."

#: ../../tutorial/classes.rst:566
msgid "Inheritance"
msgstr "ارث"

#: ../../tutorial/classes.rst:568
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"البته، یک ویژگی زبان بدون پشتیبانی از وراثت شایسته نام \"کلاس\" نخواهد بود."
"  نحو برای تعریف کلاس مشتق شده به صورت زیر است:"

#: ../../tutorial/classes.rst:572
msgid ""
"class DerivedClassName(BaseClassName):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class DerivedClassName(BaseClassName):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"

#: ../../tutorial/classes.rst:579
msgid ""
"The name :class:`!BaseClassName` must be defined in a namespace accessible "
"from the scope containing the derived class definition.  In place of a base "
"class name, other arbitrary expressions are also allowed.  This can be "
"useful, for example, when the base class is defined in another module::"
msgstr ""
"نام :class:`!BaseClassName` باید در یک فضای نام قابل دسترسی از محدوده حاوی "
"تعریف کلاس مشتق شده تعریف شود.  به جای نام کلاس پایه، عبارات دلخواه دیگری "
"نیز مجاز هستند.  این می تواند مفید باشد، برای مثال، زمانی که کلاس پایه در "
"ماژول دیگری تعریف شده است::"

#: ../../tutorial/classes.rst:585
msgid "class DerivedClassName(modname.BaseClassName):"
msgstr "class DerivedClassName(modname.BaseClassName):"

#: ../../tutorial/classes.rst:587
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is"
" not found in the class, the search proceeds to look in the base class.  "
"This rule is applied recursively if the base class itself is derived from "
"some other class."
msgstr ""
"اجرای تعریف کلاس مشتق شده مانند کلاس پایه پیش می رود. هنگامی که شی کلاس "
"ساخته می شود، کلاس پایه به خاطر سپرده می شود.  این برای حل و فصل ارجاعات "
"ویژگی استفاده می شود: اگر ویژگی درخواستی در کلاس یافت نشد، جستجو برای جستجو "
"در کلاس پایه ادامه می یابد.  اگر خود کلاس پایه از کلاس دیگری مشتق شده باشد، "
"این قانون به صورت بازگشتی اعمال می شود."

#: ../../tutorial/classes.rst:593
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"هیچ چیز خاصی در مورد نمونه سازی کلاس های مشتق شده وجود ندارد: "
"``DerivedClassName()`` یک نمونه جدید از کلاس ایجاد می کند.  ارجاعات روش به "
"صورت زیر حل می‌شوند: ویژگی کلاس مربوطه جستجو می‌شود، در صورت لزوم از زنجیره "
"کلاس‌های پایه پایین می‌آید، و مرجع متد در صورتی معتبر است که یک شی تابع را "
"به دست آورد."

#: ../../tutorial/classes.rst:599
msgid ""
"Derived classes may override methods of their base classes.  Because methods"
" have no special privileges when calling other methods of the same object, a"
" method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"کلاس های مشتق شده ممکن است روش های کلاس های پایه خود را لغو کنند.  از آنجایی"
" که متدها هنگام فراخوانی متدهای دیگر یک شی، امتیاز خاصی ندارند، متدی از یک "
"کلاس پایه که متد دیگری را که در همان کلاس پایه تعریف شده است فراخوانی "
"می‌کند، ممکن است در نهایت متدی از یک کلاس مشتق شده را فراخوانی کند که آن را "
"لغو می‌کند.  (برای برنامه نویسان ++C: همه روش ها در پایتون به طور موثر "
"``virtual`` هستند.)"

#: ../../tutorial/classes.rst:605
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call "
"``BaseClassName.methodname(self, arguments)``.  This is occasionally useful "
"to clients as well.  (Note that this only works if the base class is "
"accessible as ``BaseClassName`` in the global scope.)"
msgstr ""
"یک متد overriding در یک کلاس مشتق شده ممکن است در واقع بخواهد به جای "
"جایگزینی ساده متد کلاس پایه با همان نام، گسترش یابد. یک راه ساده برای "
"فراخوانی مستقیم متد کلاس پایه وجود دارد: فقط "
"``BaseClassName.methodname(self, arguments)`` را فراخوانی کنید.  این گاهی "
"اوقات برای مشتریان نیز مفید است.  (توجه داشته باشید که این فقط در صورتی کار "
"می کند که کلاس پایه به عنوان ``BaseClassName`` در محدوده جهانی قابل دسترسی "
"باشد.)"

#: ../../tutorial/classes.rst:612
msgid "Python has two built-in functions that work with inheritance:"
msgstr "پایتون دو تابع داخلی دارد که با وراثت کار می کنند:"

#: ../../tutorial/classes.rst:614
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)``"
" will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"از :func:`isinstance` برای بررسی نوع نمونه استفاده کنید: ``isinstance(obj, "
"int)`` فقط در صورتی ``True`` خواهد بود که ``obj.__class__`` :class:`int` یا "
"کلاسی مشتق شده از :class:`int` باشد."

#: ../../tutorial/classes.rst:618
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)``"
" is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"از :func:`issubclass` برای بررسی وراثت کلاس استفاده کنید: ``issubclass(bool,"
" int)`` ``True`` است زیرا :class:`bool` زیر کلاس :class:`int` است.  با این "
"حال، ``issubclass(float, int)`` ``False`` است زیرا :class:`float` زیر کلاس "
":class:`int` نیست."

#: ../../tutorial/classes.rst:628
msgid "Multiple Inheritance"
msgstr "ارث چندگانه"

#: ../../tutorial/classes.rst:630
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"پایتون از فرمی از وراثت چندگانه نیز پشتیبانی می کند.  یک تعریف کلاس با چندین"
" کلاس پایه به صورت زیر است:"

#: ../../tutorial/classes.rst:633
msgid ""
"class DerivedClassName(Base1, Base2, Base3):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class DerivedClassName (Base1, Base2, Base3):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"

#: ../../tutorial/classes.rst:640
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`!DerivedClassName`,"
" it is searched for in :class:`!Base1`, then (recursively) in the base "
"classes of :class:`!Base1`, and if it was not found there, it was searched "
"for in :class:`!Base2`, and so on."
msgstr ""
"برای بیشتر اهداف، در ساده‌ترین موارد، می‌توانید جستجوی ویژگی‌های به ارث "
"رسیده از یک کلاس والد را به‌عنوان depth-first، از چپ به راست در نظر بگیرید، "
"نه دوبار جستجو در یک کلاس که در آن همپوشانی در سلسله مراتب وجود دارد. "
"بنابراین، اگر یک ویژگی در :class:`!DerivedClassName` یافت نشد، در "
":class:`!Base1` جستجو می شود، سپس (به صورت بازگشتی) در کلاس های پایه "
":class:`!Base1`، و اگر در آنجا یافت نشد، در :class:`!Base2` و غیره جستجو می "
"شود."

#: ../../tutorial/classes.rst:647
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"در واقع، کمی پیچیده تر از آن است. ترتیب تفکیک روش به صورت پویا تغییر می کند "
"تا از فراخوان های مشارکتی به :func:`super` پشتیبانی کند.  این رویکرد در برخی"
" دیگر از زبان‌های ارثی چندگانه به روش فراخوانی بعدی معروف است و قدرتمندتر از"
" فراخوانی موجود در زبان‌های ارثی تک است."

#: ../../tutorial/classes.rst:653
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see :ref:`python_2.3_mro`."
msgstr ""
"ترتیب پویا ضروری است زیرا همه موارد ارث چندگانه یک یا چند رابطه الماس را "
"نشان می‌دهند (که در آن حداقل یکی از کلاس‌های والد از طریق چندین مسیر از "
"پایین‌ترین کلاس قابل دسترسی است).  برای مثال، همه کلاس‌ها از :class:`object`"
" ارث می‌برند، بنابراین هر مورد وراثت چندگانه، بیش از یک مسیر را برای رسیدن "
"به :class:`object` فراهم می‌کند.  برای جلوگیری از دسترسی به کلاس های پایه "
"بیش از یک بار، الگوریتم پویا ترتیب جستجو را به گونه ای خطی می کند که ترتیب "
"چپ به راست مشخص شده در هر کلاس را حفظ می کند، که هر والد را فقط یک بار "
"فراخوانی می کند، و این یکنواخت است (به این معنی که یک کلاس می تواند بدون "
"تأثیر بر ترتیب اولویت والدینش, زیر طبقه بندی شود). در مجموع، این ویژگی ها "
"طراحی کلاس های قابل اعتماد و توسعه پذیر با ارث چندگانه را ممکن می سازد.  "
"برای جزئیات بیشتر، به :ref:`python_2.3_mro` مراجعه کنید."

#: ../../tutorial/classes.rst:670
msgid "Private Variables"
msgstr "متغیرهای خصوصی"

#: ../../tutorial/classes.rst:672
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an"
" object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"متغیرهای نمونه \"خصوصی\" که جز از داخل یک شی قابل دسترسی نیستند، در پایتون "
"وجود ندارند.  با این حال، قراردادی وجود دارد که اکثر کدهای پایتون از آن "
"پیروی می کنند: نامی که پیشوند آن زیرخط است (مثلاً ``_spam``) باید به عنوان "
"بخشی غیرعمومی از API در نظر گرفته شود (خواه یک تابع, یک متد یا یک عضو داده "
"باشد).  باید جزییات اجرایی در نظر گرفته شود و بدون اطلاع قبلی قابل تغییر "
"باشد."

#: ../../tutorial/classes.rst:682
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) stripped."
"  This mangling is done without regard to the syntactic position of the "
"identifier, as long as it occurs within the definition of a class."
msgstr ""
"از آنجایی که یک مورد استفاده معتبر برای اعضای کلاس خصوصی وجود دارد (یعنی "
"برای جلوگیری از تداخل نام نام‌ها با نام‌هایی که توسط کلاس‌های فرعی تعریف "
"شده‌اند), پشتیبانی محدودی از چنین مکانیزمی به نام :dfn:`name mangling` وجود "
"دارد.  هر شناسه ای از فرم ``__spam`` (حداقل دو زیرخط اصلی, حداکثر یک زیرخط "
"آخر) به صورت متنی با ``_classname__spam`` جایگزین می شود، که در آن "
"``classname`` نام کلاس فعلی با زیرخط(های) ابتدایی حذف شده است.  این اختلاط "
"بدون توجه به موقعیت نحوی شناسه انجام می شود، تا زمانی که در تعریف یک کلاس رخ"
" دهد."

#: ../../tutorial/classes.rst:693
msgid ""
"The :ref:`private name mangling specifications <private-name-mangling>` for "
"details and special cases."
msgstr ""
":ref:`private name mangling specifications <private-name-mangling>` برای "
"جزئیات و موارد خاص."

#: ../../tutorial/classes.rst:696
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"مخفی کردن نام برای اجازه دادن به زیر کلاس‌ها بدون شکستن فراخوانی‌های متد "
"درون‌کلاسی، نادیده گرفته می‌شود.  به عنوان مثال::"

#: ../../tutorial/classes.rst:699
msgid ""
"class Mapping:\n"
"    def __init__(self, iterable):\n"
"        self.items_list = []\n"
"        self.__update(iterable)\n"
"\n"
"    def update(self, iterable):\n"
"        for item in iterable:\n"
"            self.items_list.append(item)\n"
"\n"
"    __update = update   # private copy of original update() method\n"
"\n"
"class MappingSubclass(Mapping):\n"
"\n"
"    def update(self, keys, values):\n"
"        # provides new signature for update()\n"
"        # but does not break __init__()\n"
"        for item in zip(keys, values):\n"
"            self.items_list.append(item)"
msgstr ""
"class Mapping:\n"
"    def __init__(self, iterable):\n"
"        self.items_list = []\n"
"        self.__update(iterable)\n"
"\n"
"    def update(self, iterable):\n"
"        for item in iterable:\n"
"            self.items_list.append(item)\n"
"\n"
"    __update = update   # private copy of original update() method\n"
"\n"
"class MappingSubclass(Mapping):\n"
"\n"
"    def update(self, keys, values):\n"
"        # provides new signature for update()\n"
"        # but does not break __init__()\n"
"        for item in zip(keys, values):\n"
"            self.items_list.append(item)"

#: ../../tutorial/classes.rst:718
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a"
" ``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"مثال بالا حتی اگر ``MappingSubclass`` یک شناسه ``__update`` معرفی کند کار می"
" کند زیرا به ترتیب با ``_Mapping__update`` در کلاس ``Mapping`` و "
"``_MappingSubclass__update`` در کلاس ``MappingSubclass`` جایگزین شده است."

#: ../../tutorial/classes.rst:723
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered private."
"  This can even be useful in special circumstances, such as in the debugger."
msgstr ""
"توجه داشته باشید که قوانین انحراف بیشتر برای جلوگیری از حوادث طراحی شده اند."
" هنوز هم می توان به متغیری که خصوصی در نظر گرفته می شود دسترسی پیدا کرد یا "
"تغییر داد.  این حتی می‌تواند در شرایط خاص، مانند دیباگر، مفید باشد."

#: ../../tutorial/classes.rst:727
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"توجه داشته باشید که کد ارسال شده به ``exec()`` یا ``eval()`` نام کلاس کلاس "
"فراخوانی را کلاس فعلی در نظر نمی گیرد. این شبیه به اثر دستور ``global`` است،"
" که اثر آن نیز محدود به کدهایی است که با هم کامپایل شده اند.  همین محدودیت "
"برای ``getattr()``، ``setattr()`` و ``delattr()``، و همچنین هنگام ارجاع "
"مستقیم به ``__dict__`` اعمال می شود."

#: ../../tutorial/classes.rst:738
msgid "Odds and Ends"
msgstr "Odds and Ends"

#: ../../tutorial/classes.rst:740
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items. The idiomatic "
"approach is to use :mod:`dataclasses` for this purpose::"
msgstr ""
"گاهی اوقات مفید است که یک نوع داده شبیه به پاسکال \"Record\" یا C \"struct\""
" داشته باشید که چند مورد داده نامگذاری شده را با هم ترکیب می کند. رویکرد "
"اصطلاحی استفاده از :mod:`dataclasses` برای این منظور است:"

#: ../../tutorial/classes.rst:744
msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class Employee:\n"
"    name: str\n"
"    dept: str\n"
"    salary: int"
msgstr ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class Employee:\n"
"    name: str\n"
"    dept: str\n"
"    salary: int"

#: ../../tutorial/classes.rst:754
msgid ""
">>> john = Employee('john', 'computer lab', 1000)\n"
">>> john.dept\n"
"'computer lab'\n"
">>> john.salary\n"
"1000"
msgstr ""
">>> john = Employee('john', 'computer lab', 1000)\n"
">>> john.dept\n"
"'computer lab'\n"
">>> john.salary\n"
"1000"

#: ../../tutorial/classes.rst:760
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type instead."
"  For instance, if you have a function that formats some data from a file "
"object, you can define a class with methods :meth:`~io.TextIOBase.read` and "
":meth:`~io.TextIOBase.readline` that get the data from a string buffer "
"instead, and pass it as an argument."
msgstr ""
"قطعه ای از کد پایتون که انتظار یک نوع داده انتزاعی خاص را دارد، اغلب می "
"تواند به کلاسی منتقل شود که به جای آن روش های آن نوع داده را شبیه سازی می "
"کند.  به عنوان مثال، اگر تابعی دارید که برخی از داده‌ها را از یک شی فایل "
"قالب‌بندی می‌کند، می‌توانید کلاسی را با متدهای :meth:`~io.TextIOBase.read` و"
" :meth:`~io.TextIOBase.readline` تعریف کنید که به جای آن داده‌ها را از یک "
"بافر رشته‌ای دریافت کرده و به عنوان آرگومان ارسال کنید."

#: ../../tutorial/classes.rst:772
msgid ""
":ref:`Instance method objects <instance-methods>` have attributes, too: "
":attr:`m.__self__ <method.__self__>` is the instance object with the method "
":meth:`!m`, and :attr:`m.__func__ <method.__func__>` is the :ref:`function "
"object <user-defined-funcs>` corresponding to the method."
msgstr ""
":ref:`Instance method objects <instance-methods>` نیز ویژگی هایی دارد: "
":attr:`m.__self__ <method.__self__>` شی نمونه با متد :meth:`!m` است و "
":attr:`m.__func__ <method.__func__>` :ref:`function object <user-defined-"
"funcs>` مربوط به متد است."

#: ../../tutorial/classes.rst:782
msgid "Iterators"
msgstr "تکرار کننده ها"

#: ../../tutorial/classes.rst:784
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"احتمالاً تا به حال متوجه شده اید که بیشتر اشیاء کانتینر را می توان با "
"استفاده از دستور :keyword:`for` حلقه کرد:"

#: ../../tutorial/classes.rst:787
msgid ""
"for element in [1, 2, 3]:\n"
"    print(element)\n"
"for element in (1, 2, 3):\n"
"    print(element)\n"
"for key in {'one':1, 'two':2}:\n"
"    print(key)\n"
"for char in \"123\":\n"
"    print(char)\n"
"for line in open(\"myfile.txt\"):\n"
"    print(line, end='')"
msgstr ""
"for element in [1, 2, 3]:\n"
"    print(element)\n"
"for element in (1, 2, 3):\n"
"    print(element)\n"
"for key in {'one':1, 'two':2}:\n"
"    print(key)\n"
"for char in \"123\":\n"
"    print(char)\n"
"for line in open(\"myfile.txt\"):\n"
"    print(line, end='')"

#: ../../tutorial/classes.rst:798
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the "
":keyword:`for` statement calls :func:`iter` on the container object.  The "
"function returns an iterator object that defines the method "
":meth:`~iterator.__next__` which accesses elements in the container one at a"
" time.  When there are no more elements, :meth:`~iterator.__next__` raises a"
" :exc:`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the "
":func:`next` built-in function; this example shows how it all works::"
msgstr ""
"این سبک دسترسی واضح، مختصر و راحت است.  استفاده از تکرار کننده ها پایتون را "
"فرا گرفته و یکپارچه می کند.  در پشت صحنه، دستور :keyword:`for` :func:`iter` "
"را روی شی کانتینر فراخوانی می کند.  تابع یک شی تکرار کننده را برمی گرداند که"
" متد :meth:`~iterator.__next__` را تعریف می کند که به عناصر موجود در کانتینر"
" در یک زمان دسترسی پیدا می کند.  هنگامی که هیچ عنصر دیگری وجود ندارد، "
":meth:`~iterator.__next__` یک استثنای :exc:`StopIteration` را ایجاد می کند "
"که به حلقه :keyword:`!for` می گوید خاتمه یابد.  با استفاده از تابع داخلی "
":func:`next` می توانید روش :meth:`~iterator.__next__` را فراخوانی کنید. این "
"مثال نشان می دهد که چگونه همه چیز کار می کند::"

#: ../../tutorial/classes.rst:807
msgid ""
">>> s = 'abc'\n"
">>> it = iter(s)\n"
">>> it\n"
"<str_iterator object at 0x10c90e650>\n"
">>> next(it)\n"
"'a'\n"
">>> next(it)\n"
"'b'\n"
">>> next(it)\n"
"'c'\n"
">>> next(it)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    next(it)\n"
"StopIteration"
msgstr ""
">>> s = 'abc'\n"
">>> آن = تکرار (ها)\n"
">>> آن را\n"
"<str_iterator شی در 0x10c90e650>\n"
">>> بعدی (آن)\n"
"'a'\n"
">>> بعدی (آن)\n"
"'ب'\n"
">>> بعدی (آن)\n"
"'ج'\n"
">>> بعدی (آن)\n"
"ردیابی (آخرین تماس اخیر):\n"
"  فایل \"<stdin>\", خط 1، در <module>\n"
"    بعدی (آن)\n"
"توقف تکرار"

#: ../../tutorial/classes.rst:823
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`~container.__iter__` "
"method which returns an object with a :meth:`~iterator.__next__` method.  If"
" the class defines :meth:`!__next__`, then :meth:`!__iter__` can just return"
" ``self``::"
msgstr ""
"با مشاهده مکانیزم های پشت پروتکل تکرار کننده، اضافه کردن رفتار تکرار کننده "
"به کلاس های خود آسان است.  یک متد :meth:`~container.__iter__` تعریف کنید که "
"یک شی را با متد :meth:`~iterator.__next__` برمی گرداند.  اگر کلاس "
":meth:`!__next__` را تعریف کند، :meth:`!__iter__` فقط می تواند ``self``::"

#: ../../tutorial/classes.rst:828
msgid ""
"class Reverse:\n"
"    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n"
"    def __init__(self, data):\n"
"        self.data = data\n"
"        self.index = len(data)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.index == 0:\n"
"            raise StopIteration\n"
"        self.index = self.index - 1\n"
"        return self.data[self.index]"
msgstr ""
"class Reverse:\n"
"    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n"
"    def __init__(self, data):\n"
"        self.data = data\n"
"        self.index = len(data)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.index == 0:\n"
"            raise StopIteration\n"
"        self.index = self.index - 1\n"
"        return self.data[self.index]"

#: ../../tutorial/classes.rst:845
msgid ""
">>> rev = Reverse('spam')\n"
">>> iter(rev)\n"
"<__main__.Reverse object at 0x00A1DB50>\n"
">>> for char in rev:\n"
"...     print(char)\n"
"...\n"
"m\n"
"a\n"
"p\n"
"s"
msgstr ""
">>> rev = معکوس ('spam')\n"
">>> تکرار (شور)\n"
"<__main__. معکوس شی در 0x00A1DB50>\n"
">>> برای کاراکتر در دور:\n"
"... چاپ (کارت)\n"
"...\n"
"متر\n"
"الف\n"
"ص\n"
"س"

#: ../../tutorial/classes.rst:860
msgid "Generators"
msgstr "ژنراتورها"

#: ../../tutorial/classes.rst:862
msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the "
":keyword:`yield` statement whenever they want to return data.  Each time "
":func:`next` is called on it, the generator resumes where it left off (it "
"remembers all the data values and which statement was last executed).  An "
"example shows that generators can be trivially easy to create::"
msgstr ""
":term:`Generators <generator>` یک ابزار ساده و قدرتمند برای ایجاد تکرار "
"کننده است.  آنها مانند توابع معمولی نوشته می شوند اما هر زمان که بخواهند "
"داده را برگردانند از دستور :keyword:`yield` استفاده می کنند.  هر بار که "
":func:`next` بر روی آن فراخوانی می شود، ژنراتور از همان جایی که متوقف شده "
"بود از سر گرفته می شود (همه مقادیر داده را به خاطر می آورد و آخرین دستوری که"
" اجرا شده است).  یک مثال نشان می دهد که ایجاد ژنراتورها بسیار ساده است:"

#: ../../tutorial/classes.rst:869
msgid ""
"def reverse(data):\n"
"    for index in range(len(data)-1, -1, -1):\n"
"        yield data[index]"
msgstr ""
"def reverse(data):\n"
"    for index in range(len(data)-1, -1, -1):\n"
"        yield data[index]"

#: ../../tutorial/classes.rst:875
msgid ""
">>> for char in reverse('golf'):\n"
"...     print(char)\n"
"...\n"
"f\n"
"l\n"
"o\n"
"g"
msgstr ""
">>> for char in reverse('golf'):\n"
"...     print(char)\n"
"...\n"
"f\n"
"l\n"
"o\n"
"g"

#: ../../tutorial/classes.rst:883
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`~iterator.__iter__` and "
":meth:`~generator.__next__` methods are created automatically."
msgstr ""
"هر کاری را که بتوان با ژنراتورها انجام داد، می‌تواند با تکرارکننده‌های مبتنی"
" بر کلاس نیز همانطور که در بخش قبل توضیح داده شد، انجام داد.  چیزی که "
"ژنراتورها را بسیار فشرده می کند این است که متدهای :meth:`~iterator.__iter__`"
" و :meth:`~generator.__next__` به طور خودکار ایجاد می شوند."

#: ../../tutorial/classes.rst:888
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like "
"``self.index`` and ``self.data``."
msgstr ""
"یکی دیگر از ویژگی های کلیدی این است که متغیرهای محلی و وضعیت اجرا به طور "
"خودکار بین تماس ها ذخیره می شوند.  این کار نوشتن تابع را آسان‌تر و واضح‌تر "
"از رویکردی با استفاده از متغیرهای نمونه مانند ``self.index`` و ``self.data``"
" کرد."

#: ../../tutorial/classes.rst:893
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"علاوه بر ایجاد روش خودکار و ذخیره وضعیت برنامه، هنگامی که ژنراتورها خاتمه می"
" یابند، به طور خودکار :exc:`StopIteration` را افزایش می دهند. در ترکیب، این "
"ویژگی ها ایجاد تکرار کننده ها را بدون تلاش بیشتر از نوشتن یک تابع معمولی "
"آسان می کند."

#: ../../tutorial/classes.rst:902
msgid "Generator Expressions"
msgstr "عبارات ژنراتور"

#: ../../tutorial/classes.rst:904
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax"
" similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more"
" compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"برخی از مولدهای ساده را می توان به طور خلاصه به عنوان عبارات با استفاده از "
"نحوی شبیه به درک لیست اما با پرانتز به جای پرانتز کدگذاری کرد. این عبارات "
"برای موقعیت هایی طراحی شده اند که ژنراتور بلافاصله توسط یک تابع محصور کننده "
"استفاده می شود.  عبارات ژنراتور نسبت به تعاریف کامل مولد فشرده تر اما تطبیق "
"پذیری کمتری دارند و نسبت به درک لیست های معادل، حافظه دوستانه بیشتری دارند."

#: ../../tutorial/classes.rst:911
msgid "Examples::"
msgstr "مثال ها::"

#: ../../tutorial/classes.rst:913
msgid ""
">>> sum(i*i for i in range(10))                 # sum of squares\n"
"285\n"
"\n"
">>> xvec = [10, 20, 30]\n"
">>> yvec = [7, 5, 3]\n"
">>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n"
"260\n"
"\n"
">>> unique_words = set(word for line in page  for word in line.split())\n"
"\n"
">>> valedictorian = max((student.gpa, student.name) for student in graduates)\n"
"\n"
">>> data = 'golf'\n"
">>> list(data[i] for i in range(len(data)-1, -1, -1))\n"
"['f', 'l', 'o', 'g']"
msgstr ""
">>> sum(i*i for i in range(10))                 # sum of squares\n"
"285\n"
"\n"
">>> xvec = [10, 20, 30]\n"
">>> yvec = [7, 5, 3]\n"
">>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n"
"260\n"
"\n"
">>> unique_words = set(word for line in page  for word in line.split())\n"
"\n"
">>> valedictorian = max((student.gpa, student.name) for student in graduates)\n"
"\n"
">>> data = 'golf'\n"
">>> list(data[i] for i in range(len(data)-1, -1, -1))\n"
"['f', 'l', 'o', 'g']"

#: ../../tutorial/classes.rst:932
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../tutorial/classes.rst:933
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name ``__dict__`` is an attribute but "
"not a global name. Obviously, using this violates the abstraction of "
"namespace implementation, and should be restricted to things like post-"
"mortem debuggers."
msgstr ""
"به جز یک چیز  اشیاء ماژول دارای یک ویژگی مخفی فقط خواندنی به نام "
":attr:`~object.__dict__` هستند که فرهنگ لغت مورد استفاده برای پیاده سازی "
"فضای نام ماژول را برمی گرداند. نام ``__dict__`` یک ویژگی است اما یک نام "
"جهانی نیست. بدیهی است که استفاده از این انتزاع پیاده سازی فضای نام را نقض می"
" کند و باید به مواردی مانند اشکال زدایی پس از مرگ محدود شود."

#: ../../tutorial/classes.rst:343
msgid "object"
msgstr "شی"

#: ../../tutorial/classes.rst:343
msgid "method"
msgstr "روش"

#: ../../tutorial/classes.rst:679
msgid "name"
msgstr "نام"

#: ../../tutorial/classes.rst:679
msgid "mangling"
msgstr "درهم ریختن"
