# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Alireza Shabani <theRevisto@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-21 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:50+0000\n"
"Last-Translator: Alireza Shabani <theRevisto@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/modules.rst:5
msgid "Modules"
msgstr "ماژول ها"

#: ../../tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the definitions "
"you have made (functions and variables) are lost. Therefore, if you want to "
"write a somewhat longer program, you are better off using a text editor to "
"prepare the input for the interpreter and running it with that file as input"
" instead.  This is known as creating a *script*.  As your program gets "
"longer, you may want to split it into several files for easier maintenance."
"  You may also want to use a handy function that you've written in several "
"programs without copying its definition into each program."
msgstr ""
"اگر از مفسر پایتون خارج شوید و دوباره آن را وارد کنید، تعاریفی که ساخته اید "
"(توابع و متغیرها) از بین می روند. بنابراین، اگر می‌خواهید یک برنامه "
"طولانی‌تر بنویسید، بهتر است از یک ویرایشگر متن برای آماده کردن ورودی برای "
"مفسر استفاده کنید و آن را با آن فایل به‌عنوان ورودی اجرا کنید.  این به عنوان"
" ایجاد *script* شناخته می شود.  همانطور که برنامه شما طولانی تر می شود، ممکن"
" است بخواهید برای نگهداری آسان تر آن را به چندین فایل تقسیم کنید.  همچنین "
"ممکن است بخواهید از یک تابع مفیدی که در چندین برنامه نوشته اید بدون کپی کردن"
" تعریف آن در هر برنامه استفاده کنید."

#: ../../tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use them "
"in a script or in an interactive instance of the interpreter. Such a file is"
" called a *module*; definitions from a module can be *imported* into other "
"modules or into the *main* module (the collection of variables that you have"
" access to in a script executed at the top level and in calculator mode)."
msgstr ""
"برای پشتیبانی از این موضوع، پایتون راهی برای قرار دادن تعاریف در یک فایل و "
"استفاده از آنها در یک اسکریپت یا در یک نمونه تعاملی از مفسر دارد. چنین فایلی"
" *module* نامیده می شود. تعاریف یک ماژول می تواند *imported* به ماژول های "
"دیگر یا به ماژول *main* (مجموعه ای از متغیرهایی که در یک اسکریپت اجرا شده در"
" سطح بالا و در حالت ماشین حساب به آنها دسترسی دارید) باشد."

#: ../../tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The file "
"name is the module name with the suffix :file:`.py` appended.  Within a "
"module, the module's name (as a string) is available as the value of the "
"global variable ``__name__``.  For instance, use your favorite text editor "
"to create a file called :file:`fibo.py` in the current directory with the "
"following contents::"
msgstr ""
"ماژول فایلی است که شامل تعاریف و عبارات پایتون است.  نام فایل، نام ماژول با "
"پسوند :file:`.py` است.  در یک ماژول، نام ماژول (به عنوان یک رشته) به عنوان "
"مقدار متغیر جهانی ``__name__`` در دسترس است.  به عنوان مثال، از ویرایشگر متن"
" مورد علاقه خود برای ایجاد فایلی به نام :file:`fibo.py` در فهرست فعلی با "
"محتوای زیر استفاده کنید:"

#: ../../tutorial/modules.rst:28
msgid ""
"# Fibonacci numbers module\n"
"\n"
"def fib(n):    # write Fibonacci series up to n\n"
"    a, b = 0, 1\n"
"    while a < n:\n"
"        print(a, end=' ')\n"
"        a, b = b, a+b\n"
"    print()\n"
"\n"
"def fib2(n):   # return Fibonacci series up to n\n"
"    result = []\n"
"    a, b = 0, 1\n"
"    while a < n:\n"
"        result.append(a)\n"
"        a, b = b, a+b\n"
"    return result"
msgstr ""
"# Fibonacci numbers module\n"
"\n"
"def fib(n):    # write Fibonacci series up to n\n"
"    a, b = 0, 1\n"
"    while a < n:\n"
"        print(a, end=' ')\n"
"        a, b = b, a+b\n"
"    print()\n"
"\n"
"def fib2(n):   # return Fibonacci series up to n\n"
"    result = []\n"
"    a, b = 0, 1\n"
"    while a < n:\n"
"        result.append(a)\n"
"        a, b = b, a+b\n"
"    return result"

#: ../../tutorial/modules.rst:45
msgid ""
"Now enter the Python interpreter and import this module with the following "
"command::"
msgstr "حالا مفسر پایتون را وارد کنید و این ماژول را با دستور زیر وارد کنید:"

#: ../../tutorial/modules.rst:48
msgid ">>> import fibo"
msgstr ">>> import fibo"

#: ../../tutorial/modules.rst:50
msgid ""
"This does not add the names of the functions defined in ``fibo``  directly "
"to the current :term:`namespace` (see :ref:`tut-scopes` for more details); "
"it only adds the module name ``fibo`` there. Using the module name you can "
"access the functions::"
msgstr ""
"این نام توابع تعریف شده در ``fibo`` را مستقیماً به :term:`namespace` فعلی "
"اضافه نمی کند (برای جزئیات بیشتر به :ref:`tut-scopes` مراجعه کنید). فقط نام "
"ماژول ``fibo`` را در آنجا اضافه می کند. با استفاده از نام ماژول می توانید به"
" توابع دسترسی داشته باشید:"

#: ../../tutorial/modules.rst:55
msgid ""
">>> fibo.fib(1000)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n"
">>> fibo.fib2(100)\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
">>> fibo.__name__\n"
"'fibo'"
msgstr ""
">>> fibo.fib(1000)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n"
">>> fibo.fib2 (100)\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
">>> fibo.__name__\n"
"\"فیبو\""

#: ../../tutorial/modules.rst:62
msgid ""
"If you intend to use a function often you can assign it to a local name::"
msgstr ""
"اگر قصد دارید از یک تابع اغلب استفاده کنید، می توانید آن را به یک نام محلی "
"اختصاص دهید:"

#: ../../tutorial/modules.rst:64
msgid ""
">>> fib = fibo.fib\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""
">>> fib = fibo.fib\n"
">>> fib (500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"

#: ../../tutorial/modules.rst:72
msgid "More on Modules"
msgstr "اطلاعات بیشتر در مورد ماژول ها"

#: ../../tutorial/modules.rst:74
msgid ""
"A module can contain executable statements as well as function definitions. "
"These statements are intended to initialize the module. They are executed "
"only the *first* time the module name is encountered in an import statement."
" [#]_ (They are also run if the file is executed as a script.)"
msgstr ""
"یک ماژول می تواند شامل دستورات اجرایی و همچنین تعاریف تابع باشد. این عبارات "
"برای مقداردهی اولیه ماژول در نظر گرفته شده است. آنها فقط زمانی اجرا می شوند "
"که نام ماژول در یک دستور import با نام *first* مواجه می شود. [#]_ (اگر فایل "
"به صورت اسکریپت اجرا شود نیز اجرا می شوند.)"

#: ../../tutorial/modules.rst:79
msgid ""
"Each module has its own private namespace, which is used as the global "
"namespace by all functions defined in the module. Thus, the author of a "
"module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if you"
" know what you are doing you can touch a module's global variables with the "
"same notation used to refer to its functions, ``modname.itemname``."
msgstr ""
"هر ماژول فضای نام خصوصی خود را دارد که به عنوان فضای نام جهانی توسط تمام "
"توابع تعریف شده در ماژول استفاده می شود. بنابراین، نویسنده یک ماژول می تواند"
" از متغیرهای سراسری در ماژول استفاده کند بدون اینکه نگران برخورد تصادفی با "
"متغیرهای سراسری کاربر باشد. از سوی دیگر، اگر می‌دانید چه کار می‌کنید، "
"می‌توانید متغیرهای سراسری یک ماژول را با همان نمادی که برای اشاره به عملکرد "
"آن، ``modname.itemname`` استفاده می‌شود، لمس کنید."

#: ../../tutorial/modules.rst:86
msgid ""
"Modules can import other modules.  It is customary but not required to place"
" all :keyword:`import` statements at the beginning of a module (or script, "
"for that matter).  The imported module names, if placed at the top level of "
"a module (outside any functions or classes), are added to the module's "
"global namespace."
msgstr ""
"ماژول ها می توانند ماژول های دیگر را وارد کنند.  قرار دادن تمام عبارات "
":keyword:`import` در ابتدای یک ماژول (یا اسکریپت) مرسوم است، اما لازم نیست."
"  نام‌های ماژول وارد شده، اگر در سطح بالای یک ماژول (خارج از هر توابع یا "
"کلاس) قرار گیرند، به فضای نام جهانی ماژول اضافه می‌شوند."

#: ../../tutorial/modules.rst:91
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's namespace.  For example::"
msgstr ""
"گونه‌ای از عبارت :keyword:`import` وجود دارد که نام‌ها را از یک ماژول "
"مستقیماً به فضای نام ماژول واردکننده وارد می‌کند.  به عنوان مثال::"

#: ../../tutorial/modules.rst:94
msgid ""
">>> from fibo import fib, fib2\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""
">>> از fibo import fib, fib2\n"
">>> fib (500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"

#: ../../tutorial/modules.rst:98
msgid ""
"This does not introduce the module name from which the imports are taken in "
"the local namespace (so in the example, ``fibo`` is not defined)."
msgstr ""
"این نام ماژول را که واردات از آن در فضای نام محلی گرفته شده است معرفی نمی "
"کند (بنابراین در مثال, ``fibo`` تعریف نشده است)."

#: ../../tutorial/modules.rst:101
msgid "There is even a variant to import all names that a module defines::"
msgstr ""
"حتی یک نوع برای وارد کردن همه نام هایی که یک ماژول تعریف می کند وجود دارد:"

#: ../../tutorial/modules.rst:103
msgid ""
">>> from fibo import *\n"
">>> fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""
">>> از واردات فیبو *\n"
">>> fib (500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"

#: ../../tutorial/modules.rst:107
msgid ""
"This imports all names except those beginning with an underscore (``_``). In"
" most cases Python programmers do not use this facility since it introduces "
"an unknown set of names into the interpreter, possibly hiding some things "
"you have already defined."
msgstr ""
"این همه نام‌ها را وارد می‌کند، به جز نام‌هایی که با زیرخط (``_``) شروع "
"می‌شوند. در بیشتر موارد برنامه نویسان پایتون از این امکان استفاده نمی کنند "
"زیرا مجموعه ای ناشناخته از نام ها را در مفسر معرفی می کند و احتمالاً برخی از"
" مواردی را که قبلاً تعریف کرده اید پنهان می کند."

#: ../../tutorial/modules.rst:112
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"توجه داشته باشید که به طور کلی عمل وارد کردن ``*`` از یک ماژول یا بسته مورد "
"انتقاد قرار می گیرد، زیرا اغلب باعث کدهای ناخوانا می شود. با این حال، "
"استفاده از آن برای ذخیره تایپ در جلسات تعاملی اشکالی ندارد."

#: ../../tutorial/modules.rst:116
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following "
":keyword:`!as` is bound directly to the imported module."
msgstr ""
"اگر نام ماژول با :keyword:`!as` دنبال شود، نام زیر :keyword:`!as` مستقیماً "
"به ماژول وارد شده متصل می شود."

#: ../../tutorial/modules.rst:121
msgid ""
">>> import fibo as fib\n"
">>> fib.fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""
">>> فیبو را به عنوان فیب وارد کنید\n"
">>> fib.fib(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"

#: ../../tutorial/modules.rst:125
msgid ""
"This is effectively importing the module in the same way that ``import "
"fibo`` will do, with the only difference of it being available as ``fib``."
msgstr ""
"این عملاً ماژول را به همان روشی که ``import fibo`` انجام می دهد وارد می کند،"
" با تنها تفاوت آن در دسترس بودن به عنوان ``fib``."

#: ../../tutorial/modules.rst:128
msgid ""
"It can also be used when utilising :keyword:`from` with similar effects::"
msgstr ""
"همچنین می توان از آن در هنگام استفاده از :keyword:`from` با اثرات مشابه "
"استفاده کرد:"

#: ../../tutorial/modules.rst:130
msgid ""
">>> from fibo import fib as fibonacci\n"
">>> fibonacci(500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"
msgstr ""
">>> از fibo import fib به عنوان فیبوناچی\n"
">>> فیبوناچی (500)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377"

#: ../../tutorial/modules.rst:137
msgid ""
"For efficiency reasons, each module is only imported once per interpreter "
"session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test interactively, "
"use :func:`importlib.reload`, e.g. ``import importlib; "
"importlib.reload(modulename)``."
msgstr ""
"به دلایل کارایی، هر ماژول فقط یک بار در هر جلسه مترجم وارد می شود.  "
"بنابراین، اگر ماژول‌های خود را تغییر می‌دهید، باید مفسر را مجدداً راه‌اندازی"
" کنید - یا اگر فقط یک ماژول است که می‌خواهید به صورت تعاملی آزمایش کنید، از "
":func:`importlib.reload` استفاده کنید، به عنوان مثال. ``import importlib; "
"importlib.reload(modulename)``."

#: ../../tutorial/modules.rst:147
msgid "Executing modules as scripts"
msgstr "اجرای ماژول ها به صورت اسکریپت"

#: ../../tutorial/modules.rst:149
msgid "When you run a Python module with ::"
msgstr "وقتی ماژول پایتون را با ::"

#: ../../tutorial/modules.rst:151
msgid "python fibo.py <arguments>"
msgstr "python fibo.py <arguments>"

#: ../../tutorial/modules.rst:153
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding "
"this code at the end of your module::"
msgstr ""
"کد موجود در ماژول اجرا می شود، درست مثل اینکه شما آن را وارد کرده اید، اما "
"با ``__name__`` روی ``\"__main__\"`` تنظیم شده است.  یعنی با اضافه کردن این "
"کد در انتهای ماژول:"

#: ../../tutorial/modules.rst:157
msgid ""
"if __name__ == \"__main__\":\n"
"    import sys\n"
"    fib(int(sys.argv[1]))"
msgstr ""
"if __name__ == \"__main__\":\n"
"    import sys\n"
"    fib(int(sys.argv[1]))"

#: ../../tutorial/modules.rst:161
msgid ""
"you can make the file usable as a script as well as an importable module, "
"because the code that parses the command line only runs if the module is "
"executed as the \"main\" file:"
msgstr ""
"شما می توانید فایل را به عنوان یک اسکریپت و همچنین به عنوان یک ماژول قابل "
"واردات قابل استفاده کنید، زیرا کدی که خط فرمان را تجزیه می کند تنها در صورتی"
" اجرا می شود که ماژول به عنوان فایل \"اصلی\" اجرا شود:"

#: ../../tutorial/modules.rst:165
msgid ""
"$ python fibo.py 50\n"
"0 1 1 2 3 5 8 13 21 34"
msgstr ""
"$ python fibo.py 50\n"
"0 1 1 2 3 5 8 13 21 34"

#: ../../tutorial/modules.rst:170
msgid "If the module is imported, the code is not run::"
msgstr "اگر ماژول وارد شود، کد اجرا نمی شود::"

#: ../../tutorial/modules.rst:172
msgid ""
">>> import fibo\n"
">>>"
msgstr ""
">>> واردات فیبو\n"
">>>"

#: ../../tutorial/modules.rst:175
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes a "
"test suite)."
msgstr ""
"این اغلب برای ارائه یک رابط کاربری مناسب به یک ماژول یا برای اهداف آزمایشی "
"استفاده می شود (اجرای ماژول به عنوان یک اسکریپت یک مجموعه آزمایشی را اجرا می"
" کند)."

#: ../../tutorial/modules.rst:182
msgid "The Module Search Path"
msgstr "مسیر جستجوی ماژول"

#: ../../tutorial/modules.rst:186
msgid ""
"When a module named :mod:`!spam` is imported, the interpreter first searches"
" for a built-in module with that name. These module names are listed in "
":data:`sys.builtin_module_names`. If not found, it then searches for a file "
"named :file:`spam.py` in a list of directories given by the variable "
":data:`sys.path`.  :data:`sys.path` is initialized from these locations:"
msgstr ""
"هنگامی که یک ماژول به نام :mod:`!spam` وارد می شود، مفسر ابتدا ماژول داخلی "
"با آن نام را جستجو می کند. نام این ماژول ها در "
":data:`sys.builtin_module_names` ذکر شده است. اگر پیدا نشد، سپس فایلی به نام"
" :file:`spam.py` را در فهرستی از دایرکتوری های ارائه شده توسط متغیر "
":data:`sys.path` جستجو می کند.  :data:`sys.path` از این مکان ها مقداردهی "
"اولیه می شود:"

#: ../../tutorial/modules.rst:192
msgid ""
"The directory containing the input script (or the current directory when no "
"file is specified)."
msgstr ""
"دایرکتوری حاوی اسکریپت ورودی (یا دایرکتوری فعلی وقتی هیچ فایلی مشخص نشده "
"است)."

#: ../../tutorial/modules.rst:194
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as the"
" shell variable :envvar:`PATH`)."
msgstr ""
":envvar:`PYTHONPATH` (لیستی از نام دایرکتوری ها, با سینتکس مشابه با متغیر "
"پوسته :envvar:`PATH`)."

#: ../../tutorial/modules.rst:196
msgid ""
"The installation-dependent default (by convention including a ``site-"
"packages`` directory, handled by the :mod:`site` module)."
msgstr ""
"پیش‌فرض وابسته به نصب (طبق قرارداد شامل دایرکتوری ``site-packages`` که توسط "
"ماژول :mod:`site` مدیریت می‌شود)."

#: ../../tutorial/modules.rst:199
msgid "More details are at :ref:`sys-path-init`."
msgstr "جزئیات بیشتر در :ref:`sys-path-init` است."

#: ../../tutorial/modules.rst:202
msgid ""
"On file systems which support symlinks, the directory containing the input "
"script is calculated after the symlink is followed. In other words the "
"directory containing the symlink is **not** added to the module search path."
msgstr ""
"در سیستم های فایلی که از symlink ها پشتیبانی می کنند، دایرکتوری حاوی اسکریپت"
" ورودی پس از دنبال کردن سیم پیوند محاسبه می شود. به عبارت دیگر دایرکتوری "
"حاوی سیم پیوند **not** به مسیر جستجوی ماژول اضافه شده است."

#: ../../tutorial/modules.rst:206
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of the "
"search path, ahead of the standard library path. This means that scripts in "
"that directory will be loaded instead of modules of the same name in the "
"library directory. This is an error unless the replacement is intended.  See"
" section :ref:`tut-standardmodules` for more information."
msgstr ""
"پس از مقداردهی اولیه، برنامه های پایتون می توانند :data:`sys.path` را تغییر "
"دهند.  دایرکتوری حاوی اسکریپت در حال اجرا در ابتدای مسیر جستجو، جلوتر از "
"مسیر استاندارد کتابخانه قرار می گیرد. این بدان معنی است که اسکریپت های موجود"
" در آن دایرکتوری به جای ماژول هایی با همان نام در فهرست کتابخانه بارگذاری می"
" شوند. این یک خطا است مگر اینکه جایگزینی در نظر گرفته شده باشد.  برای "
"اطلاعات بیشتر به بخش :ref:`tut-standardmodules` مراجعه کنید."

#: ../../tutorial/modules.rst:219
msgid "\"Compiled\" Python files"
msgstr "فایل های پایتون \"کامپایل شده\"."

#: ../../tutorial/modules.rst:221
msgid ""
"To speed up loading modules, Python caches the compiled version of each "
"module in the ``__pycache__`` directory under the name "
":file:`module.{version}.pyc`, where the version encodes the format of the "
"compiled file; it generally contains the Python version number.  For "
"example, in CPython release 3.3 the compiled version of spam.py would be "
"cached as ``__pycache__/spam.cpython-33.pyc``.  This naming convention "
"allows compiled modules from different releases and different versions of "
"Python to coexist."
msgstr ""
"برای سرعت بخشیدن به بارگذاری ماژول ها، پایتون نسخه کامپایل شده هر ماژول را "
"در فهرست ``__pycache__`` تحت نام :file:`module.{version}.pyc` ذخیره می کند، "
"جایی که نسخه فرمت فایل کامپایل شده را کد می کند. به طور کلی شامل شماره نسخه "
"پایتون است.  به عنوان مثال، در نسخه 3.3 CPython، نسخه کامپایل شده spam.py به"
" عنوان ``__pycache__/spam.cpython-33.pyc`` ذخیره می شود.  این قرارداد "
"نام‌گذاری به ماژول‌های کامپایل‌شده از نسخه‌های مختلف و نسخه‌های مختلف پایتون"
" اجازه می‌دهد که همزیستی کنند."

#: ../../tutorial/modules.rst:229
msgid ""
"Python checks the modification date of the source against the compiled "
"version to see if it's out of date and needs to be recompiled.  This is a "
"completely automatic process.  Also, the compiled modules are platform-"
"independent, so the same library can be shared among systems with different "
"architectures."
msgstr ""
"پایتون تاریخ اصلاح منبع را در برابر نسخه کامپایل شده بررسی می کند تا ببیند "
"قدیمی است و نیاز به کامپایل مجدد دارد یا خیر.  این یک فرآیند کاملاً خودکار "
"است.  همچنین، ماژول های کامپایل شده مستقل از پلتفرم هستند، بنابراین می توان "
"یک کتابخانه را بین سیستم هایی با معماری های مختلف به اشتراک گذاشت."

#: ../../tutorial/modules.rst:234
msgid ""
"Python does not check the cache in two circumstances.  First, it always "
"recompiles and does not store the result for the module that's loaded "
"directly from the command line.  Second, it does not check the cache if "
"there is no source module.  To support a non-source (compiled only) "
"distribution, the compiled module must be in the source directory, and there"
" must not be a source module."
msgstr ""
"پایتون در دو حالت کش را بررسی نمی کند.  اول، همیشه دوباره کامپایل می شود و "
"نتیجه را برای ماژولی که مستقیماً از خط فرمان بارگذاری می شود ذخیره نمی کند."
"  دوم اینکه اگر ماژول منبع وجود نداشته باشد، کش را بررسی نمی کند.  برای "
"پشتیبانی از توزیع غیر منبع (فقط کامپایل شده), ماژول کامپایل شده باید در "
"دایرکتوری منبع باشد و ماژول منبع نباید وجود داشته باشد."

#: ../../tutorial/modules.rst:241
msgid "Some tips for experts:"
msgstr "چند نکته برای کارشناسان:"

#: ../../tutorial/modules.rst:243
msgid ""
"You can use the :option:`-O` or :option:`-OO` switches on the Python command"
" to reduce the size of a compiled module.  The ``-O`` switch removes assert "
"statements, the ``-OO`` switch removes both assert statements and __doc__ "
"strings.  Since some programs may rely on having these available, you should"
" only use this option if you know what you're doing.  \"Optimized\" modules "
"have an ``opt-`` tag and are usually smaller.  Future releases may change "
"the effects of optimization."
msgstr ""
"شما می توانید از سوئیچ های :option:`-O` یا :option:`-OO` در دستور پایتون "
"برای کاهش اندازه یک ماژول کامپایل شده استفاده کنید.  سوئیچ ``-O`` عبارات "
"عنوان را حذف می کند، سوئیچ ``-OO`` هر دو دستورات و رشته های __doc__ را حذف "
"می کند.  از آنجایی که برخی از برنامه ها ممکن است به در دسترس بودن اینها متکی"
" باشند، فقط در صورتی باید از این گزینه استفاده کنید که بدانید چه کاری انجام "
"می دهید.  ماژول های \"بهینه\" دارای یک برچسب ``opt-`` هستند و معمولا کوچکتر "
"هستند.  نسخه های آینده ممکن است اثرات بهینه سازی را تغییر دهند."

#: ../../tutorial/modules.rst:251
msgid ""
"A program doesn't run any faster when it is read from a ``.pyc`` file than "
"when it is read from a ``.py`` file; the only thing that's faster about "
"``.pyc`` files is the speed with which they are loaded."
msgstr ""
"وقتی یک برنامه از یک فایل ``.pyc`` خوانده می شود سریعتر از زمانی که از یک "
"فایل ``.py`` خوانده می شود، اجرا نمی شود. تنها چیزی که در مورد فایل های "
"``.pyc`` سریعتر است، سرعت بارگذاری آنها است."

#: ../../tutorial/modules.rst:255
msgid ""
"The module :mod:`compileall` can create .pyc files for all modules in a "
"directory."
msgstr ""
"ماژول :mod:`compileall` می تواند فایل های .pyc را برای همه ماژول های یک "
"دایرکتوری ایجاد کند."

#: ../../tutorial/modules.rst:258
msgid ""
"There is more detail on this process, including a flow chart of the "
"decisions, in :pep:`3147`."
msgstr ""
"جزئیات بیشتری در مورد این فرآیند، از جمله نمودار جریان تصمیمات، در "
":pep:`3147` وجود دارد."

#: ../../tutorial/modules.rst:265
msgid "Standard Modules"
msgstr "ماژول های استاندارد"

#: ../../tutorial/modules.rst:269
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter).  "
"Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such modules "
"is a configuration option which also depends on the underlying platform.  "
"For example, the :mod:`winreg` module is only provided on Windows systems. "
"One particular module deserves some attention: :mod:`sys`, which is built "
"into every Python interpreter.  The variables ``sys.ps1`` and ``sys.ps2`` "
"define the strings used as primary and secondary prompts::"
msgstr ""
"پایتون با کتابخانه ای از ماژول های استاندارد ارائه می شود که در یک سند "
"جداگانه به نام مرجع کتابخانه پایتون (از این به بعد \"مرجع کتابخانه\" توضیح "
"داده شده است.  برخی از ماژول ها در مفسر تعبیه شده اند. اینها دسترسی به "
"عملیاتی را فراهم می کنند که بخشی از هسته زبان نیستند، اما با این وجود، برای "
"کارایی یا برای دسترسی به سیستم عامل های اولیه مانند فراخوانی سیستم، ساخته "
"شده اند.  مجموعه ای از این ماژول ها یک گزینه پیکربندی است که به پلت فرم "
"زیرین نیز بستگی دارد.  به عنوان مثال، ماژول :mod:`winreg` فقط در سیستم های "
"ویندوز ارائه می شود. یک ماژول خاص سزاوار توجه است: :mod:`sys` که در هر مفسر "
"پایتون تعبیه شده است.  متغیرهای ``sys.ps1`` و ``sys.ps2`` رشته های مورد "
"استفاده را به عنوان دستورهای اولیه و ثانویه تعریف می کنند:"

#: ../../tutorial/modules.rst:281
msgid ""
">>> import sys\n"
">>> sys.ps1\n"
"'>>> '\n"
">>> sys.ps2\n"
"'... '\n"
">>> sys.ps1 = 'C> '\n"
"C> print('Yuck!')\n"
"Yuck!\n"
"C>"
msgstr ""
">>> سیستم را وارد کنید\n"
">>> sys.ps1\n"
"'>>>'\n"
">>> sys.ps2\n"
"'...'\n"
">>> sys.ps1 = 'C> '\n"
"C> print ('Yuck!')\n"
"آخه!\n"
"C>"

#: ../../tutorial/modules.rst:292
msgid ""
"These two variables are only defined if the interpreter is in interactive "
"mode."
msgstr "این دو متغیر تنها در صورتی تعریف می شوند که مفسر در حالت تعاملی باشد."

#: ../../tutorial/modules.rst:294
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default path "
"taken from the environment variable :envvar:`PYTHONPATH`, or from a built-in"
" default if :envvar:`PYTHONPATH` is not set.  You can modify it using "
"standard list operations::"
msgstr ""
"متغیر ``sys.path`` لیستی از رشته ها است که مسیر جستجوی مفسر برای ماژول ها را"
" تعیین می کند. این به یک مسیر پیش فرض گرفته شده از متغیر محیطی "
":envvar:`PYTHONPATH`، یا از یک پیش فرض داخلی اگر :envvar:`PYTHONPATH` تنظیم "
"نشده باشد، مقداردهی اولیه می شود.  شما می توانید آن را با استفاده از عملیات "
"لیست استاندارد تغییر دهید:"

#: ../../tutorial/modules.rst:300
msgid ""
">>> import sys\n"
">>> sys.path.append('/ufs/guido/lib/python')"
msgstr ""
">>> import sys\n"
">>> sys.path.append('/ufs/guido/lib/python')"

#: ../../tutorial/modules.rst:307
msgid "The :func:`dir` Function"
msgstr "عملکرد :func:`dir`"

#: ../../tutorial/modules.rst:309
msgid ""
"The built-in function :func:`dir` is used to find out which names a module "
"defines.  It returns a sorted list of strings::"
msgstr ""
"تابع داخلی :func:`dir` برای پیدا کردن نام هایی که یک ماژول تعریف می کند "
"استفاده می شود.  لیست مرتب شده ای از رشته ها را برمی گرداند::"

#: ../../tutorial/modules.rst:312
msgid ""
">>> import fibo, sys\n"
">>> dir(fibo)\n"
"['__name__', 'fib', 'fib2']\n"
">>> dir(sys)\n"
"['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n"
" '__interactivehook__', '__loader__', '__name__', '__package__', '__spec__',\n"
" '__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n"
" '_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n"
" '_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n"
" 'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n"
" 'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n"
" 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info',\n"
" 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n"
" 'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',\n"
" 'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n"
" 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n"
" 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n"
" 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n"
" 'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n"
" 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n"
" 'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix',\n"
" 'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags',\n"
" 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',\n"
" 'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info',\n"
" 'warnoptions']"
msgstr ""

#: ../../tutorial/modules.rst:338
msgid ""
"Without arguments, :func:`dir` lists the names you have defined currently::"
msgstr ""
"بدون آرگومان، :func:`dir` نام هایی را که در حال حاضر تعریف کرده اید فهرست می"
" کند:"

#: ../../tutorial/modules.rst:340
msgid ""
">>> a = [1, 2, 3, 4, 5]\n"
">>> import fibo\n"
">>> fib = fibo.fib\n"
">>> dir()\n"
"['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']"
msgstr ""
">>> a = [1, 2, 3, 4, 5]\n"
">>> import fibo\n"
">>> fib = fibo.fib\n"
">>> dir()\n"
"['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']"

#: ../../tutorial/modules.rst:346
msgid ""
"Note that it lists all types of names: variables, modules, functions, etc."
msgstr ""
"توجه داشته باشید که همه انواع نام ها را فهرست می کند: متغیرها، ماژول ها، "
"توابع و غیره."

#: ../../tutorial/modules.rst:350
msgid ""
":func:`dir` does not list the names of built-in functions and variables.  If"
" you want a list of those, they are defined in the standard module "
":mod:`builtins`::"
msgstr ""
":func:`dir` نام توابع و متغیرهای داخلی را فهرست نمی کند.  اگر لیستی از آن ها"
" را می خواهید، در ماژول استاندارد :mod:`builtins` تعریف شده اند:"

#: ../../tutorial/modules.rst:354
msgid ""
">>> import builtins\n"
">>> dir(builtins)\n"
"['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n"
" 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n"
" 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n"
" 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n"
" 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n"
" 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n"
" 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n"
" 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n"
" 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n"
" 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',\n"
" 'NotImplementedError', 'OSError', 'OverflowError',\n"
" 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n"
" 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n"
" 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n"
" 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n"
" 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n"
" 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n"
" 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n"
" '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n"
" 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n"
" 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n"
" 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n"
" 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n"
" 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n"
" 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n"
" 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n"
" 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n"
" 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n"
" 'zip']"
msgstr ""

#: ../../tutorial/modules.rst:389
msgid "Packages"
msgstr "بسته ها"

#: ../../tutorial/modules.rst:391
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`!A.B` "
"designates a submodule named ``B`` in a package named ``A``.  Just like the "
"use of modules saves the authors of different modules from having to worry "
"about each other's global variable names, the use of dotted module names "
"saves the authors of multi-module packages like NumPy or Pillow from having "
"to worry about each other's module names."
msgstr ""
"بسته‌ها روشی برای ساختاردهی فضای نام ماژول پایتون با استفاده از «نام‌های "
"ماژول نقطه‌دار» هستند.  به عنوان مثال، نام ماژول :mod:`!A.B` یک زیر ماژول به"
" نام ``B`` را در بسته ای به نام ``A`` تعیین می کند.  درست همانطور که استفاده"
" از ماژول ها باعث می شود نویسندگان ماژول های مختلف نگران نام متغیرهای جهانی "
"یکدیگر نباشند، استفاده از نام ماژول های نقطه دار باعث می شود نویسندگان بسته "
"های چند ماژول مانند NumPy یا Pillow نگران نام ماژول های یکدیگر نباشند."

#: ../../tutorial/modules.rst:399
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for the "
"uniform handling of sound files and sound data.  There are many different "
"sound file formats (usually recognized by their extension, for example: "
":file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to create and "
"maintain a growing collection of modules for the conversion between the "
"various file formats. There are also many different operations you might "
"want to perform on sound data (such as mixing, adding echo, applying an "
"equalizer function, creating an artificial stereo effect), so in addition "
"you will be writing a never-ending stream of modules to perform these "
"operations.  Here's a possible structure for your package (expressed in "
"terms of a hierarchical filesystem):"
msgstr ""
"فرض کنید می خواهید مجموعه ای از ماژول ها (یک \"بسته\") برای مدیریت یکنواخت "
"فایل های صوتی و داده های صوتی طراحی کنید.  فرمت‌های فایل صوتی بسیار زیادی "
"وجود دارد (معمولاً با پسوند آنها شناخته می‌شوند, به عنوان مثال: "
":file:`.wav`, :file:`.aiff`, :file:`.au`), بنابراین ممکن است نیاز به ایجاد و"
" نگهداری مجموعه‌ای از ماژول‌ها برای تبدیل بین فرمت‌های مختلف فایل داشته "
"باشید. همچنین بسیاری از عملیات‌های مختلفی وجود دارد که ممکن است بخواهید روی "
"داده‌های صدا انجام دهید (مانند میکس کردن, افزودن اکو, اعمال یک عملکرد "
"اکولایزر, ایجاد یک افکت استریو مصنوعی), بنابراین علاوه بر این، شما یک جریان "
"بی‌پایان از ماژول‌ها را برای انجام این عملیات می‌نویسید.  در اینجا یک ساختار"
" ممکن برای بسته شما وجود دارد (که در قالب یک فایل سیستم سلسله مراتبی بیان می"
" شود):"

#: ../../tutorial/modules.rst:410
msgid ""
"sound/                          Top-level package\n"
"      __init__.py               Initialize the sound package\n"
"      formats/                  Subpackage for file format conversions\n"
"              __init__.py\n"
"              wavread.py\n"
"              wavwrite.py\n"
"              aiffread.py\n"
"              aiffwrite.py\n"
"              auread.py\n"
"              auwrite.py\n"
"              ...\n"
"      effects/                  Subpackage for sound effects\n"
"              __init__.py\n"
"              echo.py\n"
"              surround.py\n"
"              reverse.py\n"
"              ...\n"
"      filters/                  Subpackage for filters\n"
"              __init__.py\n"
"              equalizer.py\n"
"              vocoder.py\n"
"              karaoke.py\n"
"              ..."
msgstr ""
"صدا/ بسته سطح بالا\n"
"      __init__.py بسته صدا را راه اندازی کنید\n"
"      فرمت ها/ بسته فرعی برای تبدیل فرمت فایل\n"
"              __init__.py\n"
"              wavread.py\n"
"              wavwrite.py\n"
"              aiffread.py\n"
"              aiffwrite.py\n"
"              auread.py\n"
"              auwrite.py\n"
"              ...\n"
"      جلوه ها/ بسته فرعی برای جلوه های صوتی\n"
"              __init__.py\n"
"              echo.py\n"
"              surround.py\n"
"              reverse.py\n"
"              ...\n"
"      فیلترها/ بسته فرعی برای فیلترها\n"
"              __init__.py\n"
"              اکولایزر.py\n"
"              vocoder.py\n"
"              karaoke.py\n"
"              ..."

#: ../../tutorial/modules.rst:436
msgid ""
"When importing the package, Python searches through the directories on "
"``sys.path`` looking for the package subdirectory."
msgstr ""
"هنگام وارد کردن بسته، پایتون از طریق دایرکتوری های موجود در ``sys.path`` به "
"دنبال زیر شاخه بسته می گردد."

#: ../../tutorial/modules.rst:439
msgid ""
"The :file:`__init__.py` files are required to make Python treat directories "
"containing the file as packages (unless using a :term:`namespace package`, a"
" relatively advanced feature). This prevents directories with a common name,"
" such as ``string``, from unintentionally hiding valid modules that occur "
"later on the module search path. In the simplest case, :file:`__init__.py` "
"can just be an empty file, but it can also execute initialization code for "
"the package or set the ``__all__`` variable, described later."
msgstr ""
"فایل‌های :file:`__init__.py` مورد نیاز هستند تا پایتون دایرکتوری‌های حاوی "
"فایل را به‌عنوان بسته‌ها در نظر بگیرد (مگر اینکه از :term:`namespace "
"package` که یک ویژگی نسبتاً پیشرفته است استفاده کنید). این امر از پوشاندن "
"ناخواسته ماژول‌های معتبری که بعداً در مسیر جستجوی ماژول رخ می‌دهند، "
"دایرکتوری‌هایی با نام مشترک، مانند ``string``، جلوگیری می‌کند. در ساده‌ترین "
"حالت، :file:`__init__.py` فقط می‌تواند یک فایل خالی باشد، اما همچنین "
"می‌تواند کد اولیه را برای بسته اجرا کند یا متغیر ``__all__`` را که بعدا "
"توضیح داده شد، تنظیم کند."

#: ../../tutorial/modules.rst:447
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr ""
"کاربران بسته می توانند ماژول های جداگانه را از بسته وارد کنند، به عنوان "
"مثال:"

#: ../../tutorial/modules.rst:450
msgid "import sound.effects.echo"
msgstr "import sound.effects.echo"

#: ../../tutorial/modules.rst:452
msgid ""
"This loads the submodule :mod:`!sound.effects.echo`.  It must be referenced "
"with its full name. ::"
msgstr ""
"این زیر ماژول :mod:`!sound.effects.echo` را بارگیری می کند.  باید با نام "
"کامل آن ارجاع داده شود. ::"

#: ../../tutorial/modules.rst:455
msgid "sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)"
msgstr "sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)"

#: ../../tutorial/modules.rst:457
msgid "An alternative way of importing the submodule is::"
msgstr "یک راه جایگزین برای وارد کردن زیر ماژول این است:"

#: ../../tutorial/modules.rst:459
msgid "from sound.effects import echo"
msgstr "from sound.effects import echo"

#: ../../tutorial/modules.rst:461
msgid ""
"This also loads the submodule :mod:`!echo`, and makes it available without "
"its package prefix, so it can be used as follows::"
msgstr ""
"این همچنین زیر ماژول :mod:`!echo` را بارگیری می کند و آن را بدون پیشوند بسته"
" در دسترس قرار می دهد، بنابراین می توان از آن به صورت زیر استفاده کرد:"

#: ../../tutorial/modules.rst:464
msgid "echo.echofilter(input, output, delay=0.7, atten=4)"
msgstr "echo.echofilter(input, output, delay=0.7, atten=4)"

#: ../../tutorial/modules.rst:466
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr "یک تغییر دیگر این است که تابع یا متغیر مورد نظر را مستقیما وارد کنید:"

#: ../../tutorial/modules.rst:468
msgid "from sound.effects.echo import echofilter"
msgstr "from sound.effects.echo import echofilter"

#: ../../tutorial/modules.rst:470
msgid ""
"Again, this loads the submodule :mod:`!echo`, but this makes its function "
":func:`!echofilter` directly available::"
msgstr ""
"مجدداً، این زیر ماژول :mod:`!echo` را بارگیری می کند، اما عملکرد آن "
":func:`!echofilter` را مستقیماً در دسترس قرار می دهد:"

#: ../../tutorial/modules.rst:473
msgid "echofilter(input, output, delay=0.7, atten=4)"
msgstr "echofilter(input, output, delay=0.7, atten=4)"

#: ../../tutorial/modules.rst:475
msgid ""
"Note that when using ``from package import item``, the item can be either a "
"submodule (or subpackage) of the package, or some  other name defined in the"
" package, like a function, class or variable.  The ``import`` statement "
"first tests whether the item is defined in the package; if not, it assumes "
"it is a module and attempts to load it.  If it fails to find it, an "
":exc:`ImportError` exception is raised."
msgstr ""
"توجه داشته باشید که هنگام استفاده از ``from package import item``، آیتم می "
"تواند یک زیر ماژول (یا بسته فرعی) بسته باشد یا نام دیگری که در بسته تعریف "
"شده است، مانند یک تابع، کلاس یا متغیر.  دستور ``import`` ابتدا تست می کند که"
" آیا آیتم در بسته تعریف شده است یا خیر. اگر نه، فرض می کند که یک ماژول است و"
" سعی می کند آن را بارگذاری کند.  اگر نتواند آن را پیدا کند، یک استثنا "
":exc:`ImportError` ایجاد می شود."

#: ../../tutorial/modules.rst:482
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, each "
"item except for the last must be a package; the last item can be a module or"
" a package but can't be a class or function or variable defined in the "
"previous item."
msgstr ""
"برعکس، هنگام استفاده از سینتکس مانند ``import item.subitem.subsubitem``، هر "
"مورد به جز مورد آخر باید یک بسته باشد. آخرین مورد می تواند یک ماژول یا یک "
"بسته باشد اما نمی تواند یک کلاس یا تابع یا متغیر تعریف شده در مورد قبلی "
"باشد."

#: ../../tutorial/modules.rst:491
msgid "Importing \\* From a Package"
msgstr "وارد کردن \\* از یک بسته"

#: ../../tutorial/modules.rst:495
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, finds "
"which submodules are present in the package, and imports them all.  This "
"could take a long time and importing sub-modules might have unwanted side-"
"effects that should only happen when the sub-module is explicitly imported."
msgstr ""
"حالا وقتی کاربر ``from sound.effects import *`` را می نویسد چه اتفاقی می "
"افتد؟  در حالت ایده‌آل، می‌توان امیدوار بود که این به نحوی به سیستم فایل "
"برود، زیر ماژول‌های موجود در بسته را بیابد و همه آنها را وارد کند.  این ممکن"
" است زمان زیادی طول بکشد و وارد کردن ماژول‌های فرعی ممکن است عوارض جانبی "
"ناخواسته‌ای داشته باشد که فقط زمانی اتفاق می‌افتد که ماژول فرعی به صراحت "
"وارد شده باشد."

#: ../../tutorial/modules.rst:501
msgid ""
"The only solution is for the package author to provide an explicit index of "
"the package.  The :keyword:`import` statement uses the following convention:"
" if a package's :file:`__init__.py` code defines a list named ``__all__``, "
"it is taken to be the list of module names that should be imported when "
"``from package import *`` is encountered.  It is up to the package author to"
" keep this list up-to-date when a new version of the package is released.  "
"Package authors may also decide not to support it, if they don't see a use "
"for importing \\* from their package.  For example, the file "
":file:`sound/effects/__init__.py` could contain the following code::"
msgstr ""
"تنها راه حل این است که نویسنده بسته یک نمایه صریح از بسته ارائه دهد.  دستور "
":keyword:`import` از قرارداد زیر استفاده می کند: اگر کد :file:`__init__.py` "
"بسته، لیستی به نام ``__all__`` را تعریف کند، به عنوان لیستی از نام ماژول ها "
"در نظر گرفته می شود که باید در هنگام مواجهه با ``from package import *`` "
"وارد شوند.  این بر عهده نویسنده بسته است که این لیست را هنگام انتشار نسخه "
"جدید بسته به روز نگه دارد.  نویسندگان بسته همچنین ممکن است تصمیم بگیرند که "
"از آن پشتیبانی نکنند، در صورتی که استفاده ای برای وارد کردن \\* از بسته خود "
"نمی بینند.  به عنوان مثال، فایل :file:`sound/effects/__init__.py` می تواند "
"حاوی کد زیر باشد:"

#: ../../tutorial/modules.rst:511
msgid "__all__ = [\"echo\", \"surround\", \"reverse\"]"
msgstr "__all__ = [\"echo\", \"surround\", \"reverse\"]"

#: ../../tutorial/modules.rst:513
msgid ""
"This would mean that ``from sound.effects import *`` would import the three "
"named submodules of the :mod:`!sound.effects` package."
msgstr ""
"این بدان معنی است که ``from sound.effects import *`` سه زیر ماژول نامگذاری "
"شده بسته :mod:`!sound.effects` را وارد می کند."

#: ../../tutorial/modules.rst:516
msgid ""
"Be aware that submodules might become shadowed by locally defined names. For"
" example, if you added a ``reverse`` function to the "
":file:`sound/effects/__init__.py` file, the ``from sound.effects import *`` "
"would only import the two submodules ``echo`` and ``surround``, but *not* "
"the ``reverse`` submodule, because it is shadowed by the locally defined "
"``reverse`` function::"
msgstr ""
"توجه داشته باشید که زیر ماژول‌ها ممکن است با نام‌هایی که به صورت محلی تعریف "
"شده‌اند، تحت‌سایه شوند. به عنوان مثال، اگر یک تابع ``reverse`` را به فایل "
":file:`sound/effects/__init__.py` اضافه کنید، ``from sound.effects import "
"*`` فقط دو زیرماژول ``echo`` و ``surround`` را وارد می کند، اما *not* "
"زیرماژول ``reverse`` را وارد می کند، زیرا توسط تابع ``reverse`` که به صورت "
"محلی تعریف شده سایه می اندازد:"

#: ../../tutorial/modules.rst:523
msgid ""
"__all__ = [\n"
"    \"echo\",      # refers to the 'echo.py' file\n"
"    \"surround\",  # refers to the 'surround.py' file\n"
"    \"reverse\",   # !!! refers to the 'reverse' function now !!!\n"
"]\n"
"\n"
"def reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule\n"
"    return msg[::-1]    #     in the case of a 'from sound.effects import *'"
msgstr ""
"__all__ = [\n"
"    \"echo\",      # refers to the 'echo.py' file\n"
"    \"surround\",  # refers to the 'surround.py' file\n"
"    \"reverse\",   # !!! refers to the 'reverse' function now !!!\n"
"]\n"
"\n"
"def reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule\n"
"    return msg[::-1]    #     in the case of a 'from sound.effects import *'"

#: ../../tutorial/modules.rst:532
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import *``"
" does *not* import all submodules from the package :mod:`!sound.effects` "
"into the current namespace; it only ensures that the package "
":mod:`!sound.effects` has been imported (possibly running any initialization"
" code in :file:`__init__.py`) and then imports whatever names are defined in"
" the package.  This includes any names defined (and submodules explicitly "
"loaded) by :file:`__init__.py`.  It also includes any submodules of the "
"package that were explicitly loaded by previous :keyword:`import` "
"statements.  Consider this code::"
msgstr ""
"اگر ``__all__`` تعریف نشده باشد، عبارت ``from sound.effects import *`` *not*"
" همه زیر ماژول ها را از بسته :mod:`!sound.effects` به فضای نام فعلی وارد می "
"کند. این فقط تضمین می کند که بسته :mod:`!sound.effects` وارد شده است "
"(احتمالاً هر کد اولیه را در :file:`__init__.py` اجرا می کند) و سپس هر نامی "
"را که در بسته تعریف شده است وارد می کند.  این شامل هر نامی است که توسط "
":file:`__init__.py` تعریف شده است (و زیر ماژول هایی که به صراحت بارگذاری شده"
" اند).  همچنین شامل هر زیر ماژول بسته است که به صراحت توسط عبارات قبلی "
":keyword:`import` بارگذاری شده است.  این کد را در نظر بگیرید::"

#: ../../tutorial/modules.rst:541
msgid ""
"import sound.effects.echo\n"
"import sound.effects.surround\n"
"from sound.effects import *"
msgstr ""
"import sound.effects.echo\n"
"import sound.effects.surround\n"
"from sound.effects import *"

#: ../../tutorial/modules.rst:545
msgid ""
"In this example, the :mod:`!echo` and :mod:`!surround` modules are imported "
"in the current namespace because they are defined in the "
":mod:`!sound.effects` package when the ``from...import`` statement is "
"executed.  (This also works when ``__all__`` is defined.)"
msgstr ""
"در این مثال، ماژول‌های :mod:`!echo` و :mod:`!surround` در فضای نام فعلی وارد"
" می‌شوند زیرا در بسته :mod:`!sound.effects` هنگام اجرای دستور "
"``from...import`` تعریف شده‌اند.  (هنگامی که ``__all__`` تعریف شده باشد این "
"کار نیز کار می کند.)"

#: ../../tutorial/modules.rst:550
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"اگرچه ماژول‌های خاصی برای صادرات فقط نام‌هایی طراحی شده‌اند که در هنگام "
"استفاده از ``import *`` از الگوهای خاصی پیروی می‌کنند، اما همچنان در کد "
"تولید بد عمل می‌شود."

#: ../../tutorial/modules.rst:554
msgid ""
"Remember, there is nothing wrong with using ``from package import "
"specific_submodule``!  In fact, this is the recommended notation unless the "
"importing module needs to use submodules with the same name from different "
"packages."
msgstr ""
"به یاد داشته باشید، استفاده از ``from package import specific_submodule`` "
"اشکالی ندارد!  در واقع، این نماد توصیه شده است، مگر اینکه ماژول واردکننده "
"نیاز به استفاده از ماژول های فرعی با همان نام از بسته های مختلف داشته باشد."

#: ../../tutorial/modules.rst:563
msgid "Intra-package References"
msgstr "مراجع درون بسته"

#: ../../tutorial/modules.rst:565
msgid ""
"When packages are structured into subpackages (as with the :mod:`!sound` "
"package in the example), you can use absolute imports to refer to submodules"
" of siblings packages.  For example, if the module "
":mod:`!sound.filters.vocoder` needs to use the :mod:`!echo` module in the "
":mod:`!sound.effects` package, it can use ``from sound.effects import "
"echo``."
msgstr ""
"هنگامی که بسته‌ها در بسته‌های فرعی ساختار می‌شوند (مانند بسته :mod:`!sound` "
"در مثال), می‌توانید از import absolute برای ارجاع به زیر ماژول‌های بسته‌های "
"خواهر و برادر استفاده کنید.  به عنوان مثال، اگر ماژول "
":mod:`!sound.filters.vocoder` نیاز به استفاده از ماژول :mod:`!echo` در بسته "
":mod:`!sound.effects` داشته باشد، می تواند از ``from sound.effects import "
"echo`` استفاده کند."

#: ../../tutorial/modules.rst:571
msgid ""
"You can also write relative imports, with the ``from module import name`` "
"form of import statement.  These imports use leading dots to indicate the "
"current and parent packages involved in the relative import.  From the "
":mod:`!surround` module for example, you might use::"
msgstr ""
"شما همچنین می توانید واردات نسبی را با فرم بیانیه واردات ``from module "
"import name`` بنویسید.  این واردات از نقاط پیشرو برای نشان دادن بسته های "
"فعلی و والد درگیر در واردات نسبی استفاده می کند.  برای مثال از ماژول "
":mod:`!surround`، ممکن است از:"

#: ../../tutorial/modules.rst:576
msgid ""
"from . import echo\n"
"from .. import formats\n"
"from ..filters import equalizer"
msgstr ""
"from . import echo\n"
"from .. import formats\n"
"from ..filters import equalizer"

#: ../../tutorial/modules.rst:580
msgid ""
"Note that relative imports are based on the name of the current module.  "
"Since the name of the main module is always ``\"__main__\"``, modules "
"intended for use as the main module of a Python application must always use "
"absolute imports."
msgstr ""
"توجه داشته باشید که واردات نسبی بر اساس نام ماژول فعلی است.  از آنجایی که "
"نام ماژول اصلی همیشه ``\"__main__\"`` است، ماژول هایی که برای استفاده به "
"عنوان ماژول اصلی برنامه پایتون در نظر گرفته شده اند باید همیشه از واردات "
"مطلق استفاده کنند."

#: ../../tutorial/modules.rst:586
msgid "Packages in Multiple Directories"
msgstr "بسته‌ها در فهرست‌های چندگانه"

#: ../../tutorial/modules.rst:588
msgid ""
"Packages support one more special attribute, :attr:`~module.__path__`.  This"
" is initialized to be a :term:`sequence` of strings containing the name of "
"the directory holding the package's :file:`__init__.py` before the code in "
"that file is executed.  This variable can be modified; doing so affects "
"future searches for modules and subpackages contained in the package."
msgstr ""
"بسته ها از یک ویژگی خاص دیگر، :attr:`~module.__path__` پشتیبانی می کنند.  "
"این به صورت :term:`sequence` از رشته‌های حاوی نام دایرکتوری حاوی "
":file:`__init__.py` بسته اولیه قبل از اجرای کد موجود در آن فایل است.  این "
"متغیر قابل تغییر است. انجام این کار بر جستجوهای آینده برای ماژول ها و بسته "
"های فرعی موجود در بسته تأثیر می گذارد."

#: ../../tutorial/modules.rst:595
msgid ""
"While this feature is not often needed, it can be used to extend the set of "
"modules found in a package."
msgstr ""
"در حالی که این ویژگی اغلب مورد نیاز نیست، می توان از آن برای گسترش مجموعه "
"ماژول های موجود در یک بسته استفاده کرد."

#: ../../tutorial/modules.rst:600
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../tutorial/modules.rst:601
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; the "
"execution of a module-level function definition adds the function name to "
"the module's global namespace."
msgstr ""
"در واقع تعاریف تابع نیز «گزاره‌هایی» هستند که «اجرا می‌شوند». اجرای یک تعریف"
" تابع در سطح ماژول، نام تابع را به فضای نام جهانی ماژول اضافه می کند."

#: ../../tutorial/modules.rst:184 ../../tutorial/modules.rst:267
#: ../../tutorial/modules.rst:348
msgid "module"
msgstr "ماژول"

#: ../../tutorial/modules.rst:184
msgid "search"
msgstr "جستجو کنید"

#: ../../tutorial/modules.rst:184
msgid "path"
msgstr "مسیر"

#: ../../tutorial/modules.rst:267
msgid "sys"
msgstr "سیستم"

#: ../../tutorial/modules.rst:348
msgid "builtins"
msgstr "سازه ها"

#: ../../tutorial/modules.rst:493
msgid "__all__"
msgstr "__all__"
