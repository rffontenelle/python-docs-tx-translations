# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# eulalio barbero espinosa <eulalio@disroot.org>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-31 11:30+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: eulalio barbero espinosa <eulalio@disroot.org>, 2024\n"
"Language-Team: Spanish (Spain) (https://app.transifex.com/python-doc/"
"teams/5390/es_ES/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_ES\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? "
"1 : 2;\n"

#: ../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "Estructuras de objetos comunes"

#: ../../c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"Hay un gran número de estructuras que se utilizan en la definición de tipos "
"de objetos para Python.  Esta sección describe estas estructuras y cómo se "
"utilizan."

#: ../../c-api/structures.rst:14
msgid "Base object types and macros"
msgstr "Tipos de objetos base y macros"

#: ../../c-api/structures.rst:16
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects.  "
"Additional macros can be found under :ref:`reference counting "
"<countingrefs>`."
msgstr ""
"Todos los objetos Python comparten, en última instancia, un pequeño número "
"de campos al principio de la representación del objeto en memoria.  Éstos "
"están representados por los tipos :c:type:`PyObject` y :c:type:"
"`PyVarObject`, que están definidos, a su vez, por las expansiones de algunas "
"macros también utilizadas, directa o indirectamente, en la definición de "
"todos los demás objetos Python.  Se pueden encontrar macros adicionales en :"
"ref:`reference counting <countingrefs>`."

#: ../../c-api/structures.rst:26
msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:expr:`PyObject*`.  Access to the members must be done by using the "
"macros :c:macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""
"Todos los tipos de objeto son extensiones de este tipo.  Es un tipo que "
"contiene la información que Python necesita para tratar un puntero a un "
"objeto como un objeto.  En una construcción normal de \"liberación\", sólo "
"contiene el recuento de referencias del objeto y un puntero al objeto de "
"tipo correspondiente. En realidad, nada se declara como un :c:type:"
"`PyObject`, pero todo puntero a un objeto Python puede ser lanzado a un :c:"
"expr:`PyObject*`. El acceso a los miembros debe hacerse utilizando las "
"macros :c:macro:`Py_REFCNT` y :c:macro:`Py_TYPE`."

#: ../../c-api/structures.rst:38
msgid ""
"This is an extension of :c:type:`PyObject` that adds the :c:member:"
"`~PyVarObject.ob_size` field.  This is only used for objects that have some "
"notion of *length*. This type does not often appear in the Python/C API. "
"Access to the members must be done by using the macros :c:macro:"
"`Py_REFCNT`, :c:macro:`Py_TYPE`, and :c:macro:`Py_SIZE`."
msgstr ""
"Se trata de una extensión de :c:type:`PyObject` que añade el campo :c:member:"
"`~PyVarObject.ob_size`.  Sólo se utiliza para objetos que tienen alguna "
"noción de *longitud*. Este tipo no suele aparecer en la API de Python/C. El "
"acceso a los miembros debe hacerse utilizando las macros :c:macro:"
"`Py_REFCNT`, :c:macro:`Py_TYPE`, y :c:macro:`Py_SIZE`."

#: ../../c-api/structures.rst:47
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"Este es un macro utilizado al declarar nuevos tipos que representan objetos "
"sin una longitud variable. El macro PyObject_HEAD se expande a:"

#: ../../c-api/structures.rst:50
msgid "PyObject ob_base;"
msgstr ""

#: ../../c-api/structures.rst:52
msgid "See documentation of :c:type:`PyObject` above."
msgstr "Ver documentación de :c:type:`PyObject` arriba."

#: ../../c-api/structures.rst:57
msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"Este es un macro utilizado al declarar nuevos tipos que representan objetos "
"con una longitud que varía de instancia a instancia. El macro "
"PyObject_VAR_HEAD se expande a:"

#: ../../c-api/structures.rst:61
msgid "PyVarObject ob_base;"
msgstr ""

#: ../../c-api/structures.rst:63
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "Ver documentación de :c:type:`PyVarObject` arriba."

#: ../../c-api/structures.rst:68
msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in Python."
msgstr ""
"Prueba si el objeto *x* es el objeto *y*, igual que ``x is y`` en Python."

#: ../../c-api/structures.rst:75
msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in "
"Python."
msgstr ""
"Prueba si un objeto es el singleton ``None``, lo mismo que ``x is None`` en "
"Python."

#: ../../c-api/structures.rst:83
msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in "
"Python."
msgstr ""
"Prueba si un objeto es el singleton ``True``, lo mismo que ``x is True`` en "
"Python."

#: ../../c-api/structures.rst:91
msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` in "
"Python."
msgstr ""
"Prueba si un objeto es el singleton ``False``, lo mismo que ``x is False`` "
"en Python."

#: ../../c-api/structures.rst:99
msgid "Get the type of the Python object *o*."
msgstr "Obtener el tipo del objeto Python *o*."

#: ../../c-api/structures.rst:101
msgid "Return a :term:`borrowed reference`."
msgstr "Devuelve un :term:`borrowed reference`."

#: ../../c-api/structures.rst:103
msgid "Use the :c:func:`Py_SET_TYPE` function to set an object type."
msgstr ""
"Utilice la función :c:func:`Py_SET_TYPE` para establecer un tipo de objeto."

#: ../../c-api/structures.rst:105
msgid ""
":c:func:`Py_TYPE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyObject*`."
msgstr ""
":c:func:`Py_TYPE()` se convierte en una función estática en línea. El tipo "
"de parámetro ya no es :c:expr:`const PyObject*`."

#: ../../c-api/structures.rst:112
msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""
"Devuelve un valor distinto de cero si el tipo del objeto *o* es *type*. "
"Devuelve cero en caso contrario. Equivalente a: ``Py_TYPE(o) == type``."

#: ../../c-api/structures.rst:120
msgid "Set the object *o* type to *type*."
msgstr "Establece el tipo del objeto *o* en *tipo*."

#: ../../c-api/structures.rst:127
msgid "Get the size of the Python object *o*."
msgstr "Obtener el tamaño del objeto Python *o*."

#: ../../c-api/structures.rst:129
msgid "Use the :c:func:`Py_SET_SIZE` function to set an object size."
msgstr ""
"Utilice la función :c:func:`Py_SET_SIZE` para establecer el tamaño de un "
"objeto."

#: ../../c-api/structures.rst:131
msgid ""
":c:func:`Py_SIZE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyVarObject*`."
msgstr ""
":c:func:`Py_SIZE()` se convierte en una función estática en línea. El tipo "
"de parámetro ya no es :c:expr:`const PyVarObject*`."

#: ../../c-api/structures.rst:138
msgid "Set the object *o* size to *size*."
msgstr "Establece el tamaño del objeto *o* en *tamaño*."

#: ../../c-api/structures.rst:145
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyObject` type.  This macro expands to::"
msgstr ""
"Esta es una macro que se expande a valores de inicialización para un nuevo "
"tipo :c:type:`PyObject`.  Esta macro se expande a::"

#: ../../c-api/structures.rst:148
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type,"
msgstr ""

#: ../../c-api/structures.rst:154
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyVarObject` type, including the :c:member:`~PyVarObject.ob_size` field. "
"This macro expands to::"
msgstr ""
"Se trata de una macro que se expande a valores de inicialización para un "
"nuevo tipo :c:type:`PyVarObject`, incluido el campo :c:member:`~PyVarObject."
"ob_size`. Esta macro se expande a::"

#: ../../c-api/structures.rst:158
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"
msgstr ""

#: ../../c-api/structures.rst:163
msgid "Implementing functions and methods"
msgstr "Implementación de funciones y métodos"

#: ../../c-api/structures.rst:167
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""
"Tipo de las funciones utilizadas para implementar la mayoría de las llamadas "
"Python en C. Las funciones de este tipo toman dos parámetros :c:expr:"
"`PyObject*` y devuelven un valor de este tipo.  Si el valor de retorno es "
"``NULL``, se habrá establecido una excepción.  Si no es ``NULL``, el valor "
"de retorno se interpreta como el valor de retorno de la función tal y como "
"se expone en Python.  La función debe devolver una nueva referencia."

#: ../../c-api/structures.rst:174
msgid "The function signature is::"
msgstr "La firma de la función es::"

#: ../../c-api/structures.rst:176
msgid ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"
msgstr ""

#: ../../c-api/structures.rst:181
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`. "
"The function signature is::"
msgstr ""
"Tipo de las funciones utilizadas para implementar llamadas de Python en C "
"con firma :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`. "
"La firma de la función es::"

#: ../../c-api/structures.rst:185
msgid ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"
msgstr ""

#: ../../c-api/structures.rst:192
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :c:macro:`METH_FASTCALL`. The function signature is::"
msgstr ""
"Tipo de las funciones utilizadas para implementar callables Python en C con "
"la firma :c:macro:`METH_FASTCALL`. La firma de la función es::"

#: ../../c-api/structures.rst:196
msgid ""
"PyObject *_PyCFunctionFast(PyObject *self,\n"
"                           PyObject *const *args,\n"
"                           Py_ssize_t nargs);"
msgstr ""

#: ../../c-api/structures.rst:202
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Tipo de las funciones utilizadas para implementar callables de Python en C "
"con firma :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. La firma de la función es::"

#: ../../c-api/structures.rst:206
msgid ""
"PyObject *_PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                       PyObject *const *args,\n"
"                                       Py_ssize_t nargs,\n"
"                                       PyObject *kwnames);"
msgstr ""

#: ../../c-api/structures.rst:213
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Tipo de las funciones utilizadas para implementar callables de Python en C "
"con firma :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`. La firma de la función es::"

#: ../../c-api/structures.rst:217
msgid ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"
msgstr ""

#: ../../c-api/structures.rst:228
msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr ""
"Estructura utilizada para describir un método de un tipo de extensión.  Esta "
"estructura tiene cuatro campos:"

#: ../../c-api/structures.rst:233
msgid "Name of the method."
msgstr "Nombre del método."

#: ../../c-api/structures.rst:237
msgid "Pointer to the C implementation."
msgstr "Puntero a la implementación en C."

#: ../../c-api/structures.rst:241
msgid "Flags bits indicating how the call should be constructed."
msgstr "Bits de bandera que indican cómo debe construirse la llamada."

#: ../../c-api/structures.rst:245
msgid "Points to the contents of the docstring."
msgstr "Apunta al contenido del docstring."

#: ../../c-api/structures.rst:247
msgid ""
"The :c:member:`~PyMethodDef.ml_meth` is a C function pointer. The functions "
"may be of different types, but they always return :c:expr:`PyObject*`.  If "
"the function is not of the :c:type:`PyCFunction`, the compiler will require "
"a cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:expr:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
":c:member:`~PyMethodDef.ml_meth` es un puntero a una función C. Las "
"funciones pueden ser de diferentes tipos, pero siempre devuelven :c:expr:"
"`PyObject*`.  Si la función no es del tipo :c:type:`PyCFunction`, el "
"compilador requerirá un cast en la tabla de métodos. Aunque :c:type:"
"`PyCFunction` defina el primer parámetro como :c:expr:`PyObject*`, es "
"habitual que la implementación del método utilice el tipo C específico del "
"objeto *self*."

#: ../../c-api/structures.rst:255
msgid ""
"The :c:member:`~PyMethodDef.ml_flags` field is a bitfield which can include "
"the following flags. The individual flags indicate either a calling "
"convention or a binding convention."
msgstr ""
"El campo :c:member:`~PyMethodDef.ml_flags` es un campo de bits que puede "
"incluir los siguientes indicadores. Las banderas individuales indican una "
"convención de llamada o una convención de enlace."

#: ../../c-api/structures.rst:260
msgid "There are these calling conventions:"
msgstr "Existen estas convenciones de llamada:"

#: ../../c-api/structures.rst:264
msgid ""
"This is the typical calling convention, where the methods have the type :c:"
"type:`PyCFunction`. The function expects two :c:expr:`PyObject*` values. The "
"first one is the *self* object for methods; for module functions, it is the "
"module object.  The second parameter (often called *args*) is a tuple object "
"representing all arguments. This parameter is typically processed using :c:"
"func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""
"Esta es la convención de llamada típica, en la que los métodos tienen el "
"tipo :c:type:`PyCFunction`. La función espera dos valores :c:expr:"
"`PyObject*`. El primero es el objeto *self* para los métodos; para las "
"funciones de módulo, es el objeto módulo.  El segundo parámetro (a menudo "
"llamado *args*) es un objeto tupla que representa todos los argumentos. Este "
"parámetro se procesa normalmente utilizando :c:func:`PyArg_ParseTuple` o :c:"
"func:`PyArg_UnpackTuple`."

#: ../../c-api/structures.rst:274
msgid ""
"Can only be used in certain combinations with other flags: :ref:"
"`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` and :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."
msgstr ""
"Sólo puede utilizarse en determinadas combinaciones con otros indicadores: :"
"ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` y :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."

#: ../../c-api/structures.rst:282
msgid ":c:expr:`METH_VARARGS | METH_KEYWORDS`"
msgstr ":c:expr:`METH_VARARGS | METH_KEYWORDS`"

#: ../../c-api/structures.rst:283
msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"Los métodos con estas banderas deben ser del tipo :c:type:"
"`PyCFunctionWithKeywords`. La función espera tres parámetros: *self*, "
"*args*, *kwargs* donde *kwargs* es un diccionario de todos los argumentos de "
"palabra clave o posiblemente ``NULL`` si no hay argumentos de palabra "
"clave.  Los parámetros se procesan normalmente utilizando :c:func:"
"`PyArg_ParseTupleAndKeywords`."

#: ../../c-api/structures.rst:292
msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`_PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:expr:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""
"Convención de llamada rápida que sólo admite argumentos posicionales. Los "
"métodos tienen el tipo :c:type:`_PyCFunctionFast`. El primer parámetro es "
"*self*, el segundo parámetro es una matriz C de valores :c:expr:`PyObject*` "
"que indican los argumentos y el tercer parámetro es el número de argumentos "
"(la longitud de la matriz)."

#: ../../c-api/structures.rst:302
msgid "``METH_FASTCALL`` is now part of the :ref:`stable ABI <stable-abi>`."
msgstr ""
"``METH_FASTCALL`` forma parte ahora de la :ref:`stable ABI <stable-abi>`."

#: ../../c-api/structures.rst:307
msgid ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"

#: ../../c-api/structures.rst:308
msgid ""
"Extension of :c:macro:`METH_FASTCALL` supporting also keyword arguments, "
"with methods of type :c:type:`_PyCFunctionFastWithKeywords`. Keyword "
"arguments are passed the same way as in the :ref:`vectorcall protocol "
"<vectorcall>`: there is an additional fourth :c:expr:`PyObject*` parameter "
"which is a tuple representing the names of the keyword arguments (which are "
"guaranteed to be strings) or possibly ``NULL`` if there are no keywords.  "
"The values of the keyword arguments are stored in the *args* array, after "
"the positional arguments."
msgstr ""
"Extensión de :c:macro:`METH_FASTCALL` que admite también argumentos de "
"palabra clave, con métodos de tipo :c:type:`_PyCFunctionFastWithKeywords`. "
"Los argumentos de palabra clave se pasan de la misma forma que en el "
"protocolo :ref:`vectorcall <vectorcall>`: hay un cuarto parámetro adicional :"
"c:expr:`PyObject*` que es una tupla que representa los nombres de los "
"argumentos de palabra clave (que se garantiza que son cadenas) o "
"posiblemente ``NULL`` si no hay palabras clave.  Los valores de los "
"argumentos de palabra clave se almacenan en la matriz *args*, después de los "
"argumentos posicionales."

#: ../../c-api/structures.rst:323
msgid ""
"Can only be used in the combination with other flags: :ref:`METH_METHOD | "
"METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."
msgstr ""
"Sólo puede utilizarse en combinación con otros indicadores: :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."

#: ../../c-api/structures.rst:329
msgid ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"

#: ../../c-api/structures.rst:330
msgid ""
"Extension of :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` supporting the *defining class*, that is, the class that "
"contains the method in question. The defining class might be a superclass of "
"``Py_TYPE(self)``."
msgstr ""
"Extensión de :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` que admite la *clase definidora*, es decir, la clase que "
"contiene el método en cuestión. La clase definidora puede ser una superclase "
"de ``Py_TYPE(self)``."

#: ../../c-api/structures.rst:335
msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"El método debe ser del tipo :c:type:`PyCMethod`, igual que para "
"``METH_FASTCALL | METH_KEYWORDS`` con el argumento ``defining_class`` "
"añadido después de ``self``."

#: ../../c-api/structures.rst:344
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :c:macro:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"Los métodos sin parámetros no necesitan comprobar si se dan argumentos si se "
"enumeran con la bandera :c:macro:`METH_NOARGS`.  Necesitan ser del tipo :c:"
"type:`PyCFunction`.  El primer parámetro suele llamarse *self* y contendrá "
"una referencia al módulo o a la instancia del objeto.  En todos los casos, "
"el segundo parámetro será ``NULL``."

#: ../../c-api/structures.rst:350
msgid ""
"The function must have 2 parameters. Since the second parameter is unused, :"
"c:macro:`Py_UNUSED` can be used to prevent a compiler warning."
msgstr ""
"La función debe tener 2 parámetros. Dado que el segundo parámetro no se "
"utiliza, se puede utilizar :c:macro:`Py_UNUSED` para evitar una advertencia "
"del compilador."

#: ../../c-api/structures.rst:356
msgid ""
"Methods with a single object argument can be listed with the :c:macro:"
"`METH_O` flag, instead of invoking :c:func:`PyArg_ParseTuple` with a "
"``\"O\"`` argument. They have the type :c:type:`PyCFunction`, with the "
"*self* parameter, and a :c:expr:`PyObject*` parameter representing the "
"single argument."
msgstr ""
"Los métodos con un único argumento objeto pueden listarse con la bandera :c:"
"macro:`METH_O`, en lugar de invocar :c:func:`PyArg_ParseTuple` con un "
"argumento ``\"O\"``. Tienen el tipo :c:type:`PyCFunction`, con el parámetro "
"*self*, y un parámetro :c:expr:`PyObject*` que representa el argumento único."

#: ../../c-api/structures.rst:362
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"Estas dos constantes no se utilizan para indicar la convención de llamada, "
"sino la vinculación cuando se usan con métodos de clases. No se pueden usar "
"para funciones definidas en módulos. Como máximo, se puede establecer una de "
"estas banderas para cualquier método dado."

#: ../../c-api/structures.rst:372
msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"El método recibirá el objeto de tipo como primer parámetro en lugar de una "
"instancia del tipo. Esto se utiliza para crear *métodos de clase*, similares "
"a los que se crean al usar la función integrada :func:`classmethod`."

#: ../../c-api/structures.rst:382
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"Al método se le pasará ``NULL`` como primer parámetro en lugar de una "
"instancia del tipo.  Esto se utiliza para crear *métodos estáticos*, "
"similares a los que se crean cuando se utiliza la función incorporada :func:"
"`staticmethod`."

#: ../../c-api/structures.rst:386
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr ""
"Otra constante controla si un método se carga en lugar de otra definición "
"con el mismo nombre de método."

#: ../../c-api/structures.rst:392
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`~object.__contains__` and preclude the loading of a corresponding "
"PyCFunction with the same name.  With the flag defined, the PyCFunction will "
"be loaded in place of the wrapper object and will co-exist with the slot.  "
"This is helpful because calls to PyCFunctions are optimized more than "
"wrapper object calls."
msgstr ""
"El método se cargará en lugar de las definiciones existentes.  Sin "
"*METH_COEXIST*, por defecto se omiten las definiciones repetidas.  Dado que "
"las envolturas de ranuras se cargan antes que la tabla de métodos, la "
"existencia de una ranura *sq_contains*, por ejemplo, generaría un método "
"envuelto llamado :meth:`~object.__contains__` e impediría la carga de una "
"PyCFunction correspondiente con el mismo nombre.  Con la bandera definida, "
"la PyCFunction se cargará en lugar del objeto envoltorio y coexistirá con la "
"ranura.  Esto es útil porque las llamadas a PyCFunctions están más "
"optimizadas que las llamadas al objeto envoltorio."

#: ../../c-api/structures.rst:404
msgid ""
"Turn *ml* into a Python :term:`callable` object. The caller must ensure that "
"*ml* outlives the :term:`callable`. Typically, *ml* is defined as a static "
"variable."
msgstr ""
"Convierte *ml* en un objeto :term:`callable` de Python. El invocador debe "
"asegurarse de que *ml* sobrevive al :term:`callable`. Normalmente, *ml* se "
"define como una variable estática."

#: ../../c-api/structures.rst:408
msgid ""
"The *self* parameter will be passed as the *self* argument to the C function "
"in ``ml->ml_meth`` when invoked. *self* can be ``NULL``."
msgstr ""
"El parámetro *self* se pasará como argumento *self* a la función C en ``ml-"
">ml_meth`` cuando se invoque. *self* puede ser ``NULL``."

#: ../../c-api/structures.rst:412
msgid ""
"The :term:`callable` object's ``__module__`` attribute can be set from the "
"given *module* argument. *module* should be a Python string, which will be "
"used as name of the module the function is defined in. If unavailable, it "
"can be set to :const:`None` or ``NULL``."
msgstr ""
"El atributo ``__module__`` del objeto :term:`callable` puede establecerse a "
"partir del argumento *module* dado. *module* debe ser una cadena de Python, "
"que se utilizará como nombre del módulo en el que se define la función. Si "
"no está disponible, puede establecerse como :const:`None` o ``NULL``."

#: ../../c-api/structures.rst:418
msgid ":attr:`function.__module__`"
msgstr ":attr:`function.__module__`"

#: ../../c-api/structures.rst:420
msgid ""
"The *cls* parameter will be passed as the *defining_class* argument to the C "
"function. Must be set if :c:macro:`METH_METHOD` is set on ``ml->ml_flags``."
msgstr ""
"El parámetro *cls* se pasará como argumento *defining_class* a la función C. "
"Debe establecerse si :c:macro:`METH_METHOD` se establece en ``ml->ml_flags``."

#: ../../c-api/structures.rst:429
msgid "Equivalent to ``PyCMethod_New(ml, self, module, NULL)``."
msgstr "Equivalente a ``PyCMethod_New(ml, self, module, NULL)``."

#: ../../c-api/structures.rst:434
msgid "Equivalent to ``PyCMethod_New(ml, self, NULL, NULL)``."
msgstr "Equivalente a ``PyCMethod_New(ml, self, NULL, NULL)``."

#: ../../c-api/structures.rst:438
msgid "Accessing attributes of extension types"
msgstr "Acceso a los atributos de los tipos de extensión"

#: ../../c-api/structures.rst:442
msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member. When defining a class, put a NULL-terminated array of these "
"structures in the :c:member:`~PyTypeObject.tp_members` slot."
msgstr ""
"Estructura que describe un atributo de un tipo que corresponde a un miembro "
"struct de C. Al definir una clase, coloque una matriz terminada en NULL de "
"estas estructuras en la ranura :c:member:`~PyTypeObject.tp_members`."

#: ../../c-api/structures.rst:447
msgid "Its fields are, in order:"
msgstr "Sus campos son, por orden:"

#: ../../c-api/structures.rst:451
msgid ""
"Name of the member. A NULL value marks the end of a ``PyMemberDef[]`` array."
msgstr ""
"Nombre del miembro. Un valor NULL marca el final de una matriz "
"``PyMemberDef[]``."

#: ../../c-api/structures.rst:454
msgid "The string should be static, no copy is made of it."
msgstr "La cadena debe ser estática, no se hace ninguna copia de ella."

#: ../../c-api/structures.rst:458
msgid ""
"The type of the member in the C struct. See :ref:`PyMemberDef-types` for the "
"possible values."
msgstr ""
"El tipo del miembro en la estructura C. Ver :ref:`PyMemberDef-types` para "
"conocer los valores posibles."

#: ../../c-api/structures.rst:463
msgid ""
"The offset in bytes that the member is located on the type’s object struct."
msgstr ""
"El desplazamiento en bytes en que se encuentra el miembro en la estructura "
"del objeto del tipo."

#: ../../c-api/structures.rst:467
msgid ""
"Zero or more of the :ref:`PyMemberDef-flags`, combined using bitwise OR."
msgstr ""
"Cero o más de los :ref:`PyMemberDef-flags`, combinados mediante bitwise OR."

#: ../../c-api/structures.rst:471
msgid ""
"The docstring, or NULL. The string should be static, no copy is made of it. "
"Typically, it is defined using :c:macro:`PyDoc_STR`."
msgstr ""
"El docstring, o NULL. La cadena debe ser estática, no se hace ninguna copia "
"de ella. Normalmente, se define utilizando :c:macro:`PyDoc_STR`."

#: ../../c-api/structures.rst:475
msgid ""
"By default (when :c:member:`~PyMemberDef.flags` is ``0``), members allow "
"both read and write access. Use the :c:macro:`Py_READONLY` flag for read-"
"only access. Certain types, like :c:macro:`Py_T_STRING`, imply :c:macro:"
"`Py_READONLY`. Only :c:macro:`Py_T_OBJECT_EX` (and legacy :c:macro:"
"`T_OBJECT`) members can be deleted."
msgstr ""
"Por defecto (cuando :c:member:`~PyMemberDef.flags` es ``0``), los miembros "
"permiten tanto el acceso de lectura como el de escritura. Utilice la "
"bandera :c:macro:`Py_READONLY` para el acceso de sólo lectura. Ciertos "
"tipos, como :c:macro:`Py_T_STRING`, implican :c:macro:`Py_READONLY`. Sólo se "
"pueden eliminar los miembros de :c:macro:`Py_T_OBJECT_EX` (y de la antigua :"
"c:macro:`T_OBJECT`)."

#: ../../c-api/structures.rst:484
msgid ""
"For heap-allocated types (created using :c:func:`PyType_FromSpec` or "
"similar), ``PyMemberDef`` may contain a definition for the special member "
"``\"__vectorcalloffset__\"``, corresponding to :c:member:`~PyTypeObject."
"tp_vectorcall_offset` in type objects. These must be defined with "
"``Py_T_PYSSIZET`` and ``Py_READONLY``, for example::"
msgstr ""
"Para tipos asignados a heap (creados usando :c:func:`PyType_FromSpec` o "
"similar), ``PyMemberDef`` puede contener una definición para el miembro "
"especial ``\"__vectorcalloffset__\"``, correspondiente a :c:member:"
"`~PyTypeObject.tp_vectorcall_offset` en objetos de tipo. Estos deben "
"definirse con ``Py_T_PYSSIZET`` y ``Py_READONLY``, por ejemplo::"

#: ../../c-api/structures.rst:490
msgid ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""

#: ../../c-api/structures.rst:496
msgid "(You may need to ``#include <stddef.h>`` for :c:func:`!offsetof`.)"
msgstr "(Puede que necesite ``#include <stddef.h>`` para :c:func:`!offsetof`.)"

#: ../../c-api/structures.rst:498
msgid ""
"The legacy offsets :c:member:`~PyTypeObject.tp_dictoffset` and :c:member:"
"`~PyTypeObject.tp_weaklistoffset` can be defined similarly using "
"``\"__dictoffset__\"`` and ``\"__weaklistoffset__\"`` members, but "
"extensions are strongly encouraged to use :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"and :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` instead."
msgstr ""
"Los desplazamientos heredados :c:member:`~PyTypeObject.tp_dictoffset` y :c:"
"member:`~PyTypeObject.tp_weaklistoffset` pueden definirse de forma similar "
"utilizando los miembros ``\"__dictoffset__\"`` y ``\"__weaklistoffset__\"``, "
"pero se recomienda encarecidamente a las extensiones que utilicen :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT` y :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` en su "
"lugar."

#: ../../c-api/structures.rst:506
msgid ""
"``PyMemberDef`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMemberDef`` está siempre disponible. Antes era necesario incluir "
"``\"structmember.h\"``."

#: ../../c-api/structures.rst:511
msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""
"Obtener un atributo perteneciente al objeto en la dirección *obj_addr*.  El "
"atributo se describe en ``PyMemberDef`` *m*.  Devuelve ``NULL`` en caso de "
"error."

#: ../../c-api/structures.rst:517
msgid ""
"``PyMember_GetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMember_GetOne`` está siempre disponible. Antes era necesario incluir "
"``\"structmember.h\"``."

#: ../../c-api/structures.rst:522
msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""
"Establece un atributo perteneciente al objeto en la dirección *obj_addr* al "
"objeto *o*. El atributo a establecer se describe en ``PyMemberDef`` *m*.  "
"Devuelve ``0`` si tiene éxito y un valor negativo en caso de fallo."

#: ../../c-api/structures.rst:528
msgid ""
"``PyMember_SetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMember_SetOne`` está siempre disponible. Antes era necesario incluir "
"``\"structmember.h\"``."

#: ../../c-api/structures.rst:534
msgid "Member flags"
msgstr "Banderas de los miembros"

#: ../../c-api/structures.rst:536
msgid "The following flags can be used with :c:member:`PyMemberDef.flags`:"
msgstr ""
"Los siguientes indicadores pueden utilizarse con :c:member:`PyMemberDef."
"flags`:"

#: ../../c-api/structures.rst:540
msgid "Not writable."
msgstr "No se puede escribir."

#: ../../c-api/structures.rst:544
msgid ""
"Emit an ``object.__getattr__`` :ref:`audit event <audit-events>` before "
"reading."
msgstr ""
"Emite un ``object.__getattr__``:ref:`audit event <audit-events>` antes de la "
"lectura."

#: ../../c-api/structures.rst:549
msgid ""
"Indicates that the :c:member:`~PyMemberDef.offset` of this ``PyMemberDef`` "
"entry indicates an offset from the subclass-specific data, rather than from "
"``PyObject``."
msgstr ""
"Indica que el :c:member:`~PyMemberDef.offset` de esta entrada "
"``PyMemberDef`` indica un desplazamiento desde los datos específicos de la "
"subclase, en lugar de desde ``PyObject``."

#: ../../c-api/structures.rst:553
msgid ""
"Can only be used as part of :c:member:`Py_tp_members <PyTypeObject."
"tp_members>` :c:type:`slot <PyType_Slot>` when creating a class using "
"negative :c:member:`~PyType_Spec.basicsize`. It is mandatory in that case."
msgstr ""
"Sólo se puede usar como parte de :c:member:`Py_tp_members <PyTypeObject."
"tp_members>`:c:type:`slot <PyType_Slot>` cuando se crea una clase usando "
"negativo :c:member:`~PyType_Spec.basicsize`. En ese caso es obligatorio."

#: ../../c-api/structures.rst:558
msgid ""
"This flag is only used in :c:type:`PyType_Slot`. When setting :c:member:"
"`~PyTypeObject.tp_members` during class creation, Python clears it and sets :"
"c:member:`PyMemberDef.offset` to the offset from the ``PyObject`` struct."
msgstr ""
"Esta bandera sólo se utiliza en :c:type:`PyType_Slot`. Cuando se establece :"
"c:member:`~PyTypeObject.tp_members` durante la creación de la clase, Python "
"lo borra y establece :c:member:`PyMemberDef.offset` al offset de la "
"estructura ``PyObject``."

#: ../../c-api/structures.rst:570
msgid ""
"The :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` and :c:macro:`!"
"WRITE_RESTRICTED` macros available with ``#include \"structmember.h\"`` are "
"deprecated. :c:macro:`!READ_RESTRICTED` and :c:macro:`!RESTRICTED` are "
"equivalent to :c:macro:`Py_AUDIT_READ`; :c:macro:`!WRITE_RESTRICTED` does "
"nothing."
msgstr ""
"Las macros :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` y :c:macro:`!"
"WRITE_RESTRICTED` disponibles con ``#include \"structmember.h\"`` están "
"obsoletas. :c:macro:`!READ_RESTRICTED` y :c:macro:`!RESTRICTED` son "
"equivalentes a :c:macro:`Py_AUDIT_READ`; :c:macro:`!WRITE_RESTRICTED` no "
"hace nada."

#: ../../c-api/structures.rst:581
msgid ""
"The :c:macro:`!READONLY` macro was renamed to :c:macro:`Py_READONLY`. The :c:"
"macro:`!PY_AUDIT_READ` macro was renamed with the ``Py_`` prefix. The new "
"names are now always available. Previously, these required ``#include "
"\"structmember.h\"``. The header is still available and it provides the old "
"names."
msgstr ""
"La macro :c:macro:`!READONLY` se ha renombrado a :c:macro:`Py_READONLY`. La "
"macro :c:macro:`!PY_AUDIT_READ` se ha renombrado con el prefijo ``Py_``. Los "
"nuevos nombres están ahora siempre disponibles. Antes se necesitaba "
"``#include \"structmember.h\"``. La cabecera sigue disponible y proporciona "
"los nombres antiguos."

#: ../../c-api/structures.rst:590
msgid "Member types"
msgstr "Tipos de miembros"

#: ../../c-api/structures.rst:592
msgid ""
":c:member:`PyMemberDef.type` can be one of the following macros "
"corresponding to various C types. When the member is accessed in Python, it "
"will be converted to the equivalent Python type. When it is set from Python, "
"it will be converted back to the C type. If that is not possible, an "
"exception such as :exc:`TypeError` or :exc:`ValueError` is raised."
msgstr ""
":c:member:`PyMemberDef.type` puede ser una de las siguientes macros "
"correspondientes a varios tipos de C. Cuando se accede al miembro en Python, "
"se convertirá al tipo Python equivalente. Cuando se establezca desde Python, "
"se convertirá de nuevo al tipo C. Si esto no es posible, se lanzará una "
"excepción como :exc:`TypeError` o :exc:`ValueError`."

#: ../../c-api/structures.rst:600
msgid ""
"Unless marked (D), attributes defined this way cannot be deleted using e.g. :"
"keyword:`del` or :py:func:`delattr`."
msgstr ""
"A menos que estén marcados con (D), los atributos definidos de esta forma no "
"se pueden eliminar utilizando, por ejemplo, :keyword:`del` o :py:func:"
"`delattr`."

#: ../../c-api/structures.rst:604
msgid "Macro name"
msgstr "Nombre de la macro"

#: ../../c-api/structures.rst:604
msgid "C type"
msgstr "Tipo C"

#: ../../c-api/structures.rst:604
msgid "Python type"
msgstr "Tipo Python"

#: ../../c-api/structures.rst:606
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: ../../c-api/structures.rst:606 ../../c-api/structures.rst:607
#: ../../c-api/structures.rst:608 ../../c-api/structures.rst:609
#: ../../c-api/structures.rst:610 ../../c-api/structures.rst:611
#: ../../c-api/structures.rst:612 ../../c-api/structures.rst:613
#: ../../c-api/structures.rst:614 ../../c-api/structures.rst:615
#: ../../c-api/structures.rst:616
msgid ":py:class:`int`"
msgstr ":py:class:`int`"

#: ../../c-api/structures.rst:607
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: ../../c-api/structures.rst:608
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../c-api/structures.rst:609
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: ../../c-api/structures.rst:610
msgid ":c:expr:`long long`"
msgstr ":c:expr:`long long`"

#: ../../c-api/structures.rst:611
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: ../../c-api/structures.rst:612
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: ../../c-api/structures.rst:613
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: ../../c-api/structures.rst:614
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: ../../c-api/structures.rst:615
msgid ":c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned long long`"

#: ../../c-api/structures.rst:616
msgid ":c:expr:`Py_ssize_t`"
msgstr ":c:expr:`Py_ssize_t`"

#: ../../c-api/structures.rst:617
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: ../../c-api/structures.rst:617 ../../c-api/structures.rst:618
msgid ":py:class:`float`"
msgstr ":py:class:`float`"

#: ../../c-api/structures.rst:618
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: ../../c-api/structures.rst:619
msgid ":c:expr:`char` (written as 0 or 1)"
msgstr ":c:expr:`char` (escrito como 0 o 1)"

#: ../../c-api/structures.rst:619
msgid ":py:class:`bool`"
msgstr ":py:class:`bool`"

#: ../../c-api/structures.rst:621
msgid ":c:expr:`const char *` (*)"
msgstr ":c:expr:`const char *` (*)"

#: ../../c-api/structures.rst:621 ../../c-api/structures.rst:622
msgid ":py:class:`str` (RO)"
msgstr ":py:class:`str` (RO)"

#: ../../c-api/structures.rst:622
msgid ":c:expr:`const char[]` (*)"
msgstr ":c:expr:`const char[]` (*)"

#: ../../c-api/structures.rst:623
msgid ":c:expr:`char` (0-127)"
msgstr ":c:expr:`char` (0-127)"

#: ../../c-api/structures.rst:623
msgid ":py:class:`str` (**)"
msgstr ":py:class:`str` (**)"

#: ../../c-api/structures.rst:624
msgid ":c:expr:`PyObject *`"
msgstr ":c:expr:`PyObject *`"

#: ../../c-api/structures.rst:624
msgid ":py:class:`object` (D)"
msgstr ":py:class:`object` (D)"

#: ../../c-api/structures.rst:627
msgid ""
"(*): Zero-terminated, UTF8-encoded C string. With :c:macro:`!Py_T_STRING` "
"the C representation is a pointer; with :c:macro:`!Py_T_STRING_INPLACE` the "
"string is stored directly in the structure."
msgstr ""
"(*): Cadena en C de terminación cero y codificada en UTF8. Con :c:macro:`!"
"Py_T_STRING` la representación C es un puntero; con :c:macro:`!"
"Py_T_STRING_INPLACE` la cadena se almacena directamente en la estructura."

#: ../../c-api/structures.rst:632
msgid "(**): String of length 1. Only ASCII is accepted."
msgstr "(**): Cadena de longitud 1. Sólo se acepta ASCII."

#: ../../c-api/structures.rst:634
msgid "(RO): Implies :c:macro:`Py_READONLY`."
msgstr "(RO): Implica :c:macro:`Py_READONLY`."

#: ../../c-api/structures.rst:636
msgid ""
"(D): Can be deleted, in which case the pointer is set to ``NULL``. Reading a "
"``NULL`` pointer raises :py:exc:`AttributeError`."
msgstr ""
"(D): Puede ser borrado, en cuyo caso el puntero se establece en ``NULL``. La "
"lectura de un puntero ``NULL`` plantea :py:exc:`AttributeError`."

#: ../../c-api/structures.rst:662
msgid ""
"In previous versions, the macros were only available with ``#include "
"\"structmember.h\"`` and were named without the ``Py_`` prefix (e.g. as "
"``T_INT``). The header is still available and contains the old names, along "
"with the following deprecated types:"
msgstr ""
"En versiones anteriores, las macros sólo estaban disponibles con ``#include "
"\"structmember.h\"`` y se nombraban sin el prefijo ``Py_`` (por ejemplo, "
"como ``T_INT``). La cabecera sigue disponible y contiene los nombres "
"antiguos, junto con los siguientes tipos obsoletos:"

#: ../../c-api/structures.rst:670
msgid ""
"Like ``Py_T_OBJECT_EX``, but ``NULL`` is converted to ``None``. This results "
"in surprising behavior in Python: deleting the attribute effectively sets it "
"to ``None``."
msgstr ""
"Como ``Py_T_OBJECT_EX``, pero ``NULL`` se convierte en ``None``. Esto da "
"lugar a un comportamiento sorprendente en Python: al eliminar el atributo, "
"se convierte en ``None``."

#: ../../c-api/structures.rst:676
msgid "Always ``None``. Must be used with :c:macro:`Py_READONLY`."
msgstr "Siempre ``None``. Debe utilizarse con :c:macro:`Py_READONLY`."

#: ../../c-api/structures.rst:679
msgid "Defining Getters and Setters"
msgstr "Definición de Getters y Setters"

#: ../../c-api/structures.rst:683
msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"Estructura para definir el acceso tipo propiedad para un tipo. Véase también "
"la descripción de la ranura :c:member:`PyTypeObject.tp_getset`."

#: ../../c-api/structures.rst:688
msgid "attribute name"
msgstr "nombre de atributo"

#: ../../c-api/structures.rst:692
msgid "C function to get the attribute."
msgstr "C para obtener el atributo."

#: ../../c-api/structures.rst:696
msgid ""
"Optional C function to set or delete the attribute. If ``NULL``, the "
"attribute is read-only."
msgstr ""
"Función C opcional para establecer o eliminar el atributo. Si ``NULL``, el "
"atributo es de sólo lectura."

#: ../../c-api/structures.rst:701
msgid "optional docstring"
msgstr "docstring opcional"

#: ../../c-api/structures.rst:705
msgid ""
"Optional user data pointer, providing additional data for getter and setter."
msgstr ""
"Puntero opcional de datos de usuario, que proporciona datos adicionales para "
"getter y setter."

#: ../../c-api/structures.rst:709
msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the instance) "
"and a user data pointer (the associated ``closure``):"
msgstr ""
"La función ``get`` toma un parámetro :c:expr:`PyObject*` (la instancia) y un "
"puntero de datos de usuario (el ``closure`` asociado):"

#: ../../c-api/structures.rst:712
msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr ""
"Debe devolver una nueva referencia en caso de éxito o ``NULL`` con una "
"excepción establecida en caso de fallo."

#: ../../c-api/structures.rst:717
msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance and "
"the value to be set) and a user data pointer (the associated ``closure``):"
msgstr ""
"``set`` toman dos parámetros :c:expr:`PyObject*` (la instancia y el valor a "
"establecer) y un puntero de datos de usuario (el ``closure`` asociado):"

#: ../../c-api/structures.rst:720
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"En caso de que el atributo se deba borrar el segundo parámetro es ``NULL``. "
"Debe devolver ``0`` en caso de éxito o ``-1`` con una excepción establecida "
"en caso de fallo."

#: ../../c-api/structures.rst:370 ../../c-api/structures.rst:380
msgid "built-in function"
msgstr "función incorporada"

#: ../../c-api/structures.rst:370
msgid "classmethod"
msgstr "classmethod"

#: ../../c-api/structures.rst:380
msgid "staticmethod"
msgstr "método estático"

#: ../../c-api/structures.rst:563
msgid "READ_RESTRICTED (C macro)"
msgstr "READ_RESTRICTED (macro C)"

#: ../../c-api/structures.rst:563
msgid "WRITE_RESTRICTED (C macro)"
msgstr "WRITE_RESTRICTED (macro C)"

#: ../../c-api/structures.rst:563
msgid "RESTRICTED (C macro)"
msgstr "RESTRICTED (macro C)"

#: ../../c-api/structures.rst:576
msgid "READONLY (C macro)"
msgstr "READONLY (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_BYTE (C macro)"
msgstr "T_BYTE (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_SHORT (C macro)"
msgstr "T_SHORT (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_INT (C macro)"
msgstr "T_INT (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_LONG (C macro)"
msgstr "T_LONG (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_LONGLONG (C macro)"
msgstr "T_LONGLONG (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_UBYTE (C macro)"
msgstr "T_UBYTE (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_USHORT (C macro)"
msgstr "T_USHORT (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_UINT (C macro)"
msgstr "T_UINT (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_ULONG (C macro)"
msgstr "T_ULONG (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_ULONGULONG (C macro)"
msgstr "T_ULONGULONG (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_PYSSIZET (C macro)"
msgstr "T_PYSSIZET (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_FLOAT (C macro)"
msgstr "T_FLOAT (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_DOUBLE (C macro)"
msgstr "T_DOUBLE (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_BOOL (C macro)"
msgstr "T_BOOL (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_CHAR (C macro)"
msgstr "T_CHAR (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_STRING (C macro)"
msgstr "T_STRING (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_STRING_INPLACE (C macro)"
msgstr "T_STRING_INPLACE (macro C)"

#: ../../c-api/structures.rst:639
msgid "T_OBJECT_EX (C macro)"
msgstr "T_OBJECT_EX (macro C)"

#: ../../c-api/structures.rst:639
msgid "structmember.h"
msgstr "structmember.h"
