# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-23 15:52+0000\n"
"PO-Revision-Date: 2017-02-16 17:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "Співпрограми та завдання"

#: ../../library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"У цьому розділі описано асинхронні API високого рівня для роботи з "
"співпрограмами та завданнями."

#: ../../library/asyncio-task.rst:19 ../../library/asyncio-task.rst:121
msgid "Coroutines"
msgstr "Співпрограми"

#: ../../library/asyncio-task.rst:21
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
":term:`Coroutines <coroutine>`, оголошений із синтаксисом async/await, є "
"кращим способом написання асинхронних програм. Наприклад, наступний фрагмент "
"коду друкує \"hello\", чекає 1 секунду, а потім друкує \"world\"::"

#: ../../library/asyncio-task.rst:37
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr "Зауважте, що простий виклик співпрограми не запланує її виконання:"

#: ../../library/asyncio-task.rst:43
msgid "To actually run a coroutine, asyncio provides three main mechanisms:"
msgstr ""
"Щоб фактично запустити співпрограму, asyncio надає три основні механізми:"

#: ../../library/asyncio-task.rst:45
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"Функція :func:`asyncio.run` для запуску функції точки входу верхнього рівня "
"\"main()\" (див. приклад вище)."

#: ../../library/asyncio-task.rst:48
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Очікування співпрограми. Наступний фрагмент коду надрукує \"привіт\" після "
"очікування 1 секунду, а потім надрукує \"світ\" після очікування *ще* 2 "
"секунди::"

#: ../../library/asyncio-task.rst:69
msgid "Expected output::"
msgstr "Очікуваний результат::"

#: ../../library/asyncio-task.rst:76
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"Функція :func:`asyncio.create_task` для одночасного запуску співпрограм як "
"asyncio :class:`Tasks <Task>`."

#: ../../library/asyncio-task.rst:79
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Давайте змінимо наведений вище приклад і запустимо дві співпрограми "
"``say_after`` *одночасно*::"

#: ../../library/asyncio-task.rst:98
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"Зауважте, що очікуваний вихід тепер показує, що фрагмент працює на 1 секунду "
"швидше, ніж раніше:"

#: ../../library/asyncio-task.rst:110
msgid "Awaitables"
msgstr "очікування"

#: ../../library/asyncio-task.rst:112
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Ми кажемо, що об’єкт є **очікуваним** об’єктом, якщо його можна "
"використовувати у виразі :keyword:`await`. Багато асинхронних API розроблено "
"для прийняття очікуваних."

#: ../../library/asyncio-task.rst:116
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Існує три основних типи *очікуваних* об’єктів: **співпрограми**, "
"**Завдання** та **Ф’ючерси**."

#: ../../library/asyncio-task.rst:122
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Співпрограми Python є *очікуваними*, тому їх можна очікувати від інших "
"співпрограм:"

#: ../../library/asyncio-task.rst:143
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"У цій документації термін \"співпрограма\" може використовуватися для двох "
"тісно пов’язаних понять:"

#: ../../library/asyncio-task.rst:146
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "*співпрограма*: функція :keyword:`async def`;"

#: ../../library/asyncio-task.rst:148
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr ""
"*об’єкт співпрограми*: об’єкт, повернутий викликом *функції співпрограми*."

#: ../../library/asyncio-task.rst:151
msgid ""
"asyncio also supports legacy :ref:`generator-based "
"<asyncio_generator_based_coro>` coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:156
msgid "Tasks"
msgstr "завдання"

#: ../../library/asyncio-task.rst:157
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*Завдання* використовуються для *одночасного* планування співпрограм."

#: ../../library/asyncio-task.rst:159
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"Коли співпрограму загорнуто в *Task* із такими функціями, як :func:`asyncio."
"create_task`, співпрограма автоматично планується для незабаром:"

#: ../../library/asyncio-task.rst:181
msgid "Futures"
msgstr "Ф'ючерси"

#: ../../library/asyncio-task.rst:182
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
":class:`Future` — це спеціальний **низькорівневий** очікуваний об’єкт, який "
"представляє **кінцевий результат** асинхронної операції."

#: ../../library/asyncio-task.rst:185
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Коли об’єкт Future *очікується*, це означає, що співпрограма чекатиме, поки "
"Future не буде дозволено в іншому місці."

#: ../../library/asyncio-task.rst:188
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Майбутні об’єкти в asyncio потрібні для того, щоб код на основі зворотного "
"виклику використовувався з async/await."

#: ../../library/asyncio-task.rst:191
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Зазвичай **немає необхідності** створювати об’єкти Future на рівні програми."

#: ../../library/asyncio-task.rst:194
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Майбутні об’єкти, іноді доступні бібліотеками та деякими асинхронними API, "
"можна очікувати:"

#: ../../library/asyncio-task.rst:206
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
"Хорошим прикладом функції низького рівня, яка повертає об’єкт Future, є :"
"meth:`loop.run_in_executor`."

#: ../../library/asyncio-task.rst:211
msgid "Running an asyncio Program"
msgstr ""

#: ../../library/asyncio-task.rst:215
msgid "Execute the :term:`coroutine` *coro* and return the result."
msgstr ""

#: ../../library/asyncio-task.rst:217
msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio "
"event loop, *finalizing asynchronous generators*, and closing the threadpool."
msgstr ""

#: ../../library/asyncio-task.rst:221
msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr ""

#: ../../library/asyncio-task.rst:224
msgid "If *debug* is ``True``, the event loop will be run in debug mode."
msgstr ""

#: ../../library/asyncio-task.rst:226
msgid ""
"This function always creates a new event loop and closes it at the end.  It "
"should be used as a main entry point for asyncio programs, and should "
"ideally only be called once."
msgstr ""

#: ../../library/asyncio-task.rst:230 ../../library/asyncio-task.rst:350
#: ../../library/asyncio-task.rst:471 ../../library/asyncio-task.rst:603
msgid "Example::"
msgstr "Приклад::"

#: ../../library/asyncio-task.rst:240
msgid "Updated to use :meth:`loop.shutdown_default_executor`."
msgstr ""

#: ../../library/asyncio-task.rst:244
msgid ""
"The source code for ``asyncio.run()`` can be found in :source:`Lib/asyncio/"
"runners.py`."
msgstr ""

#: ../../library/asyncio-task.rst:248
msgid "Creating Tasks"
msgstr "Створення завдань"

#: ../../library/asyncio-task.rst:252
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Загорніть *coro* :ref:`coroutine <coroutine>` в :class:`Task` і заплануйте "
"його виконання. Повернути об’єкт Task."

#: ../../library/asyncio-task.rst:255
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""
"Якщо *name* не є ``None``, воно встановлюється як назва завдання за "
"допомогою :meth:`Task.set_name`."

#: ../../library/asyncio-task.rst:258
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"Завдання виконується в циклі, який повертає :func:`get_running_loop`, :exc:"
"`RuntimeError` виникає, якщо в поточному потоці немає запущеного циклу."

#: ../../library/asyncio-task.rst:264
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid execution."
msgstr ""
"Збережіть посилання на результат цієї функції, щоб уникнути зникнення "
"завдання під час виконання."

#: ../../library/asyncio-task.rst:269 ../../library/asyncio-task.rst:785
msgid "Added the ``name`` parameter."
msgstr ""

#: ../../library/asyncio-task.rst:274
msgid "Sleeping"
msgstr "спить"

#: ../../library/asyncio-task.rst:278
msgid "Block for *delay* seconds."
msgstr "Блокувати на *затримку* секунд."

#: ../../library/asyncio-task.rst:280
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Якщо надано *результат*, він повертається абоненту після завершення "
"співпрограми."

#: ../../library/asyncio-task.rst:283
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` завжди призупиняє поточне завдання, дозволяючи виконувати інші "
"завдання."

#: ../../library/asyncio-task.rst:286
msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr ""
"Встановлення затримки на 0 забезпечує оптимізований шлях для виконання інших "
"завдань. Це може бути використано функціями, які довго виконуються, щоб "
"уникнути блокування циклу подій протягом повної тривалості виклику функції."

#: ../../library/asyncio-task.rst:292 ../../library/asyncio-task.rst:347
#: ../../library/asyncio-task.rst:437 ../../library/asyncio-task.rst:468
#: ../../library/asyncio-task.rst:555 ../../library/asyncio-task.rst:602
#: ../../library/asyncio-task.rst:790
msgid "The *loop* parameter."
msgstr ""

#: ../../library/asyncio-task.rst:295
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Приклад співпрограми, що відображає поточну дату кожну секунду протягом 5 "
"секунд:"

#: ../../library/asyncio-task.rst:314
msgid "Running Tasks Concurrently"
msgstr "Одночасне виконання завдань"

#: ../../library/asyncio-task.rst:318
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Запустіть :ref:`waitable objects <asyncio-awaitables>` у послідовності *aws* "
"*одночасно*."

#: ../../library/asyncio-task.rst:321
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Якщо будь-який awaitable у *aws* є співпрограмою, він автоматично "
"запланований як завдання."

#: ../../library/asyncio-task.rst:324
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Якщо всі очікування виконано успішно, результатом буде зведений список "
"повернутих значень. Порядок значень результатів відповідає порядку "
"очікуваних значень у *aws*."

#: ../../library/asyncio-task.rst:328
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Якщо *return_exceptions* має значення ``False`` (за замовчуванням), перший "
"викликаний виняток негайно поширюється на завдання, яке очікує на "
"``gather()``. Інші очікування в послідовності *aws* **не будуть скасовані** "
"і продовжуватимуть працювати."

#: ../../library/asyncio-task.rst:333
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Якщо *return_exceptions* має значення ``True``, винятки обробляються так "
"само, як успішні результати, і агрегуються в списку результатів."

#: ../../library/asyncio-task.rst:336
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Якщо ``gather()`` *скасовано*, усі надіслані очікування (які ще не "
"завершені) також *скасуються*."

#: ../../library/asyncio-task.rst:339
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Якщо будь-яке завдання або майбутнє з послідовності *aws* *скасовано*, воно "
"розглядається як викликане :exc:`CancelledError` -- у цьому випадку виклик "
"``gather()`` **не** скасовується . Це робиться для того, щоб запобігти "
"скасуванню одного поданого Завдання/Майбутнього, що спричинить скасування "
"інших Завдань/Ф’ючерсів."

#: ../../library/asyncio-task.rst:388
msgid ""
"If *return_exceptions* is False, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""
"Якщо *return_exceptions* має значення False, скасування gather() після того, "
"як його було позначено як виконане, не скасує жодних надісланих очікувань. "
"Наприклад, gather можна позначити як виконане після передачі винятку "
"викликаючому, отже, виклик ``gather.cancel()`` після перехоплення винятку "
"(викликаного одним із очікуваних) від gather не скасує жодних інших "
"очікуваних."

#: ../../library/asyncio-task.rst:395
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Якщо сам *gather* скасовано, скасування поширюється незалежно від "
"*return_exceptions*."

#: ../../library/asyncio-task.rst:401
msgid "Shielding From Cancellation"
msgstr "Захист від скасування"

#: ../../library/asyncio-task.rst:405
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Захист :ref:`очікуваного об’єкта <asyncio-awaitables>` від :meth:`скасування "
"<Task.cancel>`."

#: ../../library/asyncio-task.rst:408 ../../library/asyncio-task.rst:448
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr "Якщо *aw* є співпрограмою, вона автоматично запланована як завдання."

#: ../../library/asyncio-task.rst:410
msgid "The statement::"
msgstr "Заява::"

#: ../../library/asyncio-task.rst:414
msgid "is equivalent to::"
msgstr "еквівалентно::"

#: ../../library/asyncio-task.rst:418
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*за винятком* того, що якщо співпрограму, яка містить його, скасовується, "
"Завдання, що виконується в ``something()``, не скасовується. З точки зору "
"``something()``, скасування не відбулося. Хоча його виклик все ще скасовано, "
"тому вираз \"чекати\" все ще викликає :exc:`CancelledError`."

#: ../../library/asyncio-task.rst:424
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Якщо ``something()`` скасовано іншими засобами (тобто зсередини), це також "
"скасує ``shield()``."

#: ../../library/asyncio-task.rst:427
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Якщо потрібно повністю ігнорувати скасування (не рекомендовано), функцію "
"``shield()`` слід поєднати з реченням try/except, як показано нижче:"

#: ../../library/asyncio-task.rst:441
msgid "Timeouts"
msgstr "Тайм-аути"

#: ../../library/asyncio-task.rst:445
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Зачекайте, поки *aw* :ref:`awaitable <asyncio-awaitables>` завершиться з "
"тайм-аутом."

#: ../../library/asyncio-task.rst:450
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* може бути або ``None``, або числом секунд для очікування з "
"плаваючою точкою або int. Якщо *timeout* має значення ``None``, блокуйте до "
"завершення майбутнього."

#: ../../library/asyncio-task.rst:454
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`asyncio."
"TimeoutError`."
msgstr ""

#: ../../library/asyncio-task.rst:457
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"Щоб уникнути завдання :meth:`скасування <Task.cancel>`, загорніть його в :"
"func:`shield`."

#: ../../library/asyncio-task.rst:460
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr ""
"Функція чекатиме, доки майбутнє фактично не буде скасовано, тому загальний "
"час очікування може перевищити *тайм-аут*. Якщо під час скасування виникає "
"виняток, він поширюється."

#: ../../library/asyncio-task.rst:464
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Якщо очікування скасовується, майбутнє *aw* також скасовується."

#: ../../library/asyncio-task.rst:491
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`asyncio.TimeoutError` immediately."
msgstr ""

#: ../../library/asyncio-task.rst:498
msgid "Waiting Primitives"
msgstr "Очікування примітивів"

#: ../../library/asyncio-task.rst:503
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently and block until the condition specified by *return_when*."
msgstr ""

#: ../../library/asyncio-task.rst:507
msgid "The *aws* iterable must not be empty."
msgstr "Ітерація *aws* не має бути порожньою."

#: ../../library/asyncio-task.rst:509
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Повертає два набори Tasks/Futures: ``(done, pending)``."

#: ../../library/asyncio-task.rst:511
msgid "Usage::"
msgstr "Використання::"

#: ../../library/asyncio-task.rst:515
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (float або int), якщо вказано, можна використовувати для керування "
"максимальною кількістю секунд очікування перед поверненням."

#: ../../library/asyncio-task.rst:518
msgid ""
"Note that this function does not raise :exc:`asyncio.TimeoutError`. Futures "
"or Tasks that aren't done when the timeout occurs are simply returned in the "
"second set."
msgstr ""

#: ../../library/asyncio-task.rst:522
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* вказує, коли ця функція має повернутися. Це має бути одна з "
"таких констант:"

#: ../../library/asyncio-task.rst:528
msgid "Constant"
msgstr "Постійний"

#: ../../library/asyncio-task.rst:528
msgid "Description"
msgstr "опис"

#: ../../library/asyncio-task.rst:530
msgid ":const:`FIRST_COMPLETED`"
msgstr ":const:`FIRST_COMPLETED`"

#: ../../library/asyncio-task.rst:530
msgid "The function will return when any future finishes or is cancelled."
msgstr ""
"Функція повернеться, коли будь-який майбутній завершиться або буде скасовано."

#: ../../library/asyncio-task.rst:533
msgid ":const:`FIRST_EXCEPTION`"
msgstr ":const:`FIRST_EXCEPTION`"

#: ../../library/asyncio-task.rst:533
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"Функція повернеться, коли будь-який майбутній завершиться, викликавши "
"виняток. Якщо жодне майбутнє не викликає винятку, це еквівалентно :const:"
"`ALL_COMPLETED`."

#: ../../library/asyncio-task.rst:539
msgid ":const:`ALL_COMPLETED`"
msgstr ":const:`ALL_COMPLETED`"

#: ../../library/asyncio-task.rst:539
msgid "The function will return when all futures finish or are cancelled."
msgstr ""
"Функція повернеться, коли всі ф’ючерси закінчаться або будуть скасовані."

#: ../../library/asyncio-task.rst:543
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"На відміну від :func:`~asyncio.wait_for`, ``wait()`` не скасовує ф’ючерси, "
"коли настає тайм-аут."

#: ../../library/asyncio-task.rst:548
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task.  Passing coroutines objects to ``wait()`` directly is deprecated as it "
"leads to :ref:`confusing behavior <asyncio_example_wait_coroutine>`."
msgstr ""

#: ../../library/asyncio-task.rst:560
msgid ""
"``wait()`` schedules coroutines as Tasks automatically and later returns "
"those implicitly created Task objects in ``(done, pending)`` sets.  "
"Therefore the following code won't work as expected::"
msgstr ""

#: ../../library/asyncio-task.rst:573
msgid "Here is how the above snippet can be fixed::"
msgstr ""

#: ../../library/asyncio-task.rst:586
msgid "Passing coroutine objects to ``wait()`` directly is deprecated."
msgstr ""

#: ../../library/asyncio-task.rst:592
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently.  Return an iterator of coroutines. Each coroutine returned can "
"be awaited to get the earliest next result from the iterable of the "
"remaining awaitables."
msgstr ""
"Запустіть :ref:`waitable objects <asyncio-awaitables>` в *aws* iterable "
"одночасно. Повертає ітератор співпрограм. Кожну повернуту співпрограму можна "
"очікувати, щоб отримати найраніший наступний результат із ітерації решти "
"очікуваних."

#: ../../library/asyncio-task.rst:597
msgid ""
"Raises :exc:`asyncio.TimeoutError` if the timeout occurs before all Futures "
"are done."
msgstr ""

#: ../../library/asyncio-task.rst:611
msgid "Running in Threads"
msgstr "Запуск у потоках"

#: ../../library/asyncio-task.rst:615
msgid "Asynchronously run function *func* in a separate thread."
msgstr "Асинхронний запуск функції *func* в окремому потоці."

#: ../../library/asyncio-task.rst:617
msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""
"Будь-які \\*args і \\*\\*kwargs, надані для цієї функції, безпосередньо "
"передаються до *func*. Крім того, поточний :class:`contextvars.Context` "
"поширюється, дозволяючи доступ до змінних контексту з потоку циклу подій в "
"окремому потоці."

#: ../../library/asyncio-task.rst:622
msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr ""
"Повертає співпрограму, яку можна очікувати, щоб отримати кінцевий результат "
"*func*."

#: ../../library/asyncio-task.rst:624
msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were ran in the main thread. For example::"
msgstr ""

#: ../../library/asyncio-task.rst:654
msgid ""
"Directly calling `blocking_io()` in any coroutine would block the event loop "
"for its duration, resulting in an additional 1 second of run time. Instead, "
"by using `asyncio.to_thread()`, we can run it in a separate thread without "
"blocking the event loop."
msgstr ""
"Безпосередній виклик `blocking_io()` у будь-якій співпрограмі заблокує цикл "
"подій на весь час, що призведе до додаткової 1 секунди часу виконання. "
"Натомість, використовуючи `asyncio.to_thread()`, ми можемо запустити його в "
"окремому потоці, не блокуючи цикл подій."

#: ../../library/asyncio-task.rst:661
msgid ""
"Due to the :term:`GIL`, `asyncio.to_thread()` can typically only be used to "
"make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"`asyncio.to_thread()` can also be used for CPU-bound functions."
msgstr ""
"Завдяки :term:`GIL`, `asyncio.to_thread()` зазвичай можна використовувати "
"лише для того, щоб зробити функції, пов’язані з IO, неблокуючими. Однак для "
"модулів розширення, які випускають GIL або альтернативних реалізацій Python, "
"у яких його немає, `asyncio.to_thread()` також можна використовувати для "
"пов’язаних з ЦП функцій."

#: ../../library/asyncio-task.rst:670
msgid "Scheduling From Other Threads"
msgstr "Планування з інших потоків"

#: ../../library/asyncio-task.rst:674
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr "Надішліть співпрограму в заданий цикл подій. Ниткобезпечний."

#: ../../library/asyncio-task.rst:676
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Поверніть :class:`concurrent.futures.Future`, щоб дочекатися результату від "
"іншого потоку ОС."

#: ../../library/asyncio-task.rst:679
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Цю функцію призначено для виклику з потоку ОС, відмінного від того, у якому "
"виконується цикл подій. Приклад::"

#: ../../library/asyncio-task.rst:691
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Якщо в співпрограмі виникає виняток, буде повідомлено про повернутий Future. "
"Його також можна використовувати для скасування завдання в циклі подій::"

#: ../../library/asyncio-task.rst:705
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Перегляньте розділ :ref:`паралелізм і багатопотоковість <asyncio-"
"multithreading>` документації."

#: ../../library/asyncio-task.rst:708
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"На відміну від інших асинхронних функцій, ця функція вимагає явної передачі "
"аргументу *loop*."

#: ../../library/asyncio-task.rst:715
msgid "Introspection"
msgstr "самоаналіз"

#: ../../library/asyncio-task.rst:720
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Повертає поточний екземпляр :class:`Task` або ``None``, якщо жодне завдання "
"не виконується."

#: ../../library/asyncio-task.rst:723
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Якщо *loop* має значення ``None`` :func:`get_running_loop` використовується "
"для отримання поточного циклу."

#: ../../library/asyncio-task.rst:731
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Повертає набір ще не завершених об’єктів :class:`Task`, які виконуються "
"циклом."

#: ../../library/asyncio-task.rst:734
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Якщо *loop* має значення ``None``, :func:`get_running_loop` використовується "
"для отримання поточного циклу."

#: ../../library/asyncio-task.rst:741
msgid "Task Object"
msgstr "Об'єкт завдання"

#: ../../library/asyncio-task.rst:745
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Об’єкт :class:`подібний до майбутнього <Future>`, який запускає :ref:"
"`сопрограму Python <coroutine>`. Небезпечно для потоків."

#: ../../library/asyncio-task.rst:748
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Завдання використовуються для виконання співпрограм у циклах подій. Якщо "
"співпрограма очікує на Future, Завдання призупиняє виконання співпрограми та "
"чекає завершення Future. Коли Future *done*, виконання загорнутої "
"співпрограми відновлюється."

#: ../../library/asyncio-task.rst:754
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Цикли подій використовують кооперативне планування: цикл подій виконує одне "
"завдання за раз. Поки Завдання очікує завершення Майбутнього, цикл подій "
"запускає інші Завдання, зворотні виклики або виконує операції введення-"
"виведення."

#: ../../library/asyncio-task.rst:759
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"Використовуйте функцію високого рівня :func:`asyncio.create_task` для "
"створення завдань або функції низького рівня :meth:`loop.create_task` або :"
"func:`ensure_future`. Не рекомендується створювати завдання вручну."

#: ../../library/asyncio-task.rst:764
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"Щоб скасувати запущене завдання, використовуйте метод :meth:`cancel`. Його "
"виклик призведе до того, що завдання створить виняток :exc:`CancelledError` "
"у загорнутій співпрограмі. Якщо співпрограма очікує на об’єкті Future під "
"час скасування, об’єкт Future буде скасовано."

#: ../../library/asyncio-task.rst:769
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` можна використовувати, щоб перевірити, чи було скасовано "
"завдання. Метод повертає ``True``, якщо загорнута співпрограма не придушила "
"виняток :exc:`CancelledError` і була фактично скасована."

#: ../../library/asyncio-task.rst:774
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` успадковує від :class:`Future` усі його API, крім :"
"meth:`Future.set_result` і :meth:`Future.set_exception`."

#: ../../library/asyncio-task.rst:778
msgid ""
"Tasks support the :mod:`contextvars` module.  When a Task is created it "
"copies the current context and later runs its coroutine in the copied "
"context."
msgstr ""
"Завдання підтримують модуль :mod:`contextvars`. Коли завдання створюється, "
"воно копіює поточний контекст і пізніше виконує свою співпрограму в "
"скопійованому контексті."

#: ../../library/asyncio-task.rst:782
msgid "Added support for the :mod:`contextvars` module."
msgstr "Додано підтримку модуля :mod:`contextvars`."

#: ../../library/asyncio-task.rst:793
msgid "Request the Task to be cancelled."
msgstr "Вимагайте скасування Завдання."

#: ../../library/asyncio-task.rst:795
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""
"Це організовує виняток :exc:`CancelledError`, який буде створено в "
"загорнутій співпрограмі в наступному циклі циклу подій."

#: ../../library/asyncio-task.rst:798
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged."
msgstr ""
"Тоді співпрограма має шанс очистити або навіть відхилити запит, придушивши "
"виняток за допомогою блоку :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally`. Таким чином, на відміну від :meth:"
"`Future.cancel`, :meth:`Task.cancel` не гарантує, що Завдання буде "
"скасовано, хоча повне придушення скасування не є поширеним явищем і активно "
"не рекомендується."

#: ../../library/asyncio-task.rst:806
msgid "Added the ``msg`` parameter."
msgstr ""

#: ../../library/asyncio-task.rst:811
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"Наступний приклад ілюструє, як співпрограми можуть перехопити запит на "
"скасування:"

#: ../../library/asyncio-task.rst:850
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Повертає ``True``, якщо завдання *скасовано*."

#: ../../library/asyncio-task.rst:852
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"Завдання *скасовується*, коли запит на скасування надійшов за допомогою :"
"meth:`cancel`, а загорнута співпрограма поширила виняткову ситуацію :exc:"
"`CancelledError`, яка виникла в ній."

#: ../../library/asyncio-task.rst:858
msgid "Return ``True`` if the Task is *done*."
msgstr "Повертає ``True``, якщо завдання *виконано*."

#: ../../library/asyncio-task.rst:860
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Завдання вважається *виконаним*, коли загорнута співпрограма або повернула "
"значення, викликала виняток, або завдання було скасовано."

#: ../../library/asyncio-task.rst:865
msgid "Return the result of the Task."
msgstr "Повернути результат Завдання."

#: ../../library/asyncio-task.rst:867
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Якщо завдання *виконано*, повертається результат загорнутої співпрограми "
"(або якщо співпрограма викликала виняток, цей виняток викликається повторно)."

#: ../../library/asyncio-task.rst:871 ../../library/asyncio-task.rst:885
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Якщо завдання було *скасовано*, цей метод викликає виняток :exc:"
"`CancelledError`."

#: ../../library/asyncio-task.rst:874
msgid ""
"If the Task's result isn't yet available, this method raises a :exc:"
"`InvalidStateError` exception."
msgstr ""
"Якщо результат завдання ще не доступний, цей метод викликає виняток :exc:"
"`InvalidStateError`."

#: ../../library/asyncio-task.rst:879
msgid "Return the exception of the Task."
msgstr "Повернути виняток Завдання."

#: ../../library/asyncio-task.rst:881
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Якщо загорнута співпрограма викликала виняток, цей виняток повертається. "
"Якщо загорнута співпрограма повертає нормальний результат, цей метод "
"повертає ``None``."

#: ../../library/asyncio-task.rst:888
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Якщо завдання ще не *виконано*, цей метод викликає виняток :exc:"
"`InvalidStateError`."

#: ../../library/asyncio-task.rst:893
msgid "Add a callback to be run when the Task is *done*."
msgstr ""
"Додайте зворотний виклик, який буде запущено, коли Завдання *виконано*."

#: ../../library/asyncio-task.rst:895 ../../library/asyncio-task.rst:904
msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Цей метод слід використовувати лише в низькорівневому коді на основі "
"зворотного виклику."

#: ../../library/asyncio-task.rst:897
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Перегляньте документацію :meth:`Future.add_done_callback` для отримання "
"додаткової інформації."

#: ../../library/asyncio-task.rst:902
msgid "Remove *callback* from the callbacks list."
msgstr "Видалити *callback* зі списку зворотних викликів."

#: ../../library/asyncio-task.rst:906
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Перегляньте документацію :meth:`Future.remove_done_callback` для отримання "
"додаткової інформації."

#: ../../library/asyncio-task.rst:911
msgid "Return the list of stack frames for this Task."
msgstr "Повернути список фреймів стека для цього завдання."

#: ../../library/asyncio-task.rst:913
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Якщо загорнуту співпрограму не виконано, це повертає стек, де він був "
"призупинений. Якщо співпрограма завершилася успішно або була скасована, "
"повертається порожній список. Якщо співпрограму було припинено через "
"виняток, повертається список кадрів трасування."

#: ../../library/asyncio-task.rst:919
msgid "The frames are always ordered from oldest to newest."
msgstr "Рамки завжди впорядковуються від найстаріших до найновіших."

#: ../../library/asyncio-task.rst:921
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Для призупиненої співпрограми повертається лише один кадр стека."

#: ../../library/asyncio-task.rst:923
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"Необов'язковий аргумент *limit* встановлює максимальну кількість кадрів для "
"повернення; за замовчуванням повертаються всі доступні кадри. Порядок "
"поверненого списку відрізняється залежно від того, повертається стек чи "
"трасування: повертаються найновіші кадри стеку, але повертаються найстаріші "
"кадри трасування. (Це відповідає поведінці модуля відстеження.)"

#: ../../library/asyncio-task.rst:932
msgid "Print the stack or traceback for this Task."
msgstr "Роздрукуйте стек або відстеження для цього завдання."

#: ../../library/asyncio-task.rst:934
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Це створює вихідні дані, подібні до результатів модуля трасування для "
"кадрів, отриманих :meth:`get_stack`."

#: ../../library/asyncio-task.rst:937
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "Аргумент *limit* передається безпосередньо в :meth:`get_stack`."

#: ../../library/asyncio-task.rst:939
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stderr`."
msgstr ""
"Аргумент *file* — це потік введення/виведення, до якого записується вихід; "
"за замовчуванням вихід записується в :data:`sys.stderr`."

#: ../../library/asyncio-task.rst:944
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Повертає об’єкт співпрограми, обгорнутий :class:`Task`."

#: ../../library/asyncio-task.rst:950
msgid "Return the name of the Task."
msgstr "Повернути назву завдання."

#: ../../library/asyncio-task.rst:952
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Якщо Завданню не було явно призначено ім’я, реалізація асинхронного Завдання "
"за замовчуванням генерує ім’я за замовчуванням під час створення екземпляра."

#: ../../library/asyncio-task.rst:960
msgid "Set the name of the Task."
msgstr "Встановіть назву завдання."

#: ../../library/asyncio-task.rst:962
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"Аргументом *value* може бути будь-який об’єкт, який потім перетворюється на "
"рядок."

#: ../../library/asyncio-task.rst:965
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"У реалізації Task за замовчуванням ім’я буде видно у виводі :func:`repr` "
"об’єкта task."

#: ../../library/asyncio-task.rst:974
msgid "Generator-based Coroutines"
msgstr ""

#: ../../library/asyncio-task.rst:978
msgid ""
"Support for generator-based coroutines is **deprecated** and is removed in "
"Python 3.11."
msgstr ""

#: ../../library/asyncio-task.rst:981
msgid ""
"Generator-based coroutines predate async/await syntax.  They are Python "
"generators that use ``yield from`` expressions to await on Futures and other "
"coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:985
msgid ""
"Generator-based coroutines should be decorated with :func:`@asyncio."
"coroutine <asyncio.coroutine>`, although this is not enforced."
msgstr ""

#: ../../library/asyncio-task.rst:992
msgid "Decorator to mark generator-based coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:994
msgid ""
"This decorator enables legacy generator-based coroutines to be compatible "
"with async/await code::"
msgstr ""

#: ../../library/asyncio-task.rst:1004
msgid "This decorator should not be used for :keyword:`async def` coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:1009
msgid "Use :keyword:`async def` instead."
msgstr ""

#: ../../library/asyncio-task.rst:1013
msgid "Return ``True`` if *obj* is a :ref:`coroutine object <coroutine>`."
msgstr ""

#: ../../library/asyncio-task.rst:1015
msgid ""
"This method is different from :func:`inspect.iscoroutine` because it returns "
"``True`` for generator-based coroutines."
msgstr ""

#: ../../library/asyncio-task.rst:1020
msgid "Return ``True`` if *func* is a :ref:`coroutine function <coroutine>`."
msgstr ""

#: ../../library/asyncio-task.rst:1023
msgid ""
"This method is different from :func:`inspect.iscoroutinefunction` because it "
"returns ``True`` for generator-based coroutine functions decorated with :"
"func:`@coroutine <coroutine>`."
msgstr ""
