# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-20 14:41+0000\n"
"PO-Revision-Date: 2023-05-24 02:19+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Вбудовані типи"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"У наступних розділах описуються стандартні типи, вбудовані в інтерпретатор."

#: ../../library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"Основними вбудованими типами є числа, послідовності, відображення, класи, "
"екземпляри та винятки."

#: ../../library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Деякі класи колекцій є змінними. Методи, які додають, віднімають або "
"переставляють свої члени на місці, і не повертають конкретний елемент, "
"ніколи не повертають сам екземпляр колекції, але ``Жодного``."

#: ../../library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"Деякі операції підтримуються кількома типами об'єктів; зокрема, практично "
"всі об’єкти можна порівняти на рівність, перевірити на значення істинності "
"та перетворити на рядок (за допомогою функції :func:`repr` або трохи іншої "
"функції :func:`str`). Остання функція неявно використовується, коли об’єкт "
"записується функцією :func:`print`."

#: ../../library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Перевірка правдивості"

#: ../../library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Будь-який об’єкт можна перевірити на значення істинності, для використання в "
"умовах :keyword:`if` або :keyword:`while` або як операнд логічних операцій, "
"наведених нижче."

#: ../../library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`~object.__bool__` method that returns ``False`` or a :meth:`__len__` "
"method that returns zero, when called with the object. [1]_  Here are most "
"of the built-in objects considered false:"
msgstr ""

#: ../../library/stdtypes.rst:55
msgid "constants defined to be false: ``None`` and ``False``"
msgstr ""

#: ../../library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"нуль будь-якого числового типу: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"

#: ../../library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"порожні послідовності та колекції: ``''``, ``()``, ``[]``, ``{}``, "
"``set()``, ``range(0)``"

#: ../../library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Операції та вбудовані функції, які мають логічний результат, завжди "
"повертають ``0`` або ``False`` для false і ``1`` або ``True`` для true, якщо "
"не вказано інше. (Важливий виняток: логічні операції \"або\" та \"і\" завжди "
"повертають один із своїх операндів.)"

#: ../../library/stdtypes.rst:78
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr "Логічні операції --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: ../../library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "Це логічні операції, упорядковані за зростанням пріоритету:"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:143
#: ../../library/stdtypes.rst:275 ../../library/stdtypes.rst:365
#: ../../library/stdtypes.rst:415 ../../library/stdtypes.rst:924
#: ../../library/stdtypes.rst:1129
msgid "Operation"
msgstr "Операція"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:275
#: ../../library/stdtypes.rst:365 ../../library/stdtypes.rst:415
#: ../../library/stdtypes.rst:924 ../../library/stdtypes.rst:1129
msgid "Result"
msgstr "Результат"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:275
#: ../../library/stdtypes.rst:415 ../../library/stdtypes.rst:924
#: ../../library/stdtypes.rst:1129 ../../library/stdtypes.rst:2374
#: ../../library/stdtypes.rst:3592
msgid "Notes"
msgstr "Примітки"

#: ../../library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x або y``"

#: ../../library/stdtypes.rst:87
msgid "if *x* is true, then *x*, else *y*"
msgstr ""

#: ../../library/stdtypes.rst:87 ../../library/stdtypes.rst:926
#: ../../library/stdtypes.rst:929 ../../library/stdtypes.rst:1140
#: ../../library/stdtypes.rst:2380 ../../library/stdtypes.rst:3598
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x і y``"

#: ../../library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "якщо *x* false, тоді *x*, інакше *y*"

#: ../../library/stdtypes.rst:90 ../../library/stdtypes.rst:288
#: ../../library/stdtypes.rst:308 ../../library/stdtypes.rst:1168
#: ../../library/stdtypes.rst:2384 ../../library/stdtypes.rst:2386
#: ../../library/stdtypes.rst:3602 ../../library/stdtypes.rst:3604
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:93
msgid "``not x``"
msgstr "``не x``"

#: ../../library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "якщо *x* false, тоді ``True``, інакше ``False``"

#: ../../library/stdtypes.rst:93 ../../library/stdtypes.rst:938
#: ../../library/stdtypes.rst:1171 ../../library/stdtypes.rst:2388
#: ../../library/stdtypes.rst:2390 ../../library/stdtypes.rst:2392
#: ../../library/stdtypes.rst:2394 ../../library/stdtypes.rst:3606
#: ../../library/stdtypes.rst:3608 ../../library/stdtypes.rst:3610
#: ../../library/stdtypes.rst:3612
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:102 ../../library/stdtypes.rst:319
#: ../../library/stdtypes.rst:433 ../../library/stdtypes.rst:975
#: ../../library/stdtypes.rst:1179 ../../library/stdtypes.rst:2420
#: ../../library/stdtypes.rst:3642
msgid "Notes:"
msgstr "Примітки:"

#: ../../library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Це оператор короткого замикання, тому він обчислює лише другий аргумент, "
"якщо перший невірний."

#: ../../library/stdtypes.rst:109
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Це оператор короткого замикання, тому він обчислює лише другий аргумент, "
"якщо перший істинний."

#: ../../library/stdtypes.rst:113
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` має нижчий пріоритет, ніж не-булеві оператори, тому ``not a == b`` "
"інтерпретується як ``not (a == b)``, а ``a == not b`` є синтаксичною "
"помилкою."

#: ../../library/stdtypes.rst:120
msgid "Comparisons"
msgstr "Порівняння"

#: ../../library/stdtypes.rst:134
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"У Python є вісім операцій порівняння. Усі вони мають однаковий пріоритет "
"(вищий, ніж у логічних операцій). Порівняння можна зв'язувати довільно; "
"наприклад, ``x < y <= z`` еквівалентно ``x < y і y <= z``, за винятком того, "
"що *y* обчислюється лише один раз (але в обох випадках *z* не обчислюється в "
"все, коли ``x < y`` виявляється хибним)."

#: ../../library/stdtypes.rst:140
msgid "This table summarizes the comparison operations:"
msgstr "Ця таблиця підсумовує операції порівняння:"

#: ../../library/stdtypes.rst:143 ../../library/stdtypes.rst:2351
#: ../../library/stdtypes.rst:2374 ../../library/stdtypes.rst:3569
#: ../../library/stdtypes.rst:3592
msgid "Meaning"
msgstr "Значення"

#: ../../library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:145
msgid "strictly less than"
msgstr "строго менше ніж"

#: ../../library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:147
msgid "less than or equal"
msgstr "менше або дорівнює"

#: ../../library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "строго більше ніж"

#: ../../library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "більше або дорівнює"

#: ../../library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:153
msgid "equal"
msgstr "рівні"

#: ../../library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:155
msgid "not equal"
msgstr "не рівні"

#: ../../library/stdtypes.rst:157
msgid "``is``"
msgstr "``є``"

#: ../../library/stdtypes.rst:157
msgid "object identity"
msgstr "ідентичність об'єкта"

#: ../../library/stdtypes.rst:159
msgid "``is not``"
msgstr "``не``"

#: ../../library/stdtypes.rst:159
msgid "negated object identity"
msgstr "заперечена ідентичність об'єкта"

#: ../../library/stdtypes.rst:166
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"Об’єкти різних типів, за винятком різних числових типів, ніколи не "
"порівнюються. Оператор ``==`` завжди визначений, але для деяких типів "
"об’єктів (наприклад, об’єктів класу) еквівалентний :keyword:`is`. Оператори "
"``<``, ``<=``, ``>`` і ``>=`` визначені лише там, де вони мають сенс; "
"наприклад, вони викликають виняток :exc:`TypeError`, коли один із аргументів "
"є комплексним числом."

#: ../../library/stdtypes.rst:180
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr ""
"Неідентичні екземпляри класу зазвичай порівнюються як нерівні, якщо клас не "
"визначає метод :meth:`~object.__eq__`."

#: ../../library/stdtypes.rst:183
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object."
"__gt__`, and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :"
"meth:`~object.__eq__` are sufficient, if you want the conventional meanings "
"of the comparison operators)."
msgstr ""
"Екземпляри класу не можуть бути впорядковані відносно інших екземплярів того "
"самого класу або інших типів об’єктів, якщо клас не визначає достатньо "
"методів :meth:`~object.__lt__`, :meth:`~object.__le__` , :meth:`~object."
"__gt__` і :meth:`~object.__ge__` (загалом, :meth:`~object.__lt__` і :meth:"
"`~object.__eq__` достатньо, якщо ви хочете звичайні значення операторів "
"порівняння)."

#: ../../library/stdtypes.rst:190
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"Поведінку операторів :keyword:`is` і :keyword:`is not` не можна налаштувати; "
"також вони можуть бути застосовані до будь-яких двох об’єктів і ніколи не "
"викликають винятків."

#: ../../library/stdtypes.rst:198
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`__contains__` method."
msgstr ""
"Ще дві операції з таким же синтаксичним пріоритетом, :keyword:`in` і :"
"keyword:`not in`, підтримуються типами, які є :term:`iterable` або "
"реалізують метод :meth:`__contains__`."

#: ../../library/stdtypes.rst:205
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Числові типи --- :class:`int`, :class:`float`, :class:`complex`"

#: ../../library/stdtypes.rst:215
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:expr:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""

#: ../../library/stdtypes.rst:237
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"Числа створюються за допомогою числових літералів або як результат "
"вбудованих функцій і операторів. Неприкрашені цілі літерали (включаючи "
"шістнадцяткові, вісімкові та двійкові числа) дають цілі числа. Числові "
"літерали, що містять десяткову кому або знак експоненти, дають числа з "
"плаваючою комою. Додавання ``'j'`` або ``'J''`` до числового літералу дає "
"уявне число (комплексне число з нульовою дійсною частиною), яке ви можете "
"додати до цілого числа або числа з плаваючою точкою, щоб отримати комплексне "
"число з дійсним і уявні частини."

#: ../../library/stdtypes.rst:262
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex. A comparison between numbers "
"of different types behaves as though the exact values of those numbers were "
"being compared. [2]_"
msgstr ""
"Python повністю підтримує змішану арифметику: коли двійковий арифметичний "
"оператор має операнди різних числових типів, операнд із \"вужчим\" типом "
"розширюється до операнда іншого типу, де ціле число вужче за число з "
"плаваючою крапкою, яке є вужчим за комплексний. Порівняння між числами "
"різних типів поводиться так, ніби порівнюються точні значення цих чисел. [2]_"

#: ../../library/stdtypes.rst:268
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
"Конструктори :func:`int`, :func:`float` і :func:`complex` можна "
"використовувати для отримання чисел певного типу."

#: ../../library/stdtypes.rst:271
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"Усі числові типи (крім комплексних) підтримують наступні операції "
"(пріоритети операцій див. :ref:`operator-summary`):"

#: ../../library/stdtypes.rst:275
msgid "Full documentation"
msgstr "Повна документація"

#: ../../library/stdtypes.rst:277
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:277
msgid "sum of *x* and *y*"
msgstr "сума *x* і *y*"

#: ../../library/stdtypes.rst:279
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:279
msgid "difference of *x* and *y*"
msgstr "різниця *x* і *y*"

#: ../../library/stdtypes.rst:281
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:281
msgid "product of *x* and *y*"
msgstr "добуток *x* і *y*"

#: ../../library/stdtypes.rst:283
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:283
msgid "quotient of *x* and *y*"
msgstr "частка *x* і *y*"

#: ../../library/stdtypes.rst:285
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:285
msgid "floored quotient of *x* and *y*"
msgstr "частка *x* і *y*"

#: ../../library/stdtypes.rst:285
msgid "\\(1)\\(2)"
msgstr ""

#: ../../library/stdtypes.rst:288
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:288
msgid "remainder of ``x / y``"
msgstr "залишок ``x / y``"

#: ../../library/stdtypes.rst:290
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:290
msgid "*x* negated"
msgstr "*x* заперечено"

#: ../../library/stdtypes.rst:292
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:292
msgid "*x* unchanged"
msgstr "*x* без змін"

#: ../../library/stdtypes.rst:294
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:294
msgid "absolute value or magnitude of *x*"
msgstr "абсолютне значення або величина *x*"

#: ../../library/stdtypes.rst:294
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/stdtypes.rst:297
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:297
msgid "*x* converted to integer"
msgstr "*x* перетворено на ціле число"

#: ../../library/stdtypes.rst:297
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../../library/stdtypes.rst:297
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/stdtypes.rst:299
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:299
msgid "*x* converted to floating point"
msgstr "*x* перетворено на число з плаваючою комою"

#: ../../library/stdtypes.rst:299
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../../library/stdtypes.rst:299
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/stdtypes.rst:301
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../../library/stdtypes.rst:301
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"комплексне число з дійсною частиною *re*, уявною частиною *im*. *im* за "
"замовчуванням дорівнює нулю."

#: ../../library/stdtypes.rst:301 ../../library/stdtypes.rst:1161
#: ../../library/stdtypes.rst:2382 ../../library/stdtypes.rst:3629
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:301
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/stdtypes.rst:305
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:305
msgid "conjugate of the complex number *c*"
msgstr "спряжене комплексне число *c*"

#: ../../library/stdtypes.rst:308
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:308
msgid "the pair ``(x // y, x % y)``"
msgstr "пара ``(x // y, x % y)``"

#: ../../library/stdtypes.rst:308
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/stdtypes.rst:310
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:310 ../../library/stdtypes.rst:312
msgid "*x* to the power *y*"
msgstr "*x* у степені *y*"

#: ../../library/stdtypes.rst:310 ../../library/stdtypes.rst:312
#: ../../library/stdtypes.rst:1150 ../../library/stdtypes.rst:1153
#: ../../library/stdtypes.rst:2407 ../../library/stdtypes.rst:2410
#: ../../library/stdtypes.rst:2413 ../../library/stdtypes.rst:3625
#: ../../library/stdtypes.rst:3632
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:310
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/stdtypes.rst:312
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:322
msgid ""
"Also referred to as integer division.  For operands of type :class:`int`, "
"the result has type :class:`int`.  For operands of type :class:`float`, the "
"result has type :class:`float`.  In general, the result is a whole integer, "
"though the result's type is not necessarily :class:`int`.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""

#: ../../library/stdtypes.rst:330
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Не для комплексних чисел. Натомість конвертуйте у числа з плаваючою точкою "
"за допомогою :func:`abs`, якщо це доречно."

#: ../../library/stdtypes.rst:341
msgid ""
"Conversion from :class:`float` to :class:`int` truncates, discarding the "
"fractional part. See functions :func:`math.floor` and :func:`math.ceil` for "
"alternative conversions."
msgstr ""

#: ../../library/stdtypes.rst:346
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"float також приймає рядки \"nan\" і \"inf\" з необов'язковим префіксом \"+\" "
"або \"-\" для Not a Number (NaN) і додатною або від'ємною нескінченністю."

#: ../../library/stdtypes.rst:350
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python визначає ``pow(0, 0)`` і ``0 ** 0`` як ``1``, як це прийнято для мов "
"програмування."

#: ../../library/stdtypes.rst:354
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"Прийнятні числові літерали включають цифри від ``0`` до ``9`` або будь-який "
"еквівалент Unicode (кодові точки з властивістю ``Nd``)."

#: ../../library/stdtypes.rst:357
msgid ""
"See https://www.unicode.org/Public/14.0.0/ucd/extracted/DerivedNumericType."
"txt for a complete list of code points with the ``Nd`` property."
msgstr ""

#: ../../library/stdtypes.rst:361
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Усі типи :class:`numbers.Real` (:class:`int` і :class:`float`) також містять "
"такі операції:"

#: ../../library/stdtypes.rst:367
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:367
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* скорочено до :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:370
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:370
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* округлено до *n* цифр, округлення половини до парного числа. Якщо *n* "
"опущено, за умовчанням дорівнює 0."

#: ../../library/stdtypes.rst:374
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:374
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "найбільший :class:`~numbers.Integral` <= *x*"

#: ../../library/stdtypes.rst:377
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:377
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "найменший :class:`~numbers.Integral` >= *x*"

#: ../../library/stdtypes.rst:381
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"Для отримання додаткових числових операцій перегляньте модулі :mod:`math` і :"
"mod:`cmath`."

#: ../../library/stdtypes.rst:390
msgid "Bitwise Operations on Integer Types"
msgstr "Побітові операції над цілими типами"

#: ../../library/stdtypes.rst:404
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"Побітові операції мають сенс лише для цілих чисел. Результат порозрядних "
"операцій обчислюється так, ніби виконується в доповненні до двох із "
"нескінченною кількістю знакових бітів."

#: ../../library/stdtypes.rst:408
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"Пріоритети двійкових порозрядних операцій нижчі, ніж числових операцій, і "
"вищі, ніж порівняння; унарна операція ``~`` має той самий пріоритет, що й "
"інші унарні числові операції (``+`` і ``-``)."

#: ../../library/stdtypes.rst:412
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"У цій таблиці наведено порозрядні операції, відсортовані за зростанням "
"пріоритету:"

#: ../../library/stdtypes.rst:417
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:417
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "порозрядно :dfn:`or` *x* і *y*"

#: ../../library/stdtypes.rst:417 ../../library/stdtypes.rst:420
#: ../../library/stdtypes.rst:423 ../../library/stdtypes.rst:1174
#: ../../library/stdtypes.rst:2396 ../../library/stdtypes.rst:2400
#: ../../library/stdtypes.rst:3614 ../../library/stdtypes.rst:3618
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:420
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:420
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "порозрядно :dfn:`exclusive or` *x* та *y*"

#: ../../library/stdtypes.rst:423
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:423
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "порозрядно :dfn:`and` *x* і *y*"

#: ../../library/stdtypes.rst:426
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:426
msgid "*x* shifted left by *n* bits"
msgstr "*x* зміщено вліво на *n* бітів"

#: ../../library/stdtypes.rst:426
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:428
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:428
msgid "*x* shifted right by *n* bits"
msgstr "*x* зміщено праворуч на *n* бітів"

#: ../../library/stdtypes.rst:428
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:430
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:430
msgid "the bits of *x* inverted"
msgstr "біти *x* інвертовані"

#: ../../library/stdtypes.rst:436
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr "Підрахунок від’ємного зсуву є незаконним і викликає :exc:`ValueError`."

#: ../../library/stdtypes.rst:439
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr "Зсув вліво на *n* бітів еквівалентний множенню на ``pow(2, n)``."

#: ../../library/stdtypes.rst:442
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr ""
"Зсув праворуч на *n* бітів еквівалентний діленню підлоги за допомогою "
"``pow(2, n)``."

#: ../../library/stdtypes.rst:445
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"Виконання цих обчислень із принаймні одним додатковим бітом розширення знака "
"в поданні скінченних двох доповнень (робоча бітова ширина ``1 + max(x."
"bit_length(), y.bit_length())`` або більше) є достатньою для отримати той "
"самий результат, ніби існує нескінченна кількість знакових бітів."

#: ../../library/stdtypes.rst:452
msgid "Additional Methods on Integer Types"
msgstr "Додаткові методи для цілих типів"

#: ../../library/stdtypes.rst:454
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"Тип int реалізує :class:`numbers.Integral` :term:`abstract base class`. Крім "
"того, він надає ще кілька методів:"

#: ../../library/stdtypes.rst:459
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Повертає кількість бітів, необхідних для представлення цілого числа в "
"двійковій системі, за винятком знака та нулів на початку::"

#: ../../library/stdtypes.rst:468
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"Точніше, якщо ``x`` відмінне від нуля, то ``x.bit_length()`` є унікальним "
"натуральним числом ``k`` таким, що ``2**(k-1) <= abs(x) < 2**k``. "
"Аналогічно, коли ``abs(x)`` достатньо малий, щоб мати правильно округлений "
"логарифм, тоді ``k = 1 + int(log(abs(x), 2))``. Якщо ``x`` дорівнює нулю, то "
"``x.bit_length()`` повертає ``0``."

#: ../../library/stdtypes.rst:474 ../../library/stdtypes.rst:497
#: ../../library/stdtypes.rst:542 ../../library/stdtypes.rst:586
msgid "Equivalent to::"
msgstr "Дорівнює::"

#: ../../library/stdtypes.rst:485
msgid ""
"Return the number of ones in the binary representation of the absolute value "
"of the integer. This is also known as the population count. Example::"
msgstr ""
"Повертає кількість одиниць у двійковому представленні абсолютного значення "
"цілого числа. Це також відомо як підрахунок населення. Приклад::"

#: ../../library/stdtypes.rst:506
msgid "Return an array of bytes representing an integer."
msgstr "Повертає масив байтів, що представляє ціле число."

#: ../../library/stdtypes.rst:518
msgid ""
"The integer is represented using *length* bytes, and defaults to 1.  An :exc:"
"`OverflowError` is raised if the integer is not representable with the given "
"number of bytes."
msgstr ""

#: ../../library/stdtypes.rst:522
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte array."
msgstr ""

#: ../../library/stdtypes.rst:528
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"Аргумент *signed* визначає, чи використовується доповнення до двох для "
"представлення цілого числа. Якщо *signed* має значення ``False`` і вказано "
"від’ємне ціле число, виникає :exc:`OverflowError`. Значенням за "
"замовчуванням для *signed* є ``False``."

#: ../../library/stdtypes.rst:533
msgid ""
"The default values can be used to conveniently turn an integer into a single "
"byte object::"
msgstr ""

#: ../../library/stdtypes.rst:539
msgid ""
"However, when using the default arguments, don't try to convert a value "
"greater than 255 or you'll get an :exc:`OverflowError`."
msgstr ""

#: ../../library/stdtypes.rst:555
msgid "Added default argument values for ``length`` and ``byteorder``."
msgstr ""

#: ../../library/stdtypes.rst:560
msgid "Return the integer represented by the given array of bytes."
msgstr "Повертає ціле число, представлене заданим масивом байтів."

#: ../../library/stdtypes.rst:573
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"Аргумент *bytes* має бути або :term:`bytes-like object`, або ітерованим, що "
"створює байти."

#: ../../library/stdtypes.rst:576
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte "
"array.  To request the native byte order of the host system, use :data:`sys."
"byteorder` as the byte order value."
msgstr ""

#: ../../library/stdtypes.rst:583
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"Аргумент *signed* вказує, чи використовується доповнення до двох для "
"представлення цілого числа."

#: ../../library/stdtypes.rst:603
msgid "Added default argument value for ``byteorder``."
msgstr ""

#: ../../library/stdtypes.rst:608
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"integer and with a positive denominator. The integer ratio of integers "
"(whole numbers) is always the integer as the numerator and ``1`` as the "
"denominator."
msgstr ""

#: ../../library/stdtypes.rst:616
msgid "Additional Methods on Float"
msgstr "Додаткові методи для Float"

#: ../../library/stdtypes.rst:618
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"Тип float реалізує :class:`numbers.Real` :term:`abstract base class`. float "
"також має такі додаткові методи."

#: ../../library/stdtypes.rst:623
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""

#: ../../library/stdtypes.rst:630
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Повертає ``True``, якщо екземпляр float є кінцевим із цілим значенням, і "
"``False`` інакше::"

#: ../../library/stdtypes.rst:638
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Два методи підтримують перетворення до та з шістнадцяткових рядків. Оскільки "
"числа з плаваючою точкою Python зберігаються усередині як двійкові числа, "
"перетворення числа з плаваючою точкою в *десятковий* рядок або з нього "
"зазвичай включає невелику помилку округлення. Навпаки, шістнадцяткові рядки "
"дозволяють точне представлення та специфікацію чисел з плаваючою комою. Це "
"може бути корисним під час налагодження та чисельної роботи."

#: ../../library/stdtypes.rst:649
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Повертає представлення числа з плаваючою комою як шістнадцятковий рядок. Для "
"скінченних чисел з плаваючою комою це представлення завжди включатиме ``0x`` "
"на початку та ``p`` у кінці та експоненту."

#: ../../library/stdtypes.rst:657
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Метод класу для повернення числа з плаваючою точкою, представленого "
"шістнадцятковим рядком *s*. Рядок *s* може мати пробіли на початку та в "
"кінці."

#: ../../library/stdtypes.rst:662
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"Зауважте, що :meth:`float.hex` є методом екземпляра, тоді як :meth:`float."
"fromhex` є методом класу."

#: ../../library/stdtypes.rst:665
msgid "A hexadecimal string takes the form::"
msgstr "Шістнадцятковий рядок має вигляд::"

#: ../../library/stdtypes.rst:669
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"де необов’язковий ``знак`` може мати ``+`` або ``-``, ``ціле число`` і "
"``дріб`` є рядками шістнадцяткових цифр, а ``експонента`` є десятковим цілим "
"числом з необов’язковим переднім знаком. Регістр не є значущим, і в цілому "
"чи дробі має бути принаймні одна шістнадцяткова цифра. Цей синтаксис "
"подібний до синтаксису, зазначеного в розділі 6.4.4.2 стандарту C99, а також "
"до синтаксису, який використовується в Java 1.5 і далі. Зокрема, вихід :meth:"
"`float.hex` можна використовувати як шістнадцятковий літерал із плаваючою "
"комою в коді C або Java, а також шістнадцяткові рядки, створені символом "
"формату C ``%a`` або ``Double.toHexString`` Java приймаються :meth:`float."
"fromhex`."

#: ../../library/stdtypes.rst:682
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Зауважте, що експонента записується в десятковій, а не в шістнадцятковій "
"формі, і що вона дає ступінь 2, на який потрібно помножити коефіцієнт. "
"Наприклад, шістнадцятковий рядок ``0x3.a7p10`` представляє число з плаваючою "
"комою ``(3 + 10./16 + 7./16**2) * 2.0**10`` або ``3740.0``::"

#: ../../library/stdtypes.rst:692
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"Застосування зворотного перетворення до ``3740.0`` дає інший шістнадцятковий "
"рядок, що представляє те саме число::"

#: ../../library/stdtypes.rst:702
msgid "Hashing of numeric types"
msgstr "Хешування числових типів"

#: ../../library/stdtypes.rst:704
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types (including :"
"class:`int`, :class:`float`, :class:`decimal.Decimal` and :class:`fractions."
"Fraction`) Python's hash for numeric types is based on a single mathematical "
"function that's defined for any rational number, and hence applies to all "
"instances of :class:`int` and :class:`fractions.Fraction`, and all finite "
"instances of :class:`float` and :class:`decimal.Decimal`.  Essentially, this "
"function is given by reduction modulo ``P`` for a fixed prime ``P``.  The "
"value of ``P`` is made available to Python as the :attr:`modulus` attribute "
"of :data:`sys.hash_info`."
msgstr ""
"Для чисел ``x`` і ``y``, можливо, різних типів, є вимога, щоб ``hash(x) == "
"hash(y)`` щоразу, коли ``x == y`` (див. : документація методу :meth:`~object."
"__hash__` для отримання додаткової інформації). Для простоти впровадження та "
"ефективності для різноманітних числових типів (зокрема :class:`int`, :class:"
"`float`, :class:`decimal.Decimal` і :class:`fractions.Fraction`) хеш Python "
"для числових типи базується на одній математичній функції, яка визначена для "
"будь-якого раціонального числа, і, отже, застосовується до всіх екземплярів :"
"class:`int` і :class:`fractions.Fraction`, а також усіх кінцевих "
"екземплярів :class:`float` і :class:`decimal.Decimal`. По суті, ця функція "
"задана скороченням за модулем ``P`` для фіксованого простого ``P``. Значення "
"``P`` стає доступним для Python як атрибут :attr:`modulus` :data:`sys."
"hash_info`."

#: ../../library/stdtypes.rst:719
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"В даний час простим числом, яке використовується, є ``P = 2**31 - 1`` на "
"машинах з 32-розрядним C long і ``P = 2**61 - 1`` на машинах з 64-бітним C "
"long."

#: ../../library/stdtypes.rst:722
msgid "Here are the rules in detail:"
msgstr "Ось правила в деталях:"

#: ../../library/stdtypes.rst:724
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"Якщо ``x = m / n`` є невід’ємним раціональним числом, а ``n`` не ділиться на "
"``P``, визначте ``hash(x)`` як ``m * invmod(n, P`` ) % P``, де ``invmod(n, "
"P)`` дає обернене ``n`` за модулем ``P``."

#: ../../library/stdtypes.rst:728
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"Якщо ``x = m / n`` є невід’ємним раціональним числом, а ``n`` ділиться на "
"``P`` (але ``m`` не ділиться на ``m``), тоді ``n`` не має оберненого "
"модуля``P`` і правило вище не застосовується; у цьому випадку визначте "
"``hash(x)`` як постійне значення ``sys.hash_info.inf``."

#: ../../library/stdtypes.rst:733
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"Якщо ``x = m / n`` є від’ємним раціональним числом, визначте ``hash(x)`` як "
"``-hash(-x)``. Якщо отриманий хеш дорівнює ``-1``, замініть його ``-2``."

#: ../../library/stdtypes.rst:737
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr ""
"Конкретні значення ``sys.hash_info.inf`` і ``-sys.hash_info.inf`` "
"використовуються як хеш-значення для позитивної нескінченності або "
"негативної нескінченності (відповідно)."

#: ../../library/stdtypes.rst:741
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Для :class:`complex` числа ``z`` хеш-значення дійсної та уявної частин "
"поєднуються шляхом обчислення ``hash(z.real) + sys.hash_info.imag * hash(z."
"imag)``, зменшено за модулем ``2**sys.hash_info.width`` так, щоб він "
"знаходився в ``діапазоні (-2**(sys.hash_info.width - 1), 2**(sys.hash_info."
"width - 1) ))``. Знову ж таки, якщо результат ``-1``, він замінюється на "
"``-2``."

#: ../../library/stdtypes.rst:749
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"Щоб прояснити наведені вище правила, ось приклад коду Python, еквівалентного "
"вбудованому хешу, для обчислення хешу раціонального числа, :class:`float` "
"або :class:`complex`::"

#: ../../library/stdtypes.rst:804
msgid "Iterator Types"
msgstr "Типи ітераторів"

#: ../../library/stdtypes.rst:812
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python підтримує концепцію ітерації над контейнерами. Це реалізується за "
"допомогою двох різних методів; вони використовуються, щоб дозволити "
"визначеним користувачем класам підтримувати ітерацію. Послідовності, описані "
"нижче більш детально, завжди підтримують ітераційні методи."

#: ../../library/stdtypes.rst:817
msgid ""
"One method needs to be defined for container objects to provide :term:"
"`iterable` support:"
msgstr ""
"Потрібно визначити один метод для об’єктів-контейнерів, щоб забезпечити "
"підтримку :term:`iterable`:"

#: ../../library/stdtypes.rst:824
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"Повертає об’єкт :term:`iterator`. Об’єкт повинен підтримувати описаний нижче "
"протокол ітератора. Якщо контейнер підтримує різні типи ітерацій, можна "
"надати додаткові методи для спеціального запиту ітераторів для цих типів "
"ітерацій. (Прикладом об’єкта, що підтримує кілька форм ітерації, може бути "
"деревоподібна структура, яка підтримує обхід як у ширину, так і в глибину.) "
"Цей метод відповідає слоту :c:member:`~PyTypeObject.tp_iter` структури типу "
"для об’єктів Python в API Python/C."

#: ../../library/stdtypes.rst:833
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Самі об’єкти ітератора повинні підтримувати наступні два методи, які разом "
"утворюють :dfn:`iterator protocol`:"

#: ../../library/stdtypes.rst:839
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements.  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"Повертає сам об’єкт :term:`iterator`. Це потрібно, щоб дозволити "
"використовувати як контейнери, так і ітератори з операторами :keyword:`for` "
"і :keyword:`in`. Цей метод відповідає слоту :c:member:`~PyTypeObject."
"tp_iter` структури типу для об’єктів Python в API Python/C."

#: ../../library/stdtypes.rst:848
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to "
"the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
"Повертає наступний елемент із :term:`iterator`. Якщо більше елементів немає, "
"підніміть виняток :exc:`StopIteration`. Цей метод відповідає слоту :c:member:"
"`~PyTypeObject.tp_iternext` структури типу для об’єктів Python в API Python/"
"C."

#: ../../library/stdtypes.rst:853
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python визначає декілька об’єктів-ітераторів для підтримки ітерації "
"загальних і конкретних типів послідовностей, словників та інших більш "
"спеціалізованих форм. Конкретні типи не важливі за межами їхньої реалізації "
"протоколу ітератора."

#: ../../library/stdtypes.rst:858
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"Коли метод :meth:`~iterator.__next__` ітератора викликає :exc:"
"`StopIteration`, він повинен продовжувати робити це під час наступних "
"викликів. Реалізації, які не підкоряються цій властивості, вважаються "
"зламаними."

#: ../../library/stdtypes.rst:866
msgid "Generator Types"
msgstr "Типи генераторів"

#: ../../library/stdtypes.rst:868
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`~generator.__next__` methods. More information about generators can be "
"found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""
":term:`generator`\\s Python надають зручний спосіб реалізації протоколу "
"ітератора. Якщо метод :meth:`__iter__` об’єкта-контейнера реалізовано як "
"генератор, він автоматично повертатиме об’єкт-ітератор (технічно, об’єкт-"
"генератор), що надає методи :meth:`__iter__` і :meth:`~generator.__next__` . "
"Більше інформації про генератори можна знайти в :ref:`документації для "
"виразу yield <yieldexpr>`."

#: ../../library/stdtypes.rst:880
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "Типи послідовностей --- :class:`list`, :class:`tuple`, :class:`range`"

#: ../../library/stdtypes.rst:882
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Існує три основні типи послідовностей: списки, кортежі та об’єкти діапазону. "
"Додаткові типи послідовностей, призначені для обробки :ref:`бінарних даних "
"<binaryseq>` і :ref:`текстових рядків <textseq>`, описані у спеціальних "
"розділах."

#: ../../library/stdtypes.rst:891
msgid "Common Sequence Operations"
msgstr "Загальні операції послідовності"

#: ../../library/stdtypes.rst:895
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"Операції в наведеній нижче таблиці підтримують більшість типів "
"послідовностей, як змінних, так і незмінних. :class:`collections.abc."
"Sequence` ABC надається, щоб спростити правильну реалізацію цих операцій у "
"настроюваних типах послідовностей."

#: ../../library/stdtypes.rst:900
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"У цій таблиці наведено послідовність операцій, відсортованих за зростанням "
"пріоритету. У таблиці *s* і *t* — послідовності одного типу, *n*, *i*, *j* і "
"*k* — цілі числа, а *x* — довільний об’єкт, який відповідає будь-яким "
"обмеженням щодо типу та значення накладений *s*."

#: ../../library/stdtypes.rst:905
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"Операції ``in`` і ``not in`` мають ті самі пріоритети, що й операції "
"порівняння. Операції ``+`` (конкатенація) і ``*`` (повторення) мають той "
"самий пріоритет, що й відповідні числові операції. [3]_"

#: ../../library/stdtypes.rst:926
msgid "``x in s``"
msgstr "``x в s``"

#: ../../library/stdtypes.rst:926
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``True``, якщо елемент *s* дорівнює *x*, інакше ``False``"

#: ../../library/stdtypes.rst:929
msgid "``x not in s``"
msgstr "``x не в s``"

#: ../../library/stdtypes.rst:929
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False``, якщо елемент *s* дорівнює *x*, інакше ``True``"

#: ../../library/stdtypes.rst:932
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:932
msgid "the concatenation of *s* and *t*"
msgstr "конкатенація *s* і *t*"

#: ../../library/stdtypes.rst:932
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../library/stdtypes.rst:935
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` або ``n * s``"

#: ../../library/stdtypes.rst:935
msgid "equivalent to adding *s* to itself *n* times"
msgstr "еквівалентно додаванню *s* до самого себе *n* разів"

#: ../../library/stdtypes.rst:935
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../../library/stdtypes.rst:938
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:938
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*i*\\ ий елемент з *s*, джерело 0"

#: ../../library/stdtypes.rst:940
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:940
msgid "slice of *s* from *i* to *j*"
msgstr "фрагмент *s* від *i* до *j*"

#: ../../library/stdtypes.rst:940
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:942
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../../library/stdtypes.rst:942
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "фрагмент *s* від *i* до *j* з кроком *k*"

#: ../../library/stdtypes.rst:942
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:945
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/stdtypes.rst:945
msgid "length of *s*"
msgstr "довжина *s*"

#: ../../library/stdtypes.rst:947
msgid "``min(s)``"
msgstr "``хв(и)``"

#: ../../library/stdtypes.rst:947
msgid "smallest item of *s*"
msgstr "найменший елемент *s*"

#: ../../library/stdtypes.rst:949
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../library/stdtypes.rst:949
msgid "largest item of *s*"
msgstr "найбільший предмет *s*"

#: ../../library/stdtypes.rst:951
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../../library/stdtypes.rst:951
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"індекс першого входження *x* у *s* (за або після індексу *i* та перед "
"індексом *j*)"

#: ../../library/stdtypes.rst:951 ../../library/stdtypes.rst:3600
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/stdtypes.rst:955
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../library/stdtypes.rst:955
msgid "total number of occurrences of *x* in *s*"
msgstr "загальна кількість входжень *x* у *s*"

#: ../../library/stdtypes.rst:959
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"Послідовності одного типу також підтримують порівняння. Зокрема, кортежі та "
"списки порівнюються лексикографічно шляхом порівняння відповідних елементів. "
"Це означає, що для порівняння однаково кожен елемент повинен порівнюватись "
"рівно, а дві послідовності мають бути одного типу та мати однакову довжину. "
"(Для отримання повної інформації див. :ref:`comparisons` у мовній довідці.)"

#: ../../library/stdtypes.rst:969
msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index "
"drops below zero)."
msgstr ""
"Прямі та зворотні ітератори над змінними послідовностями отримують доступ до "
"значень за допомогою індексу. Цей індекс буде продовжувати рух вперед (або "
"назад), навіть якщо базова послідовність змінена. Ітератор завершується лише "
"тоді, коли зустрічається :exc:`IndexError` або :exc:`StopIteration` (або "
"коли індекс падає нижче нуля)."

#: ../../library/stdtypes.rst:978
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"У той час як операції ``in`` і ``not in`` використовуються лише для простого "
"тестування локалізації в загальному випадку, деякі спеціалізовані "
"послідовності (такі як :class:`str`, :class:`bytes` і :class:`bytearray`) "
"також використовуйте їх для тестування підпослідовності::"

#: ../../library/stdtypes.rst:987
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"Значення *n*, менші за ``0``, розглядаються як ``0`` (що дає порожню "
"послідовність того самого типу, що й *s*). Зверніть увагу, що елементи в "
"послідовності *s* не копіюються; на них посилаються кілька разів. Це часто "
"переслідує нових програмістів Python; розглянути::"

#: ../../library/stdtypes.rst:999
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"Сталося те, що ``[[]]`` є одноелементним списком, який містить порожній "
"список, тому всі три елементи ``[[]] * 3`` є посиланнями на цей єдиний "
"порожній список. Зміна будь-якого з елементів ``списків`` змінює цей єдиний "
"список. Ви можете створити список різних списків таким чином:"

#: ../../library/stdtypes.rst:1011
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"Подальші пояснення доступні в розділі поширених запитань :ref:`faq-"
"multidimensional-list`."

#: ../../library/stdtypes.rst:1015
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Якщо *i* або *j* є від’ємними, індекс відноситься до кінця послідовності "
"*s*: замінюється ``len(s) + i`` або ``len(s) + j``. Але зауважте, що ``-0`` "
"все одно ``0``."

#: ../../library/stdtypes.rst:1020
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"Зріз *s* від *i* до *j* визначається як послідовність елементів з індексом "
"*k*, така що ``i <= k < j``. Якщо *i* або *j* більше ніж ``len(s)``, "
"використовуйте ``len(s)``. Якщо *i* пропущено або ``None``, використовуйте "
"``0``. Якщо *j* пропущено або ``None``, використовуйте ``len(s)``. Якщо *i* "
"більше або дорівнює *j*, фрагмент порожній."

#: ../../library/stdtypes.rst:1027
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"Зріз *s* від *i* до *j* з кроком *k* визначається як послідовність елементів "
"з індексом ``x = i + n*k`` так, що ``0 <= n < (j-i )/k``. Іншими словами, "
"індекси ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` і так далі, зупиняючись, коли "
"*j* є досягнуто (але ніколи не включаючи *j*). Коли *k* додатне, *i* і *j* "
"скорочуються до ``len(s)``, якщо вони більші. Коли *k* від’ємне, *i* та *j* "
"скорочуються до ``len(s) - 1``, якщо вони більші. Якщо *i* або *j* пропущені "
"або ``None``, вони стають \"кінцевими\" значеннями (кінець залежить від "
"знака *k*). Зауважте, *k* не може дорівнювати нулю. Якщо *k* має значення "
"``None``, воно розглядається як ``1``."

#: ../../library/stdtypes.rst:1038
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"Конкатенація незмінних послідовностей завжди призводить до нового об’єкта. "
"Це означає, що створення послідовності шляхом повторної конкатенації матиме "
"квадратичну вартість виконання в загальній довжині послідовності. Щоб "
"отримати лінійну вартість роботи, ви повинні перейти до однієї з наведених "
"нижче альтернатив:"

#: ../../library/stdtypes.rst:1043
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"якщо конкатенувати об’єкти :class:`str`, ви можете створити список і "
"використовувати :meth:`str.join` наприкінці або записати в екземпляр :class:"
"`io.StringIO` і отримати його значення після завершення"

#: ../../library/stdtypes.rst:1047
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"якщо конкатенація об’єктів :class:`bytes`, ви можете так само "
"використовувати :meth:`bytes.join` або :class:`io.BytesIO`, або ви можете "
"виконати конкатенацію на місці з об’єктом :class:`bytearray`. Об’єкти :class:"
"`bytearray` є змінними та мають ефективний механізм загального розподілу"

#: ../../library/stdtypes.rst:1052
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
"якщо конкатенація об’єктів :class:`tuple`, замість цього розширте :class:"
"`list`"

#: ../../library/stdtypes.rst:1054
msgid "for other types, investigate the relevant class documentation"
msgstr "для інших типів дослідіть відповідну документацію класу"

#: ../../library/stdtypes.rst:1058
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Деякі типи послідовностей (наприклад, :class:`range`) підтримують лише "
"послідовності елементів, які відповідають певним шаблонам, і, отже, не "
"підтримують конкатенацію або повторення послідовності."

#: ../../library/stdtypes.rst:1063
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"``index`` викликає :exc:`ValueError`, коли *x* не знайдено в *s*. Не всі "
"реалізації підтримують передачу додаткових аргументів *i* і *j*. Ці "
"аргументи дозволяють здійснювати ефективний пошук підрозділів послідовності. "
"Передача додаткових аргументів приблизно еквівалентна використанню ``s[i:j]."
"index(x)``, тільки без копіювання будь-яких даних і з повернутим індексом "
"відносно початку послідовності, а не початку фрагмента. ."

#: ../../library/stdtypes.rst:1074
msgid "Immutable Sequence Types"
msgstr "Незмінні типи послідовностей"

#: ../../library/stdtypes.rst:1081
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"Єдина операція, яку зазвичай реалізують незмінні типи послідовностей, яка "
"також не реалізована змінними типами послідовностей, це підтримка "
"вбудованого :func:`hash`."

#: ../../library/stdtypes.rst:1085
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Ця підтримка дозволяє використовувати незмінні послідовності, такі як "
"екземпляри :class:`tuple`, як ключі :class:`dict` і зберігати їх у "
"екземплярах :class:`set` і :class:`frozenset`."

#: ../../library/stdtypes.rst:1089
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Спроба хешувати незмінну послідовність, яка містить нехешовані значення, "
"призведе до :exc:`TypeError`."

#: ../../library/stdtypes.rst:1096
msgid "Mutable Sequence Types"
msgstr "Змінні типи послідовностей"

#: ../../library/stdtypes.rst:1103
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"Операції в наведеній нижче таблиці визначено для змінних типів "
"послідовностей. :class:`collections.abc.MutableSequence` ABC надається, щоб "
"спростити правильну реалізацію цих операцій у настроюваних типах "
"послідовностей."

#: ../../library/stdtypes.rst:1107
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"У таблиці *s* є екземпляром змінного типу послідовності, *t* є будь-яким "
"ітерованим об’єктом, а *x* є довільним об’єктом, який відповідає будь-яким "
"обмеженням типу та значення, накладеним *s* (наприклад, :class:`bytearray` "
"приймає лише цілі числа, які відповідають обмеженню значення ``0 <= x <= "
"255``)."

#: ../../library/stdtypes.rst:1131
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1131
msgid "item *i* of *s* is replaced by *x*"
msgstr "пункт *i* з *s* замінено на *x*"

#: ../../library/stdtypes.rst:1134
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1134
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr "фрагмент *s* від *i* до *j* замінюється вмістом ітерованого *t*"

#: ../../library/stdtypes.rst:1138
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1138
msgid "same as ``s[i:j] = []``"
msgstr "те саме, що ``s[i:j] = []``"

#: ../../library/stdtypes.rst:1140
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1140
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "елементи ``s[i:j:k]`` замінюються на елементи *t*"

#: ../../library/stdtypes.rst:1143
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1143
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "видаляє елементи ``s[i:j:k]`` зі списку"

#: ../../library/stdtypes.rst:1146
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../library/stdtypes.rst:1146
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""
"додає *x* до кінця послідовності (те саме, що ``s[len(s):len(s)] = [x]``)"

#: ../../library/stdtypes.rst:1150
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../library/stdtypes.rst:1150
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "видаляє всі елементи з *s* (те саме, що ``del s[:]``)"

#: ../../library/stdtypes.rst:1153
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../library/stdtypes.rst:1153
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "створює поверхневу копію *s* (те саме, що ``s[:]``)"

#: ../../library/stdtypes.rst:1156
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` або ``s += t``"

#: ../../library/stdtypes.rst:1156
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""
"розширює *s* вмістом *t* (здебільшого те саме, що ``s[len(s):len(s)] = t``)"

#: ../../library/stdtypes.rst:1161
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../../library/stdtypes.rst:1161
msgid "updates *s* with its contents repeated *n* times"
msgstr "оновлює *s* з повторенням його вмісту *n* разів"

#: ../../library/stdtypes.rst:1164
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../library/stdtypes.rst:1164
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""
"вставляє *x* в *s* за індексом, заданим *i* (те саме, що ``s[i:i] = [x]``)"

#: ../../library/stdtypes.rst:1168
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` або ``s.pop(i)``"

#: ../../library/stdtypes.rst:1168
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "отримує елемент у *i*, а також видаляє його з *s*"

#: ../../library/stdtypes.rst:1171
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1171
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "видалити перший елемент із *s*, де ``s[i]`` дорівнює *x*"

#: ../../library/stdtypes.rst:1174
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1174
msgid "reverses the items of *s* in place"
msgstr "перевертає елементи *s* на місце"

#: ../../library/stdtypes.rst:1182
msgid "*t* must have the same length as the slice it is replacing."
msgstr "*t* має мати таку саму довжину, що й фрагмент, який він замінює."

#: ../../library/stdtypes.rst:1185
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"Необов’язковий аргумент *i* за умовчанням має значення ``-1``, тому за "
"замовчуванням останній елемент видаляється та повертається."

#: ../../library/stdtypes.rst:1189
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ":meth:`remove` викликає :exc:`ValueError`, коли *x* не знайдено в *s*."

#: ../../library/stdtypes.rst:1192
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
"Метод :meth:`reverse` змінює поточну послідовність для економії простору під "
"час реверсування великої послідовності. Щоб нагадати користувачам, що він "
"працює за побічним ефектом, він не повертає зворотну послідовність."

#: ../../library/stdtypes.rst:1197
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""
":meth:`clear` і :meth:`!copy` включено для узгодженості з інтерфейсами "
"змінних контейнерів, які не підтримують операції зрізання (таких як :class:"
"`dict` і :class:`set`). :meth:`!copy` не є частиною :class:`collections.abc."
"MutableSequence` ABC, але більшість конкретних змінних класів послідовності "
"надають його."

#: ../../library/stdtypes.rst:1203
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr "Методи :meth:`clear` і :meth:`!copy`."

#: ../../library/stdtypes.rst:1207
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"Значення *n* є цілим числом або об’єктом, що реалізує :meth:`~object."
"__index__`. Нульові та негативні значення *n* очищають послідовність. "
"Елементи послідовності не копіюються; на них посилаються кілька разів, як "
"пояснюється для ``s * n`` у :ref:`typesseq-common`."

#: ../../library/stdtypes.rst:1216
msgid "Lists"
msgstr "списки"

#: ../../library/stdtypes.rst:1220
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"Списки — це змінювані послідовності, які зазвичай використовуються для "
"зберігання колекцій однорідних елементів (де точний ступінь подібності "
"залежить від програми)."

#: ../../library/stdtypes.rst:1226
msgid "Lists may be constructed in several ways:"
msgstr "Списки можна створювати кількома способами:"

#: ../../library/stdtypes.rst:1228
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""
"Використання пари квадратних дужок для позначення порожнього списку: ``[]``"

#: ../../library/stdtypes.rst:1229
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Використовуючи квадратні дужки, розділяючи елементи комами: ``[a]``, ``[a, "
"b, c]``"

#: ../../library/stdtypes.rst:1230
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "Використання розуміння списку: ``[x for x in iterable]``"

#: ../../library/stdtypes.rst:1231
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "Використання конструктора типу: ``list()`` або ``list(iterable)``"

#: ../../library/stdtypes.rst:1233
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"Конструктор створює список, елементи якого є такими ж і в тому ж порядку, що "
"й елементи *iterable*. *iterable* може бути або послідовністю, контейнером, "
"який підтримує ітерацію, або об’єктом ітератора. Якщо *iterable* вже є "
"списком, копія створюється та повертається, подібно до ``iterable[:]``. "
"Наприклад, ``list('abc')`` повертає ``['a', 'b', 'c']``, а ``list( (1, 2, "
"3) )`` повертає ``[ 1, 2, 3]``. Якщо аргумент не задано, конструктор створює "
"новий порожній список, ``[]``."

#: ../../library/stdtypes.rst:1242
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"Багато інших операцій також створюють списки, включаючи вбудовану :func:"
"`sorted`."

#: ../../library/stdtypes.rst:1245
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Списки реалізують усі :ref:`common <typesseq-common>` і :ref:`mutable "
"<typesseq-mutable>` операції послідовності. Списки також надають наступний "
"додатковий метод:"

#: ../../library/stdtypes.rst:1251
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Цей метод сортує список на місці, використовуючи лише ``<`` порівняння між "
"елементами. Винятки не пригнічуються — якщо будь-яка операція порівняння "
"завершиться невдало, вся операція сортування буде невдалою (і список, "
"ймовірно, залишиться в частково зміненому стані)."

#: ../../library/stdtypes.rst:1256
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` приймає два аргументи, які можуть бути передані лише ключовим "
"словом (:ref:`аргументи лише для ключових слів <keyword-only_parameter>`):"

#: ../../library/stdtypes.rst:1259
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* визначає функцію одного аргументу, яка використовується для отримання "
"ключа порівняння з кожного елемента списку (наприклад, ``key=str.lower``). "
"Ключ, що відповідає кожному елементу в списку, обчислюється один раз, а "
"потім використовується для всього процесу сортування. Значення за "
"замовчуванням \"Немає\" означає, що елементи списку сортуються безпосередньо "
"без обчислення окремого значення ключа."

#: ../../library/stdtypes.rst:1266
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"Утиліта :func:`functools.cmp_to_key` доступна для перетворення функції *cmp* "
"у стилі 2.x на функцію *key*."

#: ../../library/stdtypes.rst:1269
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* — це логічне значення. Якщо встановлено значення ``True``, "
"елементи списку сортуються так, ніби кожне порівняння було зворотним."

#: ../../library/stdtypes.rst:1272
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Цей метод змінює наявну послідовність для економії простору під час "
"сортування великої послідовності. Щоб нагадати користувачам, що він працює "
"за побічним ефектом, він не повертає відсортовану послідовність "
"(використовуйте :func:`sorted`, щоб явно запитати новий екземпляр "
"відсортованого списку)."

#: ../../library/stdtypes.rst:1277
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
"Метод :meth:`sort` гарантовано буде стабільним. Сортування є стабільним, "
"якщо воно гарантує відсутність зміни відносного порядку порівнюваних рівних "
"елементів --- це корисно для сортування за кілька проходів (наприклад, "
"сортування за відділом, а потім за ступенем зарплати)."

#: ../../library/stdtypes.rst:1282
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Приклади сортування та короткий посібник із сортування див. :ref:"
"`sortinghowto`."

#: ../../library/stdtypes.rst:1286
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"Поки список сортується, ефект від спроби змінити або навіть перевірити "
"список не визначено. Реалізація Python на C робить список порожнім протягом "
"певного часу та викликає :exc:`ValueError`, якщо він може виявити, що список "
"було змінено під час сортування."

#: ../../library/stdtypes.rst:1295
msgid "Tuples"
msgstr "Кортежі"

#: ../../library/stdtypes.rst:1299
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Кортежі — це незмінні послідовності, які зазвичай використовуються для "
"зберігання колекцій різнорідних даних (таких як 2-кортежі, створені за "
"допомогою вбудованої функції :func:`enumerate`). Кортежі також "
"використовуються у випадках, коли потрібна незмінна послідовність однорідних "
"даних (наприклад, дозволити зберігання в екземплярі :class:`set` або :class:"
"`dict`)."

#: ../../library/stdtypes.rst:1307
msgid "Tuples may be constructed in a number of ways:"
msgstr "Кортежі можна побудувати кількома способами:"

#: ../../library/stdtypes.rst:1309
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""
"Використання пари круглих дужок для позначення порожнього кортежу: ``()``"

#: ../../library/stdtypes.rst:1310
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""
"Використання кінцевої коми для одноэлементного кортежу: ``a,`` або ``(a,)``"

#: ../../library/stdtypes.rst:1311
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "Розділення елементів комами: ``a, b, c`` або ``(a, b, c)``"

#: ../../library/stdtypes.rst:1312
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""
"Використання вбудованого :func:`tuple`: ``tuple()`` або ``tuple(iterable)``"

#: ../../library/stdtypes.rst:1314
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"Конструктор будує кортеж, елементи якого є такими ж і в тому ж порядку, що й "
"елементи *iterable*. *iterable* може бути або послідовністю, контейнером, "
"який підтримує ітерацію, або об’єктом ітератора. Якщо *iterable* вже є "
"кортежем, він повертається без змін. Наприклад, ``tuple('abc')`` повертає "
"``('a', 'b', 'c')``, ``tuple( [1, 2, 3] )`` повертає ``( 1, 2, 3)``. Якщо "
"аргумент не задано, конструктор створює новий порожній кортеж ``()``."

#: ../../library/stdtypes.rst:1322
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Зауважте, що насправді кома створює кортеж, а не круглі дужки. Дужки "
"необов’язкові, за винятком порожнього кортежу або коли вони потрібні для "
"уникнення синтаксичної неоднозначності. Наприклад, \"f(a, b, c)\" — це "
"виклик функції з трьома аргументами, тоді як \"f((a, b, c))\" — це виклик "
"функції з 3-кортежем як єдиним аргумент."

#: ../../library/stdtypes.rst:1328
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Кортежі реалізують усі :ref:`загальні <typesseq-common>` операції "
"послідовності."

#: ../../library/stdtypes.rst:1331
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"Для різнорідних колекцій даних, де доступ за іменем є зрозумілішим, ніж "
"доступ за індексом, :func:`collections.namedtuple` може бути більш "
"відповідним вибором, ніж простий об’єкт кортежу."

#: ../../library/stdtypes.rst:1339
msgid "Ranges"
msgstr "діапазони"

#: ../../library/stdtypes.rst:1343
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
"Тип :class:`range` представляє незмінну послідовність чисел і зазвичай "
"використовується для повторення певної кількості разів у циклах :keyword:"
"`for`."

#: ../../library/stdtypes.rst:1350
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is "
"zero, :exc:`ValueError` is raised."
msgstr ""
"Аргументи конструктора діапазону мають бути цілими числами (або вбудованим :"
"class:`int`, або будь-яким об’єктом, який реалізує спеціальний метод :meth:"
"`~object.__index__`). Якщо аргумент *step* опущено, за умовчанням він "
"дорівнює ``1``. Якщо аргумент *початок* опущено, за умовчанням він дорівнює "
"``0``. Якщо *крок* дорівнює нулю, виникає :exc:`ValueError`."

#: ../../library/stdtypes.rst:1356
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Для позитивного *кроку* вміст діапазону ``r`` визначається за формулою "
"``r[i] = start + step*i``, де ``i >= 0`` і ``r[ i] < stop``."

#: ../../library/stdtypes.rst:1360
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"Для від’ємного *кроку* вміст діапазону все ще визначається формулою ``r[i] = "
"start + step*i``, але обмеження ``i >= 0`` і ``r[ i] > stop``."

#: ../../library/stdtypes.rst:1364
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Об’єкт діапазону буде порожнім, якщо ``r[0]`` не відповідає обмеженню "
"значення. Діапазони підтримують негативні індекси, але вони інтерпретуються "
"як індексування з кінця послідовності, визначеної позитивними індексами."

#: ../../library/stdtypes.rst:1369
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"Діапазони, що містять абсолютні значення, більші за :data:`sys.maxsize`, "
"дозволені, але деякі функції (такі як :func:`len`) можуть викликати :exc:"
"`OverflowError`."

#: ../../library/stdtypes.rst:1373
msgid "Range examples::"
msgstr "Приклади асортименту::"

#: ../../library/stdtypes.rst:1390
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"Діапазони реалізують усі :ref:`загальні <typesseq-common>` операції "
"послідовності, окрім конкатенації та повторення (через те, що об’єкти "
"діапазону можуть представляти лише послідовності, які дотримуються строгого "
"шаблону, а повторення та конкатенація зазвичай порушують цей шаблон)."

#: ../../library/stdtypes.rst:1397
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr "Значення параметра *start* (або ``0``, якщо параметр не було надано)"

#: ../../library/stdtypes.rst:1402
msgid "The value of the *stop* parameter"
msgstr "Значення параметра *stop*"

#: ../../library/stdtypes.rst:1406
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr "Значення параметра *step* (або ``1``, якщо параметр не було надано)"

#: ../../library/stdtypes.rst:1409
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
"Перевага типу :class:`range` перед звичайним :class:`list` або :class:"
"`tuple` полягає в тому, що об’єкт :class:`range` завжди займатиме однаковий "
"(невеликий) обсяг пам’яті, ні не має значення розмір діапазону, який він "
"представляє (оскільки він зберігає лише значення ``start``, ``stop`` і "
"``step``, обчислюючи окремі елементи та піддіапазони за потреби)."

#: ../../library/stdtypes.rst:1415
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Об’єкти діапазону реалізують :class:`collections.abc.Sequence` ABC і надають "
"такі функції, як тести на обмеження, пошук індексу елемента, нарізка та "
"підтримка негативних індексів (див. :ref:`typesseq`):"

#: ../../library/stdtypes.rst:1435
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"Перевірка об’єктів діапазону на рівність за допомогою ``==`` і ``!=`` "
"порівнює їх як послідовності. Тобто два об’єкти діапазону вважаються "
"рівними, якщо вони представляють однакову послідовність значень. (Зверніть "
"увагу, що два об’єкти діапазону, які порівнюються, можуть мати різні "
"атрибути :attr:`~range.start`, :attr:`~range.stop` і :attr:`~range.step`, "
"наприклад ``range(0 ) == діапазон(2, 1, 3)`` або ``діапазон(0, 3, 2) == "
"діапазон(0, 4, 2)``.)"

#: ../../library/stdtypes.rst:1442
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Реалізуйте послідовність ABC. Підтримка нарізки та негативних індексів. "
"Перевіряйте об’єкти :class:`int` на приналежність у постійному часі замість "
"повторення всіх елементів."

#: ../../library/stdtypes.rst:1448
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"Визначте \"==\" і \"!=\", щоб порівнювати об’єкти діапазону на основі "
"послідовності значень, які вони визначають (замість порівняння на основі "
"ідентичності об’єкта)."

#: ../../library/stdtypes.rst:1453
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"Атрибути :attr:`~range.start`, :attr:`~range.stop` і :attr:`~range.step`."

#: ../../library/stdtypes.rst:1459
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range suitable for floating point "
"applications."
msgstr ""

#: ../../library/stdtypes.rst:1471
msgid "Text Sequence Type --- :class:`str`"
msgstr "Тип текстової послідовності --- :class:`str`"

#: ../../library/stdtypes.rst:1473
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"Текстові дані в Python обробляються за допомогою об’єктів :class:`str` або :"
"dfn:`strings`. Рядки є незмінними :ref:`послідовностями <typesseq>` кодових "
"точок Unicode. Рядкові літерали записуються різними способами:"

#: ../../library/stdtypes.rst:1478
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Одинарні лапки: ``'дозволяє вбудовані \"подвійні\" лапки'``"

#: ../../library/stdtypes.rst:1479
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "Подвійні лапки: ``\"дозволяє вбудовані 'одинарні' лапки\"``"

#: ../../library/stdtypes.rst:1480
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr ""
"Потрійні лапки: ``''Три одинарні лапки''''``, ``\"\"\"Три подвійні "
"лапки\"\"\"``"

#: ../../library/stdtypes.rst:1482
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"Рядки з потрійними лапками можуть охоплювати кілька рядків - усі пов’язані "
"пробіли будуть включені в рядковий літерал."

#: ../../library/stdtypes.rst:1485
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Рядкові літерали, які є частиною одного виразу і мають лише пробіли між "
"собою, будуть неявно перетворені в один рядковий літерал. Тобто ``(\"спам \" "
"\"яйця\") == \"спам яйця\"``."

#: ../../library/stdtypes.rst:1489
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""
"Перегляньте :ref:`strings`, щоб дізнатися більше про різні форми рядкових "
"літералів, включаючи підтримувані керуючі послідовності та префікс ``r`` "
"(\"необроблений\"), який вимикає більшість обробки керуючих послідовностей."

#: ../../library/stdtypes.rst:1493
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Рядки також можна створювати з інших об’єктів за допомогою конструктора :"
"class:`str`."

#: ../../library/stdtypes.rst:1496
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Оскільки окремого типу \"символів\" немає, індексування рядка створює рядки "
"довжиною 1. Тобто для непорожнього рядка *s* ``s[0] == s[0:1]``."

#: ../../library/stdtypes.rst:1502
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Також немає змінного типу рядка, але :meth:`str.join` або :class:`io."
"StringIO` можна використовувати для ефективного створення рядків із кількох "
"фрагментів."

#: ../../library/stdtypes.rst:1506
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Для зворотної сумісності з серією Python 2 префікс ``u`` знову дозволений у "
"рядкових літералах. Він не впливає на значення рядкових літералів і не може "
"поєднуватися з префіксом ``r``."

#: ../../library/stdtypes.rst:1518
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"Повертає :ref:`string <textseq>` версію *об’єкта*. Якщо *object* не надано, "
"повертає порожній рядок. В іншому випадку поведінка ``str()`` залежить від "
"того, чи вказано *кодування* чи *помилки*, як показано нижче."

#: ../../library/stdtypes.rst:1522
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" "
"or nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a :meth:`~object."
"__str__` method, then :func:`str` falls back to returning :meth:"
"`repr(object) <repr>`."
msgstr ""

#: ../../library/stdtypes.rst:1534
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"Якщо вказано принаймні одну з *кодування* або *помилок*, *об’єкт* має бути :"
"term:`bytes-like object` (наприклад, :class:`bytes` або :class:`bytearray`). "
"У цьому випадку, якщо *object* є об’єктом :class:`bytes` (або :class:"
"`bytearray`), тоді ``str(bytes, encoding, errors)`` еквівалентно :meth:"
"`bytes.decode (кодування, помилки) <bytes.decode>`. В іншому випадку об’єкт "
"bytes, що лежить в основі об’єкта буфера, отримується перед викликом :meth:"
"`bytes.decode`. Перегляньте :ref:`binaryseq` і :ref:`bufferobjects` для "
"отримання інформації про буферні об’єкти."

#: ../../library/stdtypes.rst:1543
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Передача об’єкта :class:`bytes` до :func:`str` без аргументів *encoding* або "
"*errors* підпадає під перший випадок повернення неформального представлення "
"рядка (див. також команду :option:`-b`- рядок для Python). Наприклад::"

#: ../../library/stdtypes.rst:1551
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"Додаткову інформацію про клас ``str`` і його методи див. у розділі :ref:"
"`textseq` і :ref:`string-methods` нижче. Щоб вивести форматовані рядки, "
"перегляньте розділи :ref:`f-strings` і :ref:`formatstrings`. Крім того, "
"перегляньте розділ :ref:`stringservices`."

#: ../../library/stdtypes.rst:1563
msgid "String Methods"
msgstr "Рядкові методи"

#: ../../library/stdtypes.rst:1568
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Рядки реалізують усі :ref:`загальні <typesseq-common>` операції "
"послідовності разом із додатковими методами, описаними нижче."

#: ../../library/stdtypes.rst:1571
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Рядки також підтримують два стилі форматування рядків: один забезпечує "
"велику гнучкість і налаштування (див. :meth:`str.format`, :ref:"
"`formatstrings` і :ref:`string-formatting`), а інший базується на "
"Форматування стилю C ``printf``, яке обробляє вужчий діапазон типів і трохи "
"важче правильно використовувати, але часто швидше для випадків, які воно "
"може обробляти (:ref:`old-string-formatting`)."

#: ../../library/stdtypes.rst:1578
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"Розділ :ref:`textservices` стандартної бібліотеки охоплює низку інших "
"модулів, які надають різноманітні утиліти, пов’язані з текстом (зокрема "
"підтримку регулярних виразів у модулі :mod:`re`)."

#: ../../library/stdtypes.rst:1584
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr "Повертає копію рядка з великим першим символом, а решта малими."

#: ../../library/stdtypes.rst:1587
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""
"Перший символ тепер вводиться в заголовок, а не у верхній регістр. Це "
"означає, що такі символи, як диграфи, матимуть велику першу літеру, а не "
"повний символ."

#: ../../library/stdtypes.rst:1594
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Повертає згорнуту копію рядка. Для зіставлення без регістру можна "
"використовувати рядки з регістром."

#: ../../library/stdtypes.rst:1597
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"Згортання регістру подібне до нижнього регістру, але більш агресивне, "
"оскільки воно призначене для видалення всіх відмінностей регістру в рядку. "
"Наприклад, німецька мала літера ``'ß'`` еквівалентна ``\"ss\"``. Оскільки це "
"вже малий регістр, :meth:`lower` нічого не зробить для ``'ß'``; :meth:"
"`casefold` перетворює його на ``\"ss\"``."

#: ../../library/stdtypes.rst:1603
msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr ""

#: ../../library/stdtypes.rst:1611
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Повернення з центром у рядку довжиною *width*. Заповнення виконується за "
"допомогою вказаного *fillchar* (за замовчуванням це пробіл ASCII). "
"Оригінальний рядок повертається, якщо *width* менше або дорівнює ``len(s)``."

#: ../../library/stdtypes.rst:1619
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Повертає кількість неперекриваючих входжень підрядка *sub* у діапазоні "
"[*початок*, *кінець*]. Необов’язкові аргументи *початок* і *кінець* "
"інтерпретуються як у нотації фрагментів."

#: ../../library/stdtypes.rst:1623
msgid ""
"If *sub* is empty, returns the number of empty strings between characters "
"which is the length of the string plus one."
msgstr ""

#: ../../library/stdtypes.rst:1629
msgid "Return the string encoded to :class:`bytes`."
msgstr ""

#: ../../library/stdtypes.rst:1631 ../../library/stdtypes.rst:2766
msgid ""
"*encoding* defaults to ``'utf-8'``; see :ref:`standard-encodings` for "
"possible values."
msgstr ""

#: ../../library/stdtypes.rst:1634
msgid ""
"*errors* controls how encoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` and any other name registered via :func:`codecs."
"register_error`. See :ref:`error-handlers` for details."
msgstr ""

#: ../../library/stdtypes.rst:1641
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless an encoding error actually occurs, :ref:`devmode` is enabled or a :"
"ref:`debug build <debug-build>` is used."
msgstr ""

#: ../../library/stdtypes.rst:1646 ../../library/stdtypes.rst:2785
msgid "Added support for keyword arguments."
msgstr "Додано підтримку аргументів ключових слів."

#: ../../library/stdtypes.rst:1649 ../../library/stdtypes.rst:2788
msgid ""
"The value of the *errors* argument is now checked in :ref:`devmode` and in :"
"ref:`debug mode <debug-build>`."
msgstr ""

#: ../../library/stdtypes.rst:1656
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"Повертає ``True``, якщо рядок закінчується вказаним *суфіксом*, інакше "
"повертає ``False``. *suffix* також може бути кортежем суфіксів для пошуку. З "
"необов'язковим *початком* тестування починається з цієї позиції. З "
"необов’язковим *end*, припинити порівняння на цій позиції."

#: ../../library/stdtypes.rst:1664
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"Повертає копію рядка, де всі символи табуляції замінені одним або кількома "
"пробілами, залежно від поточного стовпця та заданого розміру табуляції. "
"Позиції табуляції відбуваються з кожним символом *tabsize* (за замовчуванням "
"— 8, надаючи позиції табуляції в стовпцях 0, 8, 16 тощо). Щоб розгорнути "
"рядок, поточний стовпець встановлюється на нуль, а рядок перевіряється "
"символ за символом. Якщо символ є табуляцією (``\\t``), один або кілька "
"символів пробілу вставляються в результат, доки поточний стовпець не "
"зрівняється з позицією наступної табуляції. (Сам символ табуляції не "
"копіюється.) Якщо символ є символом нового рядка (``\\n``) або повернення "
"(``\\r``), він копіюється, а поточний стовпець скидається до нуля. Будь-який "
"інший символ копіюється без змін, а поточний стовпець збільшується на "
"одиницю незалежно від того, як символ представлено під час друку."

#: ../../library/stdtypes.rst:1685
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"Повертає найнижчий індекс у рядку, де підрядок *sub* знайдено в фрагменті "
"``s[start:end]``. Необов’язкові аргументи *початок* і *кінець* "
"інтерпретуються як у нотації фрагментів. Повертає ``-1``, якщо *sub* не "
"знайдено."

#: ../../library/stdtypes.rst:1691
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Метод :meth:`~str.find` слід використовувати, лише якщо вам потрібно знати "
"позицію *sub*. Щоб перевірити, чи є *sub* підрядком, скористайтеся "
"оператором :keyword:`in`::"

#: ../../library/stdtypes.rst:1701
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"Виконайте операцію форматування рядка. Рядок, у якому викликається цей "
"метод, може містити літеральний текст або поля заміни, розділені дужками ``{}"
"``. Кожне поле заміни містить або числовий індекс позиційного аргументу, або "
"назву ключового аргументу. Повертає копію рядка, де кожне поле заміни "
"замінено рядковим значенням відповідного аргументу."

#: ../../library/stdtypes.rst:1711
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Перегляньте :ref:`formatstrings` для опису різних параметрів форматування, "
"які можна вказати в рядках формату."

#: ../../library/stdtypes.rst:1715
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"Під час форматування числа (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` і підкласів) із типом ``n`` (наприклад: ``'{:n}'."
"format(1234)``, функція тимчасово встановлює локаль ``LC_CTYPE`` на мову "
"``LC_NUMERIC`` для декодування полів ``decimal_point`` і ``thousands_sep`` :"
"c:func:`localeconv`, якщо вони не є ASCII або довші за 1 байт, а локаль "
"``LC_NUMERIC`` відрізняється від локалі ``LC_CTYPE``. Ця тимчасова зміна "
"впливає на інші потоки."

#: ../../library/stdtypes.rst:1724
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"Під час форматування числа за допомогою типу ``n``, у деяких випадках "
"функція тимчасово встановлює ``LC_CTYPE`` локаль ``LC_NUMERIC``."

#: ../../library/stdtypes.rst:1732
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"Подібно до ``str.format(**mapping)``, за винятком того, що ``mapping`` "
"використовується безпосередньо, а не копіюється в :class:`dict`. Це корисно, "
"якщо, наприклад, ``mapping`` є підкласом dict:"

#: ../../library/stdtypes.rst:1748
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
"Як :meth:`~str.find`, але викликає :exc:`ValueError`, коли підрядок не "
"знайдено."

#: ../../library/stdtypes.rst:1754
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Повертає ``True``, якщо всі символи в рядку є буквено-цифровими і є "
"принаймні один символ, ``False`` інакше. Символ ``c`` є буквено-цифровим, "
"якщо одне з наступного повертає ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()`` або ``c.isnumeric()``."

#: ../../library/stdtypes.rst:1762
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the "
"\"Alphabetic\" property defined in the Unicode Standard."
msgstr ""

#: ../../library/stdtypes.rst:1771
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""
"Повертає ``True``, якщо рядок порожній або всі символи в рядку є ASCII, "
"``False`` інакше. Символи ASCII мають кодові точки в діапазоні U+0000-U+007F."

#: ../../library/stdtypes.rst:1780
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""
"Повертає ``True``, якщо всі символи в рядку є десятковими символами і є "
"принаймні один символ, ``False`` інакше. Десяткові символи – це ті, які "
"можна використовувати для утворення чисел за основою 10, напр. U+0660, "
"АРАБСЬКО-ІНДІЙСЬКА ЦИФРА НУЛЬ. Формально десятковий символ — це символ у "
"загальній категорії Unicode \"Nd\"."

#: ../../library/stdtypes.rst:1790
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Повертає ``True``, якщо всі символи в рядку є цифрами і є принаймні один "
"символ, ``False`` інакше. Цифри включають десяткові символи та цифри, які "
"потребують спеціальної обробки, наприклад цифри сумісності над індексом. Це "
"охоплює цифри, які не можна використовувати для формування чисел з основою "
"10, як-от числа Харості. Формально цифра — це символ, який має значення "
"властивості Numeric_Type=Digit або Numeric_Type=Decimal."

#: ../../library/stdtypes.rst:1800
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""
"Повертає ``True``, якщо рядок є дійсним ідентифікатором відповідно до "
"визначення мови, розділ :ref:`identifiers`."

#: ../../library/stdtypes.rst:1803
msgid ""
"Call :func:`keyword.iskeyword` to test whether string ``s`` is a reserved "
"identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""

#: ../../library/stdtypes.rst:1806
msgid "Example: ::"
msgstr "Приклад: ::"

#: ../../library/stdtypes.rst:1819
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо всі символи регістру [4]_ в рядку є малими і є "
"принаймні один символ регістру, ``False`` інакше."

#: ../../library/stdtypes.rst:1825
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"Повертає ``True``, якщо всі символи в рядку є цифровими символами, і є "
"принаймні один символ, ``False`` інакше. Цифрові символи включають цифрові "
"символи та всі символи, які мають властивість числового значення Unicode, "
"напр. U+2155, ВУЛЬГАРНА ФРАКЦІЯ ОДНА П’ЯТА. Формально цифровими символами є "
"символи зі значенням властивості Numeric_Type=Digit, Numeric_Type=Decimal "
"або Numeric_Type=Numeric."

#: ../../library/stdtypes.rst:1835
msgid ""
"Return ``True`` if all characters in the string are printable or the string "
"is empty, ``False`` otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Повертає ``True``, якщо всі символи в рядку можна надрукувати або рядок "
"порожній, ``False`` інакше. Символи, що не друкуються, — це символи, "
"визначені в базі даних символів Unicode як \"Інші\" або \"Розділювачі\", за "
"винятком пробілу ASCII (0x20), який вважається придатним для друку. "
"(Зауважте, що друковані символи в цьому контексті – це ті символи, які не "
"слід екранувати, коли :func:`repr` викликається в рядку. Це не впливає на "
"обробку рядків, записаних у :data:`sys.stdout` або :data:`sys.stderr`.)"

#: ../../library/stdtypes.rst:1846
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо в рядку є лише пробіли та є принаймні один символ, "
"``False`` інакше."

#: ../../library/stdtypes.rst:1849
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"Символ є *пробілом*, якщо в базі даних символів Unicode (див. :mod:"
"`unicodedata`) або його загальна категорія ``Zs`` (\"Роздільник, пробіл\"), "
"або його двонаправлений клас є одним із ``WS``, ``B`` або ``S``."

#: ../../library/stdtypes.rst:1857
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"Повертає ``True``, якщо рядок є рядком із заголовком і містить принаймні "
"один символ, наприклад, символи верхнього регістру можуть слідувати лише за "
"символами без регістру, а символи нижнього регістру – лише за символами в "
"регістрі. В іншому випадку поверніть ``False``."

#: ../../library/stdtypes.rst:1864
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо всі символи регістру [4]_ в рядку є верхніми і є "
"принаймні один символ регістру, ``False`` інакше."

#: ../../library/stdtypes.rst:1882
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"Повертає рядок, який є конкатенацією рядків у *iterable*. Помилка :exc:"
"`TypeError` буде викликана, якщо в *iterable* є будь-які нерядкові значення, "
"включаючи об’єкти :class:`bytes`. Роздільником між елементами є рядок, що "
"забезпечує цей метод."

#: ../../library/stdtypes.rst:1890
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Повертає рядок, вирівняний за лівим краєм, у рядку довжини *width*. "
"Заповнення виконується за допомогою вказаного *fillchar* (за замовчуванням "
"це пробіл ASCII). Оригінальний рядок повертається, якщо *width* менше або "
"дорівнює ``len(s)``."

#: ../../library/stdtypes.rst:1897
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Повертає копію рядка з усіма регістровими символами [4]_, перетвореними на "
"нижній регістр."

#: ../../library/stdtypes.rst:1900
msgid ""
"The lowercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""

#: ../../library/stdtypes.rst:1906
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Повертає копію рядка з видаленими початковими символами. Аргумент *chars* — "
"це рядок, який визначає набір символів, які потрібно видалити. Якщо "
"пропущено або ``None``, аргумент *chars* за умовчанням видаляє пробіли. "
"Аргумент *chars* не є префіксом; навпаки, усі комбінації його значень "
"видаляються:"

#: ../../library/stdtypes.rst:1916
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Перегляньте :meth:`str.removeprefix` для методу, який видаляє один рядок "
"префікса, а не весь набір символів. Наприклад::"

#: ../../library/stdtypes.rst:1927
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Цей статичний метод повертає таблицю перекладу, яку можна використовувати "
"для :meth:`str.translate`."

#: ../../library/stdtypes.rst:1929
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Якщо є лише один аргумент, це має бути словник, який відображає порядкові "
"номери Unicode (цілі числа) або символи (рядки довжиною 1) на порядкові "
"номери Unicode, рядки (довільної довжини) або ``None``. Потім символьні "
"ключі будуть перетворені на порядкові."

#: ../../library/stdtypes.rst:1934
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"Якщо є два аргументи, вони мають бути рядками однакової довжини, і в "
"отриманому словнику кожен символ у x буде зіставлено зі символом у тій же "
"позиції в y. Якщо є третій аргумент, це має бути рядок, символи якого будуть "
"зіставлені на ``None`` у результаті."

#: ../../library/stdtypes.rst:1942
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Розділіть рядок при першому входженні *sep* і поверніть 3-кортеж, що містить "
"частину перед роздільником, сам роздільник і частину після роздільника. Якщо "
"роздільник не знайдено, поверніть 3-кортеж, що містить сам рядок, а потім "
"два порожні рядки."

#: ../../library/stdtypes.rst:1950
msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr ""
"Якщо рядок починається з рядка *prefix*, поверніть ``string[len(prefix):]``. "
"В іншому випадку поверніть копію оригінального рядка::"

#: ../../library/stdtypes.rst:1964
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"Якщо рядок закінчується рядком *suffix* і цей *suffix* не є порожнім, "
"поверніть ``string[:-len(suffix)]``. В іншому випадку поверніть копію "
"оригінального рядка::"

#: ../../library/stdtypes.rst:1978
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"Повертає копію рядка з усіма входженнями підрядка *old*, заміненими на "
"*new*. Якщо вказано необов’язковий аргумент *count*, заміняються лише перші "
"випадки *count*."

#: ../../library/stdtypes.rst:1985
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Повертає найвищий індекс у рядку, де знайдено підрядок *sub*, так що *sub* "
"міститься в ``s[start:end]``. Необов’язкові аргументи *початок* і *кінець* "
"інтерпретуються як у нотації фрагментів. Повернути ``-1`` у разі помилки."

#: ../../library/stdtypes.rst:1992
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Подібно до :meth:`rfind`, але викликає :exc:`ValueError`, коли підрядок "
"*sub* не знайдено."

#: ../../library/stdtypes.rst:1998
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Повертає рядок, вирівняний по правому краю, у рядку довжини *width*. "
"Заповнення виконується за допомогою вказаного *fillchar* (за замовчуванням "
"це пробіл ASCII). Оригінальний рядок повертається, якщо *width* менше або "
"дорівнює ``len(s)``."

#: ../../library/stdtypes.rst:2005
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Розділіть рядок на останнє входження *sep* і поверніть 3-кортеж, що містить "
"частину перед роздільником, сам роздільник і частину після роздільника. Якщо "
"роздільник не знайдено, поверніть 3-кортеж, що містить два порожні рядки, а "
"потім сам рядок."

#: ../../library/stdtypes.rst:2013
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Повертає список слів у рядку, використовуючи *sep* як роздільник. Якщо "
"задано *maxsplit*, виконується щонайбільше *maxsplit* розбиття, "
"*найправіші*. Якщо *sep* не вказано або ``None``, будь-який пробільний рядок "
"є роздільником. За винятком розділення справа, :meth:`rsplit` поводиться як :"
"meth:`split`, що детально описано нижче."

#: ../../library/stdtypes.rst:2022
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Повертає копію рядка з видаленими кінцевими символами. Аргумент *chars* — це "
"рядок, який визначає набір символів, які потрібно видалити. Якщо пропущено "
"або ``None``, аргумент *chars* за умовчанням видаляє пробіли. Аргумент "
"*chars* не є суфіксом; навпаки, усі комбінації його значень видаляються:"

#: ../../library/stdtypes.rst:2032
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Перегляньте :meth:`str.removesuffix` для методу, який видаляє один рядок "
"суфікса, а не весь набір символів. Наприклад::"

#: ../../library/stdtypes.rst:2042
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Повертає список слів у рядку, використовуючи *sep* як роздільник. Якщо "
"вказано *maxsplit*, виконується щонайбільше *maxsplit* розбиття (отже, "
"список міститиме щонайбільше елементів ``maxsplit+1``). Якщо *maxsplit* не "
"вказано або ``-1``, тоді немає обмеження на кількість розділень (виконуються "
"всі можливі розділення)."

#: ../../library/stdtypes.rst:2048
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"Якщо задано *sep*, послідовні розділювачі не групуються разом і вважаються "
"роздільниками порожніх рядків (наприклад, ``'1,,2'.split(',')`` повертає "
"``['1', ' ', '2']``). Аргумент *sep* може складатися з кількох символів "
"(наприклад, ``'1 <> 2 <> 3'.split(' <> ')`` повертає ``['1', '2', '3']`` ). "
"Розділення порожнього рядка з указаним роздільником повертає ``['']``."

#: ../../library/stdtypes.rst:2054 ../../library/stdtypes.rst:2070
#: ../../library/stdtypes.rst:2122 ../../library/stdtypes.rst:2190
#: ../../library/stdtypes.rst:2257 ../../library/stdtypes.rst:3104
#: ../../library/stdtypes.rst:3120 ../../library/stdtypes.rst:3211
#: ../../library/stdtypes.rst:3227 ../../library/stdtypes.rst:3252
#: ../../library/stdtypes.rst:3266 ../../library/stdtypes.rst:3294
#: ../../library/stdtypes.rst:3308 ../../library/stdtypes.rst:3326
#: ../../library/stdtypes.rst:3353 ../../library/stdtypes.rst:3376
#: ../../library/stdtypes.rst:3403 ../../library/stdtypes.rst:3445
#: ../../library/stdtypes.rst:3469
msgid "For example::"
msgstr "Наприклад::"

#: ../../library/stdtypes.rst:2063
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Якщо *sep* не вказано або має значення ``None``, застосовується інший "
"алгоритм поділу: цикли послідовних пробілів розглядаються як один "
"роздільник, і результат не міститиме порожніх рядків на початку або в кінці, "
"якщо рядок має пробіли на початку або в кінці. Отже, розділення порожнього "
"рядка або рядка, що складається лише з пробілів, за допомогою розділювача "
"``None`` повертає ``[]``."

#: ../../library/stdtypes.rst:2085
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Повертає список рядків у рядку, розриваючи межі рядків. Розриви рядків не "
"включаються в результуючий список, якщо *keepends* не задано і не відповідає "
"дійсності."

#: ../../library/stdtypes.rst:2089
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Цей метод розбивається на наступні межі рядків. Зокрема, межі є надмножиною :"
"term:`universal newlines`."

#: ../../library/stdtypes.rst:2093
msgid "Representation"
msgstr "Представництво"

#: ../../library/stdtypes.rst:2093
msgid "Description"
msgstr "опис"

#: ../../library/stdtypes.rst:2095
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:2095
msgid "Line Feed"
msgstr "Переведення рядка"

#: ../../library/stdtypes.rst:2097
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:2097
msgid "Carriage Return"
msgstr "Повернення каретки"

#: ../../library/stdtypes.rst:2099
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../../library/stdtypes.rst:2099
msgid "Carriage Return + Line Feed"
msgstr "Повернення каретки + Переведення рядка"

#: ../../library/stdtypes.rst:2101
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` або ``\\x0b``"

#: ../../library/stdtypes.rst:2101
msgid "Line Tabulation"
msgstr "Лінія табуляції"

#: ../../library/stdtypes.rst:2103
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` або ``\\x0c``"

#: ../../library/stdtypes.rst:2103
msgid "Form Feed"
msgstr "Подача форми"

#: ../../library/stdtypes.rst:2105
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../../library/stdtypes.rst:2105
msgid "File Separator"
msgstr "Роздільник файлів"

#: ../../library/stdtypes.rst:2107
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../../library/stdtypes.rst:2107
msgid "Group Separator"
msgstr "Роздільник груп"

#: ../../library/stdtypes.rst:2109
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../../library/stdtypes.rst:2109
msgid "Record Separator"
msgstr "Розділювач записів"

#: ../../library/stdtypes.rst:2111
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:2111
msgid "Next Line (C1 Control Code)"
msgstr "Наступний рядок (контрольний код C1)"

#: ../../library/stdtypes.rst:2113
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:2113
msgid "Line Separator"
msgstr "Розділювач рядків"

#: ../../library/stdtypes.rst:2115
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:2115
msgid "Paragraph Separator"
msgstr "Роздільник абзаців"

#: ../../library/stdtypes.rst:2120
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` і ``\\f`` додано до списку меж ліній."

#: ../../library/stdtypes.rst:2129
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"На відміну від :meth:`~str.split`, коли задано рядок роздільника *sep*, цей "
"метод повертає порожній список для порожнього рядка, а розрив кінцевого "
"рядка не призводить до додаткового рядка::"

#: ../../library/stdtypes.rst:2138
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Для порівняння ``split('\\n')`` дає:"

#: ../../library/stdtypes.rst:2148
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Повертає ``True``, якщо рядок починається з *префікса*, інакше повертає "
"``False``. *префікс* також може бути кортежем префіксів для пошуку. З "
"необов’язковим *початком*, тестовий рядок починається з цієї позиції. З "
"необов’язковим *end* припиняє порівнювати рядок у цій позиції."

#: ../../library/stdtypes.rst:2156
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Повертає копію рядка з видаленими початковими та кінцевими символами. "
"Аргумент *chars* — це рядок, який визначає набір символів, які потрібно "
"видалити. Якщо пропущено або ``None``, аргумент *chars* за умовчанням "
"видаляє пробіли. Аргумент *chars* не є префіксом або суфіксом; навпаки, усі "
"комбінації його значень видаляються:"

#: ../../library/stdtypes.rst:2167
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"Зовнішні початкові та кінцеві значення аргументів *chars* видаляються з "
"рядка. Символи видаляються з початку, доки не досягнеться символ рядка, який "
"не міститься в наборі символів у *chars*. Подібна дія відбувається на кінці. "
"Наприклад::"

#: ../../library/stdtypes.rst:2180
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Повертає копію рядка з символами верхнього регістру, перетвореними на малі, "
"і навпаки. Зауважте, що ``s.swapcase().swapcase() == s`` не обов’язково "
"правда."

#: ../../library/stdtypes.rst:2187
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Повертає версію рядка в заголовку, де слова починаються з великої літери, а "
"решта символів – нижніми."

#: ../../library/stdtypes.rst:2195 ../../library/stdtypes.rst:3413
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"Алгоритм використовує просте незалежне від мови визначення слова як групи "
"послідовних букв. Визначення працює в багатьох контекстах, але це означає, "
"що апостроф у скороченнях і присвійних формах формує межі слів, що може бути "
"не бажаним результатом:"

#: ../../library/stdtypes.rst:2203
msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ""
"Функція :func:`string.capwords` не має цієї проблеми, оскільки вона розділяє "
"слова лише на пробіли."

#: ../../library/stdtypes.rst:2206
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr ""
"Крім того, обхідний шлях для апострофів можна створити за допомогою "
"регулярних виразів::"

#: ../../library/stdtypes.rst:2221
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`~object.__getitem__`, typically a :term:`mapping` or :"
"term:`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""

#: ../../library/stdtypes.rst:2230
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"Ви можете використовувати :meth:`str.maketrans`, щоб створити карту "
"перекладу з відображень символів у різні формати."

#: ../../library/stdtypes.rst:2233
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"Перегляньте також модуль :mod:`codecs` для більш гнучкого підходу до "
"нестандартних відображень символів."

#: ../../library/stdtypes.rst:2239
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Повертає копію рядка з усіма символами [4]_, перетвореними на верхній "
"регістр. Зауважте, що ``s.upper().isupper()`` може мати значення ``False``, "
"якщо ``s`` містить символи без регістру або якщо категорія Юнікоду "
"результуючих символів не є \"Lu\" (літера , верхній регістр), але напр. "
"\"Lt\" (літера, регістр)."

#: ../../library/stdtypes.rst:2245
msgid ""
"The uppercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""

#: ../../library/stdtypes.rst:2251
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Поверніть копію рядка зліва, заповненого цифрами ASCII ``'0''``, щоб "
"отримати рядок довжини *width*. Початковий префікс знака (``'+'``/``'-'``) "
"обробляється шляхом вставки заповнення *після* символу знака, а не перед "
"ним. Оригінальний рядок повертається, якщо *width* менше або дорівнює "
"``len(s)``."

#: ../../library/stdtypes.rst:2269
msgid "``printf``-style String Formatting"
msgstr "Форматування рядків у стилі ``printf``"

#: ../../library/stdtypes.rst:2282
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""
"Операції форматування, описані тут, демонструють різноманітні особливості, "
"які призводять до низки поширених помилок (наприклад, неправильне "
"відображення кортежів і словників). Використання нових :ref:`відформатованих "
"рядкових літералів <f-strings>`, інтерфейсу :meth:`str.format` або :ref:"
"`шаблонних рядків <template-strings>` може допомогти уникнути цих помилок. "
"Кожна з цих альтернатив забезпечує власні компроміси та переваги простоти, "
"гнучкості та/або розширюваності."

#: ../../library/stdtypes.rst:2290
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""
"Рядкові об’єкти мають одну унікальну вбудовану операцію: оператор ``%`` (по "
"модулю). Це також відоме як оператор *форматування* рядка або "
"*інтерполяції*. З огляду на ``формат % значень`` (де *format* є рядком), "
"``%`` специфікації перетворення у *format* замінюються нулем або більше "
"елементами *значень*. Ефект подібний до використання :c:func:`sprintf` у "
"мові C."

#: ../../library/stdtypes.rst:2296
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Якщо для *format* потрібен один аргумент, *values* може бути одним "
"некортежним об’єктом. [5]_ В іншому випадку *values* має бути кортежем із "
"точною кількістю елементів, визначених рядком формату, або одним об’єктом "
"відображення (наприклад, словником)."

#: ../../library/stdtypes.rst:2306 ../../library/stdtypes.rst:3524
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Специфікатор перетворення містить два або більше символів і має наступні "
"компоненти, які мають відображатися в такому порядку:"

#: ../../library/stdtypes.rst:2309 ../../library/stdtypes.rst:3527
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "Символ ``'%'``, який позначає початок специфікатора."

#: ../../library/stdtypes.rst:2311 ../../library/stdtypes.rst:3529
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"Ключ відображення (необов’язковий), що складається з послідовності символів "
"у дужках (наприклад, ``(якесь ім’я)``)."

#: ../../library/stdtypes.rst:2314 ../../library/stdtypes.rst:3532
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Прапорці перетворення (опціонально), які впливають на результат деяких типів "
"перетворення."

#: ../../library/stdtypes.rst:2317 ../../library/stdtypes.rst:3535
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Мінімальна ширина поля (опціонально). Якщо вказано як ``'*'`` (зірочка), "
"фактична ширина зчитується з наступного елемента кортежу в *значеннях*, а "
"об’єкт для перетворення йде після мінімальної ширини поля та необов’язкової "
"точності."

#: ../../library/stdtypes.rst:2321 ../../library/stdtypes.rst:3539
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"Точність (необов’язкова), подається як ``'.'`` (крапка), за якою йде "
"точність. Якщо вказано як ``'*'`` (зірочка), фактична точність зчитується з "
"наступного елемента кортежу в *значеннях*, а значення для перетворення йде "
"після точності."

#: ../../library/stdtypes.rst:2326 ../../library/stdtypes.rst:3544
msgid "Length modifier (optional)."
msgstr "Модифікатор довжини (необов'язково)."

#: ../../library/stdtypes.rst:2328 ../../library/stdtypes.rst:3546
msgid "Conversion type."
msgstr "Тип перетворення."

#: ../../library/stdtypes.rst:2330
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Якщо правильний аргумент є словником (або іншим типом відображення), то "
"формати в рядку *мають* містити ключ відображення в дужках у цьому словнику, "
"вставлений одразу після символу ``'%'``. Ключ відображення вибирає значення, "
"яке потрібно відформатувати, із відображення. Наприклад:"

#: ../../library/stdtypes.rst:2339 ../../library/stdtypes.rst:3557
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"У цьому випадку у форматі не може бути специфікаторів ``*`` (оскільки вони "
"вимагають послідовного списку параметрів)."

#: ../../library/stdtypes.rst:2342 ../../library/stdtypes.rst:3560
msgid "The conversion flag characters are:"
msgstr "Символи прапора перетворення:"

#: ../../library/stdtypes.rst:2351 ../../library/stdtypes.rst:3569
msgid "Flag"
msgstr "Прапор"

#: ../../library/stdtypes.rst:2353 ../../library/stdtypes.rst:3571
msgid "``'#'``"
msgstr "``'#''``"

#: ../../library/stdtypes.rst:2353 ../../library/stdtypes.rst:3571
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""
"Перетворення значень використовуватиме \"альтернативну форму\" (де визначено "
"нижче)."

#: ../../library/stdtypes.rst:2356 ../../library/stdtypes.rst:3574
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:2356 ../../library/stdtypes.rst:3574
msgid "The conversion will be zero padded for numeric values."
msgstr "Перетворення буде доповнено нулем для числових значень."

#: ../../library/stdtypes.rst:2358 ../../library/stdtypes.rst:3576
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:2358 ../../library/stdtypes.rst:3576
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"Перетворене значення коригується зліва (перевизначає перетворення ``'0'``, "
"якщо подано обидва значення)."

#: ../../library/stdtypes.rst:2361 ../../library/stdtypes.rst:3579
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:2361 ../../library/stdtypes.rst:3579
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(пробіл) Пробіл слід залишити перед додатним числом (або порожнім рядком), "
"утвореним перетворенням зі знаком."

#: ../../library/stdtypes.rst:2364 ../../library/stdtypes.rst:3582
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:2364 ../../library/stdtypes.rst:3582
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"Символ знака (``'+'`` або ``'-'``) передуватиме перетворенню (перевизначає "
"позначку \"пробіл\")."

#: ../../library/stdtypes.rst:2368 ../../library/stdtypes.rst:3586
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Модифікатор довжини (``h``, ``l`` або ``L``) може бути присутнім, але він "
"ігнорується, оскільки він не є необхідним для Python - так, напр. ``%ld`` "
"ідентичний ``%d``."

#: ../../library/stdtypes.rst:2371 ../../library/stdtypes.rst:3589
msgid "The conversion types are:"
msgstr "Типи перетворення:"

#: ../../library/stdtypes.rst:2374 ../../library/stdtypes.rst:3592
msgid "Conversion"
msgstr "Перетворення"

#: ../../library/stdtypes.rst:2376 ../../library/stdtypes.rst:3594
msgid "``'d'``"
msgstr "``'d''``"

#: ../../library/stdtypes.rst:2376 ../../library/stdtypes.rst:2378
#: ../../library/stdtypes.rst:3594 ../../library/stdtypes.rst:3596
msgid "Signed integer decimal."
msgstr "Ціле десяткове число зі знаком."

#: ../../library/stdtypes.rst:2378 ../../library/stdtypes.rst:3596
msgid "``'i'``"
msgstr "``'я''``"

#: ../../library/stdtypes.rst:2380 ../../library/stdtypes.rst:3598
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:2380 ../../library/stdtypes.rst:3598
msgid "Signed octal value."
msgstr "Вісімкове значення зі знаком."

#: ../../library/stdtypes.rst:2382 ../../library/stdtypes.rst:3600
msgid "``'u'``"
msgstr "``'u''``"

#: ../../library/stdtypes.rst:2382 ../../library/stdtypes.rst:3600
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Застарілий тип -- він ідентичний ``'d'``."

#: ../../library/stdtypes.rst:2384 ../../library/stdtypes.rst:3602
msgid "``'x'``"
msgstr "``'x''``"

#: ../../library/stdtypes.rst:2384 ../../library/stdtypes.rst:3602
msgid "Signed hexadecimal (lowercase)."
msgstr "Шістнадцяткове число зі знаком (нижній регістр)."

#: ../../library/stdtypes.rst:2386 ../../library/stdtypes.rst:3604
msgid "``'X'``"
msgstr "``'X''``"

#: ../../library/stdtypes.rst:2386 ../../library/stdtypes.rst:3604
msgid "Signed hexadecimal (uppercase)."
msgstr "Шістнадцяткове число зі знаком (верхній регістр)."

#: ../../library/stdtypes.rst:2388 ../../library/stdtypes.rst:3606
msgid "``'e'``"
msgstr "``'e''``"

#: ../../library/stdtypes.rst:2388 ../../library/stdtypes.rst:3606
msgid "Floating point exponential format (lowercase)."
msgstr "Експоненціальний формат із плаваючою комою (нижній регістр)."

#: ../../library/stdtypes.rst:2390 ../../library/stdtypes.rst:3608
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:2390 ../../library/stdtypes.rst:3608
msgid "Floating point exponential format (uppercase)."
msgstr "Експоненціальний формат із плаваючою комою (верхній регістр)."

#: ../../library/stdtypes.rst:2392 ../../library/stdtypes.rst:3610
msgid "``'f'``"
msgstr "``'f''``"

#: ../../library/stdtypes.rst:2392 ../../library/stdtypes.rst:2394
#: ../../library/stdtypes.rst:3610 ../../library/stdtypes.rst:3612
msgid "Floating point decimal format."
msgstr "Десятковий формат із плаваючою комою."

#: ../../library/stdtypes.rst:2394 ../../library/stdtypes.rst:3612
msgid "``'F'``"
msgstr "``'F''``"

#: ../../library/stdtypes.rst:2396 ../../library/stdtypes.rst:3614
msgid "``'g'``"
msgstr "``'g''``"

#: ../../library/stdtypes.rst:2396 ../../library/stdtypes.rst:3614
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Формат з плаваючою комою. Використовує нижній регістр експоненціального "
"формату, якщо показник степеня менший за -4 або не менший за точність, "
"десятковий формат інакше."

#: ../../library/stdtypes.rst:2400 ../../library/stdtypes.rst:3618
msgid "``'G'``"
msgstr "``'G''``"

#: ../../library/stdtypes.rst:2400 ../../library/stdtypes.rst:3618
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Формат з плаваючою комою. Використовує експоненціальний формат у верхньому "
"регістрі, якщо показник степеня менший за -4 або не менший за точність, "
"інакше – десятковий формат."

#: ../../library/stdtypes.rst:2404 ../../library/stdtypes.rst:3622
msgid "``'c'``"
msgstr "``'c''``"

#: ../../library/stdtypes.rst:2404
msgid "Single character (accepts integer or single character string)."
msgstr "Один символ (приймає рядок цілих чи односимвольних символів)."

#: ../../library/stdtypes.rst:2407 ../../library/stdtypes.rst:3635
msgid "``'r'``"
msgstr "``'r''``"

#: ../../library/stdtypes.rst:2407
msgid "String (converts any Python object using :func:`repr`)."
msgstr "Рядок (перетворює будь-який об’єкт Python за допомогою :func:`repr`)."

#: ../../library/stdtypes.rst:2410 ../../library/stdtypes.rst:3629
msgid "``'s'``"
msgstr "``'s''``"

#: ../../library/stdtypes.rst:2410
msgid "String (converts any Python object using :func:`str`)."
msgstr "Рядок (перетворює будь-який об’єкт Python за допомогою :func:`str`)."

#: ../../library/stdtypes.rst:2413 ../../library/stdtypes.rst:3632
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/stdtypes.rst:2413
msgid "String (converts any Python object using :func:`ascii`)."
msgstr "Рядок (перетворює будь-який об’єкт Python за допомогою :func:`ascii`)."

#: ../../library/stdtypes.rst:2416 ../../library/stdtypes.rst:3638
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:2416 ../../library/stdtypes.rst:3638
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"Жоден аргумент не перетворюється, результатом є символ ``'%'`` в результаті."

#: ../../library/stdtypes.rst:2423 ../../library/stdtypes.rst:3645
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"Альтернативна форма призводить до того, що початковий вісімковий "
"специфікатор (``'0o'``) буде вставлено перед першою цифрою."

#: ../../library/stdtypes.rst:2427 ../../library/stdtypes.rst:3649
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"Альтернативна форма призводить до того, що початковий ``'0x'`` або ``'0X'`` "
"(залежно від того, використовувався формат ``'x'`` або ``'X'``) буде "
"вставлено перед перша цифра."

#: ../../library/stdtypes.rst:2431 ../../library/stdtypes.rst:3653
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"Альтернативна форма призводить до того, що результат завжди містить "
"десяткову крапку, навіть якщо за нею не йде цифра."

#: ../../library/stdtypes.rst:2434 ../../library/stdtypes.rst:3656
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"Точність визначає кількість цифр після коми та за замовчуванням дорівнює 6."

#: ../../library/stdtypes.rst:2438 ../../library/stdtypes.rst:3660
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"Альтернативна форма призводить до того, що результат завжди містить "
"десяткову кому, а кінцеві нулі не видаляються, як це було б інакше."

#: ../../library/stdtypes.rst:2441 ../../library/stdtypes.rst:3663
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"Точність визначає кількість значущих цифр до та після десяткової коми та за "
"умовчанням дорівнює 6."

#: ../../library/stdtypes.rst:2445 ../../library/stdtypes.rst:3667
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "Якщо точність ``N``, вивід скорочується до ``N`` символів."

#: ../../library/stdtypes.rst:2448 ../../library/stdtypes.rst:3676
msgid "See :pep:`237`."
msgstr "Дивіться :pep:`237`."

#: ../../library/stdtypes.rst:2450
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Оскільки рядки Python мають явну довжину, перетворення ``%s`` не "
"припускають, що ``'\\0`` є кінцем рядка."

#: ../../library/stdtypes.rst:2455
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"Перетворення ``%f`` для чисел, абсолютне значення яких перевищує 1e50, "
"більше не замінюються перетвореннями ``%g``."

#: ../../library/stdtypes.rst:2466
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"Типи бінарних послідовностей --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"

#: ../../library/stdtypes.rst:2474
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"Основними вбудованими типами для обробки двійкових даних є :class:`bytes` і :"
"class:`bytearray`. Вони підтримуються :class:`memoryview`, який "
"використовує :ref:`протокол буфера <bufferobjects>` для доступу до пам’яті "
"інших бінарних об’єктів без необхідності створення копії."

#: ../../library/stdtypes.rst:2479
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
"Модуль :mod:`array` підтримує ефективне зберігання основних типів даних, "
"таких як 32-розрядні цілі числа та плаваючі значення подвійної точності "
"IEEE754."

#: ../../library/stdtypes.rst:2485
msgid "Bytes Objects"
msgstr "Об'єкти Bytes"

#: ../../library/stdtypes.rst:2489
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"Об’єкти Bytes — це незмінні послідовності окремих байтів. Оскільки багато "
"основних двійкових протоколів базуються на текстовому кодуванні ASCII, "
"об’єкти bytes пропонують кілька методів, які дійсні лише під час роботи з "
"даними, сумісними з ASCII, і тісно пов’язані з рядковими об’єктами різними "
"способами."

#: ../../library/stdtypes.rst:2496
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"По-перше, синтаксис байтових літералів здебільшого такий самий, як і для "
"рядкових літералів, за винятком того, що додано префікс ``b``:"

#: ../../library/stdtypes.rst:2499
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "Одинарні лапки: ``b'все ще дозволяє вбудовані \"подвійні\" лапки``"

#: ../../library/stdtypes.rst:2500
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr "Подвійні лапки: ``b\"все ще дозволяє вбудовані 'одинарні' лапки``"

#: ../../library/stdtypes.rst:2501
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"Потрійні лапки: ``b''''3 одинарні лапки''''``, ``b\"\"\"3 подвійні "
"лапки\"\"\"``"

#: ../../library/stdtypes.rst:2503
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"У байтових літералах дозволені лише символи ASCII (незалежно від оголошеного "
"кодування вихідного коду). Будь-які двійкові значення понад 127 потрібно "
"вводити в байтові літерали за допомогою відповідної керуючої послідовності."

#: ../../library/stdtypes.rst:2507
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"Як і рядкові літерали, літерали bytes також можуть використовувати префікс "
"``r``, щоб вимкнути обробку керуючих послідовностей. Перегляньте :ref:"
"`strings`, щоб дізнатися більше про різні форми літералів байтів, включаючи "
"підтримувані керуючі послідовності."

#: ../../library/stdtypes.rst:2511
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"У той час як байтові літерали та представлення базуються на тексті ASCII, "
"об’єкти байтів фактично поводяться як незмінні послідовності цілих чисел, де "
"кожне значення в послідовності обмежено таким чином, що ``0 <= x < 256`` "
"(спроби порушити це обмеження викличуть :exc:`ValueError`). Це зроблено "
"навмисно, щоб підкреслити, що хоча багато двійкових форматів включають "
"елементи на основі ASCII і ними можна корисно маніпулювати за допомогою "
"деяких текстово-орієнтованих алгоритмів, це зазвичай не стосується довільних "
"двійкових даних (сліпе застосування алгоритмів обробки тексту до двійкових "
"форматів даних, які не Сумісність із ASCII зазвичай призводить до "
"пошкодження даних)."

#: ../../library/stdtypes.rst:2521
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""
"Окрім літеральних форм, об’єкти bytes можна створювати кількома іншими "
"способами:"

#: ../../library/stdtypes.rst:2524
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr "Об’єкт із заповненими нулем байтами вказаної довжини: ``bytes(10)``"

#: ../../library/stdtypes.rst:2525
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "З ітерації цілих чисел: ``bytes(range(20))``"

#: ../../library/stdtypes.rst:2526
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Копіювання існуючих двійкових даних через протокол буфера: ``bytes(obj)``"

#: ../../library/stdtypes.rst:2528
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "Також перегляньте вбудований :ref:`bytes <func-bytes>`."

#: ../../library/stdtypes.rst:2530
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"Оскільки 2 шістнадцяткові цифри точно відповідають одному байту, "
"шістнадцяткові числа є широко використовуваним форматом для опису двійкових "
"даних. Відповідно, тип bytes має додатковий метод класу для читання даних у "
"цьому форматі:"

#: ../../library/stdtypes.rst:2536
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Цей метод класу :class:`bytes` повертає об’єкт bytes, декодуючи даний "
"рядковий об’єкт. Рядок має містити дві шістнадцяткові цифри на байт, при "
"цьому пробіли ASCII ігноруються."

#: ../../library/stdtypes.rst:2543
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
":meth:`bytes.fromhex` тепер пропускає всі пробіли ASCII у рядку, а не лише "
"пробіли."

#: ../../library/stdtypes.rst:2547
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"Існує функція зворотного перетворення для перетворення об’єкта байтів у його "
"шістнадцяткове представлення."

#: ../../library/stdtypes.rst:2552 ../../library/stdtypes.rst:2637
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"Повертає рядковий об’єкт, що містить дві шістнадцяткові цифри для кожного "
"байта екземпляра."

#: ../../library/stdtypes.rst:2558
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, "
"this separator will be included between each byte. A second optional "
"*bytes_per_sep* parameter controls the spacing. Positive values calculate "
"the separator position from the right, negative values from the left."
msgstr ""

#: ../../library/stdtypes.rst:2575
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""
":meth:`bytes.hex` тепер підтримує додаткові параметри *sep* і "
"*bytes_per_sep* для вставки роздільників між байтами в шістнадцятковому "
"виведенні."

#: ../../library/stdtypes.rst:2579
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"Оскільки об’єкти bytes — це послідовності цілих чисел (подібно до кортежу), "
"для об’єкта bytes *b* \"b[0]\" буде цілим числом, тоді як \"b[0:1]\" буде "
"байтом об’єкт довжини 1. (Це контрастує з текстовими рядками, де як "
"індексування, так і нарізка створять рядок довжиною 1)"

#: ../../library/stdtypes.rst:2584
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"Для представлення об’єктів bytes використовується літеральний формат "
"(``b'...''``), оскільки він часто корисніший, ніж, наприклад, ``bytes([46, "
"46, 46])``. Ви завжди можете перетворити об’єкт bytes на список цілих чисел "
"за допомогою ``list(b)``."

#: ../../library/stdtypes.rst:2592
msgid "Bytearray Objects"
msgstr "Об’єкти байтового масиву"

#: ../../library/stdtypes.rst:2596
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
"Об’єкти :class:`bytearray` є змінними аналогами об’єктів :class:`bytes`."

#: ../../library/stdtypes.rst:2601
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"Для об’єктів bytearray немає виділеного синтаксису літералів, натомість вони "
"завжди створюються шляхом виклику конструктора:"

#: ../../library/stdtypes.rst:2604
msgid "Creating an empty instance: ``bytearray()``"
msgstr "Створення порожнього екземпляра: ``bytearray()``"

#: ../../library/stdtypes.rst:2605
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""
"Створення екземпляра із заповненням нуля із заданою довжиною: "
"``bytearray(10)``"

#: ../../library/stdtypes.rst:2606
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "З ітерації цілих чисел: ``bytearray(range(20))``"

#: ../../library/stdtypes.rst:2607
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Копіювання наявних двійкових даних за допомогою буферного протоколу: "
"``bytearray(b'Hi!')``"

#: ../../library/stdtypes.rst:2609
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Оскільки об’єкти bytearray є змінними, вони підтримують операції "
"послідовності :ref:`mutable <typesseq-mutable>` на додаток до звичайних "
"операцій з байтами та байтовими масивами, описаних у :ref:`bytes-methods`."

#: ../../library/stdtypes.rst:2613
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr "Також перегляньте вбудований :ref:`bytearray <func-bytearray>`."

#: ../../library/stdtypes.rst:2615
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"Оскільки 2 шістнадцяткові цифри точно відповідають одному байту, "
"шістнадцяткові числа є широко використовуваним форматом для опису двійкових "
"даних. Відповідно, тип bytearray має додатковий метод класу для читання "
"даних у цьому форматі:"

#: ../../library/stdtypes.rst:2621
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"Цей метод класу :class:`bytearray` повертає об’єкт bytearray, декодуючи "
"заданий рядковий об’єкт. Рядок має містити дві шістнадцяткові цифри на байт, "
"при цьому пробіли ASCII ігноруються."

#: ../../library/stdtypes.rst:2628
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""
":meth:`bytearray.fromhex` тепер пропускає всі пробіли ASCII у рядку, а не "
"лише пробіли."

#: ../../library/stdtypes.rst:2632
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"Існує функція зворотного перетворення для перетворення об’єкта байтового "
"масиву в його шістнадцяткове представлення."

#: ../../library/stdtypes.rst:2645
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"Подібно до :meth:`bytes.hex`, :meth:`bytearray.hex` тепер підтримує "
"додаткові параметри *sep* і *bytes_per_sep* для вставки роздільників між "
"байтами в шістнадцятковому виведенні."

#: ../../library/stdtypes.rst:2650
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"Оскільки об’єкти bytearray — це послідовності цілих чисел (схожі на список), "
"для об’єкта bytearray *b* \"b[0]\" буде цілим числом, а \"b[0:1]\" буде "
"масивом bytearray об’єкт довжини 1. (Це контрастує з текстовими рядками, де "
"як індексування, так і нарізка створять рядок довжиною 1)"

#: ../../library/stdtypes.rst:2655
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"У представленні об’єктів bytearray використовується формат літералу bytes "
"(``bytearray(b'...')``), оскільки він часто корисніший, ніж, наприклад, "
"``bytearray([46, 46, 46])``. Ви завжди можете перетворити об’єкт bytearray "
"на список цілих чисел за допомогою ``list(b)``."

#: ../../library/stdtypes.rst:2664
msgid "Bytes and Bytearray Operations"
msgstr "Операції з байтами та масивом байтів"

#: ../../library/stdtypes.rst:2669
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"Як об’єкти bytes, так і bytearray підтримують операції послідовності :ref:"
"`common <typesseq-common>`. Вони взаємодіють не тільки з операндами того "
"самого типу, але й з будь-яким :term:`bytes-like object`. Завдяки цій "
"гнучкості їх можна вільно змішувати під час операцій, не викликаючи помилок. "
"Однак тип результату може залежати від порядку операндів."

#: ../../library/stdtypes.rst:2677
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"Методи для об’єктів bytes і bytearray не приймають рядки як аргументи, так "
"само як методи для рядків не приймають байти як аргументи. Наприклад, ви "
"повинні написати::"

#: ../../library/stdtypes.rst:2684
msgid "and::"
msgstr "і::"

#: ../../library/stdtypes.rst:2689
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"Деякі операції з байтами та масивами байтів передбачають використання "
"двійкових форматів, сумісних із ASCII, і тому їх слід уникати під час роботи "
"з довільними двійковими даними. Ці обмеження описані нижче."

#: ../../library/stdtypes.rst:2694
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"Використання цих операцій на основі ASCII для обробки двійкових даних, які "
"не зберігаються у форматі на основі ASCII, може призвести до пошкодження "
"даних."

#: ../../library/stdtypes.rst:2697
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"Наступні методи для об’єктів bytes і bytearray можна використовувати з "
"довільними двійковими даними."

#: ../../library/stdtypes.rst:2703
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Повертає кількість неперекриваючих входжень підпослідовності *sub* у "
"діапазоні [*початок*, *кінець*]. Необов’язкові аргументи *початок* і "
"*кінець* інтерпретуються як у нотації фрагментів."

#: ../../library/stdtypes.rst:2707 ../../library/stdtypes.rst:2812
#: ../../library/stdtypes.rst:2834 ../../library/stdtypes.rst:2900
#: ../../library/stdtypes.rst:2913
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"Підпослідовністю для пошуку може бути будь-який :term:`bytes-like object` "
"або ціле число в діапазоні від 0 до 255."

#: ../../library/stdtypes.rst:2710
msgid ""
"If *sub* is empty, returns the number of empty slices between characters "
"which is the length of the bytes object plus one."
msgstr ""

#: ../../library/stdtypes.rst:2713 ../../library/stdtypes.rst:2824
#: ../../library/stdtypes.rst:2837 ../../library/stdtypes.rst:2903
#: ../../library/stdtypes.rst:2916
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr ""
"Також прийняти ціле число в діапазоні від 0 до 255 як підпослідовність."

#: ../../library/stdtypes.rst:2720
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr ""
"Якщо двійкові дані починаються з рядка *prefix*, поверніть "
"``bytes[len(prefix):]``. В іншому випадку поверніть копію вихідних двійкових "
"даних::"

#: ../../library/stdtypes.rst:2729
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr "*Префікс* може бути будь-яким :term:`bytes-like object`."

#: ../../library/stdtypes.rst:2733 ../../library/stdtypes.rst:2755
#: ../../library/stdtypes.rst:2888 ../../library/stdtypes.rst:2981
#: ../../library/stdtypes.rst:2995 ../../library/stdtypes.rst:3026
#: ../../library/stdtypes.rst:3040 ../../library/stdtypes.rst:3082
#: ../../library/stdtypes.rst:3152 ../../library/stdtypes.rst:3170
#: ../../library/stdtypes.rst:3198 ../../library/stdtypes.rst:3337
#: ../../library/stdtypes.rst:3392 ../../library/stdtypes.rst:3435
#: ../../library/stdtypes.rst:3456 ../../library/stdtypes.rst:3478
#: ../../library/stdtypes.rst:3680
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"Версія bytearray цього методу *не* працює на місці – вона завжди створює "
"новий об’єкт, навіть якщо не було зроблено жодних змін."

#: ../../library/stdtypes.rst:2742
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""
"Якщо двійкові дані закінчуються рядком *суфікса* і цей *суфікс* не порожній, "
"поверніть ``bytes[:-len(suffix)]``. В іншому випадку поверніть копію "
"вихідних двійкових даних::"

#: ../../library/stdtypes.rst:2751
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr "*Суфіксом* може бути будь-який :term:`bytes-like object`."

#: ../../library/stdtypes.rst:2764
msgid "Return the bytes decoded to a :class:`str`."
msgstr ""

#: ../../library/stdtypes.rst:2769
msgid ""
"*errors* controls how decoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, and any other name registered via :func:"
"`codecs.register_error`. See :ref:`error-handlers` for details."
msgstr ""

#: ../../library/stdtypes.rst:2775
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless a decoding error actually occurs, :ref:`devmode` is enabled or a :ref:"
"`debug build <debug-build>` is used."
msgstr ""

#: ../../library/stdtypes.rst:2781
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary :class:`!"
"bytes` or :class:`!bytearray` object."
msgstr ""

#: ../../library/stdtypes.rst:2796
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Повертає ``True``, якщо двійкові дані закінчуються вказаним *суфіксом*, "
"інакше повертає ``False``. *suffix* також може бути кортежем суфіксів для "
"пошуку. З необов'язковим *початком* тестування починається з цієї позиції. З "
"необов’язковим *end*, припинити порівняння на цій позиції."

#: ../../library/stdtypes.rst:2801
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr "Суфікс(и) для пошуку може бути будь-яким :term:`bytes-like object`."

#: ../../library/stdtypes.rst:2807
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"Повертає найнижчий індекс у даних, де знайдено підпослідовність *sub*, так "
"що *sub* міститься в сегменті ``s[start:end]``. Необов’язкові аргументи "
"*початок* і *кінець* інтерпретуються як у нотації фрагментів. Повертає "
"``-1``, якщо *sub* не знайдено."

#: ../../library/stdtypes.rst:2817
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Метод :meth:`~bytes.find` слід використовувати, лише якщо вам потрібно знати "
"позицію *sub*. Щоб перевірити, чи є *sub* підрядком, скористайтеся "
"оператором :keyword:`in`::"

#: ../../library/stdtypes.rst:2831
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
"Як :meth:`~bytes.find`, але викликає :exc:`ValueError`, коли "
"підпослідовність не знайдено."

#: ../../library/stdtypes.rst:2844
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"Повертає об’єкт bytes або bytearray, який є конкатенацією двійкових "
"послідовностей даних у *iterable*. Помилка :exc:`TypeError` буде викликана, "
"якщо в *iterable* є будь-які значення, які не є :term:`bytes-подібними "
"об’єктами <bytes-like object>`, включаючи об’єкти :class:`str`. Роздільником "
"між елементами є вміст об’єкта bytes або bytearray, що забезпечує цей метод."

#: ../../library/stdtypes.rst:2855
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"Цей статичний метод повертає таблицю перекладу, придатну для :meth:`bytes."
"translate`, яка відобразить кожен символ у *from* на символ у тій же позиції "
"в *to*; *from* і *to* мають бути :term:`байтоподібними об’єктами <bytes-like "
"object>` і мати однакову довжину."

#: ../../library/stdtypes.rst:2866
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"Розділіть послідовність при першому входженні *sep* і поверніть 3-кортеж, що "
"містить частину перед роздільником, сам роздільник або його копію байтового "
"масиву та частину після роздільника. Якщо роздільник не знайдено, поверніть "
"3-кортеж, що містить копію вихідної послідовності, за якою слідують два "
"порожні байти або об’єкти bytearray."

#: ../../library/stdtypes.rst:2873 ../../library/stdtypes.rst:2930
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr "Роздільником для пошуку може бути будь-який :term:`bytes-like object`."

#: ../../library/stdtypes.rst:2879
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"Повертає копію послідовності з заміною всіх входжень підпослідовності *old* "
"на *new*. Якщо вказано необов’язковий аргумент *count*, заміняються лише "
"перші випадки *count*."

#: ../../library/stdtypes.rst:2883
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"Підпослідовністю для пошуку та її заміною може бути будь-який :term:`bytes-"
"like object`."

#: ../../library/stdtypes.rst:2895
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"Повертає найвищий індекс у послідовності, де знайдено підпослідовність "
"*sub*, так що *sub* міститься в ``s[start:end]``. Необов’язкові аргументи "
"*початок* і *кінець* інтерпретуються як у нотації фрагментів. Повернути "
"``-1`` у разі помилки."

#: ../../library/stdtypes.rst:2910
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
"Подібно до :meth:`~bytes.rfind`, але викликає :exc:`ValueError`, коли "
"підпослідовність *sub* не знайдено."

#: ../../library/stdtypes.rst:2923
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"Розділіть послідовність при останньому входженні *sep* і поверніть 3-кортеж, "
"що містить частину перед роздільником, сам роздільник або його копію "
"байтового масиву та частину після роздільника. Якщо роздільник не знайдено, "
"поверніть 3-кортеж, що містить два порожні об’єкти байтів або масиву байтів, "
"а потім копію вихідної послідовності."

#: ../../library/stdtypes.rst:2936
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Повертає ``True``, якщо двійкові дані починаються з указаного *префікса*, "
"інакше повертає ``False``. *префікс* також може бути кортежем префіксів для "
"пошуку. З необов’язковим *початком* тестування починається з цієї позиції. З "
"необов’язковим *end*, припинити порівняння на цій позиції."

#: ../../library/stdtypes.rst:2941
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr "Префікс(и) для пошуку може бути будь-яким :term:`bytes-like object`."

#: ../../library/stdtypes.rst:2947
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"Повертає копію об’єкта bytes або bytearray, де всі байти, що зустрічаються в "
"необов’язковому аргументі *delete*, видаляються, а решта байтів відображено "
"через задану таблицю перекладу, яка має бути об’єктом bytes довжиною 256."

#: ../../library/stdtypes.rst:2952
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"Ви можете використовувати метод :func:`bytes.maketrans` для створення "
"таблиці перекладу."

#: ../../library/stdtypes.rst:2955
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"Встановіть для аргументу *table* значення ``None`` для перекладів, які "
"видаляють лише символи::"

#: ../../library/stdtypes.rst:2961
msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* тепер підтримується як аргумент ключового слова."

#: ../../library/stdtypes.rst:2965
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"Наведені нижче методи для об’єктів bytes і bytearray мають поведінку за "
"замовчуванням, яка передбачає використання ASCII-сумісних двійкових "
"форматів, але все одно їх можна використовувати з довільними двійковими "
"даними шляхом передачі відповідних аргументів. Зауважте, що всі методи "
"bytearray у цьому розділі *не* працюють на місці, а створюють нові об’єкти."

#: ../../library/stdtypes.rst:2974
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Повертає копію об’єкта з центром у послідовності довжиною *шириною*. "
"Доповнення виконується за допомогою вказаного *fillbyte* (за замовчуванням "
"це пробіл ASCII). Для об’єктів :class:`bytes` оригінальна послідовність "
"повертається, якщо *width* менше або дорівнює ``len(s)``."

#: ../../library/stdtypes.rst:2988
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Повертає копію об’єкта, вирівняну за лівим краєм у послідовності довжини "
"*ширина*. Доповнення виконується за допомогою вказаного *fillbyte* (за "
"замовчуванням це пробіл ASCII). Для об’єктів :class:`bytes` вихідна "
"послідовність повертається, якщо *width* менше або дорівнює ``len(s)``."

#: ../../library/stdtypes.rst:3002
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Повертає копію послідовності з видаленими вказаними початковими байтами. "
"Аргумент *chars* є двійковою послідовністю, яка визначає набір значень "
"байтів, які потрібно видалити. Назва вказує на те, що цей метод зазвичай "
"використовується з символами ASCII. Якщо пропущено або ``None``, аргумент "
"*chars* за умовчанням видаляє пробіли ASCII. Аргумент *chars* не є "
"префіксом; навпаки, усі комбінації його значень видаляються:"

#: ../../library/stdtypes.rst:3014
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""
"Двійкова послідовність байтових значень для видалення може бути будь-яким :"
"term:`bytes-like object`. Перегляньте :meth:`~bytes.removeprefix` для "
"методу, який видаляє один рядок префікса, а не весь набір символів. "
"Наприклад::"

#: ../../library/stdtypes.rst:3033
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Повертає копію об’єкта, вирівняну по правому краю в послідовності довжина "
"*ширина*. Доповнення виконується за допомогою вказаного *fillbyte* (за "
"замовчуванням це пробіл ASCII). Для об’єктів :class:`bytes` оригінальна "
"послідовність повертається, якщо *width* менше або дорівнює ``len(s)``."

#: ../../library/stdtypes.rst:3047
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"Розділіть бінарну послідовність на підпослідовності одного типу, "
"використовуючи *sep* як рядок-роздільник. Якщо задано *maxsplit*, "
"виконується щонайбільше *maxsplit* розбиття, *найправіші*. Якщо *sep* не "
"вказано або ``None``, будь-яка підпослідовність, що складається виключно з "
"пробілів ASCII, є роздільником. За винятком розділення справа, :meth:"
"`rsplit` поводиться як :meth:`split`, що детально описано нижче."

#: ../../library/stdtypes.rst:3058
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Повертає копію послідовності з видаленими вказаними кінцевими байтами. "
"Аргумент *chars* є двійковою послідовністю, яка визначає набір значень "
"байтів, які потрібно видалити. Назва вказує на те, що цей метод зазвичай "
"використовується з символами ASCII. Якщо пропущено або ``None``, аргумент "
"*chars* за замовчуванням видаляє пробіли ASCII. Аргумент *chars* не є "
"суфіксом; навпаки, усі комбінації його значень видаляються:"

#: ../../library/stdtypes.rst:3070
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""
"Двійкова послідовність байтових значень для видалення може бути будь-яким :"
"term:`bytes-like object`. Перегляньте :meth:`~bytes.removesuffix`, щоб "
"дізнатися про метод, який видалить один рядок суфікса, а не весь набір "
"символів. Наприклад::"

#: ../../library/stdtypes.rst:3089
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"Розділіть бінарну послідовність на підпослідовності одного типу, "
"використовуючи *sep* як рядок-роздільник. Якщо задано *maxsplit* і воно є "
"невід’ємним, виконується щонайбільше розділень *maxsplit* (отже, список "
"матиме щонайбільше елементів ``maxsplit+1``). Якщо *maxsplit* не вказано або "
"дорівнює ``-1``, тоді немає обмежень на кількість розбивок (виконуються всі "
"можливі розбиття)."

#: ../../library/stdtypes.rst:3095
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of "
"object being split.  The *sep* argument may be any :term:`bytes-like object`."
msgstr ""
"Якщо задано *sep*, послідовні розділювачі не групуються разом і вважаються "
"розмежовуючими порожні підпослідовності (наприклад, ``b'1,,2'.split(b',')`` "
"повертає ``[b'1 ', b'', b'2']``). Аргумент *sep* може складатися з "
"багатобайтової послідовності (наприклад, ``b'1 <> 2 <> 3'.split(b' <> ')`` "
"повертає ``[b'1', b'2', b '3']``). Розділення порожньої послідовності з "
"указаним роздільником повертає ``[b'']`` або ``[bytearray(b'')]`` залежно "
"від типу об’єкта, який розділяється. Аргументом *sep* може бути будь-який :"
"term:`bytes-like object`."

#: ../../library/stdtypes.rst:3113
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"Якщо *sep* не вказано або має значення ``None``, застосовується інший "
"алгоритм поділу: цикли послідовних пробілів ASCII розглядаються як один "
"роздільник, і результат не міститиме порожніх рядків на початку або в кінці, "
"якщо послідовність має пробіли на початку або в кінці. Отже, розділення "
"порожньої послідовності або послідовності, що складається виключно з "
"пробілів ASCII без указаного роздільника, повертає ``[]``."

#: ../../library/stdtypes.rst:3134
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Повертає копію послідовності з вилученими вказаними початковим і кінцевим "
"байтами. Аргумент *chars* є двійковою послідовністю, яка визначає набір "
"значень байтів, які потрібно видалити. Назва вказує на те, що цей метод "
"зазвичай використовується з символами ASCII. Якщо пропущено або ``None``, "
"аргумент *chars* за замовчуванням видаляє пробіли ASCII. Аргумент *chars* не "
"є префіксом або суфіксом; навпаки, усі комбінації його значень видаляються:"

#: ../../library/stdtypes.rst:3147
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"Двійкова послідовність байтових значень для видалення може бути будь-яким :"
"term:`bytes-like object`."

#: ../../library/stdtypes.rst:3156
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"Наступні методи для об’єктів bytes і bytearray передбачають використання "
"двійкових форматів, сумісних із ASCII, і їх не слід застосовувати до "
"довільних двійкових даних. Зауважте, що всі методи bytearray у цьому розділі "
"*не* працюють на місці, а створюють нові об’єкти."

#: ../../library/stdtypes.rst:3164
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"Повертає копію послідовності з кожним байтом, інтерпретованим як символ "
"ASCII, і перший байт у великому регістрі, а решта – у нижньому. Байтові "
"значення, відмінні від ASCII, передаються без змін."

#: ../../library/stdtypes.rst:3177
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"Повертає копію послідовності, де всі символи табуляції ASCII замінено одним "
"або декількома пробілами ASCII, залежно від поточного стовпця та заданого "
"розміру табуляції. Позиції табуляції відбуваються кожні байти *табуляції* "
"(за замовчуванням — 8, надаючи позиції табуляції в стовпцях 0, 8, 16 і так "
"далі). Щоб розширити послідовність, поточний стовпець встановлюється на нуль "
"і послідовність перевіряється побайтно. Якщо байт є символом табуляції ASCII "
"(``b'\\t'``), один або більше символів пробілу вставляються в результат, "
"доки поточний стовпець не буде відповідати наступній позиції табуляції. (Сам "
"символ табуляції не копіюється.) Якщо поточний байт є ASCII символом нового "
"рядка (``b'\\n'``) або поверненням каретки (``b'\\r'``), він копіюється і "
"поточний стовпець скидається на нуль. Будь-яке інше значення байта "
"копіюється без змін, а поточний стовпець збільшується на одиницю незалежно "
"від того, як значення байта представлено під час друку::"

#: ../../library/stdtypes.rst:3205
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Повертає ``True``, якщо всі байти в послідовності є алфавітними символами "
"ASCII або десятковими цифрами ASCII і послідовність не є порожньою, "
"``False`` інакше. Алфавітні символи ASCII – це значення байтів у "
"послідовності ``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``. "
"Десяткові цифри ASCII – це значення байтів у послідовності ``b'0123456789``."

#: ../../library/stdtypes.rst:3222
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Повертає ``True``, якщо всі байти в послідовності є алфавітними символами "
"ASCII і послідовність не є пустою, ``False`` інакше. Алфавітні символи ASCII "
"– це значення байтів у послідовності "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``."

#: ../../library/stdtypes.rst:3238
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"Повертає ``True``, якщо послідовність порожня або всі байти в послідовності "
"ASCII, ``False`` інакше. Байти ASCII знаходяться в діапазоні 0-0x7F."

#: ../../library/stdtypes.rst:3248
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Повертає ``True``, якщо всі байти в послідовності є десятковими цифрами "
"ASCII і послідовність не порожня, ``False`` інакше. Десяткові цифри ASCII – "
"це значення байтів у послідовності ``b'0123456789``."

#: ../../library/stdtypes.rst:3263
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо в послідовності є принаймні один символ нижнього "
"регістру ASCII і немає символів ASCII у верхньому регістрі, інакше ``False``."

#: ../../library/stdtypes.rst:3273 ../../library/stdtypes.rst:3315
#: ../../library/stdtypes.rst:3331 ../../library/stdtypes.rst:3381
#: ../../library/stdtypes.rst:3450
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Символи ASCII у нижньому регістрі – це значення байтів у послідовності "
"``b'abcdefghijklmnopqrstuvwxyz``. Символи ASCII у верхньому регістрі – це "
"значення байтів у послідовності ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ``."

#: ../../library/stdtypes.rst:3281
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Повертає ``True``, якщо всі байти в послідовності є пробілами ASCII і "
"послідовність не порожня, ``False`` інакше. Пробільні символи ASCII – це "
"значення байтів у послідовності ``b' \\t\\n\\r\\x0b\\f''`` (пробіл, "
"табуляція, новий рядок, повернення каретки, вертикальна табуляція, передача "
"форми)."

#: ../../library/stdtypes.rst:3290
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Повертає ``True``, якщо послідовність має регістр заголовків ASCII і "
"послідовність не є порожньою, ``False`` інакше. Дивіться :meth:`bytes."
"title`, щоб дізнатися більше про визначення \"заголовка\"."

#: ../../library/stdtypes.rst:3305
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""
"Повертає ``True``, якщо в послідовності є принаймні один символ ASCII у "
"верхньому регістрі та відсутні символи ASCII у нижньому регістрі, інакше "
"``False``."

#: ../../library/stdtypes.rst:3323
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"Повертає копію послідовності з усіма символами ASCII у верхньому регістрі, "
"перетвореними на їхні відповідні відповідники у нижньому регістрі."

#: ../../library/stdtypes.rst:3348
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"Повертає список рядків у двійковій послідовності, розриваючи межі рядків "
"ASCII. Цей метод використовує підхід :term:`universal newlines` до "
"розділення рядків. Розриви рядків не включаються до результуючого списку, "
"якщо не задано *keepends* і воно є істинним."

#: ../../library/stdtypes.rst:3360
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"На відміну від :meth:`~bytes.split`, коли задано рядок розділювача *sep*, "
"цей метод повертає порожній список для порожнього рядка, а розрив кінцевого "
"рядка не призводить до додаткового рядка::"

#: ../../library/stdtypes.rst:3373
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Повертає копію послідовності з усіма символами нижнього регістру ASCII, "
"перетвореними на їхні відповідні відповідники у верхньому регістрі та "
"навпаки."

#: ../../library/stdtypes.rst:3385
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
"На відміну від :func:`str.swapcase()`, це завжди так, що ``bin.swapcase()."
"swapcase() == bin`` для бінарних версій. Перетворення регістру є симетричним "
"у ASCII, навіть якщо це зазвичай не вірно для довільних кодових точок "
"Unicode."

#: ../../library/stdtypes.rst:3399
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"Повертає версію двійкової послідовності в заголовку, де слова починаються з "
"символу ASCII у верхньому регістрі, а решта символів – у нижньому регістрі. "
"Значення байтів без регістру залишаються незмінними."

#: ../../library/stdtypes.rst:3408
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"Символи ASCII у нижньому регістрі – це значення байтів у послідовності "
"``b'abcdefghijklmnopqrstuvwxyz``. Символи ASCII у верхньому регістрі – це "
"значення байтів у послідовності ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ``. Усі інші "
"значення байтів без регістру."

#: ../../library/stdtypes.rst:3421
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Обхідний шлях для апострофів можна створити за допомогою регулярних виразів:"

#: ../../library/stdtypes.rst:3442
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"Повертає копію послідовності з усіма символами нижнього регістру ASCII, "
"перетвореними на їхні відповідні відповідники у верхньому регістрі."

#: ../../library/stdtypes.rst:3463
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"Поверніть копію послідовності зліва, заповнену цифрами ASCII ``b'0``, щоб "
"створити послідовність довжиною *ширина*. Початковий префікс знака "
"(``b'+'``/ ``b'-'``) обробляється шляхом вставки заповнення *після* символу "
"знака, а не перед ним. Для об’єктів :class:`bytes` оригінальна послідовність "
"повертається, якщо *width* менше або дорівнює ``len(seq)``."

#: ../../library/stdtypes.rst:3485
msgid "``printf``-style Bytes Formatting"
msgstr "Форматування байтів у стилі ``printf``"

#: ../../library/stdtypes.rst:3502
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"Операції форматування, описані тут, демонструють різноманітні особливості, "
"які призводять до низки поширених помилок (наприклад, неправильне "
"відображення кортежів і словників). Якщо значення, яке друкується, може бути "
"кортежем або словником, оберніть його в кортеж."

#: ../../library/stdtypes.rst:3507
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"Об’єкти Bytes (``bytes``/``bytearray``) мають одну унікальну вбудовану "
"операцію: оператор ``%`` (за модулем). Це також відоме як оператор "
"*форматування* або *інтерполяції* байтів. Враховуючи ``формат % значень`` "
"(де *format* є об’єктом байтів), ``%`` специфікації перетворення у *format* "
"замінюються нулем або більше елементами *значень*. Ефект подібний до "
"використання :c:func:`sprintf` у мові C."

#: ../../library/stdtypes.rst:3514
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Якщо для *format* потрібен один аргумент, *values* може бути одним "
"некортежним об’єктом. [5]_ В іншому випадку *values* має бути кортежем із "
"точною кількістю елементів, указаною об’єктом format bytes, або одним "
"об’єктом відображення (наприклад, словником)."

#: ../../library/stdtypes.rst:3548
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Коли правильний аргумент є словником (або іншим типом відображення), тоді "
"формати в об’єкті bytes *мають* містити ключ відображення в дужках у цьому "
"словнику, вставлений відразу після символу ``'%'``. Ключ відображення "
"вибирає значення, яке потрібно відформатувати, із відображення. Наприклад:"

#: ../../library/stdtypes.rst:3622
msgid "Single byte (accepts integer or single byte objects)."
msgstr "Однобайтовий (приймає цілі чи однобайтові об’єкти)."

#: ../../library/stdtypes.rst:3625
msgid "``'b'``"
msgstr "``'b''``"

#: ../../library/stdtypes.rst:3625
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`__bytes__`)."
msgstr ""
"Байти (будь-який об’єкт, який відповідає :ref:`протоколу буфера "
"<bufferobjects>` або має :meth:`__bytes__`)."

#: ../../library/stdtypes.rst:3629
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'s''`` є псевдонімом для ``'b''`` і має використовуватися лише для "
"базового коду Python2/3."

#: ../../library/stdtypes.rst:3632
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""
"Байти (перетворює будь-який об’єкт Python за допомогою ``repr(obj)."
"encode('ascii', 'backslashreplace')``)."

#: ../../library/stdtypes.rst:3635
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'r'`` є псевдонімом для ``'a'`` і має використовуватися лише для базових "
"кодів Python2/3."

#: ../../library/stdtypes.rst:3635
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/stdtypes.rst:3670
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s`` є застарілим, але не буде видалено протягом серії 3.x."

#: ../../library/stdtypes.rst:3673
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r''`` є застарілим, але не буде видалено протягом серії 3.x."

#: ../../library/stdtypes.rst:3685
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - Додано форматування % до байтів і масиву байтів"

#: ../../library/stdtypes.rst:3692
msgid "Memory Views"
msgstr "Перегляди пам'яті"

#: ../../library/stdtypes.rst:3694
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
"Об’єкти :class:`memoryview` дозволяють коду Python отримувати доступ до "
"внутрішніх даних об’єкта, який підтримує :ref:`протокол буфера "
"<bufferobjects>` без копіювання."

#: ../../library/stdtypes.rst:3700
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""
"Створіть :class:`memoryview`, який посилається на *об’єкт*. *об’єкт* має "
"підтримувати протокол буфера. Вбудовані об’єкти, які підтримують протокол "
"буфера, включають :class:`bytes` і :class:`bytearray`."

#: ../../library/stdtypes.rst:3704
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such "
"as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""
":class:`memoryview` має поняття *елемента*, який є атомарною одиницею "
"пам’яті, яка обробляється вихідним *об’єктом*. Для багатьох простих типів, "
"таких як :class:`bytes` і :class:`bytearray`, елемент є одним байтом, але "
"інші типи, такі як :class:`array.array`, можуть мати більші елементи."

#: ../../library/stdtypes.rst:3709
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the view. "
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""

#: ../../library/stdtypes.rst:3716
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
":class:`memoryview` підтримує нарізку та індексування для показу своїх "
"даних. Одновимірне нарізання призведе до підвиду::"

#: ../../library/stdtypes.rst:3729
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"Якщо :class:`~memoryview.format` є одним із власних специфікаторів формату з "
"модуля :mod:`struct`, індексація за допомогою цілого числа або кортежу цілих "
"чисел також підтримується та повертає один *елемент* із правильним типом . "
"Одновимірні представлення пам'яті можна індексувати за допомогою цілого або "
"одноцілого кортежу. Багатовимірні представлення пам’яті можна індексувати за "
"допомогою кортежів з точно *ndim* цілих чисел, де *ndim* є кількістю "
"вимірів. Нульвимірні представлення пам'яті можна індексувати за допомогою "
"порожнього кортежу."

#: ../../library/stdtypes.rst:3738
msgid "Here is an example with a non-byte format::"
msgstr "Ось приклад небайтового формату::"

#: ../../library/stdtypes.rst:3750
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"Якщо основний об’єкт доступний для запису, memoryview підтримує одновимірне "
"призначення фрагментів. Зміна розміру заборонена::"

#: ../../library/stdtypes.rst:3771
msgid ""
"One-dimensional memoryviews of :term:`hashable` (read-only) types with "
"formats 'B', 'b' or 'c' are also hashable. The hash is defined as ``hash(m) "
"== hash(m.tobytes())``::"
msgstr ""

#: ../../library/stdtypes.rst:3783
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now :term:`hashable`."
msgstr ""

#: ../../library/stdtypes.rst:3787
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"memoryview тепер автоматично реєструється в :class:`collections.abc.Sequence`"

#: ../../library/stdtypes.rst:3791
msgid "memoryviews can now be indexed with tuple of integers."
msgstr "memoryviews тепер можна індексувати кортежем цілих чисел."

#: ../../library/stdtypes.rst:3794
msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` має кілька методів:"

#: ../../library/stdtypes.rst:3798
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"Memoriview і експортер :pep:`3118` є рівними, якщо їхні форми еквівалентні "
"та якщо всі відповідні значення рівні, коли відповідні коди формату "
"операндів інтерпретуються за допомогою синтаксису :mod:`struct`."

#: ../../library/stdtypes.rst:3802
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"Для підмножини рядків формату :mod:`struct`, які зараз підтримуються :meth:"
"`tolist`, ``v`` і ``w`` рівні, якщо ``v.tolist() == w.tolist()``::"

#: ../../library/stdtypes.rst:3821
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"Якщо будь-який рядок формату не підтримується модулем :mod:`struct`, тоді "
"об’єкти завжди порівнюватимуться як нерівні (навіть якщо рядки формату та "
"вміст буфера ідентичні)::"

#: ../../library/stdtypes.rst:3837
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"Зауважте, що, як і у випадку з числами з плаваючою комою, ``v є w`` *не* "
"означає ``v == w`` для об'єктів memoryview."

#: ../../library/stdtypes.rst:3840
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"Попередні версії порівнювали необроблену пам’ять без урахування формату "
"елемента та логічної структури масиву."

#: ../../library/stdtypes.rst:3846
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Повертає дані в буфері як байтовий рядок. Це еквівалентно виклику "
"конструктора :class:`bytes` у memoryview. ::"

#: ../../library/stdtypes.rst:3855
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"Для несуміжних масивів результат дорівнює представленню зведеного списку з "
"усіма елементами, перетвореними на байти. :meth:`tobytes` підтримує всі "
"рядки формату, включно з тими, яких немає в синтаксисі модуля :mod:`struct`."

#: ../../library/stdtypes.rst:3860
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""
"*порядок* може бути {'C', 'F', 'A'}. Якщо *порядок* має значення \"C\" або "
"\"F\", дані вихідного масиву перетворюються на порядок C або Fortran. Для "
"суміжних переглядів \"A\" повертає точну копію фізичної пам’яті. Зокрема, "
"зберігається порядок Fortran у пам'яті. Для несуміжних переглядів дані "
"спочатку перетворюються на C. *order=None* те саме, що *order='C'*."

#: ../../library/stdtypes.rst:3869
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""
"Повертає рядковий об’єкт, що містить дві шістнадцяткові цифри для кожного "
"байта в буфері. ::"

#: ../../library/stdtypes.rst:3878
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"Подібно до :meth:`bytes.hex`, :meth:`memoryview.hex` тепер підтримує "
"додаткові параметри *sep* і *bytes_per_sep* для вставки роздільників між "
"байтами в шістнадцятковому виведенні."

#: ../../library/stdtypes.rst:3885
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "Повертає дані в буфері як список елементів. ::"

#: ../../library/stdtypes.rst:3895
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""
":meth:`tolist` тепер підтримує всі односимвольні рідні формати в синтаксисі "
"модуля :mod:`struct`, а також багатовимірні представлення."

#: ../../library/stdtypes.rst:3902
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""
"Повертає версію об’єкта memoryview лише для читання. Оригінальний об’єкт "
"memoryview не змінено. ::"

#: ../../library/stdtypes.rst:3921
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"Вивільніть базовий буфер, відкритий об’єктом memoryview. Багато об’єктів "
"виконують спеціальні дії, коли їх переглядають (наприклад, :class:"
"`bytearray` тимчасово забороняє зміну розміру); отже, виклик release() є "
"зручним, щоб усунути ці обмеження (і звільнити будь-які завислі ресурси) "
"якомога швидше."

#: ../../library/stdtypes.rst:3927
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""
"Після виклику цього методу будь-яка подальша операція з представленням "
"викликає помилку :class:`ValueError` (крім самого :meth:`release()`, який "
"можна викликати кілька разів)::"

#: ../../library/stdtypes.rst:3938
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"Протокол керування контекстом може бути використаний для подібного ефекту, "
"використовуючи оператор ``with``::"

#: ../../library/stdtypes.rst:3954
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"Транслюйте пам’ять у новий формат або форму. *shape* за умовчанням має "
"значення ``[byte_length//new_itemsize]``, що означає, що перегляд результату "
"буде одновимірним. Поверненим значенням є новий перегляд пам’яті, але сам "
"буфер не копіюється. Підтримувані приведення: 1D -> C-:term:`contiguous` і C-"
"contiguous -> 1D."

#: ../../library/stdtypes.rst:3960
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length. "
"Note that all byte lengths may depend on the operating system."
msgstr ""

#: ../../library/stdtypes.rst:3966
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "Перетворення 1D/long на 1D/беззнакові байти::"

#: ../../library/stdtypes.rst:3989
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "Перетворення 1D/беззнакових байтів у 1D/char::"

#: ../../library/stdtypes.rst:4002
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "Перетворити 1D/байти на 3D/ints на 1D/signed char::"

#: ../../library/stdtypes.rst:4028
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "Перетворення 1D/unsigned long на 2D/unsigned long ::"

#: ../../library/stdtypes.rst:4042
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"Вихідний формат більше не обмежений під час трансляції до байтового "
"перегляду."

#: ../../library/stdtypes.rst:4045
msgid "There are also several readonly attributes available:"
msgstr "Також є кілька доступних атрибутів лише для читання:"

#: ../../library/stdtypes.rst:4049
msgid "The underlying object of the memoryview::"
msgstr "Основний об’єкт memoryview::"

#: ../../library/stdtypes.rst:4060
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. Це обсяг "
"простору в байтах, який буде використовуватися масивом у безперервному "
"представленні. Воно не обов’язково дорівнює ``len(m)``::"

#: ../../library/stdtypes.rst:4079
msgid "Multi-dimensional arrays::"
msgstr "Багатовимірні масиви::"

#: ../../library/stdtypes.rst:4096
msgid "A bool indicating whether the memory is read only."
msgstr "Bool, що вказує, чи є пам’ять лише для читання."

#: ../../library/stdtypes.rst:4100
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"Рядок, що містить формат (у стилі модуля :mod:`struct`) для кожного елемента "
"в поданні. Огляд пам’яті можна створити з експортерів із довільними рядками "
"формату, але деякі методи (наприклад, :meth:`tolist`) обмежені рідними "
"одноелементними форматами."

#: ../../library/stdtypes.rst:4105
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"формат ``'B'`` тепер обробляється відповідно до синтаксису модуля struct. Це "
"означає, що ``memoryview(b'abc')[0] == b'abc'[0] == 97``."

#: ../../library/stdtypes.rst:4111
msgid "The size in bytes of each element of the memoryview::"
msgstr "Розмір у байтах кожного елемента memoryview::"

#: ../../library/stdtypes.rst:4124
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Ціле число, що вказує, скільки вимірів багатовимірного масиву представляє "
"пам’ять."

#: ../../library/stdtypes.rst:4129
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"Кортеж цілих чисел довжиною :attr:`ndim`, що надає форму пам’яті як N-"
"вимірного масиву."

#: ../../library/stdtypes.rst:4132 ../../library/stdtypes.rst:4140
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "Порожній кортеж замість ``None``, коли ndim = 0."

#: ../../library/stdtypes.rst:4137
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"Кортеж цілих чисел довжиною :attr:`ndim`, що вказує розмір у байтах для "
"доступу до кожного елемента для кожного виміру масиву."

#: ../../library/stdtypes.rst:4145
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""
"Використовується внутрішньо для масивів у стилі PIL. Значення лише "
"інформаційне."

#: ../../library/stdtypes.rst:4149
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "Логічне значення, яке вказує, чи є пам’ять C-:term:`contiguous`."

#: ../../library/stdtypes.rst:4155
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "Логічне значення, що вказує, чи є пам’ять Fortran :term:`contiguous`."

#: ../../library/stdtypes.rst:4161
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "Bool, що вказує, чи є пам’ять :term:`contiguous`."

#: ../../library/stdtypes.rst:4169
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Типи наборів --- :class:`set`, :class:`frozenset`"

#: ../../library/stdtypes.rst:4173
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Об’єкт :dfn:`set` — це невпорядкована колекція окремих об’єктів :term:"
"`hashable`. Загальне використання включає тестування членства, видалення "
"дублікатів із послідовності та обчислення математичних операцій, таких як "
"перетин, об’єднання, різниця та симетрична різниця. (Для інших контейнерів "
"перегляньте вбудовані класи :class:`dict`, :class:`list` і :class:`tuple`, а "
"також модуль :mod:`collections`.)"

#: ../../library/stdtypes.rst:4180
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Як і інші колекції, набори підтримують ``x in set``, ``len(set)`` і ``for x "
"in set``. Будучи невпорядкованою колекцією, набори не записують положення "
"елемента або порядок вставки. Відповідно, набори не підтримують "
"індексування, нарізку чи іншу поведінку, подібну до послідовності."

#: ../../library/stdtypes.rst:4185
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"Наразі існує два вбудовані типи наборів: :class:`set` і :class:`frozenset`. "
"Тип :class:`set` є змінним --- вміст можна змінити за допомогою таких "
"методів, як :meth:`~set.add` і :meth:`~set.remove`. Оскільки він є змінним, "
"він не має хеш-значення і не може використовуватися ні як ключ словника, ні "
"як елемент іншого набору. Тип :class:`frozenset` є незмінним і :term:"
"`hashable` --- його вміст не можна змінити після створення; тому його можна "
"використовувати як ключ до словника або як елемент іншого набору."

#: ../../library/stdtypes.rst:4193
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"Непорожні набори (не заморожені набори) можна створити шляхом розміщення "
"списку елементів, розділених комами, у фігурних дужках, наприклад: "
"``{'jack', 'sjoerd'}``, на додаток до :class:`set` конструктор."

#: ../../library/stdtypes.rst:4197
msgid "The constructors for both classes work the same:"
msgstr "Конструктори для обох класів працюють однаково:"

#: ../../library/stdtypes.rst:4202
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Повертає новий набір або заморожений об’єкт, елементи якого взяті з "
"*iterable*. Елементи набору мають бути :term:`hashable`. Щоб представити "
"набори наборів, внутрішні набори мають бути об’єктами :class:`frozenset`. "
"Якщо *iterable* не вказано, повертається новий порожній набір."

#: ../../library/stdtypes.rst:4208
msgid "Sets can be created by several means:"
msgstr "Набори можна створювати кількома способами:"

#: ../../library/stdtypes.rst:4210
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr ""
"Використовуйте список елементів, розділених комами, у фігурних дужках: "
"``{'jack', 'sjoerd'}``"

#: ../../library/stdtypes.rst:4211
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr ""
"Використовуйте розуміння набору: ``{c для c в 'abracadabra' якщо c не в "
"'abc'}``"

#: ../../library/stdtypes.rst:4212
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""
"Використовуйте конструктор типу: ``set()``, ``set('foobar')``, ``set(['a', "
"'b', 'foo'])``"

#: ../../library/stdtypes.rst:4214
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"Екземпляри :class:`set` і :class:`frozenset` забезпечують такі операції:"

#: ../../library/stdtypes.rst:4219
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "Повертає кількість елементів у наборі *s* (мощність *s*)."

#: ../../library/stdtypes.rst:4223
msgid "Test *x* for membership in *s*."
msgstr "Перевірте *x* на членство в *s*."

#: ../../library/stdtypes.rst:4227
msgid "Test *x* for non-membership in *s*."
msgstr "Перевірте *x* на неналежність до *s*."

#: ../../library/stdtypes.rst:4231
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Повертає ``True``, якщо набір не має спільних елементів з *other*. Множини "
"непересічні тоді і тільки тоді, коли їх перетин є порожньою множиною."

#: ../../library/stdtypes.rst:4237
msgid "Test whether every element in the set is in *other*."
msgstr "Перевірте, чи кожен елемент у наборі знаходиться в *other*."

#: ../../library/stdtypes.rst:4241
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Перевірте, чи набір є правильною підмножиною *other*, тобто ``set <= other і "
"set != other``."

#: ../../library/stdtypes.rst:4247
msgid "Test whether every element in *other* is in the set."
msgstr "Перевірте, чи всі елементи в *other* є в наборі."

#: ../../library/stdtypes.rst:4251
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Перевірте, чи є набір правильною надмножиною *other*, тобто ``set >= other і "
"set != other``."

#: ../../library/stdtypes.rst:4257
msgid "Return a new set with elements from the set and all others."
msgstr "Повернути новий набір з елементами з набору та всі інші."

#: ../../library/stdtypes.rst:4262
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Повертає новий набір із елементами, спільними для набору та всіх інших."

#: ../../library/stdtypes.rst:4267
msgid "Return a new set with elements in the set that are not in the others."
msgstr "Повертає новий набір з елементами в наборі, яких немає в інших."

#: ../../library/stdtypes.rst:4272
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Повертає новий набір з елементами або в наборі, або в *іншому*, але не в "
"обох."

#: ../../library/stdtypes.rst:4276
msgid "Return a shallow copy of the set."
msgstr "Поверніть мілку копію набору."

#: ../../library/stdtypes.rst:4279
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and :meth:"
"`issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of "
"the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Зауважте, версії без операторів :meth:`union`, :meth:`intersection`, :meth:"
"`difference`, :meth:`symmetric_difference`, :meth:`issubset` і :meth:"
"`issuperset` методи приймуть будь-яку ітерацію як аргумент. На відміну від "
"цього, їхні аналоги на основі операторів вимагають, щоб їхні аргументи були "
"наборами. Це виключає такі схильні до помилок конструкції, як ``set('abc') & "
"'cbs'`` на користь більш читабельного ``set('abc').intersection('cbs')``."

#: ../../library/stdtypes.rst:4286
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"І :class:`set`, і :class:`frozenset` підтримують набір для встановлення "
"порівнянь. Дві множини рівні тоді і тільки тоді, коли кожен елемент кожної "
"множини міститься в іншій (кожен є підмножиною іншого). Набір менший за "
"інший набір тоді і тільки тоді, коли перший набір є належним підмножиною "
"другого набору (є підмножиною, але не дорівнює). Набір більший за інший "
"набір тоді і тільки тоді, коли перший набір є належним надмножиною другого "
"набору (є надмножиною, але не є рівним)."

#: ../../library/stdtypes.rst:4293
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Примірники :class:`set` порівнюються з примірниками :class:`frozenset` на "
"основі їхніх членів. Наприклад, ``set('abc') == frozenset('abc')`` повертає "
"``True``, а також ``set('abc')`` у ``set([frozenset('abc')])``."

#: ../../library/stdtypes.rst:4297
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"Порівняння підмножини та рівності не узагальнюють до загальної функції "
"впорядкування. Наприклад, будь-які дві непорожні непересічні множини не "
"рівні і не є підмножинами одна одної, тому *всі* з наступного повертають "
"``False``: ``a <b``, ``a==b``, or ``a> b``."

#: ../../library/stdtypes.rst:4302
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Оскільки набори визначають лише часткове впорядкування (відносини "
"підмножин), вихід методу :meth:`list.sort` не визначений для списків наборів."

#: ../../library/stdtypes.rst:4305
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr "Елементи набору, як і ключі словника, мають бути :term:`hashable`."

#: ../../library/stdtypes.rst:4307
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Бінарні операції, які поєднують екземпляри :class:`set` із :class:"
"`frozenset`, повертають тип першого операнда. Наприклад: ``frozenset('ab') | "
"set('bc')`` повертає екземпляр :class:`frozenset`."

#: ../../library/stdtypes.rst:4311
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"У наступній таблиці наведено операції, доступні для :class:`set`, які не "
"застосовуються до незмінних екземплярів :class:`frozenset`:"

#: ../../library/stdtypes.rst:4317
msgid "Update the set, adding elements from all others."
msgstr "Оновіть набір, додавши елементи з усіх інших."

#: ../../library/stdtypes.rst:4322
msgid "Update the set, keeping only elements found in it and all others."
msgstr "Оновіть набір, зберігаючи лише елементи, знайдені в ньому, і всі інші."

#: ../../library/stdtypes.rst:4327
msgid "Update the set, removing elements found in others."
msgstr "Оновіть набір, видаляючи елементи, знайдені в інших."

#: ../../library/stdtypes.rst:4332
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Оновіть набір, зберігаючи лише елементи, знайдені в будь-якому наборі, але "
"не в обох."

#: ../../library/stdtypes.rst:4336
msgid "Add element *elem* to the set."
msgstr "Додайте елемент *elem* до набору."

#: ../../library/stdtypes.rst:4340
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Видалити елемент *elem* із набору. Викликає :exc:`KeyError`, якщо *elem* не "
"міститься в наборі."

#: ../../library/stdtypes.rst:4345
msgid "Remove element *elem* from the set if it is present."
msgstr "Видалити елемент *elem* із набору, якщо він присутній."

#: ../../library/stdtypes.rst:4349
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Вилучити та повернути довільний елемент із набору. Викликає :exc:`KeyError`, "
"якщо набір порожній."

#: ../../library/stdtypes.rst:4354
msgid "Remove all elements from the set."
msgstr "Видаліть усі елементи з набору."

#: ../../library/stdtypes.rst:4357
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Зауважте, що безоператорні версії методів :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update` і :meth:"
"`symmetric_difference_update` прийматимуть будь-яку ітерацію як аргумент."

#: ../../library/stdtypes.rst:4362
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""
"Зауважте, що аргумент *elem* для методів :meth:`__contains__`, :meth:"
"`remove` і :meth:`discard` може бути набором. Щоб підтримувати пошук "
"еквівалентного замороженого набору, тимчасовий набір створюється з *elem*."

#: ../../library/stdtypes.rst:4370
msgid "Mapping Types --- :class:`dict`"
msgstr "Типи зіставлення --- :class:`dict`"

#: ../../library/stdtypes.rst:4380
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Об’єкт :term:`mapping` відображає значення :term:`hashable` на довільні "
"об’єкти. Відображення є змінними об'єктами. Зараз існує лише один "
"стандартний тип відображення, :dfn:`dictionary`. (Для інших контейнерів "
"перегляньте вбудовані класи :class:`list`, :class:`set` і :class:`tuple`, а "
"також модуль :mod:`collections`.)"

#: ../../library/stdtypes.rst:4386
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys. Values that compare equal (such as ``1``, ``1.0``, "
"and ``True``) can be used interchangeably to index the same dictionary entry."
msgstr ""

#: ../../library/stdtypes.rst:4397
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"Повертає новий словник, ініціалізований необов’язковим позиційним аргументом "
"і, можливо, порожнім набором ключових аргументів."

#: ../../library/stdtypes.rst:4400
msgid "Dictionaries can be created by several means:"
msgstr "Словники можна створювати кількома способами:"

#: ../../library/stdtypes.rst:4402
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"Використовуйте розділений комами список пар ``ключ: значення`` у дужках: "
"``{'jack': 4098, 'sjoerd': 4127}`` або ``{4098: 'jack', 4127: 'sjoerd' }``"

#: ../../library/stdtypes.rst:4404
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr ""
"Використовуйте розуміння диктового слова: ``{}``, ``{x: x ** 2 для x в "
"діапазоні (10)}``"

#: ../../library/stdtypes.rst:4405
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""
"Використовуйте конструктор типу: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"

#: ../../library/stdtypes.rst:4408
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"Якщо позиційний аргумент не задано, створюється порожній словник. Якщо "
"вказано позиційний аргумент і він є об’єктом відображення, словник "
"створюється з тими самими парами ключ-значення, що й об’єкт відображення. В "
"іншому випадку позиційний аргумент має бути об’єктом :term:`iterable`. Кожен "
"елемент у ітераторі повинен сам бути ітератором із рівно двома об’єктами. "
"Перший об’єкт кожного елемента стає ключем у новому словнику, а другий "
"об’єкт – відповідним значенням. Якщо ключ зустрічається більше одного разу, "
"останнє значення цього ключа стає відповідним значенням у новому словнику."

#: ../../library/stdtypes.rst:4418
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"Якщо надано аргументи ключового слова, аргументи ключового слова та їхні "
"значення додаються до словника, створеного з позиційного аргументу. Якщо "
"ключ, який додається, уже присутній, значення з аргументу ключового слова "
"замінює значення з позиційного аргументу."

#: ../../library/stdtypes.rst:4423
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Для ілюстрації, усі наступні приклади повертають словник, що дорівнює "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"

#: ../../library/stdtypes.rst:4435
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Надання аргументів ключових слів, як у першому прикладі, працює лише для "
"ключів, які є дійсними ідентифікаторами Python. В іншому випадку можна "
"використовувати будь-які дійсні ключі."

#: ../../library/stdtypes.rst:4439
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Це операції, які підтримують словники (і, отже, також повинні підтримуватися "
"спеціальні типи зіставлення):"

#: ../../library/stdtypes.rst:4444
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "Повернути список усіх ключів, які використовуються у словнику *d*."

#: ../../library/stdtypes.rst:4448
msgid "Return the number of items in the dictionary *d*."
msgstr "Повернути кількість елементів у словнику *d*."

#: ../../library/stdtypes.rst:4452
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"Поверніть елемент *d* за допомогою ключа *key*. Викликає :exc:`KeyError`, "
"якщо *key* немає на карті."

#: ../../library/stdtypes.rst:4457
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"Якщо підклас dict визначає метод :meth:`__missing__` і *key* відсутній, "
"операція ``d[key]`` викликає цей метод із ключем *key* як аргументом. Потім "
"операція ``d[key]`` повертає або викликає все, що повертається або "
"викликається викликом ``__missing__(key)``. Жодні інші операції чи методи не "
"викликають :meth:`__missing__`. Якщо :meth:`__missing__` не визначено, "
"виникає :exc:`KeyError`. :meth:`__missing__` має бути методом; це не може "
"бути змінна екземпляра::"

#: ../../library/stdtypes.rst:4475
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"Наведений вище приклад показує частину реалізації :class:`collections."
"Counter`. Інший метод ``__missing__`` використовується :class:`collections."
"defaultdict`."

#: ../../library/stdtypes.rst:4481
msgid "Set ``d[key]`` to *value*."
msgstr "Установіть для ``d[key]`` значення *value*."

#: ../../library/stdtypes.rst:4485
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"Видаліть ``d[key]`` з *d*. Викликає :exc:`KeyError`, якщо *key* немає на "
"карті."

#: ../../library/stdtypes.rst:4490
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "Повертає ``True``, якщо *d* має ключ *key*, інакше ``False``."

#: ../../library/stdtypes.rst:4494
msgid "Equivalent to ``not key in d``."
msgstr "Еквівалент ``не вводити d``."

#: ../../library/stdtypes.rst:4498
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Повертає ітератор над ключами словника. Це ярлик для ``iter(d.keys())``."

#: ../../library/stdtypes.rst:4503
msgid "Remove all items from the dictionary."
msgstr "Видаліть усі елементи зі словника."

#: ../../library/stdtypes.rst:4507
msgid "Return a shallow copy of the dictionary."
msgstr "Поверніть мілку копію словника."

#: ../../library/stdtypes.rst:4511
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"Створіть новий словник із ключами з *iterable* і значеннями, встановленими "
"на *value*."

#: ../../library/stdtypes.rst:4513
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""
":meth:`fromkeys` — це метод класу, який повертає новий словник. *value* за "
"замовчуванням ``None``. Усі значення стосуються лише одного екземпляра, тому "
"загалом не має сенсу, щоб *value* було змінним об’єктом, таким як порожній "
"список. Щоб отримати різні значення, замість цього використовуйте :ref:`dict "
"comprehension <dict>`."

#: ../../library/stdtypes.rst:4521
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Повертає значення для *key*, якщо *key* є в словнику, інакше *за "
"замовчуванням*. Якщо *default* не вказано, за замовчуванням буде ``None``, "
"тому цей метод ніколи не викликає :exc:`KeyError`."

#: ../../library/stdtypes.rst:4527
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"Повертає нове подання елементів словника (пари \"(ключ, значення)\"). "
"Перегляньте :ref:`документацію об’єктів перегляду <dict-views>`."

#: ../../library/stdtypes.rst:4532
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Повернути новий вигляд ключів словника. Перегляньте :ref:`документацію "
"об’єктів перегляду <dict-views>`."

#: ../../library/stdtypes.rst:4537
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"Якщо *key* є у словнику, видаліть його та поверніть його значення, інакше "
"поверніть *default*. Якщо *default* не вказано, а *key* немає в словнику, "
"виникає :exc:`KeyError`."

#: ../../library/stdtypes.rst:4543
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"Видалити та повернути пару ``(ключ, значення)`` зі словника. Пари "
"повертаються в порядку :abbr:`LIFO (останній прийшов, перший вийшов)`."

#: ../../library/stdtypes.rst:4546
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem` корисний для деструктивного повторення словника, як це часто "
"використовується в набір алгоритмів. Якщо словник порожній, виклик :meth:"
"`popitem` викликає :exc:`KeyError`."

#: ../../library/stdtypes.rst:4550
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""
"Замовлення LIFO тепер гарантовано. У попередніх версіях :meth:`popitem` "
"повертав довільну пару ключ/значення."

#: ../../library/stdtypes.rst:4556
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""
"Повертає зворотний ітератор над ключами словника. Це ярлик для ``reversed(d."
"keys())``."

#: ../../library/stdtypes.rst:4563
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Якщо *key* є в словнику, поверніть його значення. Якщо ні, вставте *ключ* зі "
"значенням *default* і поверніть *default*. *default* за замовчуванням "
"``None``."

#: ../../library/stdtypes.rst:4569
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Оновіть словник парами ключ/значення з *other*, перезаписавши існуючі ключі. "
"Повернути ``Жодного``."

#: ../../library/stdtypes.rst:4572
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` приймає або інший об’єкт словника, або ітерацію пар ключ/"
"значення (як кортежі чи інші ітерації довжиною два). Якщо вказано аргументи "
"ключового слова, словник оновлюється такими парами ключ/значення: ``d."
"update(red=1, blue=2)``."

#: ../../library/stdtypes.rst:4579
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"Повернути нове подання значень словника. Перегляньте :ref:`документацію "
"об’єктів перегляду <dict-views>`."

#: ../../library/stdtypes.rst:4582
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""
"Порівняння рівності між одним переглядом ``dict.values()`` та іншим завжди "
"повертатиме ``False``. Це також стосується порівняння ``dict.values()`` із "
"собою::"

#: ../../library/stdtypes.rst:4592
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""
"Створіть новий словник із об’єднаними ключами та значеннями *d* та *other*, "
"які мають бути словниками. Значення *other* мають пріоритет, коли *d* та "
"*other* мають спільні ключі."

#: ../../library/stdtypes.rst:4600
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""
"Оновіть словник *d* ключами та значеннями з *other*, які можуть бути :term:"
"`mapping` або :term:`iterable` пар ключ/значення. Значення *other* мають "
"пріоритет, коли *d* та *other* мають спільні ключі."

#: ../../library/stdtypes.rst:4606
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`."
msgstr ""
"Словники порівнюються рівними тоді і тільки тоді, коли вони мають однакові "
"пари ``(ключ, значення)`` (незалежно від порядку). Порівняння порядку (' <', "
"'<=', '> =', '>') викликає :exc:`TypeError`."

#: ../../library/stdtypes.rst:4610
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"Словники зберігають порядок вставки. Зауважте, що оновлення ключа не впливає "
"на порядок. Ключі, додані після видалення, вставляються в кінці. ::"

#: ../../library/stdtypes.rst:4628
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"Порядок словника гарантовано буде порядком вставки. Така поведінка була "
"деталлю реалізації CPython від 3.6."

#: ../../library/stdtypes.rst:4632
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr "Словники та перегляди словників є оборотними. ::"

#: ../../library/stdtypes.rst:4644
msgid "Dictionaries are now reversible."
msgstr "Словники тепер оборотні."

#: ../../library/stdtypes.rst:4649
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
":class:`types.MappingProxyType` можна використовувати для створення "
"перегляду :class:`dict` лише для читання."

#: ../../library/stdtypes.rst:4656
msgid "Dictionary view objects"
msgstr "Об’єкти перегляду словника"

#: ../../library/stdtypes.rst:4658
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
"Об’єкти, які повертаються :meth:`dict.keys`, :meth:`dict.values` і :meth:"
"`dict.items`, є *об’єктами перегляду*. Вони забезпечують динамічний перегляд "
"статей словника, що означає, що коли словник змінюється, перегляд відображає "
"ці зміни."

#: ../../library/stdtypes.rst:4663
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Перегляди словників можна повторювати, щоб отримати відповідні дані та "
"підтримувати тести членства:"

#: ../../library/stdtypes.rst:4668
msgid "Return the number of entries in the dictionary."
msgstr "Повернути кількість статей у словнику."

#: ../../library/stdtypes.rst:4672
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Повертає ітератор над ключами, значеннями або елементами (представленими у "
"вигляді кортежів ``(ключ, значення)``) у словнику."

#: ../../library/stdtypes.rst:4675
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"Ключі та значення повторюються в порядку вставки. Це дозволяє створювати "
"пари ``(значення, ключ)`` за допомогою :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``. Інший спосіб створити той самий список: ``pairs = "
"[(v, k) for (k, v) in d.items()]``."

#: ../../library/stdtypes.rst:4680
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Ітерація подання під час додавання чи видалення записів у словнику може "
"викликати :exc:`RuntimeError` або не вдається виконати ітерацію по всіх "
"записах."

#: ../../library/stdtypes.rst:4683
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "Порядок словника гарантовано буде порядком вставки."

#: ../../library/stdtypes.rst:4688
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Повертає ``True``, якщо *x* міститься в ключах, значеннях або елементах "
"основного словника (в останньому випадку *x* має бути кортежем ``(ключ, "
"значення)``)."

#: ../../library/stdtypes.rst:4693
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""
"Повертає зворотний ітератор над ключами, значеннями або елементами словника. "
"Подання буде повторено в порядку, зворотному до вставки."

#: ../../library/stdtypes.rst:4696
msgid "Dictionary views are now reversible."
msgstr "Перегляди словника тепер оборотні."

#: ../../library/stdtypes.rst:4701
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr ""
"Повертає :class:`types.MappingProxyType`, який обгортає вихідний словник, на "
"який посилається перегляд."

#: ../../library/stdtypes.rst:4706
msgid ""
"Keys views are set-like since their entries are unique and :term:"
"`hashable`.  If all values are hashable, so that ``(key, value)`` pairs are "
"unique and hashable, then the items view is also set-like.  (Values views "
"are not treated as set-like since the entries are generally not unique.)  "
"For set-like views, all of the operations defined for the abstract base "
"class :class:`collections.abc.Set` are available (for example, ``==``, "
"``<``, or ``^``)."
msgstr ""

#: ../../library/stdtypes.rst:4713
msgid "An example of dictionary view usage::"
msgstr "Приклад використання перегляду словника::"

#: ../../library/stdtypes.rst:4756
msgid "Context Manager Types"
msgstr "Типи менеджера контексту"

#: ../../library/stdtypes.rst:4763
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"Оператор Python :keyword:`with` підтримує концепцію контексту виконання, "
"визначеного менеджером контексту. Це реалізовано за допомогою пари методів, "
"які дозволяють визначеним користувачем класам визначати контекст виконання, "
"який вводиться перед виконанням тіла оператора та виходить, коли оператор "
"закінчується:"

#: ../../library/stdtypes.rst:4771
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"Введіть контекст середовища виконання та поверніть або цей об’єкт, або інший "
"об’єкт, пов’язаний із контекстом середовища виконання. Значення, яке "
"повертає цей метод, прив’язується до ідентифікатора в пункті :keyword:`!as` "
"операторів :keyword:`with` за допомогою цього менеджера контексту."

#: ../../library/stdtypes.rst:4776
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"Прикладом контекстного менеджера, який повертає сам себе, є :term:`file "
"object`. Файлові об’єкти повертаються з __enter__(), щоб дозволити "
"використовувати :func:`open` як вираз контексту в операторі :keyword:`with`."

#: ../../library/stdtypes.rst:4780
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"Прикладом менеджера контексту, який повертає пов’язаний об’єкт, є той, який "
"повертає :func:`decimal.localcontext`. Ці менеджери встановлюють активний "
"десятковий контекст на копію вихідного десяткового контексту, а потім "
"повертають копію. Це дозволяє вносити зміни до поточного десяткового "
"контексту в тілі оператора :keyword:`with`, не впливаючи на код поза "
"оператором :keyword:`!with`."

#: ../../library/stdtypes.rst:4790
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Вийдіть із контексту виконання та поверніть логічний прапор, який вказує, чи "
"має бути придушено будь-який виняток, який стався. Якщо виняток стався під "
"час виконання тіла оператора :keyword:`with`, аргументи містять тип винятку, "
"значення та інформацію про відстеження. В іншому випадку всі три аргументи є "
"``Жодним``."

#: ../../library/stdtypes.rst:4795
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"Повернення цього методу справжнього значення призведе до того, що оператор :"
"keyword:`with` придушить виняток і продовжить виконання з оператором, який "
"слідує безпосередньо за оператором :keyword:`!with`. В іншому випадку "
"виняткова ситуація продовжує поширюватися після завершення виконання цього "
"методу. Винятки, які виникають під час виконання цього методу, замінять будь-"
"які винятки, які виникли в тілі оператора :keyword:`!with`."

#: ../../library/stdtypes.rst:4802
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`~object."
"__exit__` method has actually failed."
msgstr ""

#: ../../library/stdtypes.rst:4808
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python визначає декілька контекстних менеджерів для підтримки легкої "
"синхронізації потоків, швидкого закриття файлів чи інших об’єктів і "
"простішого маніпулювання активним десятковим арифметичним контекстом. "
"Конкретні типи не розглядаються спеціально за межами їх реалізації в "
"протоколі керування контекстом. Перегляньте модуль :mod:`contextlib` для "
"деяких прикладів."

#: ../../library/stdtypes.rst:4814
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` methods, "
"rather than the iterator produced by an undecorated generator function."
msgstr ""
":term:`generator`\\s Python і декоратор :class:`contextlib.contextmanager` "
"забезпечують зручний спосіб реалізації цих протоколів. Якщо функція-"
"генератор прикрашена декоратором :class:`contextlib.contextmanager`, вона "
"повертатиме менеджер контексту, який реалізує необхідні методи :meth:"
"`~contextmanager.__enter__` і :meth:`~contextmanager.__exit__`, а не "
"ітератор, створений недекорованою функцією генератора."

#: ../../library/stdtypes.rst:4821
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"Зауважте, що немає спеціального слота для жодного з цих методів у структурі "
"типу для об’єктів Python в API Python/C. Типи розширень, які хочуть "
"визначити ці методи, повинні надати їх як звичайний доступний метод Python. "
"Порівняно з накладними витратами на налаштування контексту виконання, "
"накладні витрати на пошук словника одного класу є незначними."

#: ../../library/stdtypes.rst:4829
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"
msgstr ""
"Типи анотацій типу --- :ref:`Загальний псевдонім <types-genericalias>`, :ref:"
"`Об’єднання <types-union>`"

#: ../../library/stdtypes.rst:4834
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
"Основними вбудованими типами для :term:`анотацій типу <annotation>` є :ref:"
"`Generic Alias <types-genericalias>` і :ref:`Union <types-union>`."

#: ../../library/stdtypes.rst:4841
msgid "Generic Alias Type"
msgstr "Загальний тип псевдоніма"

#: ../../library/stdtypes.rst:4847
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"Об’єкти ``GenericAlias`` зазвичай створюються :ref:`індексом "
"<subscriptions>` класу. Найчастіше вони використовуються з :ref:"
"`контейнерними класами <sequence-types>`, такими як :class:`list` або :class:"
"`dict`. Наприклад, ``list[int]`` є об’єктом ``GenericAlias``, створеним "
"шляхом підписання класу ``list`` з аргументом :class:`int`. Об’єкти "
"``GenericAlias`` призначені насамперед для використання з :term:`анотаціями "
"типу <annotation>`."

#: ../../library/stdtypes.rst:4857
msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr ""
"Як правило, індекс класу можливий, лише якщо клас реалізує спеціальний "
"метод :meth:`~object.__class_getitem__`."

#: ../../library/stdtypes.rst:4860
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr ""
"Об’єкт ``GenericAlias`` діє як проксі для :term:`generic type`, реалізуючи "
"*параметризовані генерики*."

#: ../../library/stdtypes.rst:4863
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations "
"to signify a :class:`set` in which all the elements are of type :class:"
"`bytes`."
msgstr ""
"Для класу-контейнера аргумент(и), що надаються :ref:`підписці "
"<subscriptions>` класу, може вказувати тип(и) елементів, які містить об’єкт. "
"Наприклад, ``set[bytes]`` можна використовувати в анотаціях типу для "
"позначення :class:`set`, у якому всі елементи мають тип :class:`bytes`."

#: ../../library/stdtypes.rst:4869
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both "
"the :class:`str` data type and the :class:`bytes` data type:"
msgstr ""
"Для класу, який визначає :meth:`~object.__class_getitem__`, але не є "
"контейнером, аргумент(и), що надаються до підписки класу, часто вказуватиме "
"тип(и) повернення одного або кількох методів, визначених для об’єкта . "
"Наприклад, :mod:`регулярні вирази <re>` можна використовувати як для типу "
"даних :class:`str`, так і для типу даних :class:`bytes`:"

#: ../../library/stdtypes.rst:4875
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"Якщо ``x = re.search('foo', 'foo')``, ``x`` буде об’єктом :ref:`re.Match "
"<match-objects>`, де повертаються значення ``x.group(0 )`` і ``x[0]`` будуть "
"мати тип :class:`str`. Ми можемо представити цей тип об’єктів в анотаціях "
"типу за допомогою ``GenericAlias`` ``re.Match[str]``."

#: ../../library/stdtypes.rst:4881
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""
"Якщо ``y = re.search(b'bar', b'bar')`` (зверніть увагу на ``b`` для :class:"
"`bytes`), ``y`` також буде екземпляром ``re.Match``, але повертані значення "
"``y.group(0)`` і ``y[0]`` будуть мати тип :class:`bytes`. В анотаціях типів "
"ми б представили цю різноманітність об’єктів :ref:`re.Match <match-objects>` "
"за допомогою ``re.Match[bytes]``."

#: ../../library/stdtypes.rst:4887
msgid ""
"``GenericAlias`` objects are instances of the class :class:`types."
"GenericAlias`, which can also be used to create ``GenericAlias`` objects "
"directly."
msgstr ""
"Об’єкти ``GenericAlias`` є екземплярами класу :class:`types.GenericAlias`, "
"який також можна використовувати для безпосереднього створення об’єктів "
"``GenericAlias``."

#: ../../library/stdtypes.rst:4893
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"Створює ``Generic Alias``, що представляє тип ``T``, параметризований типами "
"*X*, *Y* тощо залежно від ``T``, що використовується. Наприклад, функція, "
"яка очікує :class:`list`, що містить елементи :class:`float`::"

#: ../../library/stdtypes.rst:4901
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is "
"a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
"Інший приклад для об’єктів :term:`mapping` з використанням :class:`dict`, "
"який є загальним типом, який очікує двох параметрів типу, що представляють "
"тип ключа та тип значення. У цьому прикладі функція очікує ``dict`` з "
"ключами типу :class:`str` і значеннями типу :class:`int`::"

#: ../../library/stdtypes.rst:4909
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"Вбудовані функції :func:`isinstance` і :func:`issubclass` не приймають типи "
"``GenericAlias`` для свого другого аргументу::"

#: ../../library/stdtypes.rst:4917
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"Середовище виконання Python не вимагає :term:`анотацій типу <annotation>`. "
"Це поширюється на загальні типи та їхні параметри типу. Під час створення "
"об’єкта-контейнера з ``GenericAlias`` елементи в контейнері не перевіряються "
"на їх тип. Наприклад, наступний код не рекомендується, але працюватиме без "
"помилок:"

#: ../../library/stdtypes.rst:4927
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr ""
"Крім того, параметризовані генерики стирають параметри типу під час "
"створення об’єкта:"

#: ../../library/stdtypes.rst:4938
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr ""
"Виклик :func:`repr` або :func:`str` у загальному показує параметризований "
"тип::"

#: ../../library/stdtypes.rst:4946
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"Метод :meth:`~object.__getitem__` загальних контейнерів викличе виняток, щоб "
"заборонити такі помилки, як ``dict[str][str]``::"

#: ../../library/stdtypes.rst:4954
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"Однак такі вирази дійсні, коли використовуються :ref:`змінні типу "
"<generics>`. Індекс має містити стільки елементів, скільки елементів змінних "
"типу в об’єкті ``GenericAlias`` :attr:`~genericalias.__args__`. ::"

#: ../../library/stdtypes.rst:4965
msgid "Standard Generic Classes"
msgstr "Стандартні загальні класи"

#: ../../library/stdtypes.rst:4967
msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr ""
"Наступні стандартні бібліотечні класи підтримують параметризовані генерики. "
"Цей список не є вичерпним."

#: ../../library/stdtypes.rst:4970
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../library/stdtypes.rst:4971
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../../library/stdtypes.rst:4972
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../library/stdtypes.rst:4973
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../library/stdtypes.rst:4974
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../library/stdtypes.rst:4975
msgid ":class:`type`"
msgstr ":class:`type`"

#: ../../library/stdtypes.rst:4976
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../library/stdtypes.rst:4977
msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

#: ../../library/stdtypes.rst:4978
msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

#: ../../library/stdtypes.rst:4979
msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

#: ../../library/stdtypes.rst:4980
msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

#: ../../library/stdtypes.rst:4981
msgid ":class:`collections.abc.Awaitable`"
msgstr ":class:`collections.abc.Awaitable`"

#: ../../library/stdtypes.rst:4982
msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

#: ../../library/stdtypes.rst:4983
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: ../../library/stdtypes.rst:4984
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterator`"

#: ../../library/stdtypes.rst:4985
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

#: ../../library/stdtypes.rst:4986
msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

#: ../../library/stdtypes.rst:4987
msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

#: ../../library/stdtypes.rst:4988
msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

#: ../../library/stdtypes.rst:4989
msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

#: ../../library/stdtypes.rst:4990
msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

#: ../../library/stdtypes.rst:4991
msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

#: ../../library/stdtypes.rst:4992
msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

#: ../../library/stdtypes.rst:4993
msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

#: ../../library/stdtypes.rst:4994
msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

#: ../../library/stdtypes.rst:4995
msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

#: ../../library/stdtypes.rst:4996
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

#: ../../library/stdtypes.rst:4997
msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

#: ../../library/stdtypes.rst:4998
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

#: ../../library/stdtypes.rst:4999
msgid ":class:`collections.abc.ByteString`"
msgstr ":class:`collections.abc.ByteString`"

#: ../../library/stdtypes.rst:5000
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

#: ../../library/stdtypes.rst:5001
msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

#: ../../library/stdtypes.rst:5002
msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

#: ../../library/stdtypes.rst:5003
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

#: ../../library/stdtypes.rst:5004
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

#: ../../library/stdtypes.rst:5005
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

#: ../../library/stdtypes.rst:5006
msgid ":class:`dataclasses.Field`"
msgstr ":class:`dataclasses.Field`"

#: ../../library/stdtypes.rst:5007
msgid ":class:`functools.cached_property`"
msgstr ":class:`functools.cached_property`"

#: ../../library/stdtypes.rst:5008
msgid ":class:`functools.partialmethod`"
msgstr ":class:`functools.partialmethod`"

#: ../../library/stdtypes.rst:5009
msgid ":class:`os.PathLike`"
msgstr ":class:`os.PathLike`"

#: ../../library/stdtypes.rst:5010
msgid ":class:`queue.LifoQueue`"
msgstr ":class:`queue.LifoQueue`"

#: ../../library/stdtypes.rst:5011
msgid ":class:`queue.Queue`"
msgstr ":class:`queue.Queue`"

#: ../../library/stdtypes.rst:5012
msgid ":class:`queue.PriorityQueue`"
msgstr ":class:`queue.PriorityQueue`"

#: ../../library/stdtypes.rst:5013
msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`queue.SimpleQueue`"

#: ../../library/stdtypes.rst:5014
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Патерн <re-objects>`"

#: ../../library/stdtypes.rst:5015
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: ../../library/stdtypes.rst:5016
msgid ":class:`shelve.BsdDbShelf`"
msgstr ":class:`полиця.BsdDbShelf`"

#: ../../library/stdtypes.rst:5017
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":class:`полиця.DbfilenameShelf`"

#: ../../library/stdtypes.rst:5018
msgid ":class:`shelve.Shelf`"
msgstr ":class:`полиця.Полиця`"

#: ../../library/stdtypes.rst:5019
msgid ":class:`types.MappingProxyType`"
msgstr ":class:`types.MappingProxyType`"

#: ../../library/stdtypes.rst:5020
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":class:`weakref.WeakKeyDictionary`"

#: ../../library/stdtypes.rst:5021
msgid ":class:`weakref.WeakMethod`"
msgstr ":class:`weakref.WeakMethod`"

#: ../../library/stdtypes.rst:5022
msgid ":class:`weakref.WeakSet`"
msgstr ":class:`weakref.WeakSet`"

#: ../../library/stdtypes.rst:5023
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":class:`weakref.WeakValueDictionary`"

#: ../../library/stdtypes.rst:5028
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "Спеціальні атрибути об’єктів ``GenericAlias``"

#: ../../library/stdtypes.rst:5030
msgid "All parameterized generics implement special read-only attributes."
msgstr ""
"Усі параметризовані генерики реалізують спеціальні атрибути лише для читання."

#: ../../library/stdtypes.rst:5034
msgid "This attribute points at the non-parameterized generic class::"
msgstr "Цей атрибут вказує на непараметризований загальний клас::"

#: ../../library/stdtypes.rst:5042
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr ""
"Цей атрибут є :class:`tuple` (можливо, довжиною 1) загальних типів, "
"переданих до оригінального :meth:`~object.__class_getitem__` загального "
"класу::"

#: ../../library/stdtypes.rst:5052
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr ""
"Цей атрибут є ліниво обчисленим кортежем (можливо, порожнім) унікальних "
"змінних типу, знайдених у ``__args__``::"

#: ../../library/stdtypes.rst:5063
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because :class:`typing."
"ParamSpec` is intended primarily for static type checking."
msgstr ""
"Об’єкт ``GenericAlias`` з параметрами :class:`typing.ParamSpec` може не мати "
"правильних ``__parameters__`` після заміни, тому що :class:`typing."
"ParamSpec` призначений насамперед для статичної перевірки типу."

#: ../../library/stdtypes.rst:5070
msgid ""
"A boolean that is true if the alias has been unpacked using the ``*`` "
"operator (see :data:`~typing.TypeVarTuple`)."
msgstr ""

#: ../../library/stdtypes.rst:5079
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - підказки типу"

#: ../../library/stdtypes.rst:5079
msgid "Introducing Python's framework for type annotations."
msgstr "Представляємо структуру Python для анотацій типів."

#: ../../library/stdtypes.rst:5084
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - Універсальні підказки типів у стандартних колекціях"

#: ../../library/stdtypes.rst:5082
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr ""
"Представляємо можливість нативної параметризації класів стандартної "
"бібліотеки, якщо вони реалізують спеціальний метод класу :meth:`~object."
"__class_getitem__`."

#: ../../library/stdtypes.rst:5087
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`визначені користувачем узагальнення <user-defined-"
"generics>` і :class:`typing.Generic`"

#: ../../library/stdtypes.rst:5087
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Документація про те, як реалізувати загальні класи, які можна "
"параметризувати під час виконання та розуміти статичними засобами перевірки "
"типів."

#: ../../library/stdtypes.rst:5096
msgid "Union Type"
msgstr "Тип союзу"

#: ../../library/stdtypes.rst:5102
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended "
"primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to :data:`typing."
"Union`."
msgstr ""
"Об’єкт об’єднання містить значення операції ``|`` (порозрядної або) на "
"кількох :ref:`об’єктах типу <bltin-type-objects>`. Ці типи призначені "
"насамперед для :term:`анотацій типу <annotation>`. Вираз типу об’єднання "
"забезпечує чіткіший синтаксис підказки типу порівняно з :data:`typing.Union`."

#: ../../library/stdtypes.rst:5109
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or :"
"class:`float`::"
msgstr ""
"Визначає об’єкт об’єднання, який містить типи *X*, *Y* і так далі. ``X | Y`` "
"означає X або Y. Це еквівалентно ``typing.Union[X, Y]``. Наприклад, наступна "
"функція очікує аргумент типу :class:`int` або :class:`float`::"

#: ../../library/stdtypes.rst:5119
msgid ""
"The ``|`` operand cannot be used at runtime to define unions where one or "
"more members is a forward reference. For example, ``int | \"Foo\"``, where "
"``\"Foo\"`` is a reference to a class not yet defined, will fail at runtime. "
"For unions which include forward references, present the whole expression as "
"a string, e.g. ``\"int | Foo\"``."
msgstr ""

#: ../../library/stdtypes.rst:5127
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr ""
"Об’єкти об’єднання можна перевірити на рівність з іншими об’єктами "
"об’єднання. Подробиці:"

#: ../../library/stdtypes.rst:5129
msgid "Unions of unions are flattened::"
msgstr "Союзи союзів сплощені::"

#: ../../library/stdtypes.rst:5133
msgid "Redundant types are removed::"
msgstr "Зайві типи видаляються:"

#: ../../library/stdtypes.rst:5137
msgid "When comparing unions, the order is ignored::"
msgstr "Під час порівняння об'єднань порядок ігнорується:"

#: ../../library/stdtypes.rst:5141
msgid "It is compatible with :data:`typing.Union`::"
msgstr "Він сумісний з :data:`typing.Union`::"

#: ../../library/stdtypes.rst:5145
msgid "Optional types can be spelled as a union with ``None``::"
msgstr "Необов'язкові типи можуть бути написані як об'єднання з ``None``::"

#: ../../library/stdtypes.rst:5152
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr ""
"Виклики :func:`isinstance` і :func:`issubclass` також підтримуються з "
"об’єктом об’єднання::"

#: ../../library/stdtypes.rst:5158
msgid ""
"However, :ref:`parameterized generics <types-genericalias>` in union objects "
"cannot be checked::"
msgstr ""

#: ../../library/stdtypes.rst:5168
msgid ""
"The user-exposed type for the union object can be accessed from :data:`types."
"UnionType` and used for :func:`isinstance` checks.  An object cannot be "
"instantiated from the type::"
msgstr ""
"Доступ до відкритого користувачем типу для об’єкта union можна отримати з :"
"data:`types.UnionType` і використовувати для перевірки :func:`isinstance`. "
"Об’єкт не може бути створений із типу::"

#: ../../library/stdtypes.rst:5181
msgid ""
"The :meth:`__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`__or__`, the Union may override "
"it::"
msgstr ""
"Метод :meth:`__or__` було додано для підтримки синтаксису ``X | Y``. Якщо "
"метаклас реалізує :meth:`__or__`, об’єднання може замінити його::"

#: ../../library/stdtypes.rst:5199
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` -- PEP пропонує ``X | Синтаксис Y`` і тип Union."

#: ../../library/stdtypes.rst:5207
msgid "Other Built-in Types"
msgstr "Інші вбудовані типи"

#: ../../library/stdtypes.rst:5209
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"Інтерпретатор підтримує кілька інших видів об'єктів. Більшість із них "
"підтримує лише одну або дві операції."

#: ../../library/stdtypes.rst:5216
msgid "Modules"
msgstr "Модулі"

#: ../../library/stdtypes.rst:5218
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"Єдиною спеціальною операцією над модулем є доступ до атрибутів: ``m.name``, "
"де *m* — це модуль, а *name* отримує доступ до імені, визначеного в таблиці "
"символів *m*. Модулю можна призначити атрибути. (Зауважте, що оператор :"
"keyword:`import` не є, строго кажучи, операцією над об’єктом модуля; "
"``import foo`` не вимагає існування об’єкта модуля з назвою *foo*, скоріше "
"для цього потрібен (зовнішній) *визначення* для модуля з назвою *foo* десь.)"

#: ../../library/stdtypes.rst:5225
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Спеціальним атрибутом кожного модуля є :attr:`~object.__dict__`. Це словник, "
"що містить таблицю символів модуля. Зміна цього словника фактично змінить "
"таблицю символів модуля, але пряме призначення атрибуту :attr:`~object."
"__dict__` неможливо (ви можете написати ``m.__dict__['a'] = 1``, що визначає "
"``m.a`` буде ``1``, але ви не можете написати ``m.__dict__ = {}``). Не "
"рекомендується безпосередньо змінювати :attr:`~object.__dict__`."

#: ../../library/stdtypes.rst:5233
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Модулі, вбудовані в інтерпретатор, записуються так: ``<module 'sys' (built-"
"in)>``. Якщо завантажуються з файлу, вони записуються як ``<module 'os' from "
"'/usr/local/lib/pythonX.Y/os.pyc'>``."

#: ../../library/stdtypes.rst:5241
msgid "Classes and Class Instances"
msgstr "Класи та екземпляри класів"

#: ../../library/stdtypes.rst:5243
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Перегляньте :ref:`objects` і :ref:`class` для них."

#: ../../library/stdtypes.rst:5249
msgid "Functions"
msgstr "Функції"

#: ../../library/stdtypes.rst:5251
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Функціональні об’єкти створюються визначеннями функцій. Єдина операція над "
"об’єктом-функцією – це викликати його: ``func(список-аргументів)``."

#: ../../library/stdtypes.rst:5254
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Насправді існує два види функціональних об’єктів: вбудовані функції та "
"функції, визначені користувачем. Обидва підтримують однакову операцію "
"(виклик функції), але реалізація різна, отже, різні типи об’єктів."

#: ../../library/stdtypes.rst:5258
msgid "See :ref:`function` for more information."
msgstr "Перегляньте :ref:`function` для отримання додаткової інформації."

#: ../../library/stdtypes.rst:5264
msgid "Methods"
msgstr "методи"

#: ../../library/stdtypes.rst:5268
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"Методи — це функції, які викликаються за допомогою нотації атрибутів. Є два "
"варіанти: вбудовані методи (такі як :meth:`append` у списках) і методи "
"екземплярів класу. Вбудовані методи описані з типами, які їх підтримують."

#: ../../library/stdtypes.rst:5273
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to "
"the argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is "
"the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-"
"n)`` is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"Якщо ви отримуєте доступ до методу (функції, визначеної в просторі імен "
"класу) через екземпляр, ви отримуєте спеціальний об’єкт: об’єкт :dfn:"
"`зв’язаний метод` (також званий :dfn:`instance method`). Під час виклику він "
"додасть аргумент ``self`` до списку аргументів. Зв’язані методи мають два "
"спеціальні атрибути лише для читання: ``m.__self__`` - це об'єкт, з яким "
"працює метод, і ``m.__func__`` - це функція, що реалізує метод. Виклик "
"``m(arg-1, arg-2, ..., arg-n)`` повністю еквівалентний виклику ``m."
"__func__(m.__self__, arg-1, arg-2, ..., arg-n)``."

#: ../../library/stdtypes.rst:5282
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""
"Як і функціональні об’єкти, зв’язані об’єкти методів підтримують отримання "
"довільних атрибутів. Однак, оскільки атрибути методу фактично зберігаються в "
"базовому об’єкті функції (``meth.__func__``), встановлення атрибутів методу "
"для зв’язаних методів заборонено. Спроба встановити атрибут для методу "
"призводить до появи :exc:`AttributeError`. Щоб установити атрибут методу, "
"вам потрібно явно встановити його на базовому об’єкті функції::"

#: ../../library/stdtypes.rst:5302 ../../library/stdtypes.rst:5333
msgid "See :ref:`types` for more information."
msgstr "Перегляньте :ref:`types` для отримання додаткової інформації."

#: ../../library/stdtypes.rst:5310
msgid "Code Objects"
msgstr "Об'єкти коду"

#: ../../library/stdtypes.rst:5316
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`__code__` attribute. See also the :mod:`code` module."
msgstr ""
"Об’єкти коду використовуються реалізацією для представлення "
"\"псевдокомпільованого\" виконуваного коду Python, такого як тіло функції. "
"Вони відрізняються від функціональних об’єктів, оскільки не містять "
"посилання на своє глобальне середовище виконання. Об’єкти коду повертаються "
"вбудованою функцією :func:`compile` і можуть бути витягнуті з об’єктів "
"функції через їх атрибут :attr:`__code__`. Дивіться також модуль :mod:`code`."

#: ../../library/stdtypes.rst:5323
msgid ""
"Accessing ``__code__`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"__code__\"``."
msgstr ""
"Доступ до ``__code__`` викликає :ref:`подію аудиту <auditing>` ``object."
"__getattr__`` з аргументами ``obj`` і ``\"__code__\"``."

#: ../../library/stdtypes.rst:5330
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Об’єкт коду можна виконати або оцінити, передавши його (замість вихідного "
"рядка) у вбудовані функції :func:`exec` або :func:`eval`."

#: ../../library/stdtypes.rst:5339
msgid "Type Objects"
msgstr "Об'єкти типу"

#: ../../library/stdtypes.rst:5345
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Об’єкти типу представляють різні типи об’єктів. Доступ до типу об’єкта "
"здійснюється за допомогою вбудованої функції :func:`type`. Над типами немає "
"спеціальних операцій. Стандартний модуль :mod:`types` визначає імена для "
"всіх стандартних вбудованих типів."

#: ../../library/stdtypes.rst:5350
msgid "Types are written like this: ``<class 'int'>``."
msgstr "Типи записуються так: ``<class 'int'>``."

#: ../../library/stdtypes.rst:5356
msgid "The Null Object"
msgstr "Нульовий об’єкт"

#: ../../library/stdtypes.rst:5358
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Цей об’єкт повертають функції, які явно не повертають значення. Він не "
"підтримує ніяких спеціальних операцій. Існує рівно один нульовий об’єкт із "
"назвою ``None`` (вбудована назва). ``type(None)()`` створює той самий "
"синглтон."

#: ../../library/stdtypes.rst:5362
msgid "It is written as ``None``."
msgstr "Він записується як ``None``."

#: ../../library/stdtypes.rst:5369
msgid "The Ellipsis Object"
msgstr "Об’єкт \"Еліпсис\"."

#: ../../library/stdtypes.rst:5371
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Цей об’єкт зазвичай використовується для нарізки (див. :ref:`slicings`). Він "
"не підтримує ніяких спеціальних операцій. Існує рівно один об’єкт з крапкою, "
"який називається :const:`Ellipsis` (вбудована назва). ``type(Ellipsis)()`` "
"виробляє :const:`Ellipsis` синглтон."

#: ../../library/stdtypes.rst:5376
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "Він записується як ``Еліпсис`` або ``...``."

#: ../../library/stdtypes.rst:5382
msgid "The NotImplemented Object"
msgstr "Об’єкт NotImplemented"

#: ../../library/stdtypes.rst:5384
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"Цей об’єкт повертається з порівнянь і двійкових операцій, коли їх запитують "
"оперувати типами, які вони не підтримують. Перегляньте :ref:`comparisons` "
"для отримання додаткової інформації. Існує рівно один об’єкт "
"``NotImplemented``. ``type(NotImplemented)()`` створює одиночний екземпляр."

#: ../../library/stdtypes.rst:5389
msgid "It is written as ``NotImplemented``."
msgstr "Це написано як ``NotImplemented``."

#: ../../library/stdtypes.rst:5395
msgid "Boolean Values"
msgstr ""

#: ../../library/stdtypes.rst:5397
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""

#: ../../library/stdtypes.rst:5410
msgid "They are written as ``False`` and ``True``, respectively."
msgstr ""

#: ../../library/stdtypes.rst:5416
msgid "Internal Objects"
msgstr "Внутрішні об'єкти"

#: ../../library/stdtypes.rst:5418
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"Перегляньте :ref:`types` цю інформацію. Він описує об’єкти фрейму стека, "
"об’єкти трасування та об’єкти фрагментів."

#: ../../library/stdtypes.rst:5425
msgid "Special Attributes"
msgstr "Спеціальні атрибути"

#: ../../library/stdtypes.rst:5427
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"Реалізація додає кілька спеціальних атрибутів лише для читання до кількох "
"типів об’єктів, де вони актуальні. Деякі з них не повідомляються вбудованою "
"функцією :func:`dir`."

#: ../../library/stdtypes.rst:5434
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"Словник або інший об’єкт відображення, який використовується для зберігання "
"атрибутів об’єкта (для запису)."

#: ../../library/stdtypes.rst:5440
msgid "The class to which a class instance belongs."
msgstr "Клас, до якого належить екземпляр класу."

#: ../../library/stdtypes.rst:5445
msgid "The tuple of base classes of a class object."
msgstr "Кортеж базових класів об’єкта класу."

#: ../../library/stdtypes.rst:5450
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr "Ім'я класу, функції, методу, дескриптора або екземпляра генератора."

#: ../../library/stdtypes.rst:5456
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
":term:`qualified name` класу, функції, методу, дескриптора або екземпляра "
"генератора."

#: ../../library/stdtypes.rst:5464
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"Цей атрибут є кортежем класів, які враховуються під час пошуку базових "
"класів під час вирішення методу."

#: ../../library/stdtypes.rst:5470
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"Цей метод може бути перевизначений метакласом, щоб налаштувати порядок "
"вирішення методів для його екземплярів. Він викликається під час створення "
"екземпляра класу, а його результат зберігається в :attr:`~class.__mro__`."

#: ../../library/stdtypes.rst:5477
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive.  The list is "
"in definition order.  Example::"
msgstr ""
"Кожен клас зберігає список слабких посилань на його безпосередні підкласи. "
"Цей метод повертає список усіх посилань, які ще живі. Список у порядку "
"визначення. Приклад::"

#: ../../library/stdtypes.rst:5488
msgid "Integer string conversion length limitation"
msgstr ""

#: ../../library/stdtypes.rst:5490
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:"
"`str` to mitigate denial of service attacks. This limit *only* applies to "
"decimal or other non-power-of-two number bases. Hexadecimal, octal, and "
"binary conversions are unlimited. The limit can be configured."
msgstr ""

#: ../../library/stdtypes.rst:5495
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that "
"can convert a string to a binary integer or a binary integer to a string in "
"linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""

#: ../../library/stdtypes.rst:5502
msgid ""
"Limiting conversion size offers a practical way to avoid `CVE-2020-10735 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735>`_."
msgstr ""

#: ../../library/stdtypes.rst:5505
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr ""

#: ../../library/stdtypes.rst:5509
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr ""

#: ../../library/stdtypes.rst:5531
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be "
"configured is 640 digits as provided in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."
msgstr ""

#: ../../library/stdtypes.rst:5536
msgid "Verification:"
msgstr ""

#: ../../library/stdtypes.rst:5551
msgid "Affected APIs"
msgstr ""

#: ../../library/stdtypes.rst:5553
msgid ""
"The limitation only applies to potentially slow conversions between :class:"
"`int` and :class:`str` or :class:`bytes`:"
msgstr ""

#: ../../library/stdtypes.rst:5556
msgid "``int(string)`` with default base 10."
msgstr ""

#: ../../library/stdtypes.rst:5557
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr ""

#: ../../library/stdtypes.rst:5558
msgid "``str(integer)``."
msgstr ""

#: ../../library/stdtypes.rst:5559
msgid "``repr(integer)``."
msgstr ""

#: ../../library/stdtypes.rst:5560
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""

#: ../../library/stdtypes.rst:5563
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr ""

#: ../../library/stdtypes.rst:5565
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr ""

#: ../../library/stdtypes.rst:5566
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ""

#: ../../library/stdtypes.rst:5567
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ""

#: ../../library/stdtypes.rst:5568
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ""

#: ../../library/stdtypes.rst:5569
msgid ":class:`str` to :class:`float`."
msgstr ""

#: ../../library/stdtypes.rst:5570
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ""

#: ../../library/stdtypes.rst:5573
msgid "Configuring the limit"
msgstr ""

#: ../../library/stdtypes.rst:5575
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr ""

#: ../../library/stdtypes.rst:5578
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""

#: ../../library/stdtypes.rst:5581
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""

#: ../../library/stdtypes.rst:5583
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the "
"env var and the ``-X`` option are set, the ``-X`` option takes precedence. A "
"value of *-1* indicates that both were unset, thus a value of :data:`sys."
"int_info.default_max_str_digits` was used during initialization."
msgstr ""

#: ../../library/stdtypes.rst:5589
msgid ""
"From code, you can inspect the current limit and set a new one using these :"
"mod:`sys` APIs:"
msgstr ""

#: ../../library/stdtypes.rst:5592
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have "
"their own limit."
msgstr ""

#: ../../library/stdtypes.rst:5596
msgid ""
"Information about the default and minimum can be found in :data:`sys."
"int_info`:"
msgstr ""

#: ../../library/stdtypes.rst:5598
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ""

#: ../../library/stdtypes.rst:5600
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""

#: ../../library/stdtypes.rst:5607
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or "
"even at installation time - anytime an up to date ``.pyc`` does not already "
"exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""

#: ../../library/stdtypes.rst:5616
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""

#: ../../library/stdtypes.rst:5622
msgid "Recommended configuration"
msgstr ""

#: ../../library/stdtypes.rst:5624
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.11."
msgstr ""

#: ../../library/stdtypes.rst:5629
msgid "Example::"
msgstr "Приклад::"

#: ../../library/stdtypes.rst:5641
msgid "If you need to disable it entirely, set it to ``0``."
msgstr ""

#: ../../library/stdtypes.rst:5645
msgid "Footnotes"
msgstr "Виноски"

#: ../../library/stdtypes.rst:5646
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Додаткову інформацію про ці спеціальні методи можна знайти в довідковому "
"посібнику Python (:ref:`customization`)."

#: ../../library/stdtypes.rst:5649
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"Як наслідок, список ``[1, 2]`` вважається рівним ``[1.0, 2.0]``, і "
"аналогічно для кортежів."

#: ../../library/stdtypes.rst:5652
msgid "They must have since the parser can't tell the type of the operands."
msgstr "Мабуть, оскільки аналізатор не може визначити тип операндів."

#: ../../library/stdtypes.rst:5654
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Регістр символів — це символи загальної категорії, які мають одну з таких "
"властивостей: \"Lu\" (літера, верхній регістр), \"Ll\" (літера, нижній "
"регістр) або \"Lt\" (літера, регістр заголовка)."

#: ../../library/stdtypes.rst:5657
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Щоб відформатувати лише кортеж, ви повинні надати одиночний кортеж, єдиним "
"елементом якого є кортеж, який потрібно відформатувати."

#: ../../library/stdtypes.rst:13
msgid "built-in"
msgstr ""

#: ../../library/stdtypes.rst:13 ../../library/stdtypes.rst:315
#: ../../library/stdtypes.rst:392 ../../library/stdtypes.rst:909
#: ../../library/stdtypes.rst:1076 ../../library/stdtypes.rst:1098
#: ../../library/stdtypes.rst:1113 ../../library/stdtypes.rst:4372
#: ../../library/stdtypes.rst:5341
msgid "types"
msgstr "види"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:1113
#: ../../library/stdtypes.rst:4372
msgid "statement"
msgstr "заява"

#: ../../library/stdtypes.rst:34
msgid "if"
msgstr ""

#: ../../library/stdtypes.rst:34
msgid "while"
msgstr ""

#: ../../library/stdtypes.rst:34
msgid "truth"
msgstr ""

#: ../../library/stdtypes.rst:34
msgid "value"
msgstr "значення"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:80
#: ../../library/stdtypes.rst:207 ../../library/stdtypes.rst:5405
msgid "Boolean"
msgstr ""

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:80
#: ../../library/stdtypes.rst:392
msgid "operations"
msgstr ""

#: ../../library/stdtypes.rst:34
msgid "false"
msgstr "помилковий"

#: ../../library/stdtypes.rst:44
msgid "true"
msgstr "правда"

#: ../../library/stdtypes.rst:51
msgid "None (Built-in object)"
msgstr ""

#: ../../library/stdtypes.rst:51
msgid "False (Built-in object)"
msgstr ""

#: ../../library/stdtypes.rst:63 ../../library/stdtypes.rst:97
#: ../../library/stdtypes.rst:122 ../../library/stdtypes.rst:194
#: ../../library/stdtypes.rst:245 ../../library/stdtypes.rst:392
#: ../../library/stdtypes.rst:909
msgid "operator"
msgstr "оператор"

#: ../../library/stdtypes.rst:63 ../../library/stdtypes.rst:97
msgid "or"
msgstr ""

#: ../../library/stdtypes.rst:63 ../../library/stdtypes.rst:97
msgid "and"
msgstr ""

#: ../../library/stdtypes.rst:63 ../../library/stdtypes.rst:5405
msgid "False"
msgstr "помилковий"

#: ../../library/stdtypes.rst:63 ../../library/stdtypes.rst:5405
msgid "True"
msgstr "правда"

#: ../../library/stdtypes.rst:97
msgid "not"
msgstr ""

#: ../../library/stdtypes.rst:122
msgid "chaining"
msgstr ""

#: ../../library/stdtypes.rst:122
msgid "comparisons"
msgstr ""

#: ../../library/stdtypes.rst:122
msgid "comparison"
msgstr ""

#: ../../library/stdtypes.rst:122
msgid "=="
msgstr ""

#: ../../library/stdtypes.rst:122
msgid "< (less)"
msgstr ""

#: ../../library/stdtypes.rst:122
msgid "<="
msgstr ""

#: ../../library/stdtypes.rst:122
msgid "> (greater)"
msgstr ""

#: ../../library/stdtypes.rst:122
msgid ">="
msgstr ""

#: ../../library/stdtypes.rst:122
msgid "!="
msgstr ""

#: ../../library/stdtypes.rst:122
msgid "is"
msgstr ""

#: ../../library/stdtypes.rst:122
msgid "is not"
msgstr ""

#: ../../library/stdtypes.rst:162 ../../library/stdtypes.rst:207
#: ../../library/stdtypes.rst:893 ../../library/stdtypes.rst:1076
#: ../../library/stdtypes.rst:1098 ../../library/stdtypes.rst:1218
#: ../../library/stdtypes.rst:1297 ../../library/stdtypes.rst:1341
#: ../../library/stdtypes.rst:1463 ../../library/stdtypes.rst:1499
#: ../../library/stdtypes.rst:2468 ../../library/stdtypes.rst:2487
#: ../../library/stdtypes.rst:2594 ../../library/stdtypes.rst:4171
#: ../../library/stdtypes.rst:4372 ../../library/stdtypes.rst:4843
#: ../../library/stdtypes.rst:5098 ../../library/stdtypes.rst:5266
#: ../../library/stdtypes.rst:5305
msgid "object"
msgstr "об'єкт"

#: ../../library/stdtypes.rst:162 ../../library/stdtypes.rst:207
#: ../../library/stdtypes.rst:228 ../../library/stdtypes.rst:315
#: ../../library/stdtypes.rst:334
msgid "numeric"
msgstr ""

#: ../../library/stdtypes.rst:162
msgid "objects"
msgstr ""

#: ../../library/stdtypes.rst:162
msgid "comparing"
msgstr ""

#: ../../library/stdtypes.rst:172
msgid "__eq__() (instance method)"
msgstr ""

#: ../../library/stdtypes.rst:172
msgid "__ne__() (instance method)"
msgstr ""

#: ../../library/stdtypes.rst:172
msgid "__lt__() (instance method)"
msgstr ""

#: ../../library/stdtypes.rst:172
msgid "__le__() (instance method)"
msgstr ""

#: ../../library/stdtypes.rst:172
msgid "__gt__() (instance method)"
msgstr ""

#: ../../library/stdtypes.rst:172
msgid "__ge__() (instance method)"
msgstr ""

#: ../../library/stdtypes.rst:194 ../../library/stdtypes.rst:909
msgid "in"
msgstr ""

#: ../../library/stdtypes.rst:194 ../../library/stdtypes.rst:909
msgid "not in"
msgstr ""

#: ../../library/stdtypes.rst:207 ../../library/stdtypes.rst:228
#: ../../library/stdtypes.rst:392
msgid "integer"
msgstr "ціле число"

#: ../../library/stdtypes.rst:207 ../../library/stdtypes.rst:228
msgid "floating point"
msgstr ""

#: ../../library/stdtypes.rst:207 ../../library/stdtypes.rst:228
msgid "complex number"
msgstr "комплексне число"

#: ../../library/stdtypes.rst:207
msgid "C"
msgstr "C"

#: ../../library/stdtypes.rst:207
msgid "language"
msgstr ""

#: ../../library/stdtypes.rst:228
msgid "literals"
msgstr ""

#: ../../library/stdtypes.rst:228
msgid "hexadecimal"
msgstr ""

#: ../../library/stdtypes.rst:228
msgid "octal"
msgstr ""

#: ../../library/stdtypes.rst:228
msgid "binary"
msgstr ""

#: ../../library/stdtypes.rst:245
msgid "arithmetic"
msgstr ""

#: ../../library/stdtypes.rst:245 ../../library/stdtypes.rst:909
#: ../../library/stdtypes.rst:1076 ../../library/stdtypes.rst:4372
#: ../../library/stdtypes.rst:5312 ../../library/stdtypes.rst:5326
#: ../../library/stdtypes.rst:5341
msgid "built-in function"
msgstr ""

#: ../../library/stdtypes.rst:245
msgid "int"
msgstr "int"

#: ../../library/stdtypes.rst:245
msgid "float"
msgstr "плавати"

#: ../../library/stdtypes.rst:245
msgid "complex"
msgstr ""

#: ../../library/stdtypes.rst:245 ../../library/stdtypes.rst:2344
#: ../../library/stdtypes.rst:3562
msgid "+ (plus)"
msgstr ""

#: ../../library/stdtypes.rst:245
msgid "unary operator"
msgstr ""

#: ../../library/stdtypes.rst:245
msgid "binary operator"
msgstr ""

#: ../../library/stdtypes.rst:245 ../../library/stdtypes.rst:2344
#: ../../library/stdtypes.rst:3562
msgid "- (minus)"
msgstr ""

#: ../../library/stdtypes.rst:245 ../../library/stdtypes.rst:2301
#: ../../library/stdtypes.rst:3519
msgid "* (asterisk)"
msgstr ""

#: ../../library/stdtypes.rst:245
msgid "/ (slash)"
msgstr ""

#: ../../library/stdtypes.rst:245
msgid "//"
msgstr ""

#: ../../library/stdtypes.rst:245 ../../library/stdtypes.rst:2271
#: ../../library/stdtypes.rst:3487
msgid "% (percent)"
msgstr ""

#: ../../library/stdtypes.rst:245
msgid "**"
msgstr ""

#: ../../library/stdtypes.rst:315 ../../library/stdtypes.rst:392
#: ../../library/stdtypes.rst:909 ../../library/stdtypes.rst:1113
#: ../../library/stdtypes.rst:4372
msgid "operations on"
msgstr ""

#: ../../library/stdtypes.rst:315
msgid "conjugate() (complex number method)"
msgstr ""

#: ../../library/stdtypes.rst:334 ../../library/stdtypes.rst:1565
#: ../../library/stdtypes.rst:2468 ../../library/stdtypes.rst:5341
msgid "module"
msgstr "модуль"

#: ../../library/stdtypes.rst:334
msgid "math"
msgstr "математика"

#: ../../library/stdtypes.rst:334
msgid "floor() (in module math)"
msgstr ""

#: ../../library/stdtypes.rst:334
msgid "ceil() (in module math)"
msgstr ""

#: ../../library/stdtypes.rst:334
msgid "trunc() (in module math)"
msgstr ""

#: ../../library/stdtypes.rst:334
msgid "conversions"
msgstr ""

#: ../../library/stdtypes.rst:392
msgid "bitwise"
msgstr ""

#: ../../library/stdtypes.rst:392
msgid "shifting"
msgstr ""

#: ../../library/stdtypes.rst:392
msgid "masking"
msgstr ""

#: ../../library/stdtypes.rst:392
msgid "| (vertical bar)"
msgstr ""

#: ../../library/stdtypes.rst:392
msgid "^ (caret)"
msgstr ""

#: ../../library/stdtypes.rst:392
msgid "& (ampersand)"
msgstr ""

#: ../../library/stdtypes.rst:392
msgid "<<"
msgstr ""

#: ../../library/stdtypes.rst:392
msgid ">>"
msgstr ""

#: ../../library/stdtypes.rst:392
msgid "~ (tilde)"
msgstr ""

#: ../../library/stdtypes.rst:806
msgid "iterator protocol"
msgstr ""

#: ../../library/stdtypes.rst:806 ../../library/stdtypes.rst:4758
msgid "protocol"
msgstr ""

#: ../../library/stdtypes.rst:806
msgid "iterator"
msgstr "ітератор"

#: ../../library/stdtypes.rst:806 ../../library/stdtypes.rst:893
#: ../../library/stdtypes.rst:909 ../../library/stdtypes.rst:1076
#: ../../library/stdtypes.rst:1098 ../../library/stdtypes.rst:1113
msgid "sequence"
msgstr "послідовність"

#: ../../library/stdtypes.rst:806
msgid "iteration"
msgstr ""

#: ../../library/stdtypes.rst:806
msgid "container"
msgstr ""

#: ../../library/stdtypes.rst:806
msgid "iteration over"
msgstr ""

#: ../../library/stdtypes.rst:909 ../../library/stdtypes.rst:4372
msgid "len"
msgstr ""

#: ../../library/stdtypes.rst:909
msgid "min"
msgstr ""

#: ../../library/stdtypes.rst:909
msgid "max"
msgstr ""

#: ../../library/stdtypes.rst:909
msgid "concatenation"
msgstr ""

#: ../../library/stdtypes.rst:909
msgid "operation"
msgstr ""

#: ../../library/stdtypes.rst:909
msgid "repetition"
msgstr ""

#: ../../library/stdtypes.rst:909 ../../library/stdtypes.rst:1113
msgid "subscript"
msgstr ""

#: ../../library/stdtypes.rst:909 ../../library/stdtypes.rst:1113
msgid "slice"
msgstr "шматочок"

#: ../../library/stdtypes.rst:909
msgid "count() (sequence method)"
msgstr ""

#: ../../library/stdtypes.rst:909
msgid "index() (sequence method)"
msgstr ""

#: ../../library/stdtypes.rst:965
msgid "loop"
msgstr ""

#: ../../library/stdtypes.rst:965
msgid "over mutable sequence"
msgstr ""

#: ../../library/stdtypes.rst:965
msgid "mutable sequence"
msgstr ""

#: ../../library/stdtypes.rst:965
msgid "loop over"
msgstr ""

#: ../../library/stdtypes.rst:1076
msgid "immutable"
msgstr "незмінний"

#: ../../library/stdtypes.rst:1076 ../../library/stdtypes.rst:1297
msgid "tuple"
msgstr "кортеж"

#: ../../library/stdtypes.rst:1076
msgid "hash"
msgstr ""

#: ../../library/stdtypes.rst:1098
msgid "mutable"
msgstr "мінливий"

#: ../../library/stdtypes.rst:1098 ../../library/stdtypes.rst:1113
#: ../../library/stdtypes.rst:1218
msgid "list"
msgstr "список"

#: ../../library/stdtypes.rst:1098 ../../library/stdtypes.rst:2468
#: ../../library/stdtypes.rst:2594 ../../library/stdtypes.rst:2666
#: ../../library/stdtypes.rst:3487
msgid "bytearray"
msgstr ""

#: ../../library/stdtypes.rst:1113 ../../library/stdtypes.rst:4372
#: ../../library/stdtypes.rst:5098 ../../library/stdtypes.rst:5341
msgid "type"
msgstr "тип"

#: ../../library/stdtypes.rst:1113
msgid "assignment"
msgstr ""

#: ../../library/stdtypes.rst:1113 ../../library/stdtypes.rst:4372
msgid "del"
msgstr ""

#: ../../library/stdtypes.rst:1113
msgid "append() (sequence method)"
msgstr ""

#: ../../library/stdtypes.rst:1113
msgid "clear() (sequence method)"
msgstr ""

#: ../../library/stdtypes.rst:1113
msgid "copy() (sequence method)"
msgstr ""

#: ../../library/stdtypes.rst:1113
msgid "extend() (sequence method)"
msgstr ""

#: ../../library/stdtypes.rst:1113
msgid "insert() (sequence method)"
msgstr ""

#: ../../library/stdtypes.rst:1113
msgid "pop() (sequence method)"
msgstr ""

#: ../../library/stdtypes.rst:1113
msgid "remove() (sequence method)"
msgstr ""

#: ../../library/stdtypes.rst:1113
msgid "reverse() (sequence method)"
msgstr ""

#: ../../library/stdtypes.rst:1341
msgid "range"
msgstr ""

#: ../../library/stdtypes.rst:1463 ../../library/stdtypes.rst:1512
#: ../../library/stdtypes.rst:1557 ../../library/stdtypes.rst:2271
msgid "string"
msgstr "рядок"

#: ../../library/stdtypes.rst:1463
msgid "text sequence type"
msgstr ""

#: ../../library/stdtypes.rst:1463 ../../library/stdtypes.rst:1512
#: ../../library/stdtypes.rst:1530
msgid "str (built-in class)"
msgstr ""

#: ../../library/stdtypes.rst:1463
msgid "(see also string)"
msgstr ""

#: ../../library/stdtypes.rst:1499
msgid "io.StringIO"
msgstr ""

#: ../../library/stdtypes.rst:1530 ../../library/stdtypes.rst:2460
msgid "buffer protocol"
msgstr ""

#: ../../library/stdtypes.rst:1530 ../../library/stdtypes.rst:2468
#: ../../library/stdtypes.rst:2487 ../../library/stdtypes.rst:2666
#: ../../library/stdtypes.rst:3487
msgid "bytes"
msgstr "байтів"

#: ../../library/stdtypes.rst:1557 ../../library/stdtypes.rst:2666
msgid "methods"
msgstr ""

#: ../../library/stdtypes.rst:1565
msgid "re"
msgstr "повторно"

#: ../../library/stdtypes.rst:2080 ../../library/stdtypes.rst:3341
msgid "universal newlines"
msgstr "універсальні символи нового рядка"

#: ../../library/stdtypes.rst:2080
msgid "str.splitlines method"
msgstr ""

#: ../../library/stdtypes.rst:2271
msgid "formatting, string (%)"
msgstr ""

#: ../../library/stdtypes.rst:2271
msgid "interpolation, string (%)"
msgstr ""

#: ../../library/stdtypes.rst:2271
msgid "formatting, printf"
msgstr ""

#: ../../library/stdtypes.rst:2271
msgid "interpolation, printf"
msgstr ""

#: ../../library/stdtypes.rst:2271 ../../library/stdtypes.rst:3487
msgid "printf-style formatting"
msgstr ""

#: ../../library/stdtypes.rst:2271 ../../library/stdtypes.rst:3487
msgid "sprintf-style formatting"
msgstr ""

#: ../../library/stdtypes.rst:2301 ../../library/stdtypes.rst:3519
msgid "() (parentheses)"
msgstr ""

#: ../../library/stdtypes.rst:2301 ../../library/stdtypes.rst:2344
#: ../../library/stdtypes.rst:3519 ../../library/stdtypes.rst:3562
msgid "in printf-style formatting"
msgstr ""

#: ../../library/stdtypes.rst:2301 ../../library/stdtypes.rst:3519
msgid ". (dot)"
msgstr ""

#: ../../library/stdtypes.rst:2344 ../../library/stdtypes.rst:3562
msgid "# (hash)"
msgstr ""

#: ../../library/stdtypes.rst:2344 ../../library/stdtypes.rst:3562
msgid "space"
msgstr "простір"

#: ../../library/stdtypes.rst:2460
msgid "binary sequence types"
msgstr ""

#: ../../library/stdtypes.rst:2468
msgid "memoryview"
msgstr ""

#: ../../library/stdtypes.rst:2468
msgid "array"
msgstr "масив"

#: ../../library/stdtypes.rst:3341
msgid "bytes.splitlines method"
msgstr ""

#: ../../library/stdtypes.rst:3341
msgid "bytearray.splitlines method"
msgstr ""

#: ../../library/stdtypes.rst:3487
msgid "formatting"
msgstr ""

#: ../../library/stdtypes.rst:3487
msgid "bytes (%)"
msgstr ""

#: ../../library/stdtypes.rst:3487
msgid "bytearray (%)"
msgstr ""

#: ../../library/stdtypes.rst:3487
msgid "interpolation"
msgstr ""

#: ../../library/stdtypes.rst:4171
msgid "set"
msgstr "встановити"

#: ../../library/stdtypes.rst:4372
msgid "mapping"
msgstr "відображення"

#: ../../library/stdtypes.rst:4372
msgid "dictionary"
msgstr "словник"

#: ../../library/stdtypes.rst:4455
msgid "__missing__()"
msgstr ""

#: ../../library/stdtypes.rst:4758
msgid "context manager"
msgstr "контекстний менеджер"

#: ../../library/stdtypes.rst:4758
msgid "context management protocol"
msgstr ""

#: ../../library/stdtypes.rst:4758
msgid "context management"
msgstr ""

#: ../../library/stdtypes.rst:4831
msgid "annotation"
msgstr "анотація"

#: ../../library/stdtypes.rst:4831
msgid "type annotation; type hint"
msgstr ""

#: ../../library/stdtypes.rst:4843
msgid "GenericAlias"
msgstr ""

#: ../../library/stdtypes.rst:4843
msgid "Generic"
msgstr ""

#: ../../library/stdtypes.rst:4843
msgid "Alias"
msgstr ""

#: ../../library/stdtypes.rst:5098
msgid "Union"
msgstr ""

#: ../../library/stdtypes.rst:5098
msgid "union"
msgstr ""

#: ../../library/stdtypes.rst:5266
msgid "method"
msgstr "метод"

#: ../../library/stdtypes.rst:5305
msgid "code"
msgstr "код"

#: ../../library/stdtypes.rst:5305
msgid "code object"
msgstr "об'єкт коду"

#: ../../library/stdtypes.rst:5312
msgid "compile"
msgstr ""

#: ../../library/stdtypes.rst:5312
msgid "__code__ (function object attribute)"
msgstr ""

#: ../../library/stdtypes.rst:5326
msgid "exec"
msgstr ""

#: ../../library/stdtypes.rst:5326
msgid "eval"
msgstr ""

#: ../../library/stdtypes.rst:5365
msgid "..."
msgstr ""

#: ../../library/stdtypes.rst:5365
msgid "ellipsis literal"
msgstr ""

#: ../../library/stdtypes.rst:5405
msgid "values"
msgstr "значення"
