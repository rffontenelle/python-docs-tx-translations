# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Dmytro Kazanzhy, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-02 14:33+0000\n"
"PO-Revision-Date: 2017-02-16 17:37+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != 11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % 100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || (n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../c-api/memory.rst:8
msgid "Memory Management"
msgstr "Управління пам'яттю"

#: ../../c-api/memory.rst:17
msgid "Overview"
msgstr "Огляд"

#: ../../c-api/memory.rst:19
msgid ""
"Memory management in Python involves a private heap containing all Python "
"objects and data structures. The management of this private heap is ensured "
"internally by the *Python memory manager*.  The Python memory manager has "
"different components which deal with various dynamic storage management "
"aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"Керування пам’яттю в Python включає приватну купу, що містить усі об’єкти та"
" структури даних Python. Управління цією приватною купою забезпечується "
"внутрішньо за допомогою *Менеджера пам’яті Python*. Менеджер пам’яті Python "
"має різні компоненти, які стосуються різноманітних аспектів керування "
"динамічним сховищем, наприклад спільного використання, сегментації, "
"попереднього розподілу чи кешування."

#: ../../c-api/memory.rst:25
msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by interacting "
"with the memory manager of the operating system. On top of the raw memory "
"allocator, several object-specific allocators operate on the same heap and "
"implement distinct memory management policies adapted to the peculiarities "
"of every object type. For example, integer objects are managed differently "
"within the heap than strings, tuples or dictionaries because integers imply "
"different storage requirements and speed/space tradeoffs. The Python memory "
"manager thus delegates some of the work to the object-specific allocators, "
"but ensures that the latter operate within the bounds of the private heap."
msgstr ""
"На найнижчому рівні розподільник необробленої пам’яті забезпечує наявність "
"достатнього місця в приватній купі для зберігання всіх пов’язаних із Python "
"даних шляхом взаємодії з диспетчером пам’яті операційної системи. Окрім "
"необробленого розподільника пам’яті, кілька об’єктно-специфічних "
"розподільників працюють на одній купі та реалізують різні політики керування"
" пам’яттю, адаптовані до особливостей кожного типу об’єкта. Наприклад, "
"цілими об’єктами в купі керують інакше, ніж рядками, кортежами чи "
"словниками, оскільки цілі числа передбачають різні вимоги до сховища та "
"компроміси між швидкістю та простором. Таким чином, менеджер пам’яті Python "
"делегує частину роботи об’єктно-специфічним розподільникам, але гарантує, що"
" останні працюють у межах приватної купи."

#: ../../c-api/memory.rst:36
msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over "
"it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and other"
" internal buffers is performed on demand by the Python memory manager "
"through the Python/C API functions listed in this document."
msgstr ""
"Важливо розуміти, що керування купою Python виконується самим "
"інтерпретатором і що користувач не має контролю над нею, навіть якщо вони "
"регулярно маніпулюють покажчиками об’єктів на блоки пам’яті всередині цієї "
"купи. Виділення простору купи для об’єктів Python та інших внутрішніх "
"буферів виконується на вимогу менеджером пам’яті Python за допомогою функцій"
" API Python/C, перелічених у цьому документі."

#: ../../c-api/memory.rst:49
msgid ""
"To avoid memory corruption, extension writers should never try to operate on"
" Python objects with the functions exported by the C library: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`.  "
"This will result in  mixed calls between the C allocator and the Python "
"memory manager with fatal consequences, because they implement different "
"algorithms and operate on different heaps.  However, one may safely allocate"
" and release memory blocks with the C library allocator for individual "
"purposes, as shown in the following example::"
msgstr ""
"Щоб уникнути пошкодження пам’яті, автори розширень ніколи не повинні "
"намагатися працювати з об’єктами Python за допомогою функцій, експортованих "
"бібліотекою C: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` і "
":c:func:`free`. Це призведе до змішаних викликів між розподільником C і "
"диспетчером пам’яті Python із фатальними наслідками, оскільки вони "
"реалізують різні алгоритми та працюють із різними купами. Однак можна "
"безпечно виділяти та звільняти блоки пам’яті за допомогою розподільника "
"бібліотеки C для окремих цілей, як показано в наступному прикладі:"

#: ../../c-api/memory.rst:68
msgid ""
"In this example, the memory request for the I/O buffer is handled by the C "
"library allocator. The Python memory manager is involved only in the "
"allocation of the bytes object returned as a result."
msgstr ""
"У цьому прикладі запит пам’яті для буфера введення/виведення обробляється "
"розподільником бібліотеки C. Менеджер пам’яті Python бере участь лише у "
"розподілі об’єкта bytes, який повертається в результаті."

#: ../../c-api/memory.rst:72
msgid ""
"In most situations, however, it is recommended to allocate memory from the "
"Python heap specifically because the latter is under control of the Python "
"memory manager. For example, this is required when the interpreter is "
"extended with new object types written in C. Another reason for using the "
"Python heap is the desire to *inform* the Python memory manager about the "
"memory needs of the extension module. Even when the requested memory is used"
" exclusively for internal, highly-specific purposes, delegating all memory "
"requests to the Python memory manager causes the interpreter to have a more "
"accurate image of its memory footprint as a whole. Consequently, under "
"certain circumstances, the Python memory manager may or may not trigger "
"appropriate actions, like garbage collection, memory compaction or other "
"preventive procedures. Note that by using the C library allocator as shown "
"in the previous example, the allocated memory for the I/O buffer escapes "
"completely the Python memory manager."
msgstr ""
"Однак у більшості ситуацій рекомендується виділяти пам’ять із купи Python "
"спеціально, оскільки остання знаходиться під контролем менеджера пам’яті "
"Python. Наприклад, це потрібно, коли інтерпретатор розширюється новими "
"типами об’єктів, написаними на C. Іншою причиною використання купи Python є "
"бажання *інформувати* менеджера пам’яті Python про потреби модуля розширення"
" в пам’яті. Навіть коли запитана пам’ять використовується виключно для "
"внутрішніх, дуже специфічних цілей, делегування всіх запитів пам’яті "
"диспетчеру пам’яті Python змушує інтерпретатора мати більш точне зображення "
"його сліду пам’яті в цілому. Отже, за певних обставин диспетчер пам’яті "
"Python може запускати або не запускати відповідні дії, як-от збирання "
"сміття, стиснення пам’яті чи інші профілактичні процедури. Зауважте, що за "
"допомогою розподілювача бібліотеки C, як показано в попередньому прикладі, "
"виділена пам’ять для буфера вводу/виводу повністю виходить з диспетчера "
"пам’яті Python."

#: ../../c-api/memory.rst:88
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to configure the"
" memory allocators used by Python."
msgstr ""
"Змінну середовища :envvar:`PYTHONMALLOC` можна використовувати для "
"налаштування розподільників пам’яті, які використовує Python."

#: ../../c-api/memory.rst:91
msgid ""
"The :envvar:`PYTHONMALLOCSTATS` environment variable can be used to print "
"statistics of the :ref:`pymalloc memory allocator <pymalloc>` every time a "
"new pymalloc object arena is created, and on shutdown."
msgstr ""
"Змінну середовища :envvar:`PYTHONMALLOCSTATS` можна використовувати для "
"виведення статистики :ref:`розподільника пам’яті pymalloc <pymalloc>` "
"кожного разу, коли створюється нова арена об’єкта pymalloc, і після "
"завершення роботи."

#: ../../c-api/memory.rst:97
msgid "Raw Memory Interface"
msgstr "Інтерфейс необробленої пам'яті"

#: ../../c-api/memory.rst:99
msgid ""
"The following function sets are wrappers to the system allocator. These "
"functions are thread-safe, the :term:`GIL <global interpreter lock>` does "
"not need to be held."
msgstr ""
"Наступні набори функцій є оболонками для системного розподілювача. Ці "
"функції є потокобезпечними, :term:`GIL <global interpreter lock>` не "
"потрібно зберігати."

#: ../../c-api/memory.rst:103
msgid ""
"The :ref:`default raw memory allocator <default-memory-allocators>` uses the"
" following functions: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"and :c:func:`free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when requesting"
" zero bytes."
msgstr ""
":ref:`за замовчуванням необроблений розподільник пам’яті <default-memory-"
"allocators>` використовує такі функції: :c:func:`malloc`, :c:func:`calloc`, "
":c:func:`realloc` і :c:func:`free`; викликати ``malloc(1)`` (або ``calloc(1,"
" 1)``), коли запитує нульові байти."

#: ../../c-api/memory.rst:112 ../../c-api/memory.rst:183
#: ../../c-api/memory.rst:285
msgid ""
"Allocates *n* bytes and returns a pointer of type :c:type:`void*` to the "
"allocated memory, or ``NULL`` if the request fails."
msgstr ""
"Виділяє *n* байт і повертає вказівник типу :c:type:`void*` на виділену "
"пам’ять або ``NULL``, якщо запит не вдається."

#: ../../c-api/memory.rst:115
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_RawMalloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Запит нульових байтів повертає окремий вказівник, відмінний від ``NULL``, "
"якщо це можливо, ніби замість цього було викликано ``PyMem_RawMalloc(1)``. "
"Пам'ять жодним чином не буде ініціалізовано."

#: ../../c-api/memory.rst:122 ../../c-api/memory.rst:193
#: ../../c-api/memory.rst:295
msgid ""
"Allocates *nelem* elements each whose size in bytes is *elsize* and returns "
"a pointer of type :c:type:`void*` to the allocated memory, or ``NULL`` if "
"the request fails. The memory is initialized to zeros."
msgstr ""
"Виділяє елементи *nelem*, розмір кожного з яких у байтах дорівнює *elsize*, "
"і повертає вказівник типу :c:type:`void*` на виділену пам’ять або ``NULL``, "
"якщо запит не вдається. Пам'ять ініціалізується нулями."

#: ../../c-api/memory.rst:126
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_RawCalloc(1, 1)`` had been "
"called instead."
msgstr ""
"Запит нульових елементів або елементів розміром нуль байтів повертає окремий"
" вказівник, відмінний від ``NULL``, якщо це можливо, ніби замість цього було"
" викликано ``PyMem_RawCalloc(1, 1)``."

#: ../../c-api/memory.rst:135 ../../c-api/memory.rst:206
#: ../../c-api/memory.rst:308
msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes."
msgstr ""
"Змінює розмір блоку пам'яті, на який вказує *p*, до *n* байтів. Вміст буде "
"незмінним до мінімуму старого та нового розмірів."

#: ../../c-api/memory.rst:138
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_RawMalloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Якщо *p* має значення ``NULL``, виклик еквівалентний ``PyMem_RawMalloc(n)``;"
" інакше, якщо *n* дорівнює нулю, розмір блоку пам’яті змінюється, але не "
"звільняється, а повернутий вказівник не є ``NULL``."

#: ../../c-api/memory.rst:142
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or "
":c:func:`PyMem_RawCalloc`."
msgstr ""
"Якщо *p* не має значення ``NULL``, воно має бути повернуто попереднім "
"викликом :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` або "
":c:func:`PyMem_RawCalloc`."

#: ../../c-api/memory.rst:146
msgid ""
"If the request fails, :c:func:`PyMem_RawRealloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Якщо запит завершується невдало, :c:func:`PyMem_RawRealloc` повертає "
"``NULL``, а *p* залишається дійсним покажчиком на попередню область пам’яті."

#: ../../c-api/memory.rst:152
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or "
":c:func:`PyMem_RawCalloc`.  Otherwise, or if ``PyMem_RawFree(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Звільняє блок пам’яті, на який вказує *p*, який мав бути повернутий "
"попереднім викликом :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` "
"або :c:func:`PyMem_RawCalloc`. В іншому випадку, або якщо "
"``PyMem_RawFree(p)`` був викликаний раніше, виникає невизначена поведінка."

#: ../../c-api/memory.rst:157 ../../c-api/memory.rst:227
#: ../../c-api/memory.rst:329
msgid "If *p* is ``NULL``, no operation is performed."
msgstr "Якщо *p* має значення ``NULL``, жодна операція не виконується."

#: ../../c-api/memory.rst:163
msgid "Memory Interface"
msgstr "Інтерфейс пам'яті"

#: ../../c-api/memory.rst:165 ../../c-api/memory.rst:271
msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating"
" and releasing memory from the Python heap."
msgstr ""
"Наступні набори функцій, створені за стандартом ANSI C, але вказуючи "
"поведінку під час запиту нульових байтів, доступні для виділення та "
"звільнення пам’яті з купи Python."

#: ../../c-api/memory.rst:169
msgid ""
"The :ref:`default memory allocator <default-memory-allocators>` uses the "
":ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
":ref:`розподільник пам’яті за замовчуванням <default-memory-allocators>` "
"використовує :ref:`розподільник пам’яті pymalloc <pymalloc>`."

#: ../../c-api/memory.rst:174 ../../c-api/memory.rst:280
msgid ""
"The :term:`GIL <global interpreter lock>` must be held when using these "
"functions."
msgstr ""
":term:`GIL <global interpreter lock>` має зберігатися під час використання "
"цих функцій."

#: ../../c-api/memory.rst:179
msgid ""
"The default allocator is now pymalloc instead of system :c:func:`malloc`."
msgstr ""
"Типовим розподільником тепер є pymalloc замість system :c:func:`malloc`."

#: ../../c-api/memory.rst:186
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""
"Запит нульових байтів повертає окремий вказівник, відмінний від ``NULL``, "
"якщо це можливо, ніби замість цього було викликано ``PyMem_Malloc(1)``. "
"Пам'ять жодним чином не буде ініціалізовано."

#: ../../c-api/memory.rst:197
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Запит нульових елементів або елементів розміром нуль байтів повертає окремий"
" вказівник, відмінний від ``NULL``, якщо це можливо, як якщо б замість цього"
" було викликано ``PyMem_Calloc(1, 1)``."

#: ../../c-api/memory.rst:209
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_Malloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-``NULL``."
msgstr ""
"Якщо *p* має значення ``NULL``, виклик еквівалентний ``PyMem_Malloc(n)``; "
"інакше, якщо *n* дорівнює нулю, розмір блоку пам’яті змінюється, але не "
"звільняється, а повернутий вказівник не є ``NULL``."

#: ../../c-api/memory.rst:213
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:`PyMem_Calloc`."
msgstr ""
"Якщо *p* не має значення ``NULL``, воно має бути повернуто попереднім "
"викликом :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` або "
":c:func:`PyMem_Calloc`."

#: ../../c-api/memory.rst:216
msgid ""
"If the request fails, :c:func:`PyMem_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Якщо запит не вдається, :c:func:`PyMem_Realloc` повертає ``NULL``, а *p* "
"залишається дійсним покажчиком на попередню область пам’яті."

#: ../../c-api/memory.rst:222
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or "
":c:func:`PyMem_Calloc`.  Otherwise, or if ``PyMem_Free(p)`` has been called "
"before, undefined behavior occurs."
msgstr ""
"Звільняє блок пам’яті, на який вказує *p*, який мав бути повернутий "
"попереднім викликом :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` або "
":c:func:`PyMem_Calloc`. В іншому випадку, або якщо ``PyMem_Free(p)`` був "
"викликаний раніше, виникає невизначена поведінка."

#: ../../c-api/memory.rst:229
msgid ""
"The following type-oriented macros are provided for convenience.  Note  that"
" *TYPE* refers to any C type."
msgstr ""
"Для зручності надано наступні типоорієнтовані макроси. Зауважте, що *TYPE* "
"відноситься до будь-якого типу C."

#: ../../c-api/memory.rst:235
msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes "
"of memory.  Returns a pointer cast to :c:type:`TYPE*`.  The memory will not "
"have been initialized in any way."
msgstr ""
"Те саме, що :c:func:`PyMem_Malloc`, але виділяє ``(n * sizeof(TYPE))`` байти"
" пам'яті. Повертає покажчик, приведений до :c:type:`TYPE*`. Пам'ять жодним "
"чином не буде ініціалізовано."

#: ../../c-api/memory.rst:242
msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n * "
"sizeof(TYPE))`` bytes.  Returns a pointer cast to :c:type:`TYPE*`. On "
"return, *p* will be a pointer to the new memory area, or ``NULL`` in the "
"event of failure."
msgstr ""
"Те саме, що :c:func:`PyMem_Realloc`, але розмір блоку пам’яті змінено до "
"``(n * sizeof(TYPE))`` байтів. Повертає покажчик, приведений до "
":c:type:`TYPE*`. Після повернення *p* буде вказівником на нову область "
"пам’яті або ``NULL`` у разі помилки."

#: ../../c-api/memory.rst:247
msgid ""
"This is a C preprocessor macro; *p* is always reassigned.  Save the original"
" value of *p* to avoid losing memory when handling errors."
msgstr ""
"Це макрос препроцесора C; *p* завжди перепризначається. Збережіть початкове "
"значення *p*, щоб уникнути втрати пам’яті під час обробки помилок."

#: ../../c-api/memory.rst:253
msgid "Same as :c:func:`PyMem_Free`."
msgstr "Те саме, що :c:func:`PyMem_Free`."

#: ../../c-api/memory.rst:255
msgid ""
"In addition, the following macro sets are provided for calling the Python "
"memory allocator directly, without involving the C API functions listed "
"above. However, note that their use does not preserve binary compatibility "
"across Python versions and is therefore deprecated in extension modules."
msgstr ""
"Крім того, наведені нижче набори макросів надаються для безпосереднього "
"виклику розподільника пам’яті Python без залучення функцій C API, "
"перелічених вище. Однак зауважте, що їх використання не зберігає двійкову "
"сумісність між версіями Python і тому не підтримується в модулях розширення."

#: ../../c-api/memory.rst:260
msgid "``PyMem_MALLOC(size)``"
msgstr "``PyMem_MALLOC(розмір)``"

#: ../../c-api/memory.rst:261
msgid "``PyMem_NEW(type, size)``"
msgstr "``PyMem_NEW(тип, розмір)``"

#: ../../c-api/memory.rst:262
msgid "``PyMem_REALLOC(ptr, size)``"
msgstr "``PyMem_REALLOC(ptr, size)``"

#: ../../c-api/memory.rst:263
msgid "``PyMem_RESIZE(ptr, type, size)``"
msgstr "``PyMem_RESIZE(ptr, тип, розмір)``"

#: ../../c-api/memory.rst:264
msgid "``PyMem_FREE(ptr)``"
msgstr "``PyMem_FREE(ptr)``"

#: ../../c-api/memory.rst:265
msgid "``PyMem_DEL(ptr)``"
msgstr "``PyMem_DEL(ptr)``"

#: ../../c-api/memory.rst:269
msgid "Object allocators"
msgstr "Розподільники об'єктів"

#: ../../c-api/memory.rst:275
msgid ""
"The :ref:`default object allocator <default-memory-allocators>` uses the "
":ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
":ref:`розподільник об’єктів за замовчуванням <default-memory-allocators>` "
"використовує :ref:`розподільник пам’яті pymalloc <pymalloc>`."

#: ../../c-api/memory.rst:288
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyObject_Malloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Запит нульових байтів повертає окремий покажчик, відмінний від ``NULL``, "
"якщо це можливо, ніби замість цього було викликано ``PyObject_Malloc(1)``. "
"Пам'ять жодним чином не буде ініціалізовано."

#: ../../c-api/memory.rst:299
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyObject_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Запит нульових елементів або елементів розміром нуль байтів повертає окремий"
" вказівник, відмінний від ``NULL``, якщо це можливо, як якщо б замість цього"
" було викликано ``PyObject_Calloc(1, 1)``."

#: ../../c-api/memory.rst:311
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyObject_Malloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Якщо *p* має значення ``NULL``, виклик еквівалентний ``PyObject_Malloc(n)``;"
" інакше, якщо *n* дорівнює нулю, розмір блоку пам’яті змінюється, але не "
"звільняється, а повернутий вказівник не є ``NULL``."

#: ../../c-api/memory.rst:315
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or "
":c:func:`PyObject_Calloc`."
msgstr ""
"Якщо *p* не має значення ``NULL``, воно має бути повернуто попереднім "
"викликом :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` або "
":c:func:`PyObject_Calloc`."

#: ../../c-api/memory.rst:318
msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Якщо запит не вдається, :c:func:`PyObject_Realloc` повертає ``NULL``, а *p* "
"залишається дійсним покажчиком на попередню область пам’яті."

#: ../../c-api/memory.rst:324
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or "
":c:func:`PyObject_Calloc`.  Otherwise, or if ``PyObject_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Звільняє блок пам’яті, на який вказує *p*, який мав бути повернутий "
"попереднім викликом :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` "
"або :c:func:`PyObject_Calloc`. В іншому випадку, або якщо "
"``PyObject_Free(p)`` був викликаний раніше, виникає невизначена поведінка."

#: ../../c-api/memory.rst:335
msgid "Default Memory Allocators"
msgstr "Типові розподілювачі пам'яті"

#: ../../c-api/memory.rst:337
msgid "Default memory allocators:"
msgstr "Розподільники пам'яті за замовчуванням:"

#: ../../c-api/memory.rst:340
msgid "Configuration"
msgstr "Конфігурація"

#: ../../c-api/memory.rst:340
msgid "Name"
msgstr "Ім'я"

#: ../../c-api/memory.rst:340
msgid "PyMem_RawMalloc"
msgstr "PyMem_RawMalloc"

#: ../../c-api/memory.rst:340
msgid "PyMem_Malloc"
msgstr "PyMem_Malloc"

#: ../../c-api/memory.rst:340
msgid "PyObject_Malloc"
msgstr "PyObject_Malloc"

#: ../../c-api/memory.rst:342
msgid "Release build"
msgstr "Реліз збірки"

#: ../../c-api/memory.rst:342
msgid "``\"pymalloc\"``"
msgstr "``\"pymalloc\"``"

#: ../../c-api/memory.rst:342 ../../c-api/memory.rst:344
#: ../../c-api/memory.rst:344 ../../c-api/memory.rst:344
msgid "``malloc``"
msgstr "``malloc``"

#: ../../c-api/memory.rst:342 ../../c-api/memory.rst:342
msgid "``pymalloc``"
msgstr "``pymalloc``"

#: ../../c-api/memory.rst:343
msgid "Debug build"
msgstr "Налагодити збірку"

#: ../../c-api/memory.rst:343
msgid "``\"pymalloc_debug\"``"
msgstr "``\"pymalloc_debug\"``"

#: ../../c-api/memory.rst:343 ../../c-api/memory.rst:345
#: ../../c-api/memory.rst:345 ../../c-api/memory.rst:345
msgid "``malloc`` + debug"
msgstr "``malloc`` + налагодження"

#: ../../c-api/memory.rst:343 ../../c-api/memory.rst:343
msgid "``pymalloc`` + debug"
msgstr "``pymalloc`` + налагодження"

#: ../../c-api/memory.rst:344
msgid "Release build, without pymalloc"
msgstr "Випуск збірки без pymalloc"

#: ../../c-api/memory.rst:344
msgid "``\"malloc\"``"
msgstr "``\"malloc\"``"

#: ../../c-api/memory.rst:345
msgid "Debug build, without pymalloc"
msgstr "Збірка налагодження без pymalloc"

#: ../../c-api/memory.rst:345
msgid "``\"malloc_debug\"``"
msgstr "``\"malloc_debug\"``"

#: ../../c-api/memory.rst:348
msgid "Legend:"
msgstr "Легенда:"

#: ../../c-api/memory.rst:350
msgid "Name: value for :envvar:`PYTHONMALLOC` environment variable"
msgstr ""

#: ../../c-api/memory.rst:351
msgid ""
"``malloc``: system allocators from the standard C library, C functions: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`"
msgstr ""

#: ../../c-api/memory.rst:353
msgid "``pymalloc``: :ref:`pymalloc memory allocator <pymalloc>`"
msgstr ""

#: ../../c-api/memory.rst:354
msgid "\"+ debug\": with debug hooks installed by :c:func:`PyMem_SetupDebugHooks`"
msgstr ""

#: ../../c-api/memory.rst:358
msgid "Customize Memory Allocators"
msgstr "Налаштувати розподільники пам'яті"

#: ../../c-api/memory.rst:364
msgid ""
"Structure used to describe a memory block allocator. The structure has the "
"following fields:"
msgstr ""
"Структура, яка використовується для опису розподілювача блоків пам'яті. "
"Структура має такі поля:"

#: ../../c-api/memory.rst:368 ../../c-api/memory.rst:513
msgid "Field"
msgstr "Поле"

#: ../../c-api/memory.rst:368 ../../c-api/memory.rst:513
msgid "Meaning"
msgstr "Значення"

#: ../../c-api/memory.rst:370 ../../c-api/memory.rst:515
msgid "``void *ctx``"
msgstr "``недійсний *ctx``"

#: ../../c-api/memory.rst:370 ../../c-api/memory.rst:515
msgid "user context passed as first argument"
msgstr "контекст користувача, переданий як перший аргумент"

#: ../../c-api/memory.rst:372
msgid "``void* malloc(void *ctx, size_t size)``"
msgstr "``void* malloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:372
msgid "allocate a memory block"
msgstr "виділити блок пам'яті"

#: ../../c-api/memory.rst:374
msgid "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"
msgstr "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"

#: ../../c-api/memory.rst:374
msgid "allocate a memory block initialized with zeros"
msgstr "виділити блок пам'яті, ініціалізований нулями"

#: ../../c-api/memory.rst:377
msgid "``void* realloc(void *ctx, void *ptr, size_t new_size)``"
msgstr "``void* realloc(void *ctx, void *ptr, size_t new_size)``"

#: ../../c-api/memory.rst:377
msgid "allocate or resize a memory block"
msgstr "виділити або змінити розмір блоку пам'яті"

#: ../../c-api/memory.rst:379
msgid "``void free(void *ctx, void *ptr)``"
msgstr "``void free(void *ctx, void *ptr)``"

#: ../../c-api/memory.rst:379
msgid "free a memory block"
msgstr "звільнити блок пам'яті"

#: ../../c-api/memory.rst:382
msgid ""
"The :c:type:`PyMemAllocator` structure was renamed to "
":c:type:`PyMemAllocatorEx` and a new ``calloc`` field was added."
msgstr ""
"Структуру :c:type:`PyMemAllocator` було перейменовано на "
":c:type:`PyMemAllocatorEx` і додано нове поле ``calloc``."

#: ../../c-api/memory.rst:389
msgid "Enum used to identify an allocator domain. Domains:"
msgstr "Enum використовується для визначення домену розподілювача. Домени:"

#: ../../c-api/memory.rst:393 ../../c-api/memory.rst:402
#: ../../c-api/memory.rst:411
msgid "Functions:"
msgstr "функції:"

#: ../../c-api/memory.rst:395
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/memory.rst:396
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/memory.rst:397
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/memory.rst:398
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/memory.rst:404
msgid ":c:func:`PyMem_Malloc`,"
msgstr ":c:func:`PyMem_Malloc`,"

#: ../../c-api/memory.rst:405
msgid ":c:func:`PyMem_Realloc`"
msgstr ":c:func:`PyMem_Realloc`"

#: ../../c-api/memory.rst:406
msgid ":c:func:`PyMem_Calloc`"
msgstr ":c:func:`PyMem_Calloc`"

#: ../../c-api/memory.rst:407
msgid ":c:func:`PyMem_Free`"
msgstr ":c:func:`PyMem_Free`"

#: ../../c-api/memory.rst:413
msgid ":c:func:`PyObject_Malloc`"
msgstr ":c:func:`PyObject_Malloc`"

#: ../../c-api/memory.rst:414
msgid ":c:func:`PyObject_Realloc`"
msgstr ":c:func:`PyObject_Realloc`"

#: ../../c-api/memory.rst:415
msgid ":c:func:`PyObject_Calloc`"
msgstr ":c:func:`PyObject_Calloc`"

#: ../../c-api/memory.rst:416
msgid ":c:func:`PyObject_Free`"
msgstr ":c:func:`PyObject_Free`"

#: ../../c-api/memory.rst:420
msgid "Get the memory block allocator of the specified domain."
msgstr "Отримати розподільник блоків пам’яті вказаного домену."

#: ../../c-api/memory.rst:425
msgid "Set the memory block allocator of the specified domain."
msgstr "Установіть розподільник блоків пам'яті для вказаного домену."

#: ../../c-api/memory.rst:427
msgid ""
"The new allocator must return a distinct non-``NULL`` pointer when "
"requesting zero bytes."
msgstr ""
"Новий розподільник має повертати окремий покажчик, відмінний від ``NULL``, "
"коли запитує нульові байти."

#: ../../c-api/memory.rst:430
msgid ""
"For the :c:data:`PYMEM_DOMAIN_RAW` domain, the allocator must be thread-"
"safe: the :term:`GIL <global interpreter lock>` is not held when the "
"allocator is called."
msgstr ""
"Для домену :c:data:`PYMEM_DOMAIN_RAW` розподільник має бути потокобезпечним:"
" :term:`GIL <global interpreter lock>` не утримується під час виклику "
"розподілювача."

#: ../../c-api/memory.rst:434
msgid ""
"If the new allocator is not a hook (does not call the previous allocator), "
"the :c:func:`PyMem_SetupDebugHooks` function must be called to reinstall the"
" debug hooks on top on the new allocator."
msgstr ""
"Якщо новий розподільник не є хуком (не викликає попереднього розподільника),"
" необхідно викликати функцію :c:func:`PyMem_SetupDebugHooks`, щоб "
"перевстановити налагоджувальні хуки поверх нового розподільника."

#: ../../c-api/memory.rst:441
msgid "Setup hooks to detect bugs in the Python memory allocator functions."
msgstr ""

#: ../../c-api/memory.rst:443
msgid ""
"Newly allocated memory is filled with the byte ``0xCD`` (``CLEANBYTE``), "
"freed memory is filled with the byte ``0xDD`` (``DEADBYTE``). Memory blocks "
"are surrounded by \"forbidden bytes\" (``FORBIDDENBYTE``: byte ``0xFD``)."
msgstr ""

#: ../../c-api/memory.rst:447
msgid "Runtime checks:"
msgstr "Перевірки виконання:"

#: ../../c-api/memory.rst:449
msgid ""
"Detect API violations, ex: :c:func:`PyObject_Free` called on a buffer "
"allocated by :c:func:`PyMem_Malloc`"
msgstr ""

#: ../../c-api/memory.rst:451
msgid "Detect write before the start of the buffer (buffer underflow)"
msgstr ""

#: ../../c-api/memory.rst:452
msgid "Detect write after the end of the buffer (buffer overflow)"
msgstr ""

#: ../../c-api/memory.rst:453
msgid ""
"Check that the :term:`GIL <global interpreter lock>` is held when allocator "
"functions of :c:data:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) and "
":c:data:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) domains are called"
msgstr ""

#: ../../c-api/memory.rst:458
msgid ""
"On error, the debug hooks use the :mod:`tracemalloc` module to get the "
"traceback where a memory block was allocated. The traceback is only "
"displayed if :mod:`tracemalloc` is tracing Python memory allocations and the"
" memory block was traced."
msgstr ""
"У разі помилки хуки налагодження використовують модуль :mod:`tracemalloc`, "
"щоб отримати зворотне відстеження, де було виділено блок пам’яті. Зворотне "
"відстеження відображається, лише якщо :mod:`tracemalloc` відстежує виділення"
" пам’яті Python і блок пам’яті відстежується."

#: ../../c-api/memory.rst:463
msgid ""
"These hooks are :ref:`installed by default <default-memory-allocators>` if "
"Python is compiled in debug mode. The :envvar:`PYTHONMALLOC` environment "
"variable can be used to install debug hooks on a Python compiled in release "
"mode."
msgstr ""

#: ../../c-api/memory.rst:468
msgid ""
"This function now also works on Python compiled in release mode. On error, "
"the debug hooks now use :mod:`tracemalloc` to get the traceback where a "
"memory block was allocated. The debug hooks now also check if the GIL is "
"held when functions of :c:data:`PYMEM_DOMAIN_OBJ` and "
":c:data:`PYMEM_DOMAIN_MEM` domains are called."
msgstr ""

#: ../../c-api/memory.rst:475
msgid ""
"Byte patterns ``0xCB`` (``CLEANBYTE``), ``0xDB`` (``DEADBYTE``) and ``0xFB``"
" (``FORBIDDENBYTE``) have been replaced with ``0xCD``, ``0xDD`` and ``0xFD``"
" to use the same values than Windows CRT debug ``malloc()`` and ``free()``."
msgstr ""

#: ../../c-api/memory.rst:485
msgid "The pymalloc allocator"
msgstr "Розподільник pymalloc"

#: ../../c-api/memory.rst:487
msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or "
"equal to 512 bytes) with a short lifetime. It uses memory mappings called "
"\"arenas\" with a fixed size of 256 KiB. It falls back to "
":c:func:`PyMem_RawMalloc` and :c:func:`PyMem_RawRealloc` for allocations "
"larger than 512 bytes."
msgstr ""
"Python має розподільник *pymalloc*, оптимізований для малих об’єктів (менших"
" або рівних 512 байтам) із коротким часом життя. Він використовує "
"відображення пам’яті, які називаються \"аренами\" з фіксованим розміром 256 "
"КБ. Він повертається до :c:func:`PyMem_RawMalloc` і "
":c:func:`PyMem_RawRealloc` для розподілу розміром більше 512 байт."

#: ../../c-api/memory.rst:492
msgid ""
"*pymalloc* is the :ref:`default allocator <default-memory-allocators>` of "
"the :c:data:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and "
":c:data:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains."
msgstr ""
"*pymalloc* є :ref:`розподільником за замовчуванням <default-memory-"
"allocators>` :c:data:`PYMEM_DOMAIN_MEM` (наприклад: :c:func:`PyMem_Malloc`) "
"і :c:data:`PYMEM_DOMAIN_OBJ` (наприклад: :c:func:`PyObject_Malloc`)."

#: ../../c-api/memory.rst:496
msgid "The arena allocator uses the following functions:"
msgstr "Розподільник арени використовує такі функції:"

#: ../../c-api/memory.rst:498
msgid ":c:func:`VirtualAlloc` and :c:func:`VirtualFree` on Windows,"
msgstr ":c:func:`VirtualAlloc` і :c:func:`VirtualFree` у Windows,"

#: ../../c-api/memory.rst:499
msgid ":c:func:`mmap` and :c:func:`munmap` if available,"
msgstr ":c:func:`mmap` і :c:func:`munmap`, якщо доступні,"

#: ../../c-api/memory.rst:500
msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr ":c:func:`malloc` і :c:func:`free` інакше."

#: ../../c-api/memory.rst:503
msgid "Customize pymalloc Arena Allocator"
msgstr "Налаштувати pymalloc Arena Allocator"

#: ../../c-api/memory.rst:509
msgid ""
"Structure used to describe an arena allocator. The structure has three "
"fields:"
msgstr ""
"Структура, яка використовується для опису розподільника арен. Структура має "
"три поля:"

#: ../../c-api/memory.rst:517
msgid "``void* alloc(void *ctx, size_t size)``"
msgstr "``void* alloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:517
msgid "allocate an arena of size bytes"
msgstr "виділити арену розміром байт"

#: ../../c-api/memory.rst:519
msgid "``void free(void *ctx, void *ptr, size_t size)``"
msgstr "``void free(void *ctx, void *ptr, size_t size)``"

#: ../../c-api/memory.rst:519
msgid "free an arena"
msgstr "звільнити арену"

#: ../../c-api/memory.rst:524
msgid "Get the arena allocator."
msgstr "Отримайте розподільник арен."

#: ../../c-api/memory.rst:528
msgid "Set the arena allocator."
msgstr "Встановіть розподільник арен."

#: ../../c-api/memory.rst:532
msgid "tracemalloc C API"
msgstr "tracemalloc C API"

#: ../../c-api/memory.rst:538
msgid "Track an allocated memory block in the :mod:`tracemalloc` module."
msgstr "Відстежуйте виділений блок пам’яті в модулі :mod:`tracemalloc`."

#: ../../c-api/memory.rst:540
msgid ""
"Return ``0`` on success, return ``-1`` on error (failed to allocate memory "
"to store the trace). Return ``-2`` if tracemalloc is disabled."
msgstr ""
"Повертає ``0`` у разі успіху, повертає ``-1`` у разі помилки (не вдалося "
"виділити пам’ять для збереження трасування). Повертає ``-2``, якщо "
"tracemalloc вимкнено."

#: ../../c-api/memory.rst:543
msgid "If memory block is already tracked, update the existing trace."
msgstr "Якщо блок пам’яті вже відстежується, оновіть наявне трасування."

#: ../../c-api/memory.rst:547
msgid ""
"Untrack an allocated memory block in the :mod:`tracemalloc` module. Do "
"nothing if the block was not tracked."
msgstr ""
"Скасувати відстеження виділеного блоку пам’яті в модулі :mod:`tracemalloc`. "
"Нічого не робити, якщо блок не відстежується."

#: ../../c-api/memory.rst:550
msgid "Return ``-2`` if tracemalloc is disabled, otherwise return ``0``."
msgstr "Повертає ``-2``, якщо tracemalloc вимкнено, інакше повертає ``0``."

#: ../../c-api/memory.rst:556
msgid "Examples"
msgstr "Приклади"

#: ../../c-api/memory.rst:558
msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that "
"the I/O buffer is allocated from the Python heap by using the first function"
" set::"
msgstr ""
"Ось приклад із розділу :ref:`memoryoverview`, переписаний таким чином, що "
"буфер введення/виведення виділяється з купи Python за допомогою першого "
"набору функцій::"

#: ../../c-api/memory.rst:571
msgid "The same code using the type-oriented function set::"
msgstr "Той самий код із використанням типу орієнтованого набору функцій::"

#: ../../c-api/memory.rst:583
msgid ""
"Note that in the two examples above, the buffer is always manipulated via "
"functions belonging to the same set. Indeed, it is required to use the same "
"memory API family for a given memory block, so that the risk of mixing "
"different allocators is reduced to a minimum. The following code sequence "
"contains two errors, one of which is labeled as *fatal* because it mixes two"
" different allocators operating on different heaps. ::"
msgstr ""
"Зауважте, що у двох наведених вище прикладах буфером завжди керують функції,"
" що належать одному набору. Дійсно, для певного блоку пам’яті потрібно "
"використовувати одне й те саме сімейство API пам’яті, щоб ризик змішування "
"різних розподільників був зведений до мінімуму. Наступна кодова "
"послідовність містить дві помилки, одна з яких позначена як *фатальна*, "
"оскільки вона змішує два різних розподільника, що працюють на різних купах. "
"::"

#: ../../c-api/memory.rst:598
msgid ""
"In addition to the functions aimed at handling raw memory blocks from the "
"Python heap, objects in Python are allocated and released with "
":c:func:`PyObject_New`, :c:func:`PyObject_NewVar` and "
":c:func:`PyObject_Del`."
msgstr ""
"На додаток до функцій, спрямованих на обробку необроблених блоків пам’яті з "
"купи Python, об’єкти в Python виділяються та звільняються за допомогою "
":c:func:`PyObject_New`, :c:func:`PyObject_NewVar` і :c:func:`PyObject_Del` ."

#: ../../c-api/memory.rst:602
msgid ""
"These will be explained in the next chapter on defining and implementing new"
" object types in C."
msgstr ""
"Це буде пояснено в наступному розділі про визначення та реалізацію нових "
"типів об’єктів у C."
