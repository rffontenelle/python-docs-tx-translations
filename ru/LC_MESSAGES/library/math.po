# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:09+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/math.rst:2
msgid ":mod:`!math` --- Mathematical functions"
msgstr ""
"Сообщайте о событиях, которые происходят во время нормальной работы "
"программы (например, для мониторинга состояния или расследования ошибок)."

#: ../../library/math.rst:13
msgid ""
"This module provides access to the mathematical functions defined by the C "
"standard."
msgstr ""
"Этот модуль обеспечивает доступ к математическим функциям, определенным "
"стандартом C."

#: ../../library/math.rst:16
msgid ""
"These functions cannot be used with complex numbers; use the functions of "
"the same name from the :mod:`cmath` module if you require support for "
"complex numbers.  The distinction between functions which support complex "
"numbers and those which don't is made since most users do not want to learn "
"quite as much mathematics as required to understand complex numbers.  "
"Receiving an exception instead of a complex result allows earlier detection "
"of the unexpected complex number used as a parameter, so that the programmer "
"can determine how and why it was generated in the first place."
msgstr ""
"Эти функции нельзя использовать с комплексными числами; используйте "
"одноименные функции из модуля :mod:`cmath`, если вам требуется поддержка "
"комплексных чисел. Различие между функциями, поддерживающими комплексные "
"числа, и функциями, которые этого не поддерживают, проводится потому, что "
"большинство пользователей не хотят изучать столько математики, сколько "
"необходимо для понимания комплексных чисел. Получение исключения вместо "
"комплексного результата позволяет раньше обнаружить неожиданное комплексное "
"число, используемое в качестве параметра, чтобы программист мог определить, "
"как и почему оно было сгенерировано."

#: ../../library/math.rst:25
msgid ""
"The following functions are provided by this module.  Except when explicitly "
"noted otherwise, all return values are floats."
msgstr ""
"Этот модуль предоставляет следующие функции. Если явно не указано иное, все "
"возвращаемые значения являются числами с плавающей запятой."

#: ../../library/math.rst:30
msgid "**Number-theoretic functions**"
msgstr "**Теоретико-числовые функции**"

#: ../../library/math.rst:32
msgid ":func:`comb(n, k) <comb>`"
msgstr ":func:`comb(n, k) <comb>`"

#: ../../library/math.rst:32
msgid ""
"Number of ways to choose *k* items from *n* items without repetition and "
"without order"
msgstr ""
"Количество способов выбрать *k* предметов из *n* предметов без повторения и "
"без порядка"

#: ../../library/math.rst:33
msgid ":func:`factorial(n) <factorial>`"
msgstr ":func:`factorial(n) <factorial>`"

#: ../../library/math.rst:33
msgid "*n* factorial"
msgstr "*n* факториал"

#: ../../library/math.rst:34
msgid ":func:`gcd(*integers) <gcd>`"
msgstr ":func:`gcd(*integers) <gcd>`"

#: ../../library/math.rst:34
msgid "Greatest common divisor of the integer arguments"
msgstr "Наибольший общий делитель целочисленных аргументов"

#: ../../library/math.rst:35
msgid ":func:`isqrt(n) <isqrt>`"
msgstr ":func:`isqrt(n) <isqrt>`"

#: ../../library/math.rst:35
msgid "Integer square root of a nonnegative integer *n*"
msgstr "Целый квадратный корень из неотрицательного целого числа *n*"

#: ../../library/math.rst:36
msgid ":func:`lcm(*integers) <lcm>`"
msgstr ":func:`lcm(*integers) <lcm>`"

#: ../../library/math.rst:36
msgid "Least common multiple of the integer arguments"
msgstr "Наименьшее общее кратное целочисленных аргументов"

#: ../../library/math.rst:37
msgid ":func:`perm(n, k) <perm>`"
msgstr ":func:`perm(n, k) <perm>`"

#: ../../library/math.rst:37
msgid ""
"Number of ways to choose *k* items from *n* items without repetition and "
"with order"
msgstr ""
"Количество способов выбрать *k* предметов из *n* предметов без повторения и "
"в порядке"

#: ../../library/math.rst:39
msgid "**Floating point arithmetic**"
msgstr "**Арифметика с плавающей запятой**"

#: ../../library/math.rst:41
msgid ":func:`ceil(x) <ceil>`"
msgstr ":func:`ceil(x) <ceil>`"

#: ../../library/math.rst:41
msgid "Ceiling of *x*, the smallest integer greater than or equal to *x*"
msgstr "Потолок *x*, наименьшее целое число, большее или равное *x*"

#: ../../library/math.rst:42
msgid ":func:`fabs(x) <fabs>`"
msgstr ":func:`fabs(x) <fabs>`"

#: ../../library/math.rst:42
msgid "Absolute value of *x*"
msgstr "Абсолютное значение *x*"

#: ../../library/math.rst:43
msgid ":func:`floor(x)  <floor>`"
msgstr ":func:`floor(x)  <floor>`"

#: ../../library/math.rst:43
msgid "Floor of *x*, the largest integer less than or equal to *x*"
msgstr "Этаж *x*, наибольшее целое число, меньшее или равное *x*"

#: ../../library/math.rst:44
msgid ":func:`fma(x, y, z) <fma>`"
msgstr ":func:`fma(x, y, z) <fma>`"

#: ../../library/math.rst:44
msgid "Fused multiply-add operation: ``(x * y) + z``"
msgstr "Объединенная операция умножения-сложения: ``(x * y) + z``"

#: ../../library/math.rst:45
msgid ":func:`fmod(x, y) <fmod>`"
msgstr ":func:`fmod(x, y) <fmod>`"

#: ../../library/math.rst:45
msgid "Remainder of division ``x / y``"
msgstr "*n* факториал"

#: ../../library/math.rst:46
msgid ":func:`modf(x) <modf>`"
msgstr ":func:`modf(x) <modf>`"

#: ../../library/math.rst:46
msgid "Fractional and integer parts of *x*"
msgstr "Дробная и целая части *x*"

#: ../../library/math.rst:47
msgid ":func:`remainder(x, y) <remainder>`"
msgstr ":func:`remainder(x, y) <remainder>`"

#: ../../library/math.rst:47
msgid "Remainder of *x* with respect to *y*"
msgstr "Остаток *x* относительно *y*"

#: ../../library/math.rst:48
msgid ":func:`trunc(x) <trunc>`"
msgstr ":func:`trunc(x) <trunc>`"

#: ../../library/math.rst:48
msgid "Integer part of *x*"
msgstr "Целая часть *x*"

#: ../../library/math.rst:50
msgid "**Floating point manipulation functions**"
msgstr "**Функции манипуляции с плавающей запятой**"

#: ../../library/math.rst:52
msgid ":func:`copysign(x, y) <copysign>`"
msgstr ":func:`copysign(x, y) <copysign>`"

#: ../../library/math.rst:52
msgid "Magnitude (absolute value) of *x* with the sign of *y*"
msgstr "Величина (абсолютное значение) *x* со знаком *y*"

#: ../../library/math.rst:53
msgid ":func:`frexp(x) <frexp>`"
msgstr ":func:`frexp(x) <frexp>`"

#: ../../library/math.rst:53
msgid "Mantissa and exponent of *x*"
msgstr "Мантисса и показатель *x*"

#: ../../library/math.rst:54
msgid ":func:`isclose(a, b, rel_tol, abs_tol) <isclose>`"
msgstr ":func:`isclose(a, b, rel_tol, abs_tol) <isclose>`"

#: ../../library/math.rst:54
msgid "Check if the values *a* and *b* are close to each other"
msgstr "Проверьте, близки ли значения *a* и *b* друг к другу."

#: ../../library/math.rst:55
msgid ":func:`isfinite(x) <isfinite>`"
msgstr ":func:`isfinite(x) <isfinite>`"

#: ../../library/math.rst:55
msgid "Check if *x* is neither an infinity nor a NaN"
msgstr "Проверьте, не является ли *x* ни бесконечностью, ни NaN."

#: ../../library/math.rst:56
msgid ":func:`isinf(x) <isinf>`"
msgstr ":func:`isinf(x) <isinf>`"

#: ../../library/math.rst:56
msgid "Check if *x* is a positive or negative infinity"
msgstr ""
"Проверьте, является ли *x* положительной или отрицательной бесконечностью."

#: ../../library/math.rst:57
msgid ":func:`isnan(x) <isnan>`"
msgstr ":func:`isnan(x) <isnan>`"

#: ../../library/math.rst:57
msgid "Check if *x* is a NaN  (not a number)"
msgstr "Проверьте, является ли *x* NaN (а не числом)"

#: ../../library/math.rst:58
msgid ":func:`ldexp(x, i) <ldexp>`"
msgstr ":func:`ldexp(x, i) <ldexp>`"

#: ../../library/math.rst:58
msgid "``x * (2**i)``, inverse of function :func:`frexp`"
msgstr "``x * (2**i)``, обратная функции :func:`frexp`"

#: ../../library/math.rst:59
msgid ":func:`nextafter(x, y, steps) <nextafter>`"
msgstr ":func:`nextafter(x, y, steps) <nextafter>`"

#: ../../library/math.rst:59
msgid "Floating-point value *steps* steps after *x* towards *y*"
msgstr "Значение с плавающей запятой *шаги* шаги после *x* в сторону *y*"

#: ../../library/math.rst:60
msgid ":func:`ulp(x) <ulp>`"
msgstr ":func:`ulp(x) <ulp>`"

#: ../../library/math.rst:60
msgid "Value of the least significant bit of *x*"
msgstr "Значение младшего бита *x*"

#: ../../library/math.rst:62
msgid "**Power, exponential and logarithmic functions**"
msgstr "**Степеньевые, показательные и логарифмические функции**"

#: ../../library/math.rst:64
msgid ":func:`cbrt(x) <cbrt>`"
msgstr ":func:`cbrt(x) <cbrt>`"

#: ../../library/math.rst:64
msgid "Cube root of *x*"
msgstr "Кубический корень из *x*"

#: ../../library/math.rst:65
msgid ":func:`exp(x) <exp>`"
msgstr ":func:`exp(x) <exp>`"

#: ../../library/math.rst:65
msgid "*e* raised to the power *x*"
msgstr "*e* возведено в степень *x*"

#: ../../library/math.rst:66
msgid ":func:`exp2(x) <exp2>`"
msgstr ":func:`exp2(x) <exp2>`"

#: ../../library/math.rst:66
msgid "*2* raised to the power *x*"
msgstr "*2* возведен в степень *x*"

#: ../../library/math.rst:67
msgid ":func:`expm1(x) <expm1>`"
msgstr ":func:`expm1(x) <expm1>`"

#: ../../library/math.rst:67
msgid "*e* raised to the power *x*, minus 1"
msgstr "*e* возведено в степень *x*, минус 1"

#: ../../library/math.rst:68
msgid ":func:`log(x, base) <log>`"
msgstr ":func:`log(x, base) <log>`"

#: ../../library/math.rst:68
msgid "Logarithm of *x* to the given base (*e* by default)"
msgstr "Логарифм *x* по заданному основанию (по умолчанию *e*)"

#: ../../library/math.rst:69
msgid ":func:`log1p(x) <log1p>`"
msgstr ":func:`log1p(x) <log1p>`"

#: ../../library/math.rst:69
msgid "Natural logarithm of *1+x* (base *e*)"
msgstr "Натуральный логарифм *1+x* (по основанию *e*)"

#: ../../library/math.rst:70
msgid ":func:`log2(x) <log2>`"
msgstr ":func:`log2(x) <log2>`"

#: ../../library/math.rst:70
msgid "Base-2 logarithm of *x*"
msgstr "Логарифм по основанию 2 от *x*"

#: ../../library/math.rst:71
msgid ":func:`log10(x) <log10>`"
msgstr ":func:`log10(x) <log10>`"

#: ../../library/math.rst:71
msgid "Base-10 logarithm of *x*"
msgstr "Логарифм по основанию 10 от *x*"

#: ../../library/math.rst:72
msgid ":func:`pow(x, y) <math.pow>`"
msgstr ":func:`pow(x, y) <math.pow>`"

#: ../../library/math.rst:72
msgid "*x* raised to the power *y*"
msgstr "*x* возведен в степень *y*"

#: ../../library/math.rst:73
msgid ":func:`sqrt(x) <sqrt>`"
msgstr ":func:`sqrt(x) <sqrt>`"

#: ../../library/math.rst:73
msgid "Square root of *x*"
msgstr "Квадратный корень из *x*"

#: ../../library/math.rst:75
msgid "**Summation and product functions**"
msgstr "**Функции суммирования и произведения**"

#: ../../library/math.rst:77
msgid ":func:`dist(p, q) <dist>`"
msgstr ":func:`dist(p, q) <dist>`"

#: ../../library/math.rst:77
msgid ""
"Euclidean distance between two points *p* and *q* given as an iterable of "
"coordinates"
msgstr ""
"Евклидово расстояние между двумя точками *p* и *q*, заданными как итерация "
"координат"

#: ../../library/math.rst:78
msgid ":func:`fsum(iterable) <fsum>`"
msgstr ":func:`fsum(iterable) <fsum>`"

#: ../../library/math.rst:78
msgid "Sum of values in the input *iterable*"
msgstr "Сумма значений во входных данных *итерируемая*"

#: ../../library/math.rst:79
msgid ":func:`hypot(*coordinates) <hypot>`"
msgstr ":func:`hypot(*coordinates) <hypot>`"

#: ../../library/math.rst:79
msgid "Euclidean norm of an iterable of coordinates"
msgstr "Евклидова норма итерации координат"

#: ../../library/math.rst:80
msgid ":func:`prod(iterable, start) <prod>`"
msgstr ":func:`prod(iterable, start) <prod>`"

#: ../../library/math.rst:80
msgid "Product of elements in the input *iterable* with a *start* value"
msgstr "Произведение элементов входных данных *iterable* со значением *start*"

#: ../../library/math.rst:81
msgid ":func:`sumprod(p, q) <sumprod>`"
msgstr ":func:`sumprod(p, q) <sumprod>`"

#: ../../library/math.rst:81
msgid "Sum of products from two iterables *p* and *q*"
msgstr "Сумма произведений двух итераций *p* и *q*"

#: ../../library/math.rst:83
msgid "**Angular conversion**"
msgstr "**Угловое преобразование**"

#: ../../library/math.rst:85
msgid ":func:`degrees(x) <degrees>`"
msgstr ":func:`grades(x) <градусы>`"

#: ../../library/math.rst:85
msgid "Convert angle *x* from radians to degrees"
msgstr "Перевести угол *x* из радиан в градусы"

#: ../../library/math.rst:86
msgid ":func:`radians(x) <radians>`"
msgstr ":func:`radians(x) <radians>`"

#: ../../library/math.rst:86
msgid "Convert angle *x* from degrees to radians"
msgstr "Перевести угол *x* из градусов в радианы"

#: ../../library/math.rst:88
msgid "**Trigonometric functions**"
msgstr "**Тригонометрические функции**"

#: ../../library/math.rst:90
msgid ":func:`acos(x) <acos>`"
msgstr ":func:`acos(x) <acos>`"

#: ../../library/math.rst:90
msgid "Arc cosine of *x*"
msgstr "Арккосинус *x*"

#: ../../library/math.rst:91
msgid ":func:`asin(x) <asin>`"
msgstr ":func:`asin(x) <asin>`"

#: ../../library/math.rst:91
msgid "Arc sine of *x*"
msgstr "Арксинус *x*"

#: ../../library/math.rst:92
msgid ":func:`atan(x) <atan>`"
msgstr ":func:`atan(x) <atan>`"

#: ../../library/math.rst:92
msgid "Arc tangent of *x*"
msgstr "Арктангенс *x*"

#: ../../library/math.rst:93
msgid ":func:`atan2(y, x) <atan2>`"
msgstr ":func:`atan2(y, x) <atan2>`"

#: ../../library/math.rst:93
msgid "``atan(y / x)``"
msgstr "``atan(y / x)``"

#: ../../library/math.rst:94
msgid ":func:`cos(x) <cos>`"
msgstr ":func:`cos(x) <cos>`"

#: ../../library/math.rst:94
msgid "Cosine of *x*"
msgstr "Косинус *x*"

#: ../../library/math.rst:95
msgid ":func:`sin(x) <sin>`"
msgstr ":func:`sin(x) <sin>`"

#: ../../library/math.rst:95
msgid "Sine of *x*"
msgstr "Синус *x*"

#: ../../library/math.rst:96
msgid ":func:`tan(x) <tan>`"
msgstr ":func:`tan(x) <tan>`"

#: ../../library/math.rst:96
msgid "Tangent of *x*"
msgstr "Тангенс *x*"

#: ../../library/math.rst:98
msgid "**Hyperbolic functions**"
msgstr "**Гиперболические функции**"

#: ../../library/math.rst:100
msgid ":func:`acosh(x) <acosh>`"
msgstr ":func:`acosh(x) <acosh>`"

#: ../../library/math.rst:100
msgid "Inverse hyperbolic cosine of *x*"
msgstr "Обратный гиперболический косинус *x*"

#: ../../library/math.rst:101
msgid ":func:`asinh(x) <asinh>`"
msgstr ":func:`asinh(x) <asinh>`"

#: ../../library/math.rst:101
msgid "Inverse hyperbolic sine of *x*"
msgstr "Обратный гиперболический синус *x*"

#: ../../library/math.rst:102
msgid ":func:`atanh(x) <atanh>`"
msgstr ":func:`atanh(x) <atanh>`"

#: ../../library/math.rst:102
msgid "Inverse hyperbolic tangent of *x*"
msgstr "Обратный гиперболический тангенс *x*"

#: ../../library/math.rst:103
msgid ":func:`cosh(x) <cosh>`"
msgstr ":func:`cosh(x) <cosh>`"

#: ../../library/math.rst:103
msgid "Hyperbolic cosine of *x*"
msgstr "Гиперболический косинус *x*"

#: ../../library/math.rst:104
msgid ":func:`sinh(x) <sinh>`"
msgstr ":func:`sinh(x) <sinh>`"

#: ../../library/math.rst:104
msgid "Hyperbolic sine of *x*"
msgstr "Гиперболический синус *x*"

#: ../../library/math.rst:105
msgid ":func:`tanh(x) <tanh>`"
msgstr ":func:`tanh(x) <tanh>`"

#: ../../library/math.rst:105
msgid "Hyperbolic tangent of *x*"
msgstr "Гиперболический тангенс *x*"

#: ../../library/math.rst:107
msgid "**Special functions**"
msgstr "**Специальные функции**"

#: ../../library/math.rst:109
msgid ":func:`erf(x) <erf>`"
msgstr ":func:`erf(x) <erf>`"

#: ../../library/math.rst:109
msgid "`Error function <https://en.wikipedia.org/wiki/Error_function>`_ at *x*"
msgstr "`Функция ошибки <https://en.wikipedia.org/wiki/Error_function>`_ в *x*"

#: ../../library/math.rst:110
msgid ":func:`erfc(x) <erfc>`"
msgstr ":func:`erfc(x) <erfc>`"

#: ../../library/math.rst:110
msgid ""
"`Complementary error function <https://en.wikipedia.org/wiki/"
"Error_function>`_ at *x*"
msgstr ""
"`Дополнительная функция ошибки <https://en.wikipedia.org/wiki/"
"Error_function>`_ в *x*"

#: ../../library/math.rst:111
msgid ":func:`gamma(x) <gamma>`"
msgstr ":func:`gamma(x) <gamma>`"

#: ../../library/math.rst:111
msgid "`Gamma function <https://en.wikipedia.org/wiki/Gamma_function>`_ at *x*"
msgstr "`Гамма-функция <https://en.wikipedia.org/wiki/Gamma_function>`_ в *x*"

#: ../../library/math.rst:112
msgid ":func:`lgamma(x) <lgamma>`"
msgstr ":func:`lgamma(x) <lgamma>`"

#: ../../library/math.rst:112
msgid ""
"Natural logarithm of the absolute value of the `Gamma function <https://en."
"wikipedia.org/wiki/Gamma_function>`_ at *x*"
msgstr ""
"Натуральный логарифм абсолютного значения `гамма-функции <https://en."
"wikipedia.org/wiki/Gamma_function>`_ в *x*"

#: ../../library/math.rst:114
msgid "**Constants**"
msgstr "**Константы**"

#: ../../library/math.rst:116
msgid ":data:`pi`"
msgstr ":data:`pi`"

#: ../../library/math.rst:116
msgid "*π* = 3.141592..."
msgstr "*π* = 3.141592..."

#: ../../library/math.rst:117
msgid ":data:`e`"
msgstr ":data:`e`"

#: ../../library/math.rst:117
msgid "*e* = 2.718281..."
msgstr "*e* = 2.718281..."

#: ../../library/math.rst:118
msgid ":data:`tau`"
msgstr ":data:`tau`"

#: ../../library/math.rst:118
msgid "*τ* = 2\\ *π* = 6.283185..."
msgstr "*τ* = 2\\ *π* = 6.283185..."

#: ../../library/math.rst:119
msgid ":data:`inf`"
msgstr ":data:`inf`"

#: ../../library/math.rst:119
msgid "Positive infinity"
msgstr "Положительная бесконечность"

#: ../../library/math.rst:120
msgid ":data:`nan`"
msgstr ":data:`nan`"

#: ../../library/math.rst:120
msgid "\"Not a number\" (NaN)"
msgstr "«Не число» (NaN)"

#: ../../library/math.rst:125
msgid "Number-theoretic functions"
msgstr "Теоретико-числовые функции"

#: ../../library/math.rst:129
msgid ""
"Return the number of ways to choose *k* items from *n* items without "
"repetition and without order."
msgstr ""
"Возвращает количество способов выбрать *k* элементов из *n* элементов без "
"повторения и без порядка."

#: ../../library/math.rst:132
msgid ""
"Evaluates to ``n! / (k! * (n - k)!)`` when ``k <= n`` and evaluates to zero "
"when ``k > n``."
msgstr ""
"Оценивается как ``n! / (k! * (n - k)!)``, когда ``k <= n``, и равен нулю, "
"когда ``k > n``."

#: ../../library/math.rst:135
msgid ""
"Also called the binomial coefficient because it is equivalent to the "
"coefficient of k-th term in polynomial expansion of ``(1 + x)ⁿ``."
msgstr ""
"Также называется биномиальным коэффициентом, потому что он эквивалентен "
"коэффициенту k-го члена в полиномиальном разложении ``(1 + x)ⁿ``."

#: ../../library/math.rst:139 ../../library/math.rst:205
msgid ""
"Raises :exc:`TypeError` if either of the arguments are not integers. Raises :"
"exc:`ValueError` if either of the arguments are negative."
msgstr ""
"Вызывает :exc:`TypeError`, если какой-либо из аргументов не является целым "
"числом. Вызывает :exc:`ValueError`, если любой из аргументов отрицательный."

#: ../../library/math.rst:147
msgid ""
"Return *n* factorial as an integer.  Raises :exc:`ValueError` if *n* is not "
"integral or is negative."
msgstr ""
"Верните факториал *n* как целое число. Вызывает :exc:`ValueError`, если *n* "
"не целое или отрицательное."

#: ../../library/math.rst:150
msgid "Floats with integral values (like ``5.0``) are no longer accepted."
msgstr ""
"Плавающие числа с целыми значениями (например, ``5.0``) больше не "
"принимаются."

#: ../../library/math.rst:156
msgid ""
"Return the greatest common divisor of the specified integer arguments. If "
"any of the arguments is nonzero, then the returned value is the largest "
"positive integer that is a divisor of all arguments.  If all arguments are "
"zero, then the returned value is ``0``.  ``gcd()`` without arguments returns "
"``0``."
msgstr ""
"Возвращает наибольший общий делитель указанных целочисленных аргументов. "
"Если какой-либо из аргументов не равен нулю, возвращаемое значение "
"представляет собой наибольшее положительное целое число, которое является "
"делителем всех аргументов. Если все аргументы равны нулю, то возвращаемое "
"значение равно «0». ``gcd()`` без аргументов возвращает ``0``."

#: ../../library/math.rst:164
msgid ""
"Added support for an arbitrary number of arguments. Formerly, only two "
"arguments were supported."
msgstr ""
"Добавлена ​​поддержка произвольного количества аргументов. Раньше "
"поддерживались только два аргумента."

#: ../../library/math.rst:171
msgid ""
"Return the integer square root of the nonnegative integer *n*. This is the "
"floor of the exact square root of *n*, or equivalently the greatest integer "
"*a* such that *a*\\ ² |nbsp| ≤ |nbsp| *n*."
msgstr ""
"Возвращает целочисленный квадратный корень из неотрицательного целого числа "
"*n*. Это нижний предел точного квадратного корня из *n* или, что то же "
"самое, наибольшего целого числа *a* такого, что *a*\\ ² |nbsp| ≤ |nbsp| *н*."

#: ../../library/math.rst:175
msgid ""
"For some applications, it may be more convenient to have the least integer "
"*a* such that *n* |nbsp| ≤ |nbsp| *a*\\ ², or in other words the ceiling of "
"the exact square root of *n*. For positive *n*, this can be computed using "
"``a = 1 + isqrt(n - 1)``."
msgstr ""
"Для некоторых приложений может быть удобнее иметь наименьшее целое число *a* "
"такое, что *n* |nbsp| ≤ |nbsp| *a*\\², или, другими словами, потолок точного "
"квадратного корня из *n*. Для положительного *n* это можно вычислить, "
"используя ``a = 1 + isqrt(n - 1)``."

#: ../../library/math.rst:185
msgid ""
"Return the least common multiple of the specified integer arguments. If all "
"arguments are nonzero, then the returned value is the smallest positive "
"integer that is a multiple of all arguments.  If any of the arguments is "
"zero, then the returned value is ``0``.  ``lcm()`` without arguments returns "
"``1``."
msgstr ""
"Возвращает наименьшее общее кратное указанных целочисленных аргументов. Если "
"все аргументы не равны нулю, то возвращаемое значение представляет собой "
"наименьшее положительное целое число, кратное всем аргументам. Если какой-"
"либо из аргументов равен нулю, то возвращаемое значение равно ``0``. "
"``lcm()`` без аргументов возвращает ``1``."

#: ../../library/math.rst:196
msgid ""
"Return the number of ways to choose *k* items from *n* items without "
"repetition and with order."
msgstr ""
"Возвращает количество способов выбрать *k* элементов из *n* элементов без "
"повторения и в определенном порядке."

#: ../../library/math.rst:199
msgid ""
"Evaluates to ``n! / (n - k)!`` when ``k <= n`` and evaluates to zero when "
"``k > n``."
msgstr ""
"Оценивается как ``n! / (n - k)!``, когда ``k <= n``, и равен нулю, когда ``k "
"> n``."

#: ../../library/math.rst:202
msgid ""
"If *k* is not specified or is ``None``, then *k* defaults to *n* and the "
"function returns ``n!``."
msgstr ""
"Если *k* не указано или равно ``None``, тогда *k* по умолчанию равно *n*, и "
"функция возвращает ``n!``."

#: ../../library/math.rst:212
msgid "Floating point arithmetic"
msgstr "Арифметика с плавающей запятой"

#: ../../library/math.rst:216
msgid ""
"Return the ceiling of *x*, the smallest integer greater than or equal to "
"*x*. If *x* is not a float, delegates to :meth:`x.__ceil__ <object."
"__ceil__>`, which should return an :class:`~numbers.Integral` value."
msgstr ""
"Возвращает потолок *x*, наименьшее целое число, большее или равное *x*. Если "
"*x* не является числом с плавающей запятой, делегируется :meth:`x.__ceil__ "
"<object.__ceil__>`, который должен возвращать значение :class:`~numbers."
"Integral`."

#: ../../library/math.rst:223
msgid "Return the absolute value of *x*."
msgstr "Верните абсолютное значение *x*."

#: ../../library/math.rst:228
msgid ""
"Return the floor of *x*, the largest integer less than or equal to *x*.  If "
"*x* is not a float, delegates to :meth:`x.__floor__ <object.__floor__>`, "
"which should return an :class:`~numbers.Integral` value."
msgstr ""
"Возвращает нижний предел *x*, наибольшее целое число, меньшее или равное "
"*x*. Если *x* не является числом с плавающей запятой, делегируется :meth:`x."
"__floor__ <object.__floor__>`, который должен возвращать значение :class:"
"`~numbers.Integral`."

#: ../../library/math.rst:235
msgid ""
"Fused multiply-add operation. Return ``(x * y) + z``, computed as though "
"with infinite precision and range followed by a single round to the "
"``float`` format. This operation often provides better accuracy than the "
"direct expression ``(x * y) + z``."
msgstr ""
"Объединенная операция умножения-сложения. Возвращает ``(x * y) + z``, "
"вычисляемое как будто с бесконечной точностью и диапазоном, за которым "
"следует один раунд в формате ``float``. Эта операция часто обеспечивает "
"лучшую точность, чем прямое выражение ``(x * y) + z``."

#: ../../library/math.rst:240
msgid ""
"This function follows the specification of the fusedMultiplyAdd operation "
"described in the IEEE 754 standard. The standard leaves one case "
"implementation-defined, namely the result of ``fma(0, inf, nan)`` and "
"``fma(inf, 0, nan)``. In these cases, ``math.fma`` returns a NaN, and does "
"not raise any exception."
msgstr ""
"Эта функция соответствует спецификации операции FusedMultiplyAdd, описанной "
"в стандарте IEEE 754. Стандарт оставляет один случай определяемым "
"реализацией, а именно результат ``fma(0, inf, nan)`` и ``fma(inf, 0, nan)``. "
"В этих случаях math.fma возвращает NaN и не вызывает никаких исключений."

#: ../../library/math.rst:251
msgid ""
"Return the floating-point remainder of ``x / y``, as defined by the platform "
"C library function ``fmod(x, y)``. Note that the Python expression ``x % y`` "
"may not return the same result.  The intent of the C standard is that "
"``fmod(x, y)`` be exactly (mathematically; to infinite precision) equal to "
"``x - n*y`` for some integer *n* such that the result has the same sign as "
"*x* and magnitude less than ``abs(y)``.  Python's ``x % y`` returns a result "
"with the sign of *y* instead, and may not be exactly computable for float "
"arguments. For example, ``fmod(-1e-100, 1e100)`` is ``-1e-100``, but the "
"result of Python's ``-1e-100 % 1e100`` is ``1e100-1e-100``, which cannot be "
"represented exactly as a float, and rounds to the surprising ``1e100``.  For "
"this reason, function :func:`fmod` is generally preferred when working with "
"floats, while Python's ``x % y`` is preferred when working with integers."
msgstr ""

#: ../../library/math.rst:267
msgid ""
"Return the fractional and integer parts of *x*.  Both results carry the sign "
"of *x* and are floats."
msgstr ""
"Возвращает дробную и целую части *x*. Оба результата имеют знак *x* и "
"являются числами с плавающей запятой."

#: ../../library/math.rst:270
msgid ""
"Note that :func:`modf` has a different call/return pattern than its C "
"equivalents: it takes a single argument and return a pair of values, rather "
"than returning its second return value through an 'output parameter' (there "
"is no such thing in Python)."
msgstr ""
"Обратите внимание, что :func:`modf` имеет другой шаблон вызова/возврата, чем "
"его эквиваленты на C: он принимает один аргумент и возвращает пару значений, "
"а не возвращает второе возвращаемое значение через «выходной "
"параметр» (такого не существует). вещь в Python)."

#: ../../library/math.rst:278
msgid ""
"Return the IEEE 754-style remainder of *x* with respect to *y*.  For finite "
"*x* and finite nonzero *y*, this is the difference ``x - n*y``, where ``n`` "
"is the closest integer to the exact value of the quotient ``x / y``.  If "
"``x / y`` is exactly halfway between two consecutive integers, the nearest "
"*even* integer is used for ``n``.  The remainder ``r = remainder(x, y)`` "
"thus always satisfies ``abs(r) <= 0.5 * abs(y)``."
msgstr ""
"Возвращает остаток *x* в стиле IEEE 754 относительно *y*. Для конечного *x* "
"и конечного ненулевого *y* это разница ``x - n*y``, где ``n`` — ближайшее "
"целое число к точному значению частного ``x / y`` . Если ``x / y`` находится "
"ровно посередине между двумя последовательными целыми числами, ближайшее "
"*чётное* целое число используется для ``n``. Таким образом, остаток ``r = "
"остаток(x, y)`` всегда удовлетворяет ``abs(r) <= 0,5 * abs(y)``."

#: ../../library/math.rst:285
msgid ""
"Special cases follow IEEE 754: in particular, ``remainder(x, math.inf)`` is "
"*x* for any finite *x*, and ``remainder(x, 0)`` and ``remainder(math.inf, "
"x)`` raise :exc:`ValueError` for any non-NaN *x*. If the result of the "
"remainder operation is zero, that zero will have the same sign as *x*."
msgstr ""
"Особые случаи соответствуют IEEE 754: в частности, ``remainder(x, math."
"inf)`` равен *x* для любого конечного *x*, а ``remainder(x, 0)`` и "
"``remainder(math.inf. inf, x)`` поднять :exc:`ValueError` для любого "
"значения, отличного от NaN *x*. Если результат операции остатка равен нулю, "
"этот ноль будет иметь тот же знак, что и *x*."

#: ../../library/math.rst:291
msgid ""
"On platforms using IEEE 754 binary floating point, the result of this "
"operation is always exactly representable: no rounding error is introduced."
msgstr ""
"На платформах, использующих двоичную плавающую запятую IEEE 754, результат "
"этой операции всегда точно представим: ошибка округления не возникает."

#: ../../library/math.rst:299
msgid ""
"Return *x* with the fractional part removed, leaving the integer part.  This "
"rounds toward 0: ``trunc()`` is equivalent to :func:`floor` for positive "
"*x*, and equivalent to :func:`ceil` for negative *x*. If *x* is not a float, "
"delegates to :meth:`x.__trunc__ <object.__trunc__>`, which should return an :"
"class:`~numbers.Integral` value."
msgstr ""
"Верните *x* с удаленной дробной частью, оставив целую часть. Округление в "
"сторону 0: ``trunc()`` эквивалентно :func:`floor` для положительного *x* и "
"эквивалентно :func:`ceil` для отрицательного *x*. Если *x* не является "
"числом с плавающей запятой, делегируется :meth:`x.__trunc__ <object."
"__trunc__>`, который должен возвращать значение :class:`~numbers.Integral`."

#: ../../library/math.rst:306
msgid ""
"For the :func:`ceil`, :func:`floor`, and :func:`modf` functions, note that "
"*all* floating-point numbers of sufficiently large magnitude are exact "
"integers. Python floats typically carry no more than 53 bits of precision "
"(the same as the platform C double type), in which case any float *x* with "
"``abs(x) >= 2**52`` necessarily has no fractional bits."
msgstr ""
"Обратите внимание, что для функций :func:`ceil`, :func:`floor` и :func:"
"`modf` *все* числа с плавающей запятой достаточно большой величины являются "
"точными целыми числами. Числа с плавающей запятой в Python обычно содержат "
"не более 53 бит точности (так же, как двойной тип платформы C), и в этом "
"случае любое число с плавающей запятой *x* с ``abs(x) >= 2**52`` обязательно "
"не имеет дробных битов. ."

#: ../../library/math.rst:314
msgid "Floating point manipulation functions"
msgstr "Функции манипуляции с плавающей запятой"

#: ../../library/math.rst:318
msgid ""
"Return a float with the magnitude (absolute value) of *x* but the sign of "
"*y*.  On platforms that support signed zeros, ``copysign(1.0, -0.0)`` "
"returns *-1.0*."
msgstr ""
"Возвращает число с плавающей запятой с величиной (абсолютным значением) *x*, "
"но со знаком *y*. На платформах, поддерживающих нули со знаком, "
"``copysign(1.0, -0.0)`` возвращает *-1.0*."

#: ../../library/math.rst:325
msgid ""
"Return the mantissa and exponent of *x* as the pair ``(m, e)``.  *m* is a "
"float and *e* is an integer such that ``x == m * 2**e`` exactly. If *x* is "
"zero, returns ``(0.0, 0)``, otherwise ``0.5 <= abs(m) < 1``.  This is used "
"to \"pick apart\" the internal representation of a float in a portable way."
msgstr ""
"Верните мантиссу и показатель степени *x* как пару ``(m, e)``. *m* — это "
"число с плавающей запятой, а *e* — целое число такое, что точно ``x == m * "
"2**e``. Если *x* равно нулю, возвращается ``(0.0, 0)``, в противном случае "
"``0.5 <= abs(m) < 1``. Это используется для «разбора» внутреннего "
"представления float переносимым способом."

#: ../../library/math.rst:330
msgid ""
"Note that :func:`frexp` has a different call/return pattern than its C "
"equivalents: it takes a single argument and return a pair of values, rather "
"than returning its second return value through an 'output parameter' (there "
"is no such thing in Python)."
msgstr ""
"Обратите внимание, что :func:`frexp` имеет другой шаблон вызова/возврата, "
"чем его эквиваленты на C: он принимает один аргумент и возвращает пару "
"значений, а не возвращает второе возвращаемое значение через «выходной "
"параметр» (такого не существует). вещь в Python)."

#: ../../library/math.rst:337
msgid ""
"Return ``True`` if the values *a* and *b* are close to each other and "
"``False`` otherwise."
msgstr ""
"Возвращайте ``True``, если значения *a* и *b* близки друг к другу, и "
"``False`` в противном случае."

#: ../../library/math.rst:340
msgid ""
"Whether or not two values are considered close is determined according to "
"given absolute and relative tolerances.  If no errors occur, the result will "
"be: ``abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)``."
msgstr ""
"Считаются ли два значения близкими или нет, определяется в соответствии с "
"заданными абсолютными и относительными допусками. Если ошибок не возникнет, "
"результатом будет: ``abs(ab) <= max(rel_tol * max(abs(a), abs(b)), "
"abs_tol)``."

#: ../../library/math.rst:344
msgid ""
"*rel_tol* is the relative tolerance -- it is the maximum allowed difference "
"between *a* and *b*, relative to the larger absolute value of *a* or *b*. "
"For example, to set a tolerance of 5%, pass ``rel_tol=0.05``.  The default "
"tolerance is ``1e-09``, which assures that the two values are the same "
"within about 9 decimal digits.  *rel_tol* must be nonnegative and less than "
"``1.0``."
msgstr ""
"*rel_tol* — это относительный допуск — это максимально допустимая разница "
"между *a* и *b* относительно большего абсолютного значения *a* или *b*. "
"Например, чтобы установить допуск 5 %, укажите rel_tol=0,05. Допуск по "
"умолчанию — «1e-09», который гарантирует, что два значения одинаковы в "
"пределах примерно 9 десятичных цифр. *rel_tol* должен быть неотрицательным и "
"меньше ``1.0``."

#: ../../library/math.rst:351
msgid ""
"*abs_tol* is the absolute tolerance; it defaults to ``0.0`` and it must be "
"nonnegative.  When comparing ``x`` to ``0.0``, ``isclose(x, 0)`` is computed "
"as ``abs(x) <= rel_tol  * abs(x)``, which is ``False`` for any ``x`` and "
"rel_tol less than ``1.0``.  So add an appropriate positive abs_tol argument "
"to the call."
msgstr ""
"*abs_tol* — абсолютный допуск; по умолчанию оно равно ``0.0`` и должно быть "
"неотрицательным. При сравнении ``x`` с ``0.0`` ``isclose(x, 0)`` вычисляется "
"как ``abs(x) <= rel_tol * abs(x)``, что является ``False` ` для любого ``x`` "
"и rel_tol меньше ``1.0``. Поэтому добавьте к вызову соответствующий "
"положительный аргумент abs_tol."

#: ../../library/math.rst:357
msgid ""
"The IEEE 754 special values of ``NaN``, ``inf``, and ``-inf`` will be "
"handled according to IEEE rules.  Specifically, ``NaN`` is not considered "
"close to any other value, including ``NaN``.  ``inf`` and ``-inf`` are only "
"considered close to themselves."
msgstr ""
"Специальные значения IEEE 754 NaN, inf и -inf будут обрабатываться в "
"соответствии с правилами IEEE. В частности, NaN не считается близким к "
"какому-либо другому значению, включая NaN. ``inf`` и ``-inf`` считаются "
"только близкими к себе."

#: ../../library/math.rst:366
msgid ":pep:`485` -- A function for testing approximate equality"
msgstr ":pep:`485` -- Функция для проверки приблизительного равенства"

#: ../../library/math.rst:371
msgid ""
"Return ``True`` if *x* is neither an infinity nor a NaN, and ``False`` "
"otherwise.  (Note that ``0.0`` *is* considered finite.)"
msgstr ""
"Возвращайте ``True``, если *x* не является ни бесконечностью, ни NaN, и "
"``False`` в противном случае. (Обратите внимание, что ``0.0`` *считается* "
"конечным.)"

#: ../../library/math.rst:379
msgid ""
"Return ``True`` if *x* is a positive or negative infinity, and ``False`` "
"otherwise."
msgstr ""
"Возвращайте ``True``, если *x* является положительной или отрицательной "
"бесконечностью, и ``False`` в противном случае."

#: ../../library/math.rst:385
msgid ""
"Return ``True`` if *x* is a NaN (not a number), and ``False`` otherwise."
msgstr ""
"Возвращайте ``True``, если *x* — это NaN (не число), и ``False`` в противном "
"случае."

#: ../../library/math.rst:390
msgid ""
"Return ``x * (2**i)``.  This is essentially the inverse of function :func:"
"`frexp`."
msgstr "Верните ``x * (2**i)``. По сути, это обратная функция :func:`frexp`."

#: ../../library/math.rst:396
msgid "Return the floating-point value *steps* steps after *x* towards *y*."
msgstr ""
"Возвращает значение с плавающей запятой *шаги* шаги после *x* в сторону *y*."

#: ../../library/math.rst:398
msgid "If *x* is equal to *y*, return *y*, unless *steps* is zero."
msgstr "Если *x* равно *y*, верните *y*, если только *steps* не равно нулю."

#: ../../library/math.rst:400
msgid "Examples:"
msgstr "Примеры:"

#: ../../library/math.rst:402
msgid "``math.nextafter(x, math.inf)`` goes up: towards positive infinity."
msgstr ""
"``math.nextafter(x, math.inf)`` идет вверх: в сторону положительной "
"бесконечности."

#: ../../library/math.rst:403
msgid "``math.nextafter(x, -math.inf)`` goes down: towards minus infinity."
msgstr ""
"``math.nextafter(x, -math.inf)`` снижается: в сторону минус бесконечности."

#: ../../library/math.rst:404
msgid "``math.nextafter(x, 0.0)`` goes towards zero."
msgstr "``math.nextafter(x, 0.0)`` стремится к нулю."

#: ../../library/math.rst:405
msgid "``math.nextafter(x, math.copysign(math.inf, x))`` goes away from zero."
msgstr "``math.nextafter(x, math.copysign(math.inf, x))`` уходит от нуля."

#: ../../library/math.rst:407
msgid "See also :func:`math.ulp`."
msgstr "См. также :func:`math.ulp`."

#: ../../library/math.rst:411
msgid "Added the *steps* argument."
msgstr "Добавлен аргумент *steps*."

#: ../../library/math.rst:417
msgid "Return the value of the least significant bit of the float *x*:"
msgstr "Вернуть значение младшего бита числа с плавающей запятой *x*:"

#: ../../library/math.rst:419
msgid "If *x* is a NaN (not a number), return *x*."
msgstr "Если *x* — это NaN (не число), верните *x*."

#: ../../library/math.rst:420
msgid "If *x* is negative, return ``ulp(-x)``."
msgstr "Если *x* отрицательное значение, верните ``ulp(-x)``."

#: ../../library/math.rst:421
msgid "If *x* is a positive infinity, return *x*."
msgstr "Если *x* — положительная бесконечность, верните *x*."

#: ../../library/math.rst:422
msgid ""
"If *x* is equal to zero, return the smallest positive *denormalized* "
"representable float (smaller than the minimum positive *normalized* float, :"
"data:`sys.float_info.min <sys.float_info>`)."
msgstr ""
"Если *x* равно нулю, верните наименьшее положительное *денормализованное* "
"представимое число с плавающей запятой (меньше, чем минимальное "
"положительное *нормализованное* число с плавающей запятой, :data:`sys."
"float_info.min <sys.float_info>`)."

#: ../../library/math.rst:425
msgid ""
"If *x* is equal to the largest positive representable float, return the "
"value of the least significant bit of *x*, such that the first float smaller "
"than *x* is ``x - ulp(x)``."
msgstr ""
"Если *x* равно наибольшему положительному представимому числу с плавающей "
"запятой, верните значение младшего бита *x*, так, чтобы первое число с "
"плавающей запятой меньше *x* было ``x - ulp(x)``."

#: ../../library/math.rst:428
msgid ""
"Otherwise (*x* is a positive finite number), return the value of the least "
"significant bit of *x*, such that the first float bigger than *x* is ``x + "
"ulp(x)``."
msgstr ""
"В противном случае (*x* — положительное конечное число) верните значение "
"младшего бита *x*, чтобы первое число с плавающей запятой, большее *x*, было "
"``x + ulp(x)``."

#: ../../library/math.rst:432
msgid "ULP stands for \"Unit in the Last Place\"."
msgstr "ULP означает «Единица на последнем месте»."

#: ../../library/math.rst:434
msgid ""
"See also :func:`math.nextafter` and :data:`sys.float_info.epsilon <sys."
"float_info>`."
msgstr ""
"См. также :func:`math.nextafter` и :data:`sys.float_info.epsilon <sys."
"float_info>`."

#: ../../library/math.rst:441
msgid "Power, exponential and logarithmic functions"
msgstr "Степенные, показательные и логарифмические функции"

#: ../../library/math.rst:445
msgid "Return the cube root of *x*."
msgstr "Возвращает кубический корень *x*."

#: ../../library/math.rst:452
msgid ""
"Return *e* raised to the power *x*, where *e* = 2.718281... is the base of "
"natural logarithms.  This is usually more accurate than ``math.e ** x`` or "
"``pow(math.e, x)``."
msgstr ""
"Верните *e*, возведенное в степень *x*, где *e* = 2,718281... — это "
"основание натуральных логарифмов. Обычно это более точно, чем ``math.e ** "
"x`` или ``pow(math.e, x)``."

#: ../../library/math.rst:459
msgid "Return *2* raised to the power *x*."
msgstr "Верните *2*, возведенную в степень *x*."

#: ../../library/math.rst:466
msgid ""
"Return *e* raised to the power *x*, minus 1.  Here *e* is the base of "
"natural logarithms.  For small floats *x*, the subtraction in ``exp(x) - 1`` "
"can result in a `significant loss of precision <https://en.wikipedia.org/"
"wiki/Loss_of_significance>`_\\; the :func:`expm1` function provides a way to "
"compute this quantity to full precision:"
msgstr ""
"Верните *e*, возведенное в степень *x*, минус 1. Здесь *e* — это основание "
"натуральных логарифмов. Для небольших чисел с плавающей запятой *x* "
"вычитание в ``exp(x) - 1`` может привести к ``значительной потере точности "
"<https://en.wikipedia.org/wiki/Loss_of_significance>`_\\; функция :func:"
"`expm1` позволяет вычислить эту величину с полной точностью:"

#: ../../library/math.rst:483
msgid "With one argument, return the natural logarithm of *x* (to base *e*)."
msgstr ""
"С одним аргументом верните натуральный логарифм *x* (по основанию *e*)."

#: ../../library/math.rst:485
msgid ""
"With two arguments, return the logarithm of *x* to the given *base*, "
"calculated as ``log(x)/log(base)``."
msgstr ""
"С двумя аргументами верните логарифм *x* по заданному *base*, рассчитанному "
"как ``log(x)/log(base)``."

#: ../../library/math.rst:491
msgid ""
"Return the natural logarithm of *1+x* (base *e*). The result is calculated "
"in a way which is accurate for *x* near zero."
msgstr ""
"Вернуть натуральный логарифм *1+x* (по основанию *e*). Результат "
"рассчитывается способом, который является точным для *x*, близкого к нулю."

#: ../../library/math.rst:497
msgid ""
"Return the base-2 logarithm of *x*. This is usually more accurate than "
"``log(x, 2)``."
msgstr ""
"Возвращает логарифм по основанию 2 числа *x*. Обычно это более точно, чем "
"``log(x, 2)``."

#: ../../library/math.rst:504
msgid ""
":meth:`int.bit_length` returns the number of bits necessary to represent an "
"integer in binary, excluding the sign and leading zeros."
msgstr ""
":meth:`int.bit_length` возвращает количество битов, необходимых для "
"представления целого числа в двоичном виде, исключая знак и ведущие нули."

#: ../../library/math.rst:510
msgid ""
"Return the base-10 logarithm of *x*.  This is usually more accurate than "
"``log(x, 10)``."
msgstr ""
"Возвращает десятичный логарифм числа *x*. Обычно это более точно, чем "
"``log(x, 10)``."

#: ../../library/math.rst:516
msgid ""
"Return *x* raised to the power *y*.  Exceptional cases follow the IEEE 754 "
"standard as far as possible.  In particular, ``pow(1.0, x)`` and ``pow(x, "
"0.0)`` always return ``1.0``, even when *x* is a zero or a NaN.  If both *x* "
"and *y* are finite, *x* is negative, and *y* is not an integer then ``pow(x, "
"y)`` is undefined, and raises :exc:`ValueError`."
msgstr ""
"Верните *x*, возведенное в степень *y*. В исключительных случаях, насколько "
"это возможно, следуйте стандарту IEEE 754. В частности, ``pow(1.0, x)`` и "
"``pow(x, 0.0)`` всегда возвращают ``1.0``, даже если *x* равно нулю или NaN. "
"Если оба *x* и *y* конечны, *x* отрицательное значение и *y* не является "
"целым числом, тогда ``pow(x, y)`` не определен и вызывает :exc:`ValueError`."

#: ../../library/math.rst:523
msgid ""
"Unlike the built-in ``**`` operator, :func:`math.pow` converts both its "
"arguments to type :class:`float`.  Use ``**`` or the built-in :func:`pow` "
"function for computing exact integer powers."
msgstr ""
"В отличие от встроенного оператора ``**``, :func:`math.pow` преобразует оба "
"своих аргумента в тип :class:`float`. Используйте ``**`` или встроенную "
"функцию :func:`pow` для вычисления точных целочисленных степеней."

#: ../../library/math.rst:527
msgid ""
"The special cases ``pow(0.0, -inf)`` and ``pow(-0.0, -inf)`` were changed to "
"return ``inf`` instead of raising :exc:`ValueError`, for consistency with "
"IEEE 754."
msgstr ""
"Особые случаи ``pow(0.0, -inf)`` и ``pow(-0.0, -inf)`` были изменены, чтобы "
"возвращать ``inf`` вместо вызова :exc:`ValueError`, для согласованности с "
"IEEE. 754."

#: ../../library/math.rst:535
msgid "Return the square root of *x*."
msgstr "Вернуть квадратный корень из *x*."

#: ../../library/math.rst:539
msgid "Summation and product functions"
msgstr "Суммирование и функции произведения"

#: ../../library/math.rst:543
msgid ""
"Return the Euclidean distance between two points *p* and *q*, each given as "
"a sequence (or iterable) of coordinates.  The two points must have the same "
"dimension."
msgstr ""
"Возвращает евклидово расстояние между двумя точками *p* и *q*, каждая из "
"которых задана как последовательность (или итерация) координат. Обе точки "
"должны иметь одинаковый размер."

#: ../../library/math.rst:547 ../../library/math.rst:608
msgid "Roughly equivalent to::"
msgstr "Примерно эквивалентно::"

#: ../../library/math.rst:549
msgid "sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))"
msgstr "sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))"

#: ../../library/math.rst:556
msgid ""
"Return an accurate floating-point sum of values in the iterable.  Avoids "
"loss of precision by tracking multiple intermediate partial sums."
msgstr ""
"Возвращает точную сумму значений с плавающей запятой в итерируемом объекте. "
"Избегает потери точности за счет отслеживания нескольких промежуточных "
"частичных сумм."

#: ../../library/math.rst:559
msgid ""
"The algorithm's accuracy depends on IEEE-754 arithmetic guarantees and the "
"typical case where the rounding mode is half-even.  On some non-Windows "
"builds, the underlying C library uses extended precision addition and may "
"occasionally double-round an intermediate sum causing it to be off in its "
"least significant bit."
msgstr ""
"Точность алгоритма зависит от арифметических гарантий IEEE-754 и типичного "
"случая, когда режим округления является получетным. В некоторых сборках, "
"отличных от Windows, базовая библиотека C использует сложение с повышенной "
"точностью и иногда может дважды округлять промежуточную сумму, что приводит "
"к ее отключению в наименее значимом бите."

#: ../../library/math.rst:565
msgid ""
"For further discussion and two alternative approaches, see the `ASPN "
"cookbook recipes for accurate floating-point summation <https://code."
"activestate.com/recipes/393090-binary-floating-point-summation-accurate-to-"
"full-p/>`_\\."
msgstr ""
"Для дальнейшего обсуждения и двух альтернативных подходов см. «Рецепты ASPN "
"для точного суммирования с плавающей запятой <https://code.activestate.com/"
"recipes/393090-binary-floating-point-summation-accurate-to-full-p». />`_\\."

#: ../../library/math.rst:572
msgid ""
"Return the Euclidean norm, ``sqrt(sum(x**2 for x in coordinates))``. This is "
"the length of the vector from the origin to the point given by the "
"coordinates."
msgstr ""
"Возвращает евклидову норму ``sqrt(sum(x**2 for x в координатах))``. Это "
"длина вектора от начала координат до точки, заданной координатами."

#: ../../library/math.rst:576
msgid ""
"For a two dimensional point ``(x, y)``, this is equivalent to computing the "
"hypotenuse of a right triangle using the Pythagorean theorem, ``sqrt(x*x + "
"y*y)``."
msgstr ""
"Для двумерной точки ``(x, y)`` это эквивалентно вычислению гипотенузы "
"прямоугольного треугольника с использованием теоремы Пифагора ``sqrt(x*x + "
"y*y)``."

#: ../../library/math.rst:580
msgid ""
"Added support for n-dimensional points. Formerly, only the two dimensional "
"case was supported."
msgstr ""
"Добавлена ​​поддержка n-мерных точек. Раньше поддерживался только двумерный "
"случай."

#: ../../library/math.rst:584
msgid ""
"Improved the algorithm's accuracy so that the maximum error is under 1 ulp "
"(unit in the last place).  More typically, the result is almost always "
"correctly rounded to within 1/2 ulp."
msgstr ""
"Повышена точность алгоритма, теперь максимальная ошибка составляет менее 1 "
"ulp (единица на последнем месте). Чаще всего результат почти всегда "
"правильно округляется с точностью до 1/2 ulp."

#: ../../library/math.rst:592
msgid ""
"Calculate the product of all the elements in the input *iterable*. The "
"default *start* value for the product is ``1``."
msgstr ""
"Вычислите произведение всех элементов входных данных *iterable*. Значение "
"*start* по умолчанию для продукта — ``1``."

#: ../../library/math.rst:595
msgid ""
"When the iterable is empty, return the start value.  This function is "
"intended specifically for use with numeric values and may reject non-numeric "
"types."
msgstr ""
"Когда итерируемый объект пуст, верните начальное значение. Эта функция "
"предназначена специально для использования с числовыми значениями и может "
"отклонять нечисловые типы."

#: ../../library/math.rst:604
msgid "Return the sum of products of values from two iterables *p* and *q*."
msgstr "Возвращает сумму произведений значений двух итераций *p* и *q*."

#: ../../library/math.rst:606
msgid "Raises :exc:`ValueError` if the inputs do not have the same length."
msgstr "Вызывает :exc:`ValueError`, если входные данные имеют разную длину."

#: ../../library/math.rst:610
msgid "sum(itertools.starmap(operator.mul, zip(p, q, strict=True)))"
msgstr "sum(itertools.starmap(operator.mul, zip(p, q, strict=True)))"

#: ../../library/math.rst:612
msgid ""
"For float and mixed int/float inputs, the intermediate products and sums are "
"computed with extended precision."
msgstr ""
"Для входных данных с плавающей запятой и смешанных значений типа int/float "
"промежуточные продукты и суммы вычисляются с повышенной точностью."

#: ../../library/math.rst:619
msgid "Angular conversion"
msgstr "Ангулярное преобразование"

#: ../../library/math.rst:623
msgid "Convert angle *x* from radians to degrees."
msgstr "Преобразуйте угол *x* из радиан в градусы."

#: ../../library/math.rst:628
msgid "Convert angle *x* from degrees to radians."
msgstr "Преобразуйте угол *x* из градусов в радианы."

#: ../../library/math.rst:632
msgid "Trigonometric functions"
msgstr "Тригонометрические функции"

#: ../../library/math.rst:636
msgid ""
"Return the arc cosine of *x*, in radians. The result is between ``0`` and "
"``pi``."
msgstr ""
"Возвращает арккосинус *x* в радианах. Результат находится между ``0`` и "
"``pi``."

#: ../../library/math.rst:642
msgid ""
"Return the arc sine of *x*, in radians. The result is between ``-pi/2`` and "
"``pi/2``."
msgstr ""
"Возвращает арксинус *x* в радианах. Результат находится между ``-pi/2`` и "
"``pi/2``."

#: ../../library/math.rst:648
msgid ""
"Return the arc tangent of *x*, in radians. The result is between ``-pi/2`` "
"and ``pi/2``."
msgstr ""
"Возвращает арктангенс *x* в радианах. Результат находится между ``-pi/2`` и "
"``pi/2``."

#: ../../library/math.rst:654
msgid ""
"Return ``atan(y / x)``, in radians. The result is between ``-pi`` and "
"``pi``. The vector in the plane from the origin to point ``(x, y)`` makes "
"this angle with the positive X axis. The point of :func:`atan2` is that the "
"signs of both inputs are known to it, so it can compute the correct quadrant "
"for the angle. For example, ``atan(1)`` and ``atan2(1, 1)`` are both "
"``pi/4``, but ``atan2(-1, -1)`` is ``-3*pi/4``."
msgstr ""
"Верните ``atan(y / x)`` в радианах. Результат находится между ``-pi`` и "
"``pi``. Вектор в плоскости от начала координат до точки ``(x, y)`` "
"составляет этот угол с положительной осью X. Суть :func:`atan2` в том, что "
"ему известны знаки обоих входов, поэтому он может вычислить правильный "
"квадрант для угла. Например, ``atan(1)`` и ``atan2(1, 1)`` оба являются "
"``pi/4``, но ``atan2(-1, -1)`` — это ``-3. *pi/4``."

#: ../../library/math.rst:664
msgid "Return the cosine of *x* radians."
msgstr "Возвращает косинус *x* радиан."

#: ../../library/math.rst:669
msgid "Return the sine of *x* radians."
msgstr "Возвращает синус *x* радиан."

#: ../../library/math.rst:674
msgid "Return the tangent of *x* radians."
msgstr "Возвращает тангенс *x* радиан."

#: ../../library/math.rst:678
msgid "Hyperbolic functions"
msgstr "Гиперболические функции"

#: ../../library/math.rst:680
msgid ""
"`Hyperbolic functions <https://en.wikipedia.org/wiki/Hyperbolic_functions>`_ "
"are analogs of trigonometric functions that are based on hyperbolas instead "
"of circles."
msgstr ""
"`Гиперболические функции <https://en.wikipedia.org/wiki/"
"Hyperbolic_functions>`_ — это аналоги тригонометрических функций, основанные "
"на гиперболах вместо окружностей."

#: ../../library/math.rst:686
msgid "Return the inverse hyperbolic cosine of *x*."
msgstr "Возвращает обратный гиперболический косинус *x*."

#: ../../library/math.rst:691
msgid "Return the inverse hyperbolic sine of *x*."
msgstr "Возвращает обратный гиперболический синус *x*."

#: ../../library/math.rst:696
msgid "Return the inverse hyperbolic tangent of *x*."
msgstr "Возвращает обратный гиперболический тангенс *x*."

#: ../../library/math.rst:701
msgid "Return the hyperbolic cosine of *x*."
msgstr "Верните гиперболический косинус *x*."

#: ../../library/math.rst:706
msgid "Return the hyperbolic sine of *x*."
msgstr "Верните гиперболический синус *x*."

#: ../../library/math.rst:711
msgid "Return the hyperbolic tangent of *x*."
msgstr "Возвращает гиперболический тангенс *x*."

#: ../../library/math.rst:715
msgid "Special functions"
msgstr "Специальные функции"

#: ../../library/math.rst:719
msgid ""
"Return the `error function <https://en.wikipedia.org/wiki/Error_function>`_ "
"at *x*."
msgstr ""
"Верните функцию ошибки <https://en.wikipedia.org/wiki/Error_function>`_ в "
"*x*."

#: ../../library/math.rst:722
msgid ""
"The :func:`erf` function can be used to compute traditional statistical "
"functions such as the `cumulative standard normal distribution <https://en."
"wikipedia.org/wiki/Cumulative_distribution_function>`_::"
msgstr ""
"Функцию :func:`erf` можно использовать для вычисления традиционных "
"статистических функций, таких как `кумулятивное стандартное нормальное "
"распределение <https://en.wikipedia.org/wiki/"
"Cumulative_distribution_function>`_::"

#: ../../library/math.rst:726
msgid ""
"def phi(x):\n"
"    'Cumulative distribution function for the standard normal distribution'\n"
"    return (1.0 + erf(x / sqrt(2.0))) / 2.0"
msgstr ""
"def phi(x):\n"
"    'Cumulative distribution function for the standard normal distribution'\n"
"    return (1.0 + erf(x / sqrt(2.0))) / 2.0"

#: ../../library/math.rst:735
msgid ""
"Return the complementary error function at *x*.  The `complementary error "
"function <https://en.wikipedia.org/wiki/Error_function>`_ is defined as "
"``1.0 - erf(x)``.  It is used for large values of *x* where a subtraction "
"from one would cause a `loss of significance <https://en.wikipedia.org/wiki/"
"Loss_of_significance>`_\\."
msgstr ""
"Верните дополнительную функцию ошибки в *x*. `Дополнительная функция ошибок "
"<https://en.wikipedia.org/wiki/Error_function>`_ определяется как ``1.0 - "
"erf(x)``. Он используется для больших значений *x*, когда вычитание из "
"единицы может привести к `потере значимости <https://en.wikipedia.org/wiki/"
"Loss_of_significance>`_\\."

#: ../../library/math.rst:746
msgid ""
"Return the `Gamma function <https://en.wikipedia.org/wiki/Gamma_function>`_ "
"at *x*."
msgstr ""
"Верните `гамма-функцию <https://en.wikipedia.org/wiki/Gamma_function>`_ в "
"*x*."

#: ../../library/math.rst:754
msgid ""
"Return the natural logarithm of the absolute value of the Gamma function at "
"*x*."
msgstr ""
"Возвращает натуральный логарифм абсолютного значения гамма-функции в точке "
"*x*."

#: ../../library/math.rst:761
msgid "Constants"
msgstr "Константы"

#: ../../library/math.rst:765
msgid "The mathematical constant *π* = 3.141592..., to available precision."
msgstr "Математическая константа *π* = 3,141592... с доступной точностью."

#: ../../library/math.rst:770
msgid "The mathematical constant *e* = 2.718281..., to available precision."
msgstr "Математическая константа *e* = 2,718281... с доступной точностью."

#: ../../library/math.rst:775
msgid ""
"The mathematical constant *τ* = 6.283185..., to available precision. Tau is "
"a circle constant equal to 2\\ *π*, the ratio of a circle's circumference to "
"its radius. To learn more about Tau, check out Vi Hart's video `Pi is "
"(still) Wrong <https://www.youtube.com/watch?v=jG7vhMMXagQ>`_, and start "
"celebrating `Tau day <https://tauday.com/>`_ by eating twice as much pie!"
msgstr ""
"Математическая константа *τ* = 6,283185..., с доступной точностью. Тау — "
"постоянная окружности, равная 2\\ *π*, отношению длины окружности к ее "
"радиусу. Чтобы узнать больше о Тау, посмотрите видео Ви Харта «Пи (все еще) "
"неправильно» <https://www.youtube.com/watch?v=jG7vhMMXagQ>`_ и начните "
"праздновать `День Тау <https://tauday .com/>`_ съедая в два раза больше "
"пирогов!"

#: ../../library/math.rst:786
msgid ""
"A floating-point positive infinity.  (For negative infinity, use ``-math."
"inf``.)  Equivalent to the output of ``float('inf')``."
msgstr ""
"Положительная бесконечность с плавающей запятой. (Для отрицательной "
"бесконечности используйте ``-math.inf``.) Эквивалент вывода ``float('inf')``."

#: ../../library/math.rst:794
msgid ""
"A floating-point \"not a number\" (NaN) value. Equivalent to the output of "
"``float('nan')``. Due to the requirements of the `IEEE-754 standard <https://"
"en.wikipedia.org/wiki/IEEE_754>`_, ``math.nan`` and ``float('nan')`` are not "
"considered to equal to any other numeric value, including themselves. To "
"check whether a number is a NaN, use the :func:`isnan` function to test for "
"NaNs instead of ``is`` or ``==``. Example:"
msgstr ""
"Значение с плавающей запятой, не являющееся числом (NaN). Эквивалент вывода "
"``float('nan')``. В связи с требованиями стандарта IEEE-754 <https://en."
"wikipedia.org/wiki/IEEE_754>`_, ``math.nan`` и ``float('nan')`` не "
"учитываются. быть равным любому другому числовому значению, включая себя. "
"Чтобы проверить, является ли число NaN, используйте функцию :func:`isnan` "
"для проверки NaN вместо ``is`` или ``==``. Пример:"

#: ../../library/math.rst:814
msgid "It is now always available."
msgstr "Теперь он всегда доступен."

#: ../../library/math.rst:820
msgid ""
"The :mod:`math` module consists mostly of thin wrappers around the platform "
"C math library functions.  Behavior in exceptional cases follows Annex F of "
"the C99 standard where appropriate.  The current implementation will raise :"
"exc:`ValueError` for invalid operations like ``sqrt(-1.0)`` or ``log(0.0)`` "
"(where C99 Annex F recommends signaling invalid operation or divide-by-"
"zero), and :exc:`OverflowError` for results that overflow (for example, "
"``exp(1000.0)``).  A NaN will not be returned from any of the functions "
"above unless one or more of the input arguments was a NaN; in that case, "
"most functions will return a NaN, but (again following C99 Annex F) there "
"are some exceptions to this rule, for example ``pow(float('nan'), 0.0)`` or "
"``hypot(float('nan'), float('inf'))``."
msgstr ""
"Модуль :mod:`math` состоит в основном из тонких оболочек вокруг функций "
"математической библиотеки платформы C. Поведение в исключительных случаях "
"соответствует приложению F стандарта C99, где это необходимо. Текущая "
"реализация вызовет :exc:`ValueError` для недопустимых операций, таких как "
"``sqrt(-1.0)`` или ``log(0.0)`` (где C99 Приложение F рекомендует "
"сигнализировать о недопустимой операции или делении на ноль), и :exc:"
"`OverflowError` для результатов, которые переполняются (например, "
"``exp(1000.0)``). NaN не будет возвращено ни одной из вышеперечисленных "
"функций, если один или несколько входных аргументов не будут NaN; в этом "
"случае большинство функций вернут NaN, но (опять же согласно Приложению F "
"C99) из этого правила есть некоторые исключения, например, "
"``pow(float('nan'), 0.0)`` или ``hypot(float ('nan'), float('inf'))``."

#: ../../library/math.rst:832
msgid ""
"Note that Python makes no effort to distinguish signaling NaNs from quiet "
"NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior "
"is to treat all NaNs as though they were quiet."
msgstr ""
"Обратите внимание, что Python не пытается отличить сигнальные NaN от тихих "
"NaN, и поведение сигнальных NaN остается неопределенным. Типичным поведением "
"является обращение со всеми NaN, как если бы они были тихими."

#: ../../library/math.rst:839
msgid "Module :mod:`cmath`"
msgstr "Модуль :mod:`cmath`"

#: ../../library/math.rst:840
msgid "Complex number versions of many of these functions."
msgstr "Комплексные числовые версии многих из этих функций."
