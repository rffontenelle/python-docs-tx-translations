# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:12+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/abc.rst:2
msgid ":mod:`abc` --- Abstract Base Classes"
msgstr ""

#: ../../library/abc.rst:11
msgid "**Source code:** :source:`Lib/abc.py`"
msgstr "**Исходный код:** :source:`Lib/abc.py`"

#: ../../library/abc.rst:15
msgid ""
"This module provides the infrastructure for defining :term:`abstract base "
"classes <abstract base class>` (ABCs) in Python, as outlined in :pep:`3119`; "
"see the PEP for why this was added to Python. (See also :pep:`3141` and the :"
"mod:`numbers` module regarding a type hierarchy for numbers based on ABCs.)"
msgstr ""
"Этот модуль предоставляет инфраструктуру для определения :term:`абстрактных "
"базовых классов <абстрактный базовый класс>` (ABC) в Python, как описано в :"
"pep:`3119`; см. PEP, чтобы узнать, почему это было добавлено в Python. (См. "
"также :pep:`3141` и модуль :mod:`numbers` относительно иерархии типов чисел, "
"основанных на ABC.)"

#: ../../library/abc.rst:20
msgid ""
"The :mod:`collections` module has some concrete classes that derive from "
"ABCs; these can, of course, be further derived. In addition, the :mod:"
"`collections.abc` submodule has some ABCs that can be used to test whether a "
"class or instance provides a particular interface, for example, if it is :"
"term:`hashable` or if it is a :term:`mapping`."
msgstr ""
"Модуль :mod:`collections` имеет несколько конкретных классов, производных от "
"ABC; их, конечно, можно получить и дальше. Кроме того, подмодуль :mod:"
"`collections.abc` имеет некоторые ABC, которые можно использовать для "
"проверки того, предоставляет ли класс или экземпляр определенный интерфейс, "
"например, является ли он :term:`hashable` или является ли он : термин: "
"`отображение`."

#: ../../library/abc.rst:27
msgid ""
"This module provides the metaclass :class:`ABCMeta` for defining ABCs and a "
"helper class :class:`ABC` to alternatively define ABCs through inheritance:"
msgstr ""
"Этот модуль предоставляет метакласс :class:`ABCMeta` для определения ABC и "
"вспомогательный класс :class:`ABC` для альтернативного определения ABC "
"посредством наследования:"

#: ../../library/abc.rst:32
msgid ""
"A helper class that has :class:`ABCMeta` as its metaclass.  With this class, "
"an abstract base class can be created by simply deriving from :class:`!ABC` "
"avoiding sometimes confusing metaclass usage, for example::"
msgstr ""
"Вспомогательный класс, метакласс которого имеет :class:`ABCMeta`. С помощью "
"этого класса можно создать абстрактный базовый класс, просто производя его "
"от :class:`!ABC`, избегая иногда запутанного использования метакласса, "
"например::"

#: ../../library/abc.rst:41
msgid ""
"Note that the type of :class:`!ABC` is still :class:`ABCMeta`, therefore "
"inheriting from :class:`!ABC` requires the usual precautions regarding "
"metaclass usage, as multiple inheritance may lead to metaclass conflicts. "
"One may also define an abstract base class by passing the metaclass keyword "
"and using :class:`!ABCMeta` directly, for example::"
msgstr ""
"Обратите внимание, что типом :class:`!ABC` по-прежнему является :class:"
"`ABCMeta`, поэтому наследование от :class:`!ABC` требует обычных мер "
"предосторожности относительно использования метакласса, поскольку "
"множественное наследование может привести к конфликтам метаклассов. Можно "
"также определить абстрактный базовый класс, передав ключевое слово "
"метакласса и напрямую используя :class:`!ABCMeta`, например::"

#: ../../library/abc.rst:57
msgid "Metaclass for defining Abstract Base Classes (ABCs)."
msgstr "Метакласс для определения абстрактных базовых классов (ABC)."

#: ../../library/abc.rst:59
msgid ""
"Use this metaclass to create an ABC.  An ABC can be subclassed directly, and "
"then acts as a mix-in class.  You can also register unrelated concrete "
"classes (even built-in classes) and unrelated ABCs as \"virtual subclasses\" "
"-- these and their descendants will be considered subclasses of the "
"registering ABC by the built-in :func:`issubclass` function, but the "
"registering ABC won't show up in their MRO (Method Resolution Order) nor "
"will method implementations defined by the registering ABC be callable (not "
"even via :func:`super`). [#]_"
msgstr ""
"Используйте этот метакласс для создания ABC. ABC может быть непосредственно "
"разделен на подклассы, а затем действовать как смешанный класс. Вы также "
"можете зарегистрировать несвязанные конкретные классы (даже встроенные "
"классы) и несвязанные ABC как «виртуальные подклассы» — эти и их потомки "
"будут считаться подклассами регистрирующего ABC встроенной функцией :func:"
"`issubclass`, но регистрирующийся ABC не будет отображаться в их MRO "
"(порядок разрешения методов), а реализации методов, определенные "
"регистрирующимся ABC, не будут вызываться (даже через :func:`super`). [#]_"

#: ../../library/abc.rst:68
msgid ""
"Classes created with a metaclass of :class:`!ABCMeta` have the following "
"method:"
msgstr ""
"Классы, созданные с помощью метакласса :class:`!ABCMeta`, имеют следующий "
"метод:"

#: ../../library/abc.rst:72
msgid ""
"Register *subclass* as a \"virtual subclass\" of this ABC. For example::"
msgstr ""
"Зарегистрируйте *подкласс* как «виртуальный подкласс» этого ABC. Например::"

#: ../../library/abc.rst:85
msgid "Returns the registered subclass, to allow usage as a class decorator."
msgstr ""
"Возвращает зарегистрированный подкласс, чтобы его можно было использовать в "
"качестве декоратора класса."

#: ../../library/abc.rst:88
msgid ""
"To detect calls to :meth:`!register`, you can use the :func:"
"`get_cache_token` function."
msgstr ""
"Чтобы обнаружить вызовы :meth:`!register`, вы можете использовать функцию :"
"func:`get_cache_token`."

#: ../../library/abc.rst:92
msgid "You can also override this method in an abstract base class:"
msgstr ""
"Вы также можете переопределить этот метод в абстрактном базовом классе:"

#: ../../library/abc.rst:96
msgid "(Must be defined as a class method.)"
msgstr "(Должен быть определен как метод класса.)"

#: ../../library/abc.rst:98
msgid ""
"Check whether *subclass* is considered a subclass of this ABC.  This means "
"that you can customize the behavior of :func:`issubclass` further without "
"the need to call :meth:`register` on every class you want to consider a "
"subclass of the ABC.  (This class method is called from the :meth:`~class."
"__subclasscheck__` method of the ABC.)"
msgstr ""

#: ../../library/abc.rst:104
msgid ""
"This method should return ``True``, ``False`` or :data:`NotImplemented`.  If "
"it returns ``True``, the *subclass* is considered a subclass of this ABC. If "
"it returns ``False``, the *subclass* is not considered a subclass of this "
"ABC, even if it would normally be one.  If it returns :data:`!"
"NotImplemented`, the subclass check is continued with the usual mechanism."
msgstr ""
"Этот метод должен возвращать ``True``, ``False`` или :data:`NotImplemented`. "
"Если он возвращает True, *подкласс* считается подклассом этого ABC. Если он "
"возвращает False, *подкласс* не считается подклассом этого ABC, даже если он "
"обычно им является. Если он возвращает :data:`!NotImplemented`, проверка "
"подкласса продолжается обычным механизмом."

#: ../../library/abc.rst:114
msgid ""
"For a demonstration of these concepts, look at this example ABC definition::"
msgstr ""
"Для демонстрации этих концепций посмотрите на этот пример определения ABC:"

#: ../../library/abc.rst:143
msgid ""
"The ABC ``MyIterable`` defines the standard iterable method, :meth:"
"`~iterator.__iter__`, as an abstract method.  The implementation given here "
"can still be called from subclasses.  The :meth:`!get_iterator` method is "
"also part of the ``MyIterable`` abstract base class, but it does not have to "
"be overridden in non-abstract derived classes."
msgstr ""
"ABC ``MyIterable`` определяет стандартный итерируемый метод :meth:`~iterator."
"__iter__` как абстрактный метод. Приведенную здесь реализацию по-прежнему "
"можно вызывать из подклассов. Метод :meth:`!get_iterator` также является "
"частью абстрактного базового класса MyIterable, но его не обязательно "
"переопределять в неабстрактных производных классах."

#: ../../library/abc.rst:149
msgid ""
"The :meth:`__subclasshook__` class method defined here says that any class "
"that has an :meth:`~iterator.__iter__` method in its :attr:`~object."
"__dict__` (or in that of one of its base classes, accessed via the :attr:"
"`~class.__mro__` list) is considered a ``MyIterable`` too."
msgstr ""

#: ../../library/abc.rst:154
msgid ""
"Finally, the last line makes ``Foo`` a virtual subclass of ``MyIterable``, "
"even though it does not define an :meth:`~iterator.__iter__` method (it uses "
"the old-style iterable protocol, defined in terms of :meth:`~object.__len__` "
"and :meth:`~object.__getitem__`).  Note that this will not make "
"``get_iterator`` available as a method of ``Foo``, so it is provided "
"separately."
msgstr ""
"Наконец, последняя строка делает Foo виртуальным подклассом MyIterable, хотя "
"он и не определяет метод :meth:`~iterator.__iter__` (он использует "
"итерируемый протокол старого стиля, определенный в термины :meth:`~object."
"__len__` и :meth:`~object.__getitem__`). Обратите внимание, что это не "
"сделает ``get_iterator`` доступным как метод ``Foo``, поэтому он "
"предоставляется отдельно."

#: ../../library/abc.rst:163
msgid "The :mod:`!abc` module also provides the following decorator:"
msgstr "Модуль :mod:`!abc` также предоставляет следующий декоратор:"

#: ../../library/abc.rst:167
msgid "A decorator indicating abstract methods."
msgstr "Декоратор, указывающий абстрактные методы."

#: ../../library/abc.rst:169
msgid ""
"Using this decorator requires that the class's metaclass is :class:`ABCMeta` "
"or is derived from it.  A class that has a metaclass derived from :class:`!"
"ABCMeta` cannot be instantiated unless all of its abstract methods and "
"properties are overridden.  The abstract methods can be called using any of "
"the normal 'super' call mechanisms.  :func:`!abstractmethod` may be used to "
"declare abstract methods for properties and descriptors."
msgstr ""
"Использование этого декоратора требует, чтобы метакласс класса был :class:"
"`ABCMeta` или был производным от него. Класс, имеющий метакласс, производный "
"от :class:`!ABCMeta`, не может быть создан, пока не будут переопределены все "
"его абстрактные методы и свойства. Абстрактные методы можно вызывать с "
"использованием любого обычного механизма вызова «супер». :func:`!"
"abstractmethod` может использоваться для объявления абстрактных методов для "
"свойств и дескрипторов."

#: ../../library/abc.rst:176
msgid ""
"Dynamically adding abstract methods to a class, or attempting to modify the "
"abstraction status of a method or class once it is created, are only "
"supported using the :func:`update_abstractmethods` function.  The :func:`!"
"abstractmethod` only affects subclasses derived using regular inheritance; "
"\"virtual subclasses\" registered with the ABC's :meth:`~ABCMeta.register` "
"method are not affected."
msgstr ""
"Использование этого декоратора требует, чтобы метакласс класса был :class:"
"`ABCMeta` или был производным от него. Класс, имеющий метакласс, производный "
"от :class:`!ABCMeta`, не может быть создан, пока не будут переопределены все "
"его абстрактные методы и свойства. Абстрактные методы можно вызывать с "
"использованием любого обычного механизма вызова «супер». :func:`!"
"abstractmethod` может использоваться для объявления абстрактных методов для "
"свойств и дескрипторов."

#: ../../library/abc.rst:183
msgid ""
"When :func:`!abstractmethod` is applied in combination with other method "
"descriptors, it should be applied as the innermost decorator, as shown in "
"the following usage examples::"
msgstr ""
"Когда :func:`!abstractmethod` применяется в сочетании с другими "
"дескрипторами методов, его следует применять в качестве самого внутреннего "
"декоратора, как показано в следующих примерах использования:"

#: ../../library/abc.rst:217
msgid ""
"In order to correctly interoperate with the abstract base class machinery, "
"the descriptor must identify itself as abstract using :attr:`!"
"__isabstractmethod__`. In general, this attribute should be ``True`` if any "
"of the methods used to compose the descriptor are abstract. For example, "
"Python's built-in :class:`property` does the equivalent of::"
msgstr ""
"Чтобы правильно взаимодействовать с механизмом абстрактного базового класса, "
"дескриптор должен идентифицировать себя как абстрактный, используя :attr:`!"
"__isabstractmethod__`. В общем, этот атрибут должен иметь значение True, "
"если какой-либо из методов, используемых для составления дескриптора, "
"является абстрактным. Например, встроенное в Python свойство :class:"
"`property` выполняет эквивалент::"

#: ../../library/abc.rst:232
msgid ""
"Unlike Java abstract methods, these abstract methods may have an "
"implementation. This implementation can be called via the :func:`super` "
"mechanism from the class that overrides it.  This could be useful as an end-"
"point for a super-call in a framework that uses cooperative multiple-"
"inheritance."
msgstr ""
"В отличие от абстрактных методов Java, эти абстрактные методы могут иметь "
"реализацию. Эту реализацию можно вызвать через механизм :func:`super` из "
"класса, который ее переопределяет. Это может быть полезно в качестве "
"конечной точки для супервызова в среде, использующей совместное "
"множественное наследование."

#: ../../library/abc.rst:239
msgid "The :mod:`!abc` module also supports the following legacy decorators:"
msgstr "Модуль :mod:`!abc` также поддерживает следующие устаревшие декораторы:"

#: ../../library/abc.rst:244
msgid ""
"It is now possible to use :class:`classmethod` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Теперь можно использовать :class:`classmethod` с :func:`abstractmethod`, что "
"делает этот декоратор ненужным."

#: ../../library/abc.rst:248
msgid ""
"A subclass of the built-in :func:`classmethod`, indicating an abstract "
"classmethod. Otherwise it is similar to :func:`abstractmethod`."
msgstr ""
"Подкласс встроенного :func:`classmethod`, указывающий на абстрактный метод "
"класса. В остальном это похоже на :func:`abstractmethod`."

#: ../../library/abc.rst:251
msgid ""
"This special case is deprecated, as the :func:`classmethod` decorator is now "
"correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Этот особый случай устарел, поскольку декоратор :func:`classmethod` теперь "
"правильно идентифицируется как абстрактный при применении к абстрактному "
"методу:"

#: ../../library/abc.rst:265
msgid ""
"It is now possible to use :class:`staticmethod` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Теперь можно использовать :class:`staticmethod` с :func:`abstractmethod`, "
"что делает этот декоратор ненужным."

#: ../../library/abc.rst:269
msgid ""
"A subclass of the built-in :func:`staticmethod`, indicating an abstract "
"staticmethod. Otherwise it is similar to :func:`abstractmethod`."
msgstr ""
"Подкласс встроенного :func:`staticmethod`, указывающий на абстрактный "
"статический метод. В остальном это похоже на :func:`abstractmethod`."

#: ../../library/abc.rst:272
msgid ""
"This special case is deprecated, as the :func:`staticmethod` decorator is "
"now correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Этот особый случай устарел, поскольку декоратор :func:`staticmethod` теперь "
"правильно идентифицируется как абстрактный при применении к абстрактному "
"методу::"

#: ../../library/abc.rst:285
msgid ""
"It is now possible to use :class:`property`, :meth:`property.getter`, :meth:"
"`property.setter` and :meth:`property.deleter` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Теперь можно использовать :class:`property`, :meth:`property.getter`, :meth:"
"`property.setter` и :meth:`property.deleter` с :func:`abstractmethod`, "
"создавая этот декоратор избыточный."

#: ../../library/abc.rst:290
msgid ""
"A subclass of the built-in :func:`property`, indicating an abstract property."
msgstr ""
"Подкласс встроенного :func:`property`, указывающий на абстрактное свойство."

#: ../../library/abc.rst:293
msgid ""
"This special case is deprecated, as the :func:`property` decorator is now "
"correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Этот особый случай устарел, поскольку декоратор :func:`property` теперь "
"правильно идентифицируется как абстрактный при применении к абстрактному "
"методу:"

#: ../../library/abc.rst:303
msgid ""
"The above example defines a read-only property; you can also define a read-"
"write abstract property by appropriately marking one or more of the "
"underlying methods as abstract::"
msgstr ""
"В приведенном выше примере определяется свойство, доступное только для "
"чтения; вы также можете определить абстрактное свойство для чтения и записи, "
"соответствующим образом пометив один или несколько базовых методов как "
"абстрактные::"

#: ../../library/abc.rst:317
msgid ""
"If only some components are abstract, only those components need to be "
"updated to create a concrete property in a subclass::"
msgstr ""
"Если только некоторые компоненты являются абстрактными, только эти "
"компоненты необходимо обновить для создания конкретного свойства в подклассе:"

#: ../../library/abc.rst:326
msgid "The :mod:`!abc` module also provides the following functions:"
msgstr "Модуль :mod:`!abc` также предоставляет следующие функции:"

#: ../../library/abc.rst:330
msgid "Returns the current abstract base class cache token."
msgstr "Возвращает текущий токен кэша абстрактного базового класса."

#: ../../library/abc.rst:332
msgid ""
"The token is an opaque object (that supports equality testing) identifying "
"the current version of the abstract base class cache for virtual subclasses. "
"The token changes with every call to :meth:`ABCMeta.register` on any ABC."
msgstr ""
"Токен — это непрозрачный объект (который поддерживает проверку на "
"равенство), идентифицирующий текущую версию кэша абстрактного базового "
"класса для виртуальных подклассов. Токен меняется при каждом вызове :meth:"
"`ABCMeta.register` в любом ABC."

#: ../../library/abc.rst:340
msgid ""
"A function to recalculate an abstract class's abstraction status. This "
"function should be called if a class's abstract methods have been "
"implemented or changed after it was created. Usually, this function should "
"be called from within a class decorator."
msgstr ""
"Функция для пересчета статуса абстракции абстрактного класса. Эту функцию "
"следует вызывать, если абстрактные методы класса были реализованы или "
"изменены после его создания. Обычно эту функцию следует вызывать из "
"декоратора класса."

#: ../../library/abc.rst:345
msgid "Returns *cls*, to allow usage as a class decorator."
msgstr ""
"Возвращает *cls*, чтобы разрешить использование в качестве декоратора класса."

#: ../../library/abc.rst:347
msgid "If *cls* is not an instance of :class:`ABCMeta`, does nothing."
msgstr ""
"Если *cls* не является экземпляром :class:`ABCMeta`, ничего не происходит."

#: ../../library/abc.rst:351
msgid ""
"This function assumes that *cls*'s superclasses are already updated. It does "
"not update any subclasses."
msgstr ""
"Эта функция предполагает, что суперклассы *cls* уже обновлены. Он не "
"обновляет какие-либо подклассы."

#: ../../library/abc.rst:357
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/abc.rst:358
msgid ""
"C++ programmers should note that Python's virtual base class concept is not "
"the same as C++'s."
msgstr ""
"Программистам C++ следует учитывать, что концепция виртуального базового "
"класса Python отличается от концепции C++."
