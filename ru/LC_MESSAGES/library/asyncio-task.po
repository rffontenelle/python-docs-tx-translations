# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniil Kolesnikov, 2024
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-18 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "Сопрограммы и задачи"

#: ../../library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"В этом разделе описываются высокоуровневые API-интерфейсы asyncio для работы "
"с сопрограммами и задачами."

#: ../../library/asyncio-task.rst:19 ../../library/asyncio-task.rst:148
msgid "Coroutines"
msgstr "Сопрограммы"

#: ../../library/asyncio-task.rst:21
msgid "**Source code:** :source:`Lib/asyncio/coroutines.py`"
msgstr "**Исходный код:** :source:`Lib/asyncio/coroutines.py`"

#: ../../library/asyncio-task.rst:25
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
":term:`Сопрограммы <coroutine>`, объявленные с синтаксисом async/await, "
"являются предпочтительным способом написания асинхронных приложений. "
"Например, следующий фрагмент кода печатает «привет», ждет 1 секунду, а затем "
"печатает «мир»::"

#: ../../library/asyncio-task.rst:30
msgid ""
">>> import asyncio\n"
"\n"
">>> async def main():\n"
"...     print('hello')\n"
"...     await asyncio.sleep(1)\n"
"...     print('world')\n"
"\n"
">>> asyncio.run(main())\n"
"hello\n"
"world"
msgstr ""
">>> import asyncio\n"
"\n"
">>> async def main():\n"
"...     print('hello')\n"
"...     await asyncio.sleep(1)\n"
"...     print('world')\n"
"\n"
">>> asyncio.run(main())\n"
"hello\n"
"world"

#: ../../library/asyncio-task.rst:41
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr ""
"Обратите внимание, что простой вызов сопрограммы не запланирует ее "
"выполнение::"

#: ../../library/asyncio-task.rst:44
msgid ""
">>> main()\n"
"<coroutine object main at 0x1053bb7c8>"
msgstr ""
">>> main()\n"
"<coroutine object main at 0x1053bb7c8>"

#: ../../library/asyncio-task.rst:47
msgid "To actually run a coroutine, asyncio provides the following mechanisms:"
msgstr ""
"Для фактического запуска сопрограммы asyncio предоставляет следующие "
"механизмы:"

#: ../../library/asyncio-task.rst:49
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"Функция :func:`asyncio.run` для запуска функции main() точки входа верхнего "
"уровня (см. пример выше)."

#: ../../library/asyncio-task.rst:52
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Ожидание сопрограммы. Следующий фрагмент кода выведет «hello» после ожидания "
"в течение 1 секунды, а затем выведет «world» после ожидания *еще* 2 секунд::"

#: ../../library/asyncio-task.rst:56
msgid ""
"import asyncio\n"
"import time\n"
"\n"
"async def say_after(delay, what):\n"
"    await asyncio.sleep(delay)\n"
"    print(what)\n"
"\n"
"async def main():\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    await say_after(1, 'hello')\n"
"    await say_after(2, 'world')\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import time\n"
"\n"
"async def say_after(delay, what):\n"
"    await asyncio.sleep(delay)\n"
"    print(what)\n"
"\n"
"async def main():\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    await say_after(1, 'hello')\n"
"    await say_after(2, 'world')\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:73
msgid "Expected output::"
msgstr "Ожидаемый результат::"

#: ../../library/asyncio-task.rst:75
msgid ""
"started at 17:13:52\n"
"hello\n"
"world\n"
"finished at 17:13:55"
msgstr ""
"started at 17:13:52\n"
"hello\n"
"world\n"
"finished at 17:13:55"

#: ../../library/asyncio-task.rst:80
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"Функция :func:`asyncio.create_task` для одновременного запуска сопрограмм "
"как asyncio :class:`Tasks <Task>`."

#: ../../library/asyncio-task.rst:83
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Давайте изменим приведенный выше пример и запустим две сопрограммы Say_after "
"*параллельно*::"

#: ../../library/asyncio-task.rst:86
msgid ""
"async def main():\n"
"    task1 = asyncio.create_task(\n"
"        say_after(1, 'hello'))\n"
"\n"
"    task2 = asyncio.create_task(\n"
"        say_after(2, 'world'))\n"
"\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # Wait until both tasks are completed (should take\n"
"    # around 2 seconds.)\n"
"    await task1\n"
"    await task2\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""
"async def main():\n"
"    task1 = asyncio.create_task(\n"
"        say_after(1, 'hello'))\n"
"\n"
"    task2 = asyncio.create_task(\n"
"        say_after(2, 'world'))\n"
"\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # Wait until both tasks are completed (should take\n"
"    # around 2 seconds.)\n"
"    await task1\n"
"    await task2\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"

#: ../../library/asyncio-task.rst:102
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"Обратите внимание, что ожидаемый результат теперь показывает, что фрагмент "
"выполняется на 1 секунду быстрее, чем раньше:"

#: ../../library/asyncio-task.rst:105
msgid ""
"started at 17:14:32\n"
"hello\n"
"world\n"
"finished at 17:14:34"
msgstr ""
"started at 17:14:32\n"
"hello\n"
"world\n"
"finished at 17:14:34"

#: ../../library/asyncio-task.rst:110
msgid ""
"The :class:`asyncio.TaskGroup` class provides a more modern alternative to :"
"func:`create_task`. Using this API, the last example becomes::"
msgstr ""
"Класс :class:`asyncio.TaskGroup` предоставляет более современную "
"альтернативу :func:`create_task`. Используя этот API, последний пример "
"становится::"

#: ../../library/asyncio-task.rst:114
msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(\n"
"            say_after(1, 'hello'))\n"
"\n"
"        task2 = tg.create_task(\n"
"            say_after(2, 'world'))\n"
"\n"
"        print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # The await is implicit when the context manager exits.\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(\n"
"            say_after(1, 'hello'))\n"
"\n"
"        task2 = tg.create_task(\n"
"            say_after(2, 'world'))\n"
"\n"
"        print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # The await is implicit when the context manager exits.\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"

#: ../../library/asyncio-task.rst:128
msgid "The timing and output should be the same as for the previous version."
msgstr "Время и результат должны быть такими же, как и в предыдущей версии."

#: ../../library/asyncio-task.rst:130
msgid ":class:`asyncio.TaskGroup`."
msgstr ":class:`asyncio.TaskGroup`."

#: ../../library/asyncio-task.rst:137
msgid "Awaitables"
msgstr "Ожидаемые события"

#: ../../library/asyncio-task.rst:139
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Мы говорим, что объект является **ожидаемым** объектом, если его можно "
"использовать в выражении :keyword:`await`. Многие API-интерфейсы asyncio "
"предназначены для приема ожидаемых данных."

#: ../../library/asyncio-task.rst:143
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Существует три основных типа *ожидаемых* объектов: **сопрограммы**, "
"**Задачи** и **Фьючерсы**."

#: ../../library/asyncio-task.rst:149
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Сопрограммы Python являются *ожидаемыми* и поэтому их можно ожидать от "
"других сопрограмм::"

#: ../../library/asyncio-task.rst:152
msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Nothing happens if we just call \"nested()\".\n"
"    # A coroutine object is created but not awaited,\n"
"    # so it *won't run at all*.\n"
"    nested()  # will raise a \"RuntimeWarning\".\n"
"\n"
"    # Let's do it differently now and await it:\n"
"    print(await nested())  # will print \"42\".\n"
"\n"
"asyncio.run(main())"
msgstr ""

#: ../../library/asyncio-task.rst:170
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"В этой документации термин «сопрограмма» может использоваться для двух тесно "
"связанных понятий:"

#: ../../library/asyncio-task.rst:173
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "*функция сопрограммы*: функция :keyword:`async def`;"

#: ../../library/asyncio-task.rst:175
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr ""
"*объект сопрограммы*: объект, возвращаемый вызовом *функции сопрограммы*."

#: ../../library/asyncio-task.rst:180
msgid "Tasks"
msgstr "Задачи"

#: ../../library/asyncio-task.rst:181
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*Задачи* используются для планирования сопрограмм *одновременно*."

#: ../../library/asyncio-task.rst:183
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"Когда сопрограмма заключена в *Task* с такими функциями, как :func:`asyncio."
"create_task`, сопрограмма автоматически планируется к скорому запуску::"

#: ../../library/asyncio-task.rst:187
msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Schedule nested() to run soon concurrently\n"
"    # with \"main()\".\n"
"    task = asyncio.create_task(nested())\n"
"\n"
"    # \"task\" can now be used to cancel \"nested()\", or\n"
"    # can simply be awaited to wait until it is complete:\n"
"    await task\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Schedule nested() to run soon concurrently\n"
"    # with \"main()\".\n"
"    task = asyncio.create_task(nested())\n"
"\n"
"    # \"task\" can now be used to cancel \"nested()\", or\n"
"    # can simply be awaited to wait until it is complete:\n"
"    await task\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:205
msgid "Futures"
msgstr "Фьючерсы"

#: ../../library/asyncio-task.rst:206
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
":class:`Future` — это специальный **низкоуровневый** ожидаемый объект, "
"который представляет **конечный результат** асинхронной операции."

#: ../../library/asyncio-task.rst:209
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Когда объект Future является *ожидаемым*, это означает, что сопрограмма "
"будет ждать, пока Future не будет разрешена в каком-то другом месте."

#: ../../library/asyncio-task.rst:212
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Будущие объекты в asyncio необходимы, чтобы разрешить использование кода "
"обратного вызова с async/await."

#: ../../library/asyncio-task.rst:215
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Обычно **нет необходимости** создавать объекты Future на уровне кода "
"приложения."

#: ../../library/asyncio-task.rst:218
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Будущие объекты, иногда предоставляемые библиотеками и некоторыми API-"
"интерфейсами asyncio, могут ожидаться:"

#: ../../library/asyncio-task.rst:221
msgid ""
"async def main():\n"
"    await function_that_returns_a_future_object()\n"
"\n"
"    # this is also valid:\n"
"    await asyncio.gather(\n"
"        function_that_returns_a_future_object(),\n"
"        some_python_coroutine()\n"
"    )"
msgstr ""
"async def main():\n"
"    await function_that_returns_a_future_object()\n"
"\n"
"    # this is also valid:\n"
"    await asyncio.gather(\n"
"        function_that_returns_a_future_object(),\n"
"        some_python_coroutine()\n"
"    )"

#: ../../library/asyncio-task.rst:230
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
"Хорошим примером низкоуровневой функции, возвращающей объект Future, "
"является :meth:`loop.run_in_executor`."

#: ../../library/asyncio-task.rst:235
msgid "Creating Tasks"
msgstr "Создание задач"

#: ../../library/asyncio-task.rst:237
msgid "**Source code:** :source:`Lib/asyncio/tasks.py`"
msgstr "**Исходный код:** :source:`Lib/asyncio/tasks.py`"

#: ../../library/asyncio-task.rst:243
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Оберните *coro* :ref:`coroutine <coroutine>` в :class:`Task` и запланируйте "
"его выполнение. Верните объект Task."

#: ../../library/asyncio-task.rst:246
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""
"Если *name* не ``None``, оно устанавливается как имя задачи с помощью :meth:"
"`Task.set_name`."

#: ../../library/asyncio-task.rst:249
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"Необязательный аргумент *context*, содержащий только ключевые слова, "
"позволяет указать собственный :class:`contextvars.Context` для запуска "
"*coro*. Текущая копия контекста создается, когда *context* не указан."

#: ../../library/asyncio-task.rst:253
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"Задача выполняется в цикле, возвращаемом :func:`get_running_loop`, :exc:"
"`RuntimeError` возникает, если в текущем потоке нет работающего цикла."

#: ../../library/asyncio-task.rst:259
msgid ""
":meth:`asyncio.TaskGroup.create_task` is a new alternative leveraging "
"structural concurrency; it allows for waiting for a group of related tasks "
"with strong safety guarantees."
msgstr ""
":meth:`asyncio.TaskGroup.create_task` — это новая альтернатива, использующая "
"структурный параллелизм; это позволяет ожидать выполнения группы связанных "
"задач с надежными гарантиями безопасности."

#: ../../library/asyncio-task.rst:265
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background "
"tasks, gather them in a collection::"
msgstr ""
"Сохраните ссылку на результат этой функции, чтобы избежать исчезновения "
"задачи в середине выполнения. Цикл событий сохраняет только слабые ссылки на "
"задачи. Задача, на которую нигде нет ссылок, может быть удалена сборщиком "
"мусора в любое время, даже до того, как она будет выполнена. Для надежных "
"фоновых задач по принципу «выстрелил и забыл» соберите их в коллекцию:"

#: ../../library/asyncio-task.rst:272
msgid ""
"background_tasks = set()\n"
"\n"
"for i in range(10):\n"
"    task = asyncio.create_task(some_coro(param=i))\n"
"\n"
"    # Add task to the set. This creates a strong reference.\n"
"    background_tasks.add(task)\n"
"\n"
"    # To prevent keeping references to finished tasks forever,\n"
"    # make each task remove its own reference from the set after\n"
"    # completion:\n"
"    task.add_done_callback(background_tasks.discard)"
msgstr ""
"background_tasks = set()\n"
"\n"
"for i in range(10):\n"
"    task = asyncio.create_task(some_coro(param=i))\n"
"\n"
"    # Add task to the set. This creates a strong reference.\n"
"    background_tasks.add(task)\n"
"\n"
"    # To prevent keeping references to finished tasks forever,\n"
"    # make each task remove its own reference from the set after\n"
"    # completion:\n"
"    task.add_done_callback(background_tasks.discard)"

#: ../../library/asyncio-task.rst:287 ../../library/asyncio-task.rst:1188
msgid "Added the *name* parameter."
msgstr "Добавлен параметр *имя*."

#: ../../library/asyncio-task.rst:290 ../../library/asyncio-task.rst:1195
msgid "Added the *context* parameter."
msgstr "Добавлен параметр *context*."

#: ../../library/asyncio-task.rst:295
msgid "Task Cancellation"
msgstr "Отмена задачи"

#: ../../library/asyncio-task.rst:297
msgid ""
"Tasks can easily and safely be cancelled. When a task is cancelled, :exc:"
"`asyncio.CancelledError` will be raised in the task at the next opportunity."
msgstr ""
"Задачи можно легко и безопасно отменить. Когда задача отменяется, при "
"следующей возможности в задаче будет вызвано :exc:`asyncio.CancelledError`."

#: ../../library/asyncio-task.rst:301
msgid ""
"It is recommended that coroutines use ``try/finally`` blocks to robustly "
"perform clean-up logic. In case :exc:`asyncio.CancelledError` is explicitly "
"caught, it should generally be propagated when clean-up is complete. :exc:"
"`asyncio.CancelledError` directly subclasses :exc:`BaseException` so most "
"code will not need to be aware of it."
msgstr ""
"Рекомендуется, чтобы сопрограммы использовали блоки try/finally для "
"надежного выполнения логики очистки. В случае явного обнаружения :exc:"
"`asyncio.CancelledError`, его обычно следует распространять после завершения "
"очистки. :exc:`asyncio.CancelledError` напрямую является подклассом :exc:"
"`BaseException`, поэтому большинству кода не нужно будет об этом знать."

#: ../../library/asyncio-task.rst:307
msgid ""
"The asyncio components that enable structured concurrency, like :class:"
"`asyncio.TaskGroup` and :func:`asyncio.timeout`, are implemented using "
"cancellation internally and might misbehave if a coroutine swallows :exc:"
"`asyncio.CancelledError`. Similarly, user code should not generally call :"
"meth:`uncancel <asyncio.Task.uncancel>`. However, in cases when suppressing :"
"exc:`asyncio.CancelledError` is truly desired, it is necessary to also call "
"``uncancel()`` to completely remove the cancellation state."
msgstr ""
"Компоненты asyncio, обеспечивающие структурированный параллелизм, такие как :"
"class:`asyncio.TaskGroup` и :func:`asyncio.timeout`, реализуются с "
"использованием внутренней отмены и могут работать неправильно, если "
"сопрограмма проглотит :exc:`asyncio.CancelledError`. Аналогично, "
"пользовательский код обычно не должен вызывать :meth:`uncancel <asyncio.Task."
"uncancel>`. Однако в случаях, когда подавление :exc:`asyncio.CancelledError` "
"действительно желательно, необходимо также вызвать ``uncancel()``, чтобы "
"полностью удалить состояние отмены."

#: ../../library/asyncio-task.rst:319
msgid "Task Groups"
msgstr "Группы задач"

#: ../../library/asyncio-task.rst:321
msgid ""
"Task groups combine a task creation API with a convenient and reliable way "
"to wait for all tasks in the group to finish."
msgstr ""
"Группы задач сочетают в себе API создания задач с удобным и надежным "
"способом ожидания завершения всех задач в группе."

#: ../../library/asyncio-task.rst:326
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` holding a "
"group of tasks. Tasks can be added to the group using :meth:`create_task`. "
"All tasks are awaited when the context manager exits."
msgstr ""
":ref:`асинхронный контекстный менеджер <async-context-managers>`, содержащий "
"группу задач. Задачи можно добавлять в группу с помощью :meth:`create_task`. "
"Все задачи ожидаются после выхода из контекстного менеджера."

#: ../../library/asyncio-task.rst:335
msgid ""
"Create a task in this task group. The signature matches that of :func:"
"`asyncio.create_task`. If the task group is inactive (e.g. not yet entered, "
"already finished, or in the process of shutting down), we will close the "
"given ``coro``."
msgstr ""
"Создайте задачу в этой группе задач. Подпись соответствует подписи :func:"
"`asyncio.create_task`. Если группа задач неактивна (например, еще не "
"введена, уже завершена или находится в процессе закрытия), мы закроем данное "
"``coro``."

#: ../../library/asyncio-task.rst:343
msgid "Close the given coroutine if the task group is not active."
msgstr "Закройте данную сопрограмму, если группа задач не активна."

#: ../../library/asyncio-task.rst:345 ../../library/asyncio-task.rst:550
#: ../../library/asyncio-task.rst:723 ../../library/asyncio-task.rst:781
#: ../../library/asyncio-task.rst:807 ../../library/asyncio-task.rst:847
msgid "Example::"
msgstr "Пример::"

#: ../../library/asyncio-task.rst:347
msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(some_coro(...))\n"
"        task2 = tg.create_task(another_coro(...))\n"
"    print(f\"Both tasks have completed now: {task1.result()}, {task2."
"result()}\")"
msgstr ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(some_coro(...))\n"
"        task2 = tg.create_task(another_coro(...))\n"
"    print(f\"Both tasks have completed now: {task1.result()}, {task2."
"result()}\")"

#: ../../library/asyncio-task.rst:353
msgid ""
"The ``async with`` statement will wait for all tasks in the group to finish. "
"While waiting, new tasks may still be added to the group (for example, by "
"passing ``tg`` into one of the coroutines and calling ``tg.create_task()`` "
"in that coroutine). Once the last task has finished and the ``async with`` "
"block is exited, no new tasks may be added to the group."
msgstr ""
"Оператор ``async with`` будет ждать завершения всех задач в группе. Во время "
"ожидания в группу все равно можно добавлять новые задачи (например, передав "
"``tg`` в одну из сопрограмм и вызвав ``tg.create_task()`` в этой "
"сопрограмме). После завершения последней задачи и выхода из блока async with "
"в группу нельзя добавлять новые задачи."

#: ../../library/asyncio-task.rst:360
msgid ""
"The first time any of the tasks belonging to the group fails with an "
"exception other than :exc:`asyncio.CancelledError`, the remaining tasks in "
"the group are cancelled. No further tasks can then be added to the group. At "
"this point, if the body of the ``async with`` statement is still active (i."
"e., :meth:`~object.__aexit__` hasn't been called yet), the task directly "
"containing the ``async with`` statement is also cancelled. The resulting :"
"exc:`asyncio.CancelledError` will interrupt an ``await``, but it will not "
"bubble out of the containing ``async with`` statement."
msgstr ""
"При первом сбое какой-либо задачи, принадлежащей группе, за исключением "
"исключения :exc:`asyncio.CancelledError`, остальные задачи в группе "
"отменяются. После этого в группу невозможно будет добавить никакие "
"дальнейшие задачи. На этом этапе, если тело оператора ``async with`` все еще "
"активно (т.е. :meth:`~object.__aexit__` еще не был вызван), задача, "
"непосредственно содержащая ``async with`` заявление также аннулируется. "
"Полученный :exc:`asyncio.CancelledError` прервет ``await``, но он не выйдет "
"за пределы содержащегося ``async with`` оператора."

#: ../../library/asyncio-task.rst:370
msgid ""
"Once all tasks have finished, if any tasks have failed with an exception "
"other than :exc:`asyncio.CancelledError`, those exceptions are combined in "
"an :exc:`ExceptionGroup` or :exc:`BaseExceptionGroup` (as appropriate; see "
"their documentation) which is then raised."
msgstr ""
"Если после завершения всех задач какие-либо задачи завершились сбоем с "
"исключением, отличным от :exc:`asyncio.CancelledError`, эти исключения "
"объединяются в :exc:`ExceptionGroup` или :exc:`BaseExceptionGroup` (в "
"зависимости от ситуации; см. документации), которая затем поднимается."

#: ../../library/asyncio-task.rst:377
msgid ""
"Two base exceptions are treated specially: If any task fails with :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit`, the task group still cancels the "
"remaining tasks and waits for them, but then the initial :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit` is re-raised instead of :exc:"
"`ExceptionGroup` or :exc:`BaseExceptionGroup`."
msgstr ""
"Два базовых исключения обрабатываются особым образом: если какая-либо задача "
"завершается с ошибкой :exc:`KeyboardInterrupt` или :exc:`SystemExit`, группа "
"задач по-прежнему отменяет оставшиеся задачи и ожидает их, но затем "
"начальный :exc:`KeyboardInterrupt` или :exc:`SystemExit` повторно вызывается "
"вместо :exc:`ExceptionGroup` или :exc:`BaseExceptionGroup`."

#: ../../library/asyncio-task.rst:383
msgid ""
"If the body of the ``async with`` statement exits with an exception (so :"
"meth:`~object.__aexit__` is called with an exception set), this is treated "
"the same as if one of the tasks failed: the remaining tasks are cancelled "
"and then waited for, and non-cancellation exceptions are grouped into an "
"exception group and raised. The exception passed into :meth:`~object."
"__aexit__`, unless it is :exc:`asyncio.CancelledError`, is also included in "
"the exception group. The same special case is made for :exc:"
"`KeyboardInterrupt` and :exc:`SystemExit` as in the previous paragraph."
msgstr ""
"Если тело оператора ``async with`` завершается с исключением (поэтому :meth:"
"`~object.__aexit__` вызывается с набором исключений), это обрабатывается так "
"же, как если бы одна из задач завершилась неудачно: оставшиеся задачи "
"отменяются, а затем ожидаются, а исключения, не подлежащие отмене, "
"группируются в группу исключений и вызываются. Исключение, переданное в :"
"meth:`~object.__aexit__`, если оно не является :exc:`asyncio."
"CancelledError`, также включается в группу исключений. Для :exc:"
"`KeyboardInterrupt` и :exc:`SystemExit` предусмотрен тот же особый случай, "
"что и в предыдущем абзаце."

#: ../../library/asyncio-task.rst:395
msgid ""
"Task groups are careful not to mix up the internal cancellation used to "
"\"wake up\" their :meth:`~object.__aexit__` with cancellation requests for "
"the task in which they are running made by other parties. In particular, "
"when one task group is syntactically nested in another, and both experience "
"an exception in one of their child tasks simultaneously, the inner task "
"group will process its exceptions, and then the outer task group will "
"receive another cancellation and process its own exceptions."
msgstr ""
"Группы задач стараются не путать внутреннюю отмену, используемую для "
"«пробуждения» их :meth:`~object.__aexit__`, с запросами на отмену задачи, в "
"которой они выполняются, сделанными другими сторонами. В частности, когда "
"одна группа задач синтаксически вложена в другую и обе одновременно "
"испытывают исключение в одной из своих дочерних задач, внутренняя группа "
"задач будет обрабатывать свои исключения, а затем внешняя группа задач "
"получит еще одну отмену и обработает свои собственные исключения. ."

#: ../../library/asyncio-task.rst:403
msgid ""
"In the case where a task group is cancelled externally and also must raise "
"an :exc:`ExceptionGroup`, it will call the parent task's :meth:`~asyncio."
"Task.cancel` method. This ensures that a :exc:`asyncio.CancelledError` will "
"be raised at the next :keyword:`await`, so the cancellation is not lost."
msgstr ""
"В случае, когда группа задач отменяется извне и ей также необходимо вызвать :"
"exc:`ExceptionGroup`, она вызывает метод :meth:`~asyncio.Task.cancel` "
"родительской задачи. Это гарантирует, что при следующем :keyword:`await` "
"будет вызвана ошибка :exc:`asyncio.CancelledError`, поэтому отмена не будет "
"потеряна."

#: ../../library/asyncio-task.rst:409
msgid ""
"Task groups preserve the cancellation count reported by :meth:`asyncio.Task."
"cancelling`."
msgstr ""
"Группы задач сохраняют количество отмен, сообщаемое :meth:`asyncio.Task."
"cancelling`."

#: ../../library/asyncio-task.rst:414
msgid ""
"Improved handling of simultaneous internal and external cancellations and "
"correct preservation of cancellation counts."
msgstr ""
"Улучшена обработка одновременных внутренних и внешних отмен, а также "
"правильное сохранение количества отмен."

#: ../../library/asyncio-task.rst:418
msgid "Terminating a Task Group"
msgstr "Завершение группы задач"

#: ../../library/asyncio-task.rst:420
msgid ""
"While terminating a task group is not natively supported by the standard "
"library, termination can be achieved by adding an exception-raising task to "
"the task group and ignoring the raised exception:"
msgstr ""
"Хотя завершение группы задач не поддерживается стандартной библиотекой, "
"завершение может быть достигнуто путем добавления задачи, вызывающей "
"исключение, в группу задач и игнорирования возникшего исключения:"

#: ../../library/asyncio-task.rst:424
msgid ""
"import asyncio\n"
"from asyncio import TaskGroup\n"
"\n"
"class TerminateTaskGroup(Exception):\n"
"    \"\"\"Exception raised to terminate a task group.\"\"\"\n"
"\n"
"async def force_terminate_task_group():\n"
"    \"\"\"Used to force termination of a task group.\"\"\"\n"
"    raise TerminateTaskGroup()\n"
"\n"
"async def job(task_id, sleep_time):\n"
"    print(f'Task {task_id}: start')\n"
"    await asyncio.sleep(sleep_time)\n"
"    print(f'Task {task_id}: done')\n"
"\n"
"async def main():\n"
"    try:\n"
"        async with TaskGroup() as group:\n"
"            # spawn some tasks\n"
"            group.create_task(job(1, 0.5))\n"
"            group.create_task(job(2, 1.5))\n"
"            # sleep for 1 second\n"
"            await asyncio.sleep(1)\n"
"            # add an exception-raising task to force the group to terminate\n"
"            group.create_task(force_terminate_task_group())\n"
"    except* TerminateTaskGroup:\n"
"        pass\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"from asyncio import TaskGroup\n"
"\n"
"class TerminateTaskGroup(Exception):\n"
"    \"\"\"Exception raised to terminate a task group.\"\"\"\n"
"\n"
"async def force_terminate_task_group():\n"
"    \"\"\"Used to force termination of a task group.\"\"\"\n"
"    raise TerminateTaskGroup()\n"
"\n"
"async def job(task_id, sleep_time):\n"
"    print(f'Task {task_id}: start')\n"
"    await asyncio.sleep(sleep_time)\n"
"    print(f'Task {task_id}: done')\n"
"\n"
"async def main():\n"
"    try:\n"
"        async with TaskGroup() as group:\n"
"            # spawn some tasks\n"
"            group.create_task(job(1, 0.5))\n"
"            group.create_task(job(2, 1.5))\n"
"            # sleep for 1 second\n"
"            await asyncio.sleep(1)\n"
"            # add an exception-raising task to force the group to terminate\n"
"            group.create_task(force_terminate_task_group())\n"
"    except* TerminateTaskGroup:\n"
"        pass\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:456
msgid "Expected output:"
msgstr "Ожидаемый результат:"

#: ../../library/asyncio-task.rst:458
msgid ""
"Task 1: start\n"
"Task 2: start\n"
"Task 1: done"
msgstr ""
"Task 1: start\n"
"Task 2: start\n"
"Task 1: done"

#: ../../library/asyncio-task.rst:465
msgid "Sleeping"
msgstr "Спящий"

#: ../../library/asyncio-task.rst:469
msgid "Block for *delay* seconds."
msgstr "Блокировка на *delay* секунд."

#: ../../library/asyncio-task.rst:471
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Если указан *result*, он возвращается вызывающей стороне после завершения "
"сопрограммы."

#: ../../library/asyncio-task.rst:474
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` всегда приостанавливает текущую задачу, позволяя запустить "
"другие задачи."

#: ../../library/asyncio-task.rst:477
msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr ""
"Установка задержки на 0 обеспечивает оптимизированный путь для запуска "
"других задач. Это может использоваться долго выполняющимися функциями, чтобы "
"избежать блокировки цикла событий на весь период вызова функции."

#: ../../library/asyncio-task.rst:483
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Пример сопрограммы, отображающей текущую дату каждую секунду в течение 5 "
"секунд::"

#: ../../library/asyncio-task.rst:486
msgid ""
"import asyncio\n"
"import datetime\n"
"\n"
"async def display_date():\n"
"    loop = asyncio.get_running_loop()\n"
"    end_time = loop.time() + 5.0\n"
"    while True:\n"
"        print(datetime.datetime.now())\n"
"        if (loop.time() + 1.0) >= end_time:\n"
"            break\n"
"        await asyncio.sleep(1)\n"
"\n"
"asyncio.run(display_date())"
msgstr ""
"import asyncio\n"
"import datetime\n"
"\n"
"async def display_date():\n"
"    loop = asyncio.get_running_loop()\n"
"    end_time = loop.time() + 5.0\n"
"    while True:\n"
"        print(datetime.datetime.now())\n"
"        if (loop.time() + 1.0) >= end_time:\n"
"            break\n"
"        await asyncio.sleep(1)\n"
"\n"
"asyncio.run(display_date())"

#: ../../library/asyncio-task.rst:501 ../../library/asyncio-task.rst:599
#: ../../library/asyncio-task.rst:698 ../../library/asyncio-task.rst:872
#: ../../library/asyncio-task.rst:926 ../../library/asyncio-task.rst:983
msgid "Removed the *loop* parameter."
msgstr "Удален параметр *loop*."

#: ../../library/asyncio-task.rst:504
msgid "Raises :exc:`ValueError` if *delay* is :data:`~math.nan`."
msgstr "Вызывает :exc:`ValueError`, если *delay* равен :data:`~math.nan`."

#: ../../library/asyncio-task.rst:509
msgid "Running Tasks Concurrently"
msgstr "Одновременное выполнение задач"

#: ../../library/asyncio-task.rst:513
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Запустите :ref:`awaitable объекты <asyncio-awaitables>` в последовательности "
"*aws* *параллельно*."

#: ../../library/asyncio-task.rst:516
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Если какое-либо ожидаемое событие в *aws* является сопрограммой, оно "
"автоматически назначается как Задача."

#: ../../library/asyncio-task.rst:519
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Если все ожидаемые объекты выполнены успешно, результатом является "
"совокупный список возвращаемых значений. Порядок значений результатов "
"соответствует порядку ожидаемых объектов в *aws*."

#: ../../library/asyncio-task.rst:523
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Если *return_Exceptions* имеет значение False (по умолчанию), первое "
"возникшее исключение немедленно распространяется на задачу, ожидающую "
"Gather(). Другие ожидаемые объекты в последовательности *aws* **не будут "
"отменены** и продолжат выполняться."

#: ../../library/asyncio-task.rst:528
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Если *return_Exceptions* имеет значение True, исключения обрабатываются так "
"же, как успешные результаты, и объединяются в список результатов."

#: ../../library/asyncio-task.rst:531
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Если ``gather()`` *отменяется*, все отправленные ожидаемые объекты (которые "
"еще не завершены) также *отменяются*."

#: ../../library/asyncio-task.rst:534
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Если какая-либо Задача или Future из последовательности *aws* *отменена*, "
"она рассматривается так, как если бы она вызвала :exc:`CancelledError` — "
"вызов ``gather()`` в этом случае **не** отменяется. . Это сделано для того, "
"чтобы предотвратить отмену одной отправленной задачи/фьючерса, которая может "
"привести к отмене других задач/фьючерсов."

#: ../../library/asyncio-task.rst:541
msgid ""
"A new alternative to create and run tasks concurrently and wait for their "
"completion is :class:`asyncio.TaskGroup`. *TaskGroup* provides stronger "
"safety guarantees than *gather* for scheduling a nesting of subtasks: if a "
"task (or a subtask, a task scheduled by a task) raises an exception, "
"*TaskGroup* will, while *gather* will not, cancel the remaining scheduled "
"tasks)."
msgstr ""
"Новой альтернативой для одновременного создания и запуска задач и ожидания "
"их завершения является :class:`asyncio.TaskGroup`. *TaskGroup* обеспечивает "
"более сильные гарантии безопасности, чем *gather*, при планировании "
"вложенности подзадач: если задача (или подзадача, задача, запланированная "
"задачей) вызывает исключение, *TaskGroup* ее отменит, а *gather* нет. "
"оставшиеся запланированные задачи)."

#: ../../library/asyncio-task.rst:552
msgid ""
"import asyncio\n"
"\n"
"async def factorial(name, number):\n"
"    f = 1\n"
"    for i in range(2, number + 1):\n"
"        print(f\"Task {name}: Compute factorial({number}), currently i={i}..."
"\")\n"
"        await asyncio.sleep(1)\n"
"        f *= i\n"
"    print(f\"Task {name}: factorial({number}) = {f}\")\n"
"    return f\n"
"\n"
"async def main():\n"
"    # Schedule three calls *concurrently*:\n"
"    L = await asyncio.gather(\n"
"        factorial(\"A\", 2),\n"
"        factorial(\"B\", 3),\n"
"        factorial(\"C\", 4),\n"
"    )\n"
"    print(L)\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     Task A: Compute factorial(2), currently i=2...\n"
"#     Task B: Compute factorial(3), currently i=2...\n"
"#     Task C: Compute factorial(4), currently i=2...\n"
"#     Task A: factorial(2) = 2\n"
"#     Task B: Compute factorial(3), currently i=3...\n"
"#     Task C: Compute factorial(4), currently i=3...\n"
"#     Task B: factorial(3) = 6\n"
"#     Task C: Compute factorial(4), currently i=4...\n"
"#     Task C: factorial(4) = 24\n"
"#     [2, 6, 24]"
msgstr ""
"import asyncio\n"
"\n"
"async def factorial(name, number):\n"
"    f = 1\n"
"    for i in range(2, number + 1):\n"
"        print(f\"Task {name}: Compute factorial({number}), currently i={i}..."
"\")\n"
"        await asyncio.sleep(1)\n"
"        f *= i\n"
"    print(f\"Task {name}: factorial({number}) = {f}\")\n"
"    return f\n"
"\n"
"async def main():\n"
"    # Schedule three calls *concurrently*:\n"
"    L = await asyncio.gather(\n"
"        factorial(\"A\", 2),\n"
"        factorial(\"B\", 3),\n"
"        factorial(\"C\", 4),\n"
"    )\n"
"    print(L)\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     Task A: Compute factorial(2), currently i=2...\n"
"#     Task B: Compute factorial(3), currently i=2...\n"
"#     Task C: Compute factorial(4), currently i=2...\n"
"#     Task A: factorial(2) = 2\n"
"#     Task B: Compute factorial(3), currently i=3...\n"
"#     Task C: Compute factorial(4), currently i=3...\n"
"#     Task B: factorial(3) = 6\n"
"#     Task C: Compute factorial(4), currently i=4...\n"
"#     Task C: factorial(4) = 24\n"
"#     [2, 6, 24]"

#: ../../library/asyncio-task.rst:588
msgid ""
"If *return_exceptions* is false, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""
"Если *return_Exceptions* имеет значение false, отмена метода сбора() после "
"того, как он был помечен как выполненный, не отменит отправленные ожидаемые "
"объекты. Например, сбор может быть помечен как выполненный после "
"распространения исключения вызывающему объекту, поэтому вызов Gather."
"cancel() после перехвата исключения (вызванного одним из ожидаемых объектов) "
"из сбора не отменит другие ожидаемые объекты."

#: ../../library/asyncio-task.rst:595
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Если сам *сбор* отменен, отмена распространяется независимо от "
"*return_Exceptions*."

#: ../../library/asyncio-task.rst:602
msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running "
"event loop."
msgstr ""
"Предупреждение об устаревании выдается, если позиционные аргументы не "
"предоставлены или не все позиционные аргументы являются объектами типа "
"Future и нет текущего цикла событий."

#: ../../library/asyncio-task.rst:611
msgid "Eager Task Factory"
msgstr "Фабрика нетерпеливых задач"

#: ../../library/asyncio-task.rst:615
msgid "A task factory for eager task execution."
msgstr "Фабрика задач для оперативного выполнения задач."

#: ../../library/asyncio-task.rst:617
msgid ""
"When using this factory (via :meth:`loop.set_task_factory(asyncio."
"eager_task_factory) <loop.set_task_factory>`), coroutines begin execution "
"synchronously during :class:`Task` construction. Tasks are only scheduled on "
"the event loop if they block. This can be a performance improvement as the "
"overhead of loop scheduling is avoided for coroutines that complete "
"synchronously."
msgstr ""
"При использовании этой фабрики (через :meth:`loop.set_task_factory(asyncio."
"eager_task_factory) <loop.set_task_factory>`) сопрограммы начинают "
"выполнение синхронно во время построения :class:`Task`. Задачи планируются в "
"цикле событий только в том случае, если они блокируются. Это может повысить "
"производительность, поскольку для сопрограмм, которые выполняются синхронно, "
"можно избежать накладных расходов на планирование циклов."

#: ../../library/asyncio-task.rst:623
msgid ""
"A common example where this is beneficial is coroutines which employ caching "
"or memoization to avoid actual I/O when possible."
msgstr ""
"Типичным примером, когда это полезно, являются сопрограммы, которые "
"используют кеширование или мемоизацию, чтобы избежать фактического ввода-"
"вывода, когда это возможно."

#: ../../library/asyncio-task.rst:628
msgid ""
"Immediate execution of the coroutine is a semantic change. If the coroutine "
"returns or raises, the task is never scheduled to the event loop. If the "
"coroutine execution blocks, the task is scheduled to the event loop. This "
"change may introduce behavior changes to existing applications. For example, "
"the application's task execution order is likely to change."
msgstr ""
"Немедленное выполнение сопрограммы является семантическим изменением. Если "
"сопрограмма возвращает или вызывает вызов, задача никогда не назначается в "
"цикле событий. Если выполнение сопрограммы блокируется, задача назначается в "
"цикле событий. Это изменение может привести к изменению поведения "
"существующих приложений. Например, может измениться порядок выполнения задач "
"приложения."

#: ../../library/asyncio-task.rst:639
msgid ""
"Create an eager task factory, similar to :func:`eager_task_factory`, using "
"the provided *custom_task_constructor* when creating a new task instead of "
"the default :class:`Task`."
msgstr ""
"Создайте фабрику активных задач, аналогичную :func:`eager_task_factory`, "
"используя предоставленный *custom_task_constructor* при создании новой "
"задачи вместо стандартного :class:`Task`."

#: ../../library/asyncio-task.rst:643
msgid ""
"*custom_task_constructor* must be a *callable* with the signature matching "
"the signature of :class:`Task.__init__ <Task>`. The callable must return a :"
"class:`asyncio.Task`-compatible object."
msgstr ""
"*custom_task_constructor* должен быть *вызываемым* с сигнатурой, "
"соответствующей сигнатуре :class:`Task.__init__ <Task>`. Вызываемый объект "
"должен возвращать объект, совместимый с :class:`asyncio.Task`."

#: ../../library/asyncio-task.rst:647
msgid ""
"This function returns a *callable* intended to be used as a task factory of "
"an event loop via :meth:`loop.set_task_factory(factory) <loop."
"set_task_factory>`)."
msgstr ""
"Эта функция возвращает *вызываемый* объект, предназначенный для "
"использования в качестве фабрики задач в цикле событий через :meth:`loop."
"set_task_factory(factory) <loop.set_task_factory>`)."

#: ../../library/asyncio-task.rst:654
msgid "Shielding From Cancellation"
msgstr "Защита от отмены"

#: ../../library/asyncio-task.rst:658
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Защитите :ref:`ожидаемый объект <asyncio-awaitables>` от :meth:`отмены <Task."
"cancel>`."

#: ../../library/asyncio-task.rst:661 ../../library/asyncio-task.rst:827
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr ""
"Если *aw* является сопрограммой, она автоматически назначается как Задача."

#: ../../library/asyncio-task.rst:663
msgid "The statement::"
msgstr "Заявление::"

#: ../../library/asyncio-task.rst:665
msgid ""
"task = asyncio.create_task(something())\n"
"res = await shield(task)"
msgstr ""
"task = asyncio.create_task(something())\n"
"res = await shield(task)"

#: ../../library/asyncio-task.rst:668
msgid "is equivalent to::"
msgstr "эквивалентно::"

#: ../../library/asyncio-task.rst:670
msgid "res = await something()"
msgstr "res = await something()"

#: ../../library/asyncio-task.rst:672
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*за исключением* того, что если сопрограмма, содержащая ее, отменена, "
"Задача, выполняющаяся в ``something()``, не отменяется. С точки зрения "
"``something()`` отмены не произошло. Хотя вызывающая сторона по-прежнему "
"отменяется, выражение await по-прежнему вызывает ошибку :exc:"
"`CancelledError`."

#: ../../library/asyncio-task.rst:678
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Если ``something()`` отменяется другими способами (т.е. изнутри самого "
"себя), это также отменяет ``shield()``."

#: ../../library/asyncio-task.rst:681
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Если желательно полностью игнорировать отмену (не рекомендуется), функцию "
"«shield()» следует объединить с предложением try/Exception следующим образом:"

#: ../../library/asyncio-task.rst:685
msgid ""
"task = asyncio.create_task(something())\n"
"try:\n"
"    res = await shield(task)\n"
"except CancelledError:\n"
"    res = None"
msgstr ""
"task = asyncio.create_task(something())\n"
"try:\n"
"    res = await shield(task)\n"
"except CancelledError:\n"
"    res = None"

#: ../../library/asyncio-task.rst:693
msgid ""
"Save a reference to tasks passed to this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done."
msgstr ""
"Сохраните ссылку на задачи, переданные в эту функцию, чтобы задача не "
"исчезла в середине выполнения. Цикл событий сохраняет только слабые ссылки "
"на задачи. Задача, на которую нигде нет ссылок, может быть удалена сборщиком "
"мусора в любое время, даже до того, как она будет выполнена."

#: ../../library/asyncio-task.rst:701
msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr ""
"Предупреждение об устаревании выдается, если *aw* не является объектом типа "
"Future и нет текущего цикла событий."

#: ../../library/asyncio-task.rst:707
msgid "Timeouts"
msgstr "Таймауты"

#: ../../library/asyncio-task.rst:711
msgid ""
"Return an :ref:`asynchronous context manager <async-context-managers>` that "
"can be used to limit the amount of time spent waiting on something."
msgstr ""
"Возвращает :ref:`асинхронный контекстный менеджер <async-context-managers>`, "
"который можно использовать для ограничения времени, затрачиваемого на "
"ожидание чего-либо."

#: ../../library/asyncio-task.rst:715
msgid ""
"*delay* can either be ``None``, or a float/int number of seconds to wait. If "
"*delay* is ``None``, no time limit will be applied; this can be useful if "
"the delay is unknown when the context manager is created."
msgstr ""
"*delay* может быть либо None, либо числом в секундах ожидания с плавающей "
"запятой/int. Если *delay* имеет значение «None», ограничение по времени "
"применяться не будет; это может быть полезно, если задержка неизвестна при "
"создании диспетчера контекста."

#: ../../library/asyncio-task.rst:720
msgid ""
"In either case, the context manager can be rescheduled after creation using :"
"meth:`Timeout.reschedule`."
msgstr ""
"В любом случае диспетчер контекста может быть перепланирован после создания "
"с помощью :meth:`Timeout.reschedule`."

#: ../../library/asyncio-task.rst:725
msgid ""
"async def main():\n"
"    async with asyncio.timeout(10):\n"
"        await long_running_task()"
msgstr ""
"async def main():\n"
"    async with asyncio.timeout(10):\n"
"        await long_running_task()"

#: ../../library/asyncio-task.rst:729
msgid ""
"If ``long_running_task`` takes more than 10 seconds to complete, the context "
"manager will cancel the current task and handle the resulting :exc:`asyncio."
"CancelledError` internally, transforming it into a :exc:`TimeoutError` which "
"can be caught and handled."
msgstr ""
"Если выполнение ``long_running_task`` занимает более 10 секунд, контекстный "
"менеджер отменит текущую задачу и обработает полученную :exc:`asyncio."
"CancelledError` внутри себя, преобразуя ее в :exc:`TimeoutError`, которую "
"можно перехватить. и справился."

#: ../../library/asyncio-task.rst:736
msgid ""
"The :func:`asyncio.timeout` context manager is what transforms the :exc:"
"`asyncio.CancelledError` into a :exc:`TimeoutError`, which means the :exc:"
"`TimeoutError` can only be caught *outside* of the context manager."
msgstr ""
"Контекстный менеджер :func:`asyncio.timeout` преобразует :exc:`asyncio."
"CancelledError` в :exc:`TimeoutError`, что означает, что :exc:`TimeoutError` "
"может быть обнаружен только *вне* контекстный менеджер."

#: ../../library/asyncio-task.rst:741
msgid "Example of catching :exc:`TimeoutError`::"
msgstr "Пример перехвата :exc:`TimeoutError`::"

#: ../../library/asyncio-task.rst:743
msgid ""
"async def main():\n"
"    try:\n"
"        async with asyncio.timeout(10):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""
"async def main():\n"
"    try:\n"
"        async with asyncio.timeout(10):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"

#: ../../library/asyncio-task.rst:752
msgid ""
"The context manager produced by :func:`asyncio.timeout` can be rescheduled "
"to a different deadline and inspected."
msgstr ""
"Менеджер контекста, созданный :func:`asyncio.timeout`, может быть перенесен "
"на другой крайний срок и проверен."

#: ../../library/asyncio-task.rst:757
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` for "
"cancelling overdue coroutines."
msgstr ""
":ref:`асинхронный контекстный менеджер <async-context-managers>` для отмены "
"просроченных сопрограмм."

#: ../../library/asyncio-task.rst:760
msgid ""
"``when`` should be an absolute time at which the context should time out, as "
"measured by the event loop's clock:"
msgstr ""
"``when`` должно быть абсолютным временем, в которое контекст должен истечь, "
"измеряемым часами цикла событий:"

#: ../../library/asyncio-task.rst:763
msgid "If ``when`` is ``None``, the timeout will never trigger."
msgstr "If ``when`` is ``None``, тайм-аут никогда не сработает. "

#: ../../library/asyncio-task.rst:764
msgid ""
"If ``when < loop.time()``, the timeout will trigger on the next iteration of "
"the event loop."
msgstr ""
"If ``when < loop.time()``, тайм-аут сработает на следующей итерации цикла "
"событий. "

#: ../../library/asyncio-task.rst:769
msgid ""
"Return the current deadline, or ``None`` if the current deadline is not set."
msgstr "Возвращает текущий срок или «Нет», если текущий срок не установлен."

#: ../../library/asyncio-task.rst:774
msgid "Reschedule the timeout."
msgstr "Перепланируйте тайм-аут."

#: ../../library/asyncio-task.rst:778
msgid "Return whether the context manager has exceeded its deadline (expired)."
msgstr "Перепланируйте тайм-аут."

#: ../../library/asyncio-task.rst:783
msgid ""
"async def main():\n"
"    try:\n"
"        # We do not know the timeout when starting, so we pass ``None``.\n"
"        async with asyncio.timeout(None) as cm:\n"
"            # We know the timeout now, so we reschedule it.\n"
"            new_deadline = get_running_loop().time() + 10\n"
"            cm.reschedule(new_deadline)\n"
"\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        pass\n"
"\n"
"    if cm.expired():\n"
"        print(\"Looks like we haven't finished on time.\")"
msgstr ""
"async def main():\n"
"    try:\n"
"        # We do not know the timeout when starting, so we pass ``None``.\n"
"        async with asyncio.timeout(None) as cm:\n"
"            # We know the timeout now, so we reschedule it.\n"
"            new_deadline = get_running_loop().time() + 10\n"
"            cm.reschedule(new_deadline)\n"
"\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        pass\n"
"\n"
"    if cm.expired():\n"
"        print(\"Looks like we haven't finished on time.\")"

#: ../../library/asyncio-task.rst:798
msgid "Timeout context managers can be safely nested."
msgstr "Менеджеры контекста таймаута могут быть безопасно вложены."

#: ../../library/asyncio-task.rst:804
msgid ""
"Similar to :func:`asyncio.timeout`, except *when* is the absolute time to "
"stop waiting, or ``None``."
msgstr ""
"Аналогично :func:`asyncio.timeout`, за исключением того, что *when* — это "
"абсолютное время прекращения ожидания или ``None``."

#: ../../library/asyncio-task.rst:809
msgid ""
"async def main():\n"
"    loop = get_running_loop()\n"
"    deadline = loop.time() + 20\n"
"    try:\n"
"        async with asyncio.timeout_at(deadline):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""
"async def main():\n"
"    loop = get_running_loop()\n"
"    deadline = loop.time() + 20\n"
"    try:\n"
"        async with asyncio.timeout_at(deadline):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"

#: ../../library/asyncio-task.rst:824
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Подождите, пока *aw* :ref:`awaitable <asyncio-awaitables>` завершится с "
"таймаутом."

#: ../../library/asyncio-task.rst:829
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* может быть либо ``None``, либо числом с плавающей запятой или "
"целым числом секунд ожидания. Если *timeout* имеет значение «None», "
"блокируется до завершения будущего."

#: ../../library/asyncio-task.rst:833
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`TimeoutError`."
msgstr ""
"Если происходит таймаут, задача отменяется и выдается :exc:`TimeoutError`."

#: ../../library/asyncio-task.rst:836
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"Чтобы избежать выполнения задачи :meth:`cancellation <Task.cancel>`, "
"оберните ее в :func:`shield`."

#: ../../library/asyncio-task.rst:839
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr ""
"Функция будет ждать до тех пор, пока фьючерс не будет фактически отменен, "
"поэтому общее время ожидания может превысить *таймаут*. Если во время отмены "
"возникает исключение, оно распространяется."

#: ../../library/asyncio-task.rst:843
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Если ожидание отменяется, будущее *aw* также отменяется."

#: ../../library/asyncio-task.rst:849
msgid ""
"async def eternity():\n"
"    # Sleep for one hour\n"
"    await asyncio.sleep(3600)\n"
"    print('yay!')\n"
"\n"
"async def main():\n"
"    # Wait for at most 1 second\n"
"    try:\n"
"        await asyncio.wait_for(eternity(), timeout=1.0)\n"
"    except TimeoutError:\n"
"        print('timeout!')\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     timeout!"
msgstr ""
"async def eternity():\n"
"    # Sleep for one hour\n"
"    await asyncio.sleep(3600)\n"
"    print('yay!')\n"
"\n"
"async def main():\n"
"    # Wait for at most 1 second\n"
"    try:\n"
"        await asyncio.wait_for(eternity(), timeout=1.0)\n"
"    except TimeoutError:\n"
"        print('timeout!')\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     timeout!"

#: ../../library/asyncio-task.rst:867
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`TimeoutError` immediately."
msgstr ""
"Когда *aw* отменяется из-за таймаута, ``wait_for`` ожидает отмены *aw*. "
"Раньше он немедленно вызывал :exc:`TimeoutError`."

#: ../../library/asyncio-task.rst:875
msgid "Raises :exc:`TimeoutError` instead of :exc:`asyncio.TimeoutError`."
msgstr "Вызывает :exc:`TimeoutError` вместо :exc:`asyncio.TimeoutError`."

#: ../../library/asyncio-task.rst:880
msgid "Waiting Primitives"
msgstr "Ожидающие примитивы"

#: ../../library/asyncio-task.rst:884
msgid ""
"Run :class:`~asyncio.Future` and :class:`~asyncio.Task` instances in the "
"*aws* iterable concurrently and block until the condition specified by "
"*return_when*."
msgstr ""
"Запускайте экземпляры :class:`~asyncio.Future` и :class:`~asyncio.Task` в "
"итерации *aws* одновременно и блокируйте их до тех пор, пока не будет "
"выполнено условие, указанное в *return_when*."

#: ../../library/asyncio-task.rst:888
msgid "The *aws* iterable must not be empty."
msgstr "Итерируемый *aws* не должен быть пустым."

#: ../../library/asyncio-task.rst:890
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Возвращает два набора задач/фьючерсов: ``(выполнено, ожидается)``."

#: ../../library/asyncio-task.rst:892
msgid "Usage::"
msgstr "Использование::"

#: ../../library/asyncio-task.rst:894
msgid "done, pending = await asyncio.wait(aws)"
msgstr "done, pending = await asyncio.wait(aws)"

#: ../../library/asyncio-task.rst:896
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (число с плавающей запятой или целое число), если указано, можно "
"использовать для управления максимальным количеством секунд ожидания перед "
"возвратом."

#: ../../library/asyncio-task.rst:899
msgid ""
"Note that this function does not raise :exc:`TimeoutError`. Futures or Tasks "
"that aren't done when the timeout occurs are simply returned in the second "
"set."
msgstr ""
"Обратите внимание, что эта функция не вызывает :exc:`TimeoutError`. Фьючерсы "
"или задачи, которые не выполнены по истечении тайм-аута, просто возвращаются "
"во втором наборе."

#: ../../library/asyncio-task.rst:903
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* указывает, когда эта функция должна вернуться. Это должна быть "
"одна из следующих констант:"

#: ../../library/asyncio-task.rst:909
msgid "Constant"
msgstr "Константа"

#: ../../library/asyncio-task.rst:910
msgid "Description"
msgstr "Описание"

#: ../../library/asyncio-task.rst:913
msgid "The function will return when any future finishes or is cancelled."
msgstr "Функция вернется, когда любое будущее завершится или будет отменено."

#: ../../library/asyncio-task.rst:916
msgid ""
"The function will return when any future finishes by raising an exception. "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"Функция вернется, когда любое будущее завершится вызовом исключения. Если "
"никакое будущее не вызывает исключение, это эквивалентно :const:"
"`ALL_COMPLETED`."

#: ../../library/asyncio-task.rst:921
msgid "The function will return when all futures finish or are cancelled."
msgstr "Функция вернется, когда все фьючерсы закончатся или будут отменены."

#: ../../library/asyncio-task.rst:923
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"В отличие от :func:`~asyncio.wait_for`, ``wait()`` не отменяет фьючерсы, "
"когда происходит таймаут."

#: ../../library/asyncio-task.rst:929
msgid "Passing coroutine objects to ``wait()`` directly is forbidden."
msgstr "Передача объектов сопрограммы напрямую в wait() запрещена."

#: ../../library/asyncio-task.rst:932 ../../library/asyncio-task.rst:990
msgid "Added support for generators yielding tasks."
msgstr "Добавлена ​​поддержка генераторов, дающих задачи."

#: ../../library/asyncio-task.rst:938
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently. The returned object can be iterated to obtain the results of "
"the awaitables as they finish."
msgstr ""
"Запустите :ref:`awaitable объекты <asyncio-awaitables>` в итерации *aws* "
"одновременно. Возвращенный объект можно повторять, чтобы получить результаты "
"ожидаемых объектов по мере их завершения."

#: ../../library/asyncio-task.rst:942
msgid ""
"The object returned by ``as_completed()`` can be iterated as an :term:"
"`asynchronous iterator` or a plain :term:`iterator`. When asynchronous "
"iteration is used, the originally-supplied awaitables are yielded if they "
"are tasks or futures. This makes it easy to correlate previously-scheduled "
"tasks with their results. Example::"
msgstr ""
"Объект, возвращаемый функцией as_completed(), может быть повторен как :term:"
"`асинхронный итератор` или как обычный :term:`итератор`. При использовании "
"асинхронной итерации выдаются исходно предоставленные ожидаемые объекты, "
"если они являются задачами или будущими событиями. Это позволяет легко "
"соотносить ранее запланированные задачи с их результатами. Пример::"

#: ../../library/asyncio-task.rst:948
msgid ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"async for earliest_connect in as_completed(tasks):\n"
"    # earliest_connect is done. The result can be obtained by\n"
"    # awaiting it or calling earliest_connect.result()\n"
"    reader, writer = await earliest_connect\n"
"\n"
"    if earliest_connect is ipv6_connect:\n"
"        print(\"IPv6 connection established.\")\n"
"    else:\n"
"        print(\"IPv4 connection established.\")"
msgstr ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"async for earliest_connect in as_completed(tasks):\n"
"    # earliest_connect is done. The result can be obtained by\n"
"    # awaiting it or calling earliest_connect.result()\n"
"    reader, writer = await earliest_connect\n"
"\n"
"    if earliest_connect is ipv6_connect:\n"
"        print(\"IPv6 connection established.\")\n"
"    else:\n"
"        print(\"IPv4 connection established.\")"

#: ../../library/asyncio-task.rst:962
msgid ""
"During asynchronous iteration, implicitly-created tasks will be yielded for "
"supplied awaitables that aren't tasks or futures."
msgstr ""
"Во время асинхронной итерации неявно созданные задачи будут создаваться для "
"предоставленных ожидаемых объектов, которые не являются задачами или "
"фьючерсами."

#: ../../library/asyncio-task.rst:965
msgid ""
"When used as a plain iterator, each iteration yields a new coroutine that "
"returns the result or raises the exception of the next completed awaitable. "
"This pattern is compatible with Python versions older than 3.13::"
msgstr ""
"При использовании в качестве простого итератора каждая итерация создает "
"новую сопрограмму, которая возвращает результат или вызывает исключение "
"следующего завершенного ожидаемого объекта. Этот шаблон совместим с версиями "
"Python старше 3.13:"

#: ../../library/asyncio-task.rst:969
msgid ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"for next_connect in as_completed(tasks):\n"
"    # next_connect is not one of the original task objects. It must be\n"
"    # awaited to obtain the result value or raise the exception of the\n"
"    # awaitable that finishes next.\n"
"    reader, writer = await next_connect"
msgstr ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"for next_connect in as_completed(tasks):\n"
"    # next_connect is not one of the original task objects. It must be\n"
"    # awaited to obtain the result value or raise the exception of the\n"
"    # awaitable that finishes next.\n"
"    reader, writer = await next_connect"

#: ../../library/asyncio-task.rst:979
msgid ""
"A :exc:`TimeoutError` is raised if the timeout occurs before all awaitables "
"are done. This is raised by the ``async for`` loop during asynchronous "
"iteration or by the coroutines yielded during plain iteration."
msgstr ""
"Ошибка :exc:`TimeoutError` возникает, если тайм-аут наступает до того, как "
"все ожидаемые действия будут выполнены. Это вызывается циклом async for во "
"время асинхронной итерации или сопрограммами, создаваемыми во время простой "
"итерации."

#: ../../library/asyncio-task.rst:986
msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr ""
"Предупреждение об устаревании выдается, если не все ожидаемые объекты в "
"итерации *aws* являются объектами типа Future и не выполняется цикл "
"обработки событий."

#: ../../library/asyncio-task.rst:993
msgid ""
"The result can now be used as either an :term:`asynchronous iterator` or as "
"a plain :term:`iterator` (previously it was only a plain iterator)."
msgstr ""
"Результат теперь можно использовать либо как :term:`асинхронный итератор`, "
"либо как простой :term:`итератор` (ранее это был только простой итератор)."

#: ../../library/asyncio-task.rst:999
msgid "Running in Threads"
msgstr "Работа в потоках"

#: ../../library/asyncio-task.rst:1003
msgid "Asynchronously run function *func* in a separate thread."
msgstr "Асинхронно запустите функцию *func* в отдельном потоке."

#: ../../library/asyncio-task.rst:1005
msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""
"Любые \\*args и \\*\\*kwargs, предоставленные для этой функции, напрямую "
"передаются в *func*. Кроме того, распространяется текущий :class:"
"`contextvars.Context`, позволяя получать доступ к контекстным переменным из "
"потока цикла событий в отдельном потоке."

#: ../../library/asyncio-task.rst:1010
msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr ""
"Возвращает сопрограмму, которую можно ожидать, чтобы получить конечный "
"результат *func*."

#: ../../library/asyncio-task.rst:1012
msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were run in the main thread. For example::"
msgstr ""
"Эта функция сопрограммы в первую очередь предназначена для выполнения "
"функций/методов, связанных с вводом-выводом, которые в противном случае "
"заблокировали бы цикл событий, если бы они были запущены в основном потоке. "
"Например::"

#: ../../library/asyncio-task.rst:1016
msgid ""
"def blocking_io():\n"
"    print(f\"start blocking_io at {time.strftime('%X')}\")\n"
"    # Note that time.sleep() can be replaced with any blocking\n"
"    # IO-bound operation, such as file operations.\n"
"    time.sleep(1)\n"
"    print(f\"blocking_io complete at {time.strftime('%X')}\")\n"
"\n"
"async def main():\n"
"    print(f\"started main at {time.strftime('%X')}\")\n"
"\n"
"    await asyncio.gather(\n"
"        asyncio.to_thread(blocking_io),\n"
"        asyncio.sleep(1))\n"
"\n"
"    print(f\"finished main at {time.strftime('%X')}\")\n"
"\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"# started main at 19:50:53\n"
"# start blocking_io at 19:50:53\n"
"# blocking_io complete at 19:50:54\n"
"# finished main at 19:50:54"
msgstr ""
"def blocking_io():\n"
"    print(f\"start blocking_io at {time.strftime('%X')}\")\n"
"    # Note that time.sleep() can be replaced with any blocking\n"
"    # IO-bound operation, such as file operations.\n"
"    time.sleep(1)\n"
"    print(f\"blocking_io complete at {time.strftime('%X')}\")\n"
"\n"
"async def main():\n"
"    print(f\"started main at {time.strftime('%X')}\")\n"
"\n"
"    await asyncio.gather(\n"
"        asyncio.to_thread(blocking_io),\n"
"        asyncio.sleep(1))\n"
"\n"
"    print(f\"finished main at {time.strftime('%X')}\")\n"
"\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"# started main at 19:50:53\n"
"# start blocking_io at 19:50:53\n"
"# blocking_io complete at 19:50:54\n"
"# finished main at 19:50:54"

#: ../../library/asyncio-task.rst:1042
msgid ""
"Directly calling ``blocking_io()`` in any coroutine would block the event "
"loop for its duration, resulting in an additional 1 second of run time. "
"Instead, by using ``asyncio.to_thread()``, we can run it in a separate "
"thread without blocking the event loop."
msgstr ""
"Непосредственный вызов ``blocking_io()`` в любой сопрограмме заблокирует "
"цикл событий на время его выполнения, что приведет к дополнительной 1 "
"секунде выполнения. Вместо этого, используя asyncio.to_thread(), мы можем "
"запустить его в отдельном потоке, не блокируя цикл событий."

#: ../../library/asyncio-task.rst:1049
msgid ""
"Due to the :term:`GIL`, ``asyncio.to_thread()`` can typically only be used "
"to make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"``asyncio.to_thread()`` can also be used for CPU-bound functions."
msgstr ""
"Из-за :term:`GIL`, ``asyncio.to_thread()`` обычно можно использовать только "
"для того, чтобы сделать неблокирующими функции, связанные с вводом-выводом. "
"Однако для модулей расширения, выпускающих GIL, или альтернативных "
"реализаций Python, у которых его нет, asyncio.to_thread() также можно "
"использовать для функций, связанных с ЦП."

#: ../../library/asyncio-task.rst:1058
msgid "Scheduling From Other Threads"
msgstr "Планирование из других потоков"

#: ../../library/asyncio-task.rst:1062
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr "Отправьте сопрограмму в данный цикл событий. Потокобезопасный."

#: ../../library/asyncio-task.rst:1064
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Верните :class:`concurrent.futures.Future`, чтобы дождаться результата из "
"другого потока ОС."

#: ../../library/asyncio-task.rst:1067
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Эта функция предназначена для вызова из другого потока ОС, отличного от "
"того, в котором выполняется цикл событий. Пример::"

#: ../../library/asyncio-task.rst:1070
msgid ""
"# Create a coroutine\n"
"coro = asyncio.sleep(1, result=3)\n"
"\n"
"# Submit the coroutine to a given loop\n"
"future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"# Wait for the result with an optional timeout argument\n"
"assert future.result(timeout) == 3"
msgstr ""
"# Create a coroutine\n"
"coro = asyncio.sleep(1, result=3)\n"
"\n"
"# Submit the coroutine to a given loop\n"
"future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"# Wait for the result with an optional timeout argument\n"
"assert future.result(timeout) == 3"

#: ../../library/asyncio-task.rst:1079
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Если в сопрограмме возникает исключение, возвращаемое Future будет "
"уведомлено. Его также можно использовать для отмены задачи в цикле событий:"

#: ../../library/asyncio-task.rst:1083
msgid ""
"try:\n"
"    result = future.result(timeout)\n"
"except TimeoutError:\n"
"    print('The coroutine took too long, cancelling the task...')\n"
"    future.cancel()\n"
"except Exception as exc:\n"
"    print(f'The coroutine raised an exception: {exc!r}')\n"
"else:\n"
"    print(f'The coroutine returned: {result!r}')"
msgstr ""
"try:\n"
"    result = future.result(timeout)\n"
"except TimeoutError:\n"
"    print('The coroutine took too long, cancelling the task...')\n"
"    future.cancel()\n"
"except Exception as exc:\n"
"    print(f'The coroutine raised an exception: {exc!r}')\n"
"else:\n"
"    print(f'The coroutine returned: {result!r}')"

#: ../../library/asyncio-task.rst:1093
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"См. раздел документации о :ref:`параллелизме и многопоточности <asyncio-"
"multithreading>`."

#: ../../library/asyncio-task.rst:1096
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"В отличие от других функций asyncio, эта функция требует явной передачи "
"аргумента *loop*."

#: ../../library/asyncio-task.rst:1103
msgid "Introspection"
msgstr "самоанализ"

#: ../../library/asyncio-task.rst:1108
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Возвращает текущий запущенный экземпляр :class:`Task` или ``None``, если ни "
"одна задача не выполняется."

#: ../../library/asyncio-task.rst:1111
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Если *loop* имеет значение ``None``, для получения текущего цикла "
"используется :func:`get_running_loop`."

#: ../../library/asyncio-task.rst:1119
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Возвращает набор еще не завершенных объектов :class:`Task`, запущенных в "
"цикле."

#: ../../library/asyncio-task.rst:1122
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Если *loop* равен ``None``, для получения текущего цикла используется :func:"
"`get_running_loop`."

#: ../../library/asyncio-task.rst:1130
msgid "Return ``True`` if *obj* is a coroutine object."
msgstr "Верните ``True``, если *obj* является объектом сопрограммы."

#: ../../library/asyncio-task.rst:1136
msgid "Task Object"
msgstr "Объект задачи"

#: ../../library/asyncio-task.rst:1140
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
":class:`Future-подобный объект <Future>`, который запускает Python :ref:"
"`coroutine <coroutine>`. Не потокобезопасный."

#: ../../library/asyncio-task.rst:1143
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Задачи используются для запуска сопрограмм в циклах событий. Если "
"сопрограмма ожидает выполнения Future, Задача приостанавливает выполнение "
"сопрограммы и ожидает завершения Future. Когда Future *done*, выполнение "
"обернутой сопрограммы возобновляется."

#: ../../library/asyncio-task.rst:1149
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Циклы событий используют совместное планирование: цикл событий запускает "
"одну задачу за раз. Пока Задача ожидает завершения Будущего, цикл событий "
"запускает другие Задачи, обратные вызовы или выполняет операции ввода-вывода."

#: ../../library/asyncio-task.rst:1154
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"Используйте функцию высокого уровня :func:`asyncio.create_task` для создания "
"задач или функции низкого уровня :meth:`loop.create_task` или :func:"
"`ensure_future`. Создание экземпляров задач вручную не рекомендуется."

#: ../../library/asyncio-task.rst:1159
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"Чтобы отменить запущенную Задачу, используйте метод :meth:`cancel`. Его "
"вызов приведет к тому, что Задача выдаст исключение :exc:`CancelledError` в "
"обернутую сопрограмму. Если сопрограмма ожидает объекта Future во время "
"отмены, объект Future будет отменен."

#: ../../library/asyncio-task.rst:1164
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` можно использовать, чтобы проверить, была ли задача "
"отменена. Метод возвращает True, если обернутая сопрограмма не подавила "
"исключение :exc:`CancelledError` и была фактически отменена."

#: ../../library/asyncio-task.rst:1169
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` наследует от :class:`Future` все его API, кроме :meth:"
"`Future.set_result` и :meth:`Future.set_Exception`."

#: ../../library/asyncio-task.rst:1173
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. If no *context* is "
"provided, the Task copies the current context and later runs its coroutine "
"in the copied context."
msgstr ""
"Необязательный аргумент *context*, содержащий только ключевые слова, "
"позволяет указать собственный :class:`contextvars.Context` для запуска "
"*coro*. Если *context* не указан, Задача копирует текущий контекст и позже "
"запускает свою сопрограмму в скопированный контекст."

#: ../../library/asyncio-task.rst:1178
msgid ""
"An optional keyword-only *eager_start* argument allows eagerly starting the "
"execution of the :class:`asyncio.Task` at task creation time. If set to "
"``True`` and the event loop is running, the task will start executing the "
"coroutine immediately, until the first time the coroutine blocks. If the "
"coroutine returns or raises without blocking, the task will be finished "
"eagerly and will skip scheduling to the event loop."
msgstr ""
"Необязательный аргумент *eager_start*, содержащий только ключевые слова, "
"позволяет быстро начать выполнение :class:`asyncio.Task` во время создания "
"задачи. Если установлено значение «True» и цикл событий запущен, задача "
"начнет выполнение сопрограммы немедленно, пока сопрограмма не заблокируется "
"в первый раз. Если сопрограмма возвращается или вызывается без блокировки, "
"задача будет быстро завершена и планирование цикла событий будет пропущено."

#: ../../library/asyncio-task.rst:1185
msgid "Added support for the :mod:`contextvars` module."
msgstr "Добавлена ​​поддержка модуля :mod:`contextvars`."

#: ../../library/asyncio-task.rst:1191
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""
"Предупреждение об устаревании выдается, если *loop* не указан и нет "
"работающего цикла событий."

#: ../../library/asyncio-task.rst:1198
msgid "Added the *eager_start* parameter."
msgstr "Добавлен параметр *eager_start*."

#: ../../library/asyncio-task.rst:1203
msgid "Return ``True`` if the Task is *done*."
msgstr "Верните ``True``, если Задача *done*."

#: ../../library/asyncio-task.rst:1205
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Задача считается *выполненной*, когда обернутая сопрограмма либо вернула "
"значение, вызвала исключение, либо Задача была отменена."

#: ../../library/asyncio-task.rst:1210
msgid "Return the result of the Task."
msgstr "Вернуть результат задачи."

#: ../../library/asyncio-task.rst:1212
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Если Задача *done*, возвращается результат обернутой сопрограммы (или, если "
"сопрограмма вызвала исключение, это исключение вызывается повторно.)"

#: ../../library/asyncio-task.rst:1216 ../../library/asyncio-task.rst:1230
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Если Задача была *отменена*, этот метод вызывает исключение :exc:"
"`CancelledError`."

#: ../../library/asyncio-task.rst:1219
msgid ""
"If the Task's result isn't yet available, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Если результат Задачи еще недоступен, этот метод вызывает исключение :exc:"
"`InvalidStateError`."

#: ../../library/asyncio-task.rst:1224
msgid "Return the exception of the Task."
msgstr "Вернуть исключение задачи."

#: ../../library/asyncio-task.rst:1226
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Если обернутая сопрограмма вызвала исключение, это исключение возвращается. "
"Если обернутая сопрограмма вернулась нормально, этот метод возвращает None."

#: ../../library/asyncio-task.rst:1233
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Если Задача еще не *выполнена*, этот метод вызывает исключение :exc:"
"`InvalidStateError`."

#: ../../library/asyncio-task.rst:1238
msgid "Add a callback to be run when the Task is *done*."
msgstr ""
"Добавьте обратный вызов, который будет выполняться, когда Задача *выполнена*."

#: ../../library/asyncio-task.rst:1240 ../../library/asyncio-task.rst:1249
msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Этот метод следует использовать только в низкоуровневом коде, основанном на "
"обратном вызове."

#: ../../library/asyncio-task.rst:1242
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Дополнительную информацию смотрите в документации :meth:`Future."
"add_done_callback`."

#: ../../library/asyncio-task.rst:1247
msgid "Remove *callback* from the callbacks list."
msgstr "Удалите *callback* из списка обратных вызовов."

#: ../../library/asyncio-task.rst:1251
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Дополнительную информацию смотрите в документации :meth:`Future."
"remove_done_callback`."

#: ../../library/asyncio-task.rst:1256
msgid "Return the list of stack frames for this Task."
msgstr "Верните список кадров стека для этой задачи."

#: ../../library/asyncio-task.rst:1258
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Если обернутая сопрограмма не завершена, возвращается стек, в котором она "
"приостановлена. Если сопрограмма завершилась успешно или была отменена, "
"возвращается пустой список. Если сопрограмма была прервана из-за исключения, "
"возвращается список кадров обратной трассировки."

#: ../../library/asyncio-task.rst:1264
msgid "The frames are always ordered from oldest to newest."
msgstr ""
"Кадры всегда располагаются в порядке от самого старого к самому новому."

#: ../../library/asyncio-task.rst:1266
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Для приостановленной сопрограммы возвращается только один кадр стека."

#: ../../library/asyncio-task.rst:1268
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"Необязательный аргумент *limit* устанавливает максимальное количество "
"возвращаемых кадров; по умолчанию возвращаются все доступные кадры. Порядок "
"возвращаемого списка различается в зависимости от того, возвращается ли стек "
"или обратная трассировка: возвращаются самые новые кадры стека, но "
"возвращаются самые старые кадры обратной трассировки. (Это соответствует "
"поведению модуля трассировки.)"

#: ../../library/asyncio-task.rst:1277
msgid "Print the stack or traceback for this Task."
msgstr "Распечатайте стек или обратную трассировку для этой задачи."

#: ../../library/asyncio-task.rst:1279
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Это создает выходные данные, аналогичные выводам модуля трассировки для "
"кадров, полученных с помощью :meth:`get_stack`."

#: ../../library/asyncio-task.rst:1282
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "Аргумент *limit* передается непосредственно в :meth:`get_stack`."

#: ../../library/asyncio-task.rst:1284
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stdout`."
msgstr ""
"Аргумент *file* представляет собой поток ввода-вывода, в который "
"записываются выходные данные; по умолчанию вывод записывается в :data:`sys."
"stdout`."

#: ../../library/asyncio-task.rst:1289
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Верните объект сопрограммы, завернутый в :class:`Task`."

#: ../../library/asyncio-task.rst:1293
msgid ""
"This will return ``None`` for Tasks which have already completed eagerly. "
"See the :ref:`Eager Task Factory <eager-task-factory>`."
msgstr ""
"Это вернет None для задач, которые уже успешно завершены. См. :ref:`Eager "
"Task Factory <eager-task-factory>`."

#: ../../library/asyncio-task.rst:1300
msgid "Newly added eager task execution means result may be ``None``."
msgstr ""
"Недавно добавленное активное выполнение задачи означает, что результат может "
"быть «Нет»."

#: ../../library/asyncio-task.rst:1304
msgid ""
"Return the :class:`contextvars.Context` object associated with the task."
msgstr "Верните объект :class:`contextvars.Context`, связанный с задачей."

#: ../../library/asyncio-task.rst:1311
msgid "Return the name of the Task."
msgstr "Верните имя задачи."

#: ../../library/asyncio-task.rst:1313
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Если задаче явно не присвоено имя, реализация задачи asyncio по умолчанию "
"генерирует имя по умолчанию во время создания экземпляра."

#: ../../library/asyncio-task.rst:1321
msgid "Set the name of the Task."
msgstr "Задайте имя задачи."

#: ../../library/asyncio-task.rst:1323
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"Аргументом *value* может быть любой объект, который затем преобразуется в "
"строку."

#: ../../library/asyncio-task.rst:1326
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"В реализации задачи по умолчанию имя будет видно в выводе :func:`repr` "
"объекта задачи."

#: ../../library/asyncio-task.rst:1333
msgid "Request the Task to be cancelled."
msgstr "Запросить отмену задачи."

#: ../../library/asyncio-task.rst:1335
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""
"Это обеспечивает выдачу исключения :exc:`CancelledError` в обернутую "
"сопрограмму в следующем цикле цикла событий."

#: ../../library/asyncio-task.rst:1338
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged.  Should the coroutine nevertheless decide to "
"suppress the cancellation, it needs to call :meth:`Task.uncancel` in "
"addition to catching the exception."
msgstr ""
"Затем сопрограмма имеет возможность очистить или даже отклонить запрос, "
"подавив исключение с помощью блока :keyword:`try` ... ... ``кроме "
"CancelledError`` ... :keyword:`finally`. Таким образом, в отличие от :meth:"
"`Future.cancel`, :meth:`Task.cancel` не гарантирует, что Задача будет "
"отменена, хотя полное подавление отмены не является распространенным "
"явлением и активно не рекомендуется. Если сопрограмма все же решит подавить "
"отмену, в дополнение к перехвату исключения ей необходимо вызвать :meth:"
"`Task.uncancel`."

#: ../../library/asyncio-task.rst:1348
msgid "Added the *msg* parameter."
msgstr "Добавлен параметр *msg*."

#: ../../library/asyncio-task.rst:1351
msgid "The ``msg`` parameter is propagated from cancelled task to its awaiter."
msgstr "Параметр ``msg`` передается от отмененной задачи к ее ожидающему."

#: ../../library/asyncio-task.rst:1356
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"Следующий пример иллюстрирует, как сопрограммы могут перехватить запрос на "
"отмену:"

#: ../../library/asyncio-task.rst:1359
msgid ""
"async def cancel_me():\n"
"    print('cancel_me(): before sleep')\n"
"\n"
"    try:\n"
"        # Wait for 1 hour\n"
"        await asyncio.sleep(3600)\n"
"    except asyncio.CancelledError:\n"
"        print('cancel_me(): cancel sleep')\n"
"        raise\n"
"    finally:\n"
"        print('cancel_me(): after sleep')\n"
"\n"
"async def main():\n"
"    # Create a \"cancel_me\" Task\n"
"    task = asyncio.create_task(cancel_me())\n"
"\n"
"    # Wait for 1 second\n"
"    await asyncio.sleep(1)\n"
"\n"
"    task.cancel()\n"
"    try:\n"
"        await task\n"
"    except asyncio.CancelledError:\n"
"        print(\"main(): cancel_me is cancelled now\")\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     cancel_me(): before sleep\n"
"#     cancel_me(): cancel sleep\n"
"#     cancel_me(): after sleep\n"
"#     main(): cancel_me is cancelled now"
msgstr ""
"async def cancel_me():\n"
"    print('cancel_me(): before sleep')\n"
"\n"
"    try:\n"
"        # Wait for 1 hour\n"
"        await asyncio.sleep(3600)\n"
"    except asyncio.CancelledError:\n"
"        print('cancel_me(): cancel sleep')\n"
"        raise\n"
"    finally:\n"
"        print('cancel_me(): after sleep')\n"
"\n"
"async def main():\n"
"    # Create a \"cancel_me\" Task\n"
"    task = asyncio.create_task(cancel_me())\n"
"\n"
"    # Wait for 1 second\n"
"    await asyncio.sleep(1)\n"
"\n"
"    task.cancel()\n"
"    try:\n"
"        await task\n"
"    except asyncio.CancelledError:\n"
"        print(\"main(): cancel_me is cancelled now\")\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     cancel_me(): before sleep\n"
"#     cancel_me(): cancel sleep\n"
"#     cancel_me(): after sleep\n"
"#     main(): cancel_me is cancelled now"

#: ../../library/asyncio-task.rst:1395
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Верните ``True``, если Задача *отменена*."

#: ../../library/asyncio-task.rst:1397
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"Задача *отменяется*, когда отмена была запрошена с помощью :meth:`cancel` и "
"обернутая сопрограмма распространила в нее исключение :exc:`CancelledError`."

#: ../../library/asyncio-task.rst:1403
msgid "Decrement the count of cancellation requests to this Task."
msgstr "Уменьшите количество запросов на отмену этой задачи."

#: ../../library/asyncio-task.rst:1405
msgid "Returns the remaining number of cancellation requests."
msgstr "Возвращает оставшееся количество запросов на отмену."

#: ../../library/asyncio-task.rst:1407
msgid ""
"Note that once execution of a cancelled task completed, further calls to :"
"meth:`uncancel` are ineffective."
msgstr ""
"Обратите внимание, что после завершения выполнения отмененной задачи "
"дальнейшие вызовы :meth:`uncancel` становятся неэффективными."

#: ../../library/asyncio-task.rst:1412
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  In particular, if a Task gets successfully uncancelled, this "
"allows for elements of structured concurrency like :ref:`taskgroups` and :"
"func:`asyncio.timeout` to continue running, isolating cancellation to the "
"respective structured block. For example::"
msgstr ""
"Этот метод используется внутренними компонентами asyncio и не "
"предполагается, что он будет использоваться кодом конечного пользователя. В "
"частности, если Задача успешно отменена, это позволяет элементам "
"структурированного параллелизма, таким как :ref:`taskgroups` и :func:"
"`asyncio.timeout`, продолжать работу, изолируя отмену соответствующего "
"структурированного блока. Например::"

#: ../../library/asyncio-task.rst:1419
msgid ""
"async def make_request_with_timeout():\n"
"    try:\n"
"        async with asyncio.timeout(1):\n"
"            # Structured block affected by the timeout:\n"
"            await make_request()\n"
"            await make_another_request()\n"
"    except TimeoutError:\n"
"        log(\"There was a timeout\")\n"
"    # Outer code not affected by the timeout:\n"
"    await unrelated_code()"
msgstr ""
"async def make_request_with_timeout():\n"
"    try:\n"
"        async with asyncio.timeout(1):\n"
"            # Structured block affected by the timeout:\n"
"            await make_request()\n"
"            await make_another_request()\n"
"    except TimeoutError:\n"
"        log(\"There was a timeout\")\n"
"    # Outer code not affected by the timeout:\n"
"    await unrelated_code()"

#: ../../library/asyncio-task.rst:1430
msgid ""
"While the block with ``make_request()`` and ``make_another_request()`` might "
"get cancelled due to the timeout, ``unrelated_code()`` should continue "
"running even in case of the timeout.  This is implemented with :meth:"
"`uncancel`.  :class:`TaskGroup` context managers use :func:`uncancel` in a "
"similar fashion."
msgstr ""
"Хотя блок с ``make_request()`` и ``make_another_request()`` может быть "
"отменен из-за таймаута, ``unrelated_code()`` должен продолжать работу даже в "
"случае таймаута. Это реализуется с помощью :meth:`uncancel`. Контекстные "
"менеджеры :class:`TaskGroup` используют :func:`uncancel` аналогичным образом."

#: ../../library/asyncio-task.rst:1436
msgid ""
"If end-user code is, for some reason, suppressing cancellation by catching :"
"exc:`CancelledError`, it needs to call this method to remove the "
"cancellation state."
msgstr ""
"Если код конечного пользователя по какой-то причине подавляет отмену, "
"перехватывая :exc:`CancelledError`, ему необходимо вызвать этот метод, чтобы "
"удалить состояние отмены."

#: ../../library/asyncio-task.rst:1440
msgid ""
"When this method decrements the cancellation count to zero, the method "
"checks if a previous :meth:`cancel` call had arranged for :exc:"
"`CancelledError` to be thrown into the task. If it hasn't been thrown yet, "
"that arrangement will be rescinded (by resetting the internal "
"``_must_cancel`` flag)."
msgstr ""
"Когда этот метод уменьшает счетчик отмены до нуля, метод проверяет, был ли "
"предыдущий вызов :meth:`cancel` организован для вызова :exc:`CancelledError` "
"в задачу. Если он еще не был выбран, эта договоренность будет отменена "
"(путем сброса внутреннего флага ``_must_cancel``)."

#: ../../library/asyncio-task.rst:1446
msgid "Changed to rescind pending cancellation requests upon reaching zero."
msgstr "Изменено: отменять ожидающие запросы на отмену при достижении нуля."

#: ../../library/asyncio-task.rst:1451
msgid ""
"Return the number of pending cancellation requests to this Task, i.e., the "
"number of calls to :meth:`cancel` less the number of :meth:`uncancel` calls."
msgstr ""
"Возвращает количество ожидающих запросов на отмену для этой задачи, т. е. "
"количество вызовов :meth:`cancel` за вычетом количества вызовов :meth:"
"`uncancel`."

#: ../../library/asyncio-task.rst:1455
msgid ""
"Note that if this number is greater than zero but the Task is still "
"executing, :meth:`cancelled` will still return ``False``. This is because "
"this number can be lowered by calling :meth:`uncancel`, which can lead to "
"the task not being cancelled after all if the cancellation requests go down "
"to zero."
msgstr ""
"Обратите внимание: если это число больше нуля, но Задача все еще "
"выполняется, :meth:`cancelled` всё равно вернет ``False``. Это связано с "
"тем, что это число можно уменьшить, вызвав :meth:`uncancel`, что может "
"привести к тому, что задача вообще не будет отменена, если запросы на отмену "
"упадут до нуля."

#: ../../library/asyncio-task.rst:1461
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  See :meth:`uncancel` for more details."
msgstr ""
"Этот метод используется внутренними компонентами asyncio и не "
"предполагается, что он будет использоваться кодом конечного пользователя. "
"См. :meth:`uncancel` для более подробной информации."
