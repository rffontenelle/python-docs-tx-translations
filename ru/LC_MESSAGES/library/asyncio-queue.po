# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# 256c6f581e7306f8fe260875df9dd39f_33ba001, 2021
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/asyncio-queue.rst:7
msgid "Queues"
msgstr "Очереди"

#: ../../library/asyncio-queue.rst:9
msgid "**Source code:** :source:`Lib/asyncio/queues.py`"
msgstr "**Исходный код:** :source:`Lib/asyncio/queues.py`"

#: ../../library/asyncio-queue.rst:13
msgid ""
"asyncio queues are designed to be similar to classes of the :mod:`queue` "
"module.  Although asyncio queues are not thread-safe, they are designed to "
"be used specifically in async/await code."
msgstr ""
"Очереди asyncio созданы так, чтобы быть похожими на классы модуля :mod:"
"`queue`. Хотя очереди asyncio не являются потокобезопасными, они "
"предназначены для использования специально в коде async/await."

#: ../../library/asyncio-queue.rst:17
msgid ""
"Note that methods of asyncio queues don't have a *timeout* parameter; use :"
"func:`asyncio.wait_for` function to do queue operations with a timeout."
msgstr ""
"Обратите внимание, что методы очередей asyncio не имеют параметра *timeout*; "
"используйте функцию :func:`asyncio.wait_for` для выполнения операций с "
"очередью с таймаутом."

#: ../../library/asyncio-queue.rst:21
msgid "See also the `Examples`_ section below."
msgstr "См. также раздел «Примеры» ниже."

#: ../../library/asyncio-queue.rst:24
msgid "Queue"
msgstr "Очередь"

#: ../../library/asyncio-queue.rst:28
msgid "A first in, first out (FIFO) queue."
msgstr "Очередь «первым пришел — первым обслужен» (FIFO)."

#: ../../library/asyncio-queue.rst:30
msgid ""
"If *maxsize* is less than or equal to zero, the queue size is infinite.  If "
"it is an integer greater than ``0``, then ``await put()`` blocks when the "
"queue reaches *maxsize* until an item is removed by :meth:`get`."
msgstr ""
"Если *maxsize* меньше или равно нулю, размер очереди бесконечен. Если это "
"целое число больше ``0``, то ``await put()`` блокируется, когда очередь "
"достигает *maxsize*, пока элемент не будет удален с помощью :meth:`get`."

#: ../../library/asyncio-queue.rst:35
msgid ""
"Unlike the standard library threading :mod:`queue`, the size of the queue is "
"always known and can be returned by calling the :meth:`qsize` method."
msgstr ""
"В отличие от потоковой обработки стандартной библиотеки :mod:`queue`, размер "
"очереди всегда известен и может быть возвращен путем вызова метода :meth:"
"`qsize`."

#: ../../library/asyncio-queue.rst:39
msgid "Removed the *loop* parameter."
msgstr "Удален параметр *loop*."

#: ../../library/asyncio-queue.rst:43
msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr "Этот класс :ref:`не потокобезопасен <asyncio-multithreading>`."

#: ../../library/asyncio-queue.rst:47
msgid "Number of items allowed in the queue."
msgstr "Количество элементов, разрешенных в очереди."

#: ../../library/asyncio-queue.rst:51
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Верните True, если очередь пуста, и False в противном случае."

#: ../../library/asyncio-queue.rst:55
msgid "Return ``True`` if there are :attr:`maxsize` items in the queue."
msgstr "Верните ``True``, если в очереди есть элементы :attr:`maxsize`."

#: ../../library/asyncio-queue.rst:57
msgid ""
"If the queue was initialized with ``maxsize=0`` (the default), then :meth:"
"`full` never returns ``True``."
msgstr ""
"Если очередь была инициализирована с параметром maxsize=0 (по умолчанию), "
"то :meth:`full` никогда не возвращает ``True``."

#: ../../library/asyncio-queue.rst:62
msgid ""
"Remove and return an item from the queue. If queue is empty, wait until an "
"item is available."
msgstr ""
"Удалить и вернуть элемент из очереди. Если очередь пуста, подождите, пока "
"элемент не станет доступен."

#: ../../library/asyncio-queue.rst:65
msgid ""
"Raises :exc:`QueueShutDown` if the queue has been shut down and is empty, or "
"if the queue has been shut down immediately."
msgstr ""
"Вызывает :exc:`QueueShutDown`, если очередь была закрыта и пуста, или если "
"очередь была закрыта немедленно."

#: ../../library/asyncio-queue.rst:70
msgid ""
"Return an item if one is immediately available, else raise :exc:`QueueEmpty`."
msgstr ""
"Вернуть элемент, если он доступен сразу, иначе поднять :exc:`QueueEmpty`."

#: ../../library/asyncio-queue.rst:75
msgid "Block until all items in the queue have been received and processed."
msgstr ""
"Блокировать до тех пор, пока все элементы в очереди не будут получены и "
"обработаны."

#: ../../library/asyncio-queue.rst:77
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer coroutine calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete.  When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""
"Количество незавершенных задач увеличивается каждый раз, когда элемент "
"добавляется в очередь. Счетчик уменьшается всякий раз, когда сопрограмма "
"потребителя вызывает :meth:`task_done`, чтобы указать, что элемент был "
"получен и вся работа над ним завершена. Когда количество незавершенных задач "
"падает до нуля, :meth:`join` разблокируется."

#: ../../library/asyncio-queue.rst:85
msgid ""
"Put an item into the queue. If the queue is full, wait until a free slot is "
"available before adding the item."
msgstr ""
"Поместите элемент в очередь. Если очередь заполнена, подождите, пока "
"освободится свободное место, прежде чем добавлять элемент."

#: ../../library/asyncio-queue.rst:88
msgid "Raises :exc:`QueueShutDown` if the queue has been shut down."
msgstr "Вызывает :exc:`QueueShutDown`, если очередь отключена."

#: ../../library/asyncio-queue.rst:92
msgid "Put an item into the queue without blocking."
msgstr "Поместите элемент в очередь без блокировки."

#: ../../library/asyncio-queue.rst:94
msgid "If no free slot is immediately available, raise :exc:`QueueFull`."
msgstr "Если в данный момент свободного места нет, поднимите :exc:`QueueFull`."

#: ../../library/asyncio-queue.rst:98
msgid "Return the number of items in the queue."
msgstr "Возвращает количество элементов в очереди."

#: ../../library/asyncio-queue.rst:102
msgid ""
"Shut down the queue, making :meth:`~Queue.get` and :meth:`~Queue.put` raise :"
"exc:`QueueShutDown`."
msgstr ""
"Завершите работу очереди, заставив :meth:`~Queue.get` и :meth:`~Queue.put` "
"поднять :exc:`QueueShutDown`."

#: ../../library/asyncio-queue.rst:105
msgid ""
"By default, :meth:`~Queue.get` on a shut down queue will only raise once the "
"queue is empty. Set *immediate* to true to make :meth:`~Queue.get` raise "
"immediately instead."
msgstr ""
"По умолчанию :meth:`~Queue.get` в очереди выключения активируется только "
"тогда, когда очередь пуста. Установите для параметра *immediate* значение "
"true, чтобы вместо этого немедленно вызвать :meth:`~Queue.get`."

#: ../../library/asyncio-queue.rst:109
msgid ""
"All blocked callers of :meth:`~Queue.put` and :meth:`~Queue.get` will be "
"unblocked. If *immediate* is true, a task will be marked as done for each "
"remaining item in the queue, which may unblock callers of :meth:`~Queue."
"join`."
msgstr ""
"Все заблокированные вызывающие :meth:`~Queue.put` и :meth:`~Queue.get` будут "
"разблокированы. Если *immediate* имеет значение true, задача будет помечена "
"как выполненная для каждого оставшегося элемента в очереди, что может "
"разблокировать вызывающих :meth:`~Queue.join`."

#: ../../library/asyncio-queue.rst:118
msgid "Indicate that a formerly enqueued work item is complete."
msgstr ""

#: ../../library/asyncio-queue.rst:120
msgid ""
"Used by queue consumers. For each :meth:`~Queue.get` used to fetch a work "
"item, a subsequent call to :meth:`task_done` tells the queue that the "
"processing on the work item is complete."
msgstr ""

#: ../../library/asyncio-queue.rst:124
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Если :meth:`join` в данный момент блокируется, оно возобновится, когда все "
"элементы будут обработаны (это означает, что вызов :meth:`task_done` был "
"получен для каждого элемента, который был :meth:`~Queue.put` в очередь)."

#: ../../library/asyncio-queue.rst:129
msgid ""
"``shutdown(immediate=True)`` calls :meth:`task_done` for each remaining item "
"in the queue."
msgstr ""
"``shutdown(immediate=True)`` вызывает :meth:`task_done` для каждого "
"оставшегося элемента в очереди."

#: ../../library/asyncio-queue.rst:132
msgid ""
"Raises :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Вызывает :exc:`ValueError`, если вызывается больше раз, чем было помещено в "
"очередь элементов."

#: ../../library/asyncio-queue.rst:137
msgid "Priority Queue"
msgstr "Приоритетная очередь"

#: ../../library/asyncio-queue.rst:141
msgid ""
"A variant of :class:`Queue`; retrieves entries in priority order (lowest "
"first)."
msgstr ""
"Вариант :class:`Queue`; извлекает записи в порядке приоритета (сначала самый "
"низкий)."

#: ../../library/asyncio-queue.rst:144
msgid "Entries are typically tuples of the form ``(priority_number, data)``."
msgstr ""
"Записи обычно представляют собой кортежи формы ``(priority_number, data)``."

#: ../../library/asyncio-queue.rst:149
msgid "LIFO Queue"
msgstr "Очередь LIFO"

#: ../../library/asyncio-queue.rst:153
msgid ""
"A variant of :class:`Queue` that retrieves most recently added entries first "
"(last in, first out)."
msgstr ""
"Вариант :class:`Queue`, который сначала извлекает самые последние "
"добавленные записи (последними вошли, первыми вышли)."

#: ../../library/asyncio-queue.rst:158
msgid "Exceptions"
msgstr "Исключения"

#: ../../library/asyncio-queue.rst:162
msgid ""
"This exception is raised when the :meth:`~Queue.get_nowait` method is called "
"on an empty queue."
msgstr ""
"Это исключение возникает, когда метод :meth:`~Queue.get_nowait` вызывается в "
"пустой очереди."

#: ../../library/asyncio-queue.rst:168
msgid ""
"Exception raised when the :meth:`~Queue.put_nowait` method is called on a "
"queue that has reached its *maxsize*."
msgstr ""
"Исключение возникает, когда метод :meth:`~Queue.put_nowait` вызывается для "
"очереди, достигшей своего *максимального размера*."

#: ../../library/asyncio-queue.rst:174
msgid ""
"Exception raised when :meth:`~Queue.put` or :meth:`~Queue.get` is called on "
"a queue which has been shut down."
msgstr ""
"Исключение возникает, когда :meth:`~Queue.put` или :meth:`~Queue.get` "
"вызывается в очереди, которая была отключена."

#: ../../library/asyncio-queue.rst:181
msgid "Examples"
msgstr "Примеры"

#: ../../library/asyncio-queue.rst:185
msgid ""
"Queues can be used to distribute workload between several concurrent tasks::"
msgstr ""
"Очереди можно использовать для распределения рабочей нагрузки между "
"несколькими одновременными задачами:"

#: ../../library/asyncio-queue.rst:188
msgid ""
"import asyncio\n"
"import random\n"
"import time\n"
"\n"
"\n"
"async def worker(name, queue):\n"
"    while True:\n"
"        # Get a \"work item\" out of the queue.\n"
"        sleep_for = await queue.get()\n"
"\n"
"        # Sleep for the \"sleep_for\" seconds.\n"
"        await asyncio.sleep(sleep_for)\n"
"\n"
"        # Notify the queue that the \"work item\" has been processed.\n"
"        queue.task_done()\n"
"\n"
"        print(f'{name} has slept for {sleep_for:.2f} seconds')\n"
"\n"
"\n"
"async def main():\n"
"    # Create a queue that we will use to store our \"workload\".\n"
"    queue = asyncio.Queue()\n"
"\n"
"    # Generate random timings and put them into the queue.\n"
"    total_sleep_time = 0\n"
"    for _ in range(20):\n"
"        sleep_for = random.uniform(0.05, 1.0)\n"
"        total_sleep_time += sleep_for\n"
"        queue.put_nowait(sleep_for)\n"
"\n"
"    # Create three worker tasks to process the queue concurrently.\n"
"    tasks = []\n"
"    for i in range(3):\n"
"        task = asyncio.create_task(worker(f'worker-{i}', queue))\n"
"        tasks.append(task)\n"
"\n"
"    # Wait until the queue is fully processed.\n"
"    started_at = time.monotonic()\n"
"    await queue.join()\n"
"    total_slept_for = time.monotonic() - started_at\n"
"\n"
"    # Cancel our worker tasks.\n"
"    for task in tasks:\n"
"        task.cancel()\n"
"    # Wait until all worker tasks are cancelled.\n"
"    await asyncio.gather(*tasks, return_exceptions=True)\n"
"\n"
"    print('====')\n"
"    print(f'3 workers slept in parallel for {total_slept_for:.2f} seconds')\n"
"    print(f'total expected sleep time: {total_sleep_time:.2f} seconds')\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import random\n"
"import time\n"
"\n"
"\n"
"async def worker(name, queue):\n"
"    while True:\n"
"        # Get a \"work item\" out of the queue.\n"
"        sleep_for = await queue.get()\n"
"\n"
"        # Sleep for the \"sleep_for\" seconds.\n"
"        await asyncio.sleep(sleep_for)\n"
"\n"
"        # Notify the queue that the \"work item\" has been processed.\n"
"        queue.task_done()\n"
"\n"
"        print(f'{name} has slept for {sleep_for:.2f} seconds')\n"
"\n"
"\n"
"async def main():\n"
"    # Create a queue that we will use to store our \"workload\".\n"
"    queue = asyncio.Queue()\n"
"\n"
"    # Generate random timings and put them into the queue.\n"
"    total_sleep_time = 0\n"
"    for _ in range(20):\n"
"        sleep_for = random.uniform(0.05, 1.0)\n"
"        total_sleep_time += sleep_for\n"
"        queue.put_nowait(sleep_for)\n"
"\n"
"    # Create three worker tasks to process the queue concurrently.\n"
"    tasks = []\n"
"    for i in range(3):\n"
"        task = asyncio.create_task(worker(f'worker-{i}', queue))\n"
"        tasks.append(task)\n"
"\n"
"    # Wait until the queue is fully processed.\n"
"    started_at = time.monotonic()\n"
"    await queue.join()\n"
"    total_slept_for = time.monotonic() - started_at\n"
"\n"
"    # Cancel our worker tasks.\n"
"    for task in tasks:\n"
"        task.cancel()\n"
"    # Wait until all worker tasks are cancelled.\n"
"    await asyncio.gather(*tasks, return_exceptions=True)\n"
"\n"
"    print('====')\n"
"    print(f'3 workers slept in parallel for {total_slept_for:.2f} seconds')\n"
"    print(f'total expected sleep time: {total_sleep_time:.2f} seconds')\n"
"\n"
"\n"
"asyncio.run(main())"
