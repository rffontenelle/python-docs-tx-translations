# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-25 14:54+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/asyncio-eventloop.rst:8
msgid "Event Loop"
msgstr "Цикл событий"

#: ../../library/asyncio-eventloop.rst:10
msgid ""
"**Source code:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"
msgstr ""
"**Исходный код:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"

#: ../../library/asyncio-eventloop.rst:16
msgid "Preface"
msgstr "Введение"

#: ../../library/asyncio-eventloop.rst:17
msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""
"Цикл событий — это ядро ​​каждого асинхронного приложения. Циклы событий "
"запускают асинхронные задачи и обратные вызовы, выполняют сетевые операции "
"ввода-вывода и запускают подпроцессы."

#: ../../library/asyncio-eventloop.rst:21
msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to reference "
"the loop object or call its methods.  This section is intended mostly for "
"authors of lower-level code, libraries, and frameworks, who need finer "
"control over the event loop behavior."
msgstr ""
"Разработчикам приложений обычно следует использовать функции asyncio "
"высокого уровня, такие как :func:`asyncio.run`, и им редко приходится "
"ссылаться на объект цикла или вызывать его методы. Этот раздел предназначен "
"в основном для авторов низкоуровневого кода, библиотек и фреймворков, "
"которым требуется более тонкий контроль над поведением цикла событий."

#: ../../library/asyncio-eventloop.rst:28
msgid "Obtaining the Event Loop"
msgstr "Получение цикла событий"

#: ../../library/asyncio-eventloop.rst:29
msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr ""
"Следующие низкоуровневые функции можно использовать для получения, установки "
"или создания цикла событий:"

#: ../../library/asyncio-eventloop.rst:34
msgid "Return the running event loop in the current OS thread."
msgstr "Верните текущий цикл событий в текущий поток ОС."

#: ../../library/asyncio-eventloop.rst:36
msgid "Raise a :exc:`RuntimeError` if there is no running event loop."
msgstr "Вызовите :exc:`RuntimeError`, если нет текущего цикла событий."

#: ../../library/asyncio-eventloop.rst:38
msgid "This function can only be called from a coroutine or a callback."
msgstr "Эту функцию можно вызвать только из сопрограммы или обратного вызова."

#: ../../library/asyncio-eventloop.rst:44
msgid "Get the current event loop."
msgstr "Получить текущий цикл событий."

#: ../../library/asyncio-eventloop.rst:46
msgid ""
"When called from a coroutine or a callback (e.g. scheduled with call_soon or "
"similar API), this function will always return the running event loop."
msgstr ""
"При вызове из сопрограммы или обратного вызова (например, запланированного с "
"помощью call_soon или аналогичного API) эта функция всегда будет возвращать "
"текущий цикл событий."

#: ../../library/asyncio-eventloop.rst:50
msgid ""
"If there is no running event loop set, the function will return the result "
"of the ``get_event_loop_policy().get_event_loop()`` call."
msgstr ""
"Если не установлен текущий цикл событий, функция вернет результат вызова "
"``get_event_loop_policy().get_event_loop()``."

#: ../../library/asyncio-eventloop.rst:53
msgid ""
"Because this function has rather complex behavior (especially when custom "
"event loop policies are in use), using the :func:`get_running_loop` function "
"is preferred to :func:`get_event_loop` in coroutines and callbacks."
msgstr ""
"Поскольку эта функция имеет довольно сложное поведение (особенно когда "
"используются пользовательские политики цикла событий), использование "
"функции :func:`get_running_loop` предпочтительнее, чем :func:"
"`get_event_loop` в сопрограммах и обратных вызовах."

#: ../../library/asyncio-eventloop.rst:58
msgid ""
"As noted above, consider using the higher-level :func:`asyncio.run` "
"function, instead of using these lower level functions to manually create "
"and close an event loop."
msgstr ""
"Как отмечалось выше, рассмотрите возможность использования функции :func:"
"`asyncio.run` более высокого уровня вместо использования этих функций более "
"низкого уровня для ручного создания и закрытия цикла событий."

#: ../../library/asyncio-eventloop.rst:62
msgid ""
"Deprecation warning is emitted if there is no current event loop. In some "
"future Python release this will become an error."
msgstr ""
"Предупреждение об устаревании выдается, если текущий цикл событий "
"отсутствует. В некоторых будущих выпусках Python это станет ошибкой."

#: ../../library/asyncio-eventloop.rst:68
msgid "Set *loop* as the current event loop for the current OS thread."
msgstr ""
"Установите *loop* в качестве текущего цикла событий для текущего потока ОС."

#: ../../library/asyncio-eventloop.rst:72
msgid "Create and return a new event loop object."
msgstr "Создайте и верните новый объект цикла событий."

#: ../../library/asyncio-eventloop.rst:74
msgid ""
"Note that the behaviour of :func:`get_event_loop`, :func:`set_event_loop`, "
"and :func:`new_event_loop` functions can be altered by :ref:`setting a "
"custom event loop policy <asyncio-policies>`."
msgstr ""
"Обратите внимание, что поведение функций :func:`get_event_loop`, :func:"
"`set_event_loop` и :func:`new_event_loop` можно изменить, :ref:`устанавливая "
"пользовательскую политику цикла событий <asyncio-policies>`."

#: ../../library/asyncio-eventloop.rst:80
msgid "Contents"
msgstr " Содержание"

#: ../../library/asyncio-eventloop.rst:81
msgid "This documentation page contains the following sections:"
msgstr "Эта страница документации содержит следующие разделы:"

#: ../../library/asyncio-eventloop.rst:83
msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr ""
"Раздел «Методы цикла событий» представляет собой справочную документацию по "
"API цикла событий;"

#: ../../library/asyncio-eventloop.rst:86
msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and :class:"
"`TimerHandle` instances which are returned from scheduling methods such as :"
"meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"В разделе `Callback Handles`_ описаны экземпляры :class:`Handle` и :class:"
"`TimerHandle`, которые возвращаются из методов планирования, таких как :meth:"
"`loop.call_soon` и :meth:`loop.call_later`;"

#: ../../library/asyncio-eventloop.rst:90
msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""
"Типы документов раздела `Server Objects`_, возвращаемые методами цикла "
"событий, такими как :meth:`loop.create_server`;"

#: ../../library/asyncio-eventloop.rst:93
msgid ""
"The `Event Loop Implementations`_ section documents the :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"В разделе `Реализации цикла событий`_ описаны классы :class:"
"`SelectorEventLoop` и :class:`ProactorEventLoop`;"

#: ../../library/asyncio-eventloop.rst:96
msgid ""
"The `Examples`_ section showcases how to work with some event loop APIs."
msgstr ""
"В разделе «Примеры» показано, как работать с некоторыми API-интерфейсами "
"цикла событий."

#: ../../library/asyncio-eventloop.rst:103
msgid "Event Loop Methods"
msgstr "Методы цикла событий"

#: ../../library/asyncio-eventloop.rst:105
msgid "Event loops have **low-level** APIs for the following:"
msgstr "Циклы событий имеют **низкоуровневые** API для следующих целей:"

#: ../../library/asyncio-eventloop.rst:113
msgid "Running and stopping the loop"
msgstr "Запуск и остановка цикла"

#: ../../library/asyncio-eventloop.rst:117
msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr ""
"Выполнять до тех пор, пока *future* (экземпляр :class:`Future`) не "
"завершится."

#: ../../library/asyncio-eventloop.rst:120
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly "
"scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"Если аргументом является :ref:`объект сопрограммы <coroutine>`, он неявно "
"запланирован для запуска как :class:`asyncio.Task`."

#: ../../library/asyncio-eventloop.rst:123
msgid "Return the Future's result or raise its exception."
msgstr "Верните результат Future или вызовите его исключение."

#: ../../library/asyncio-eventloop.rst:127
msgid "Run the event loop until :meth:`stop` is called."
msgstr "Запускайте цикл событий до тех пор, пока не будет вызван :meth:`stop`."

#: ../../library/asyncio-eventloop.rst:129
msgid ""
"If :meth:`stop` is called before :meth:`run_forever` is called, the loop "
"will poll the I/O selector once with a timeout of zero, run all callbacks "
"scheduled in response to I/O events (and those that were already scheduled), "
"and then exit."
msgstr ""
"Если :meth:`stop` вызывается до вызова :meth:`run_forever`, цикл один раз "
"опрашивает селектор ввода-вывода с нулевым тайм-аутом, запускает все "
"запланированные обратные вызовы в ответ на события ввода-вывода (и те, "
"которые уже запланированы), а затем выйти."

#: ../../library/asyncio-eventloop.rst:134
msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they "
"will run the next time :meth:`run_forever` or :meth:`run_until_complete` is "
"called."
msgstr ""
"Если :meth:`stop` вызывается во время работы :meth:`run_forever`, цикл "
"выполнит текущий пакет обратных вызовов и затем завершит работу. Обратите "
"внимание, что новые обратные вызовы, запланированные обратными вызовами, в "
"этом случае не будут выполняться; вместо этого они будут запущены при "
"следующем вызове :meth:`run_forever` или :meth:`run_until_complete`."

#: ../../library/asyncio-eventloop.rst:142
msgid "Stop the event loop."
msgstr "Остановите цикл событий."

#: ../../library/asyncio-eventloop.rst:146
msgid "Return ``True`` if the event loop is currently running."
msgstr ""
"Верните ``True``, если цикл обработки событий в данный момент выполняется."

#: ../../library/asyncio-eventloop.rst:150
msgid "Return ``True`` if the event loop was closed."
msgstr "Верните True, если цикл обработки событий был закрыт."

#: ../../library/asyncio-eventloop.rst:154
msgid "Close the event loop."
msgstr "Закройте цикл событий."

#: ../../library/asyncio-eventloop.rst:156
msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr ""
"Цикл не должен выполняться при вызове этой функции. Любые ожидающие обратные "
"вызовы будут отменены."

#: ../../library/asyncio-eventloop.rst:159
msgid ""
"This method clears all queues and shuts down the executor, but does not wait "
"for the executor to finish."
msgstr ""
"Этот метод очищает все очереди и завершает работу исполнителя, но не "
"дожидается его завершения."

#: ../../library/asyncio-eventloop.rst:162
msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr ""
"Этот метод идемпотентен и необратим. Никакие другие методы не должны "
"вызываться после закрытия цикла обработки событий."

#: ../../library/asyncio-eventloop.rst:167
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose` call.  After calling this method, the event "
"loop will issue a warning if a new asynchronous generator is iterated. This "
"should be used to reliably finalize all scheduled asynchronous generators."
msgstr ""
"Запланируйте закрытие всех открытых в данный момент объектов асинхронного "
"генератора с помощью вызова :meth:`~agen.aclose`. После вызова этого метода "
"цикл событий выдаст предупреждение, если будет запущен новый асинхронный "
"генератор. Это следует использовать для надежной финализации всех "
"запланированных асинхронных генераторов."

#: ../../library/asyncio-eventloop.rst:173
msgid ""
"Note that there is no need to call this function when :func:`asyncio.run` is "
"used."
msgstr ""
"Обратите внимание, что нет необходимости вызывать эту функцию, когда "
"используется :func:`asyncio.run`."

#: ../../library/asyncio-eventloop.rst:176
#: ../../library/asyncio-eventloop.rst:1253
#: ../../library/asyncio-eventloop.rst:1671
msgid "Example::"
msgstr "Пример::"

#: ../../library/asyncio-eventloop.rst:178
msgid ""
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.run_until_complete(loop.shutdown_asyncgens())\n"
"    loop.close()"
msgstr ""
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.run_until_complete(loop.shutdown_asyncgens())\n"
"    loop.close()"

#: ../../library/asyncio-eventloop.rst:188
msgid ""
"Schedule the closure of the default executor and wait for it to join all of "
"the threads in the :class:`~concurrent.futures.ThreadPoolExecutor`. Once "
"this method has been called, using the default executor with :meth:`loop."
"run_in_executor` will raise a :exc:`RuntimeError`."
msgstr ""
"Запланируйте закрытие исполнителя по умолчанию и подождите, пока он "
"присоединится ко всем потокам в :class:`~concurrent.futures."
"ThreadPoolExecutor`. После вызова этого метода использование исполнителя по "
"умолчанию с :meth:`loop.run_in_executor` вызовет :exc:`RuntimeError`."

#: ../../library/asyncio-eventloop.rst:194
msgid ""
"The *timeout* parameter specifies the amount of time (in :class:`float` "
"seconds) the executor will be given to finish joining. With the default, "
"``None``, the executor is allowed an unlimited amount of time."
msgstr ""
"Параметр *timeout* указывает количество времени (в секундах), которое будет "
"предоставлено исполнителю для завершения присоединения. При значении по "
"умолчанию «Нет» исполнителю разрешено неограниченное количество времени."

#: ../../library/asyncio-eventloop.rst:199
msgid ""
"If the *timeout* is reached, a :exc:`RuntimeWarning` is emitted and the "
"default executor is terminated without waiting for its threads to finish "
"joining."
msgstr ""
"Если *тайм-аут* достигнут, выдается :exc:`RuntimeWarning` и исполнитель по "
"умолчанию завершается, не дожидаясь завершения соединения своих потоков."

#: ../../library/asyncio-eventloop.rst:205
msgid ""
"Do not call this method when using :func:`asyncio.run`, as the latter "
"handles default executor shutdown automatically."
msgstr ""
"Не вызывайте этот метод при использовании :func:`asyncio.run`, поскольку "
"последний автоматически обрабатывает завершение работы исполнителя по "
"умолчанию."

#: ../../library/asyncio-eventloop.rst:210
msgid "Added the *timeout* parameter."
msgstr "Добавлен параметр *timeout*."

#: ../../library/asyncio-eventloop.rst:214
msgid "Scheduling callbacks"
msgstr "Планирование обратных вызовов"

#: ../../library/asyncio-eventloop.rst:218
msgid ""
"Schedule the *callback* :term:`callback` to be called with *args* arguments "
"at the next iteration of the event loop."
msgstr ""
"Запланируйте вызов *callback* :term:`callback` с аргументами *args* на "
"следующей итерации цикла обработки событий."

#: ../../library/asyncio-eventloop.rst:221
msgid ""
"Return an instance of :class:`asyncio.Handle`, which can be used later to "
"cancel the callback."
msgstr ""
"Верните экземпляр :class:`asyncio.Handle`, который можно использовать позже "
"для отмены обратного вызова."

#: ../../library/asyncio-eventloop.rst:224
msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr ""
"Обратные вызовы вызываются в том порядке, в котором они зарегистрированы. "
"Каждый обратный вызов будет вызван ровно один раз."

#: ../../library/asyncio-eventloop.rst:227
msgid ""
"The optional keyword-only *context* argument specifies a custom :class:"
"`contextvars.Context` for the *callback* to run in. Callbacks use the "
"current context when no *context* is provided."
msgstr ""
"Необязательный аргумент *context*, содержащий только ключевые слова, "
"указывает пользовательский :class:`contextvars.Context` для выполнения "
"*обратного вызова*. Обратные вызовы используют текущий контекст, если "
"*context* не указан."

#: ../../library/asyncio-eventloop.rst:231
msgid "Unlike :meth:`call_soon_threadsafe`, this method is not thread-safe."
msgstr ""
"В отличие от :meth:`call_soon_threadsafe`, этот метод не является "
"потокобезопасным."

#: ../../library/asyncio-eventloop.rst:235
msgid ""
"A thread-safe variant of :meth:`call_soon`. When scheduling callbacks from "
"another thread, this function *must* be used, since :meth:`call_soon` is not "
"thread-safe."
msgstr ""
"Потокобезопасный вариант :meth:`call_soon`. При планировании обратных "
"вызовов из другого потока эта функция *должна* использоваться, поскольку :"
"meth:`call_soon` не является потокобезопасным."

#: ../../library/asyncio-eventloop.rst:239
msgid ""
"Raises :exc:`RuntimeError` if called on a loop that's been closed. This can "
"happen on a secondary thread when the main application is shutting down."
msgstr ""
"Вызывает :exc:`RuntimeError`, если вызывается в закрытом цикле. Это может "
"произойти во вторичном потоке, когда основное приложение завершает работу."

#: ../../library/asyncio-eventloop.rst:243
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"См. раздел документации о :ref:`параллелизме и многопоточности <asyncio-"
"multithreading>`."

#: ../../library/asyncio-eventloop.rst:246
#: ../../library/asyncio-eventloop.rst:296
#: ../../library/asyncio-eventloop.rst:316
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"Был добавлен параметр *context*, доступный только по ключевым словам. См. :"
"pep:`567` для более подробной информации."

#: ../../library/asyncio-eventloop.rst:254
msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""
"Большинство функций планирования :mod:`asyncio` не позволяют передавать "
"аргументы ключевых слов. Для этого используйте :func:`functools.partial`::"

#: ../../library/asyncio-eventloop.rst:257
msgid ""
"# will schedule \"print(\"Hello\", flush=True)\"\n"
"loop.call_soon(\n"
"    functools.partial(print, \"Hello\", flush=True))"
msgstr ""
"# will schedule \"print(\"Hello\", flush=True)\"\n"
"loop.call_soon(\n"
"    functools.partial(print, \"Hello\", flush=True))"

#: ../../library/asyncio-eventloop.rst:261
msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""
"Использование частичных объектов обычно более удобно, чем использование "
"лямбда-выражений, поскольку asyncio может лучше отображать частичные объекты "
"в сообщениях отладки и ошибках."

#: ../../library/asyncio-eventloop.rst:269
msgid "Scheduling delayed callbacks"
msgstr "Планирование отложенных обратных вызовов"

#: ../../library/asyncio-eventloop.rst:271
msgid ""
"Event loop provides mechanisms to schedule callback functions to be called "
"at some point in the future.  Event loop uses monotonic clocks to track time."
msgstr ""
"Цикл событий предоставляет механизмы для планирования вызова функций "
"обратного вызова в определенный момент в будущем. Цикл событий использует "
"монотонные часы для отслеживания времени."

#: ../../library/asyncio-eventloop.rst:278
msgid ""
"Schedule *callback* to be called after the given *delay* number of seconds "
"(can be either an int or a float)."
msgstr ""
"Запланируйте вызов *callback* через заданное *delay* количество секунд "
"(может быть как int, так и с плавающей запятой)."

#: ../../library/asyncio-eventloop.rst:281
#: ../../library/asyncio-eventloop.rst:313
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used to "
"cancel the callback."
msgstr ""
"Возвращается экземпляр :class:`asyncio.TimerHandle`, который можно "
"использовать для отмены обратного вызова."

#: ../../library/asyncio-eventloop.rst:284
msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled for "
"exactly the same time, the order in which they are called is undefined."
msgstr ""
"*callback* будет вызван ровно один раз. Если два обратных вызова "
"запланированы на одно и то же время, порядок их вызова не определен."

#: ../../library/asyncio-eventloop.rst:288
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use :"
"func:`functools.partial`."
msgstr ""
"Необязательный позиционный *args* будет передан обратному вызову при его "
"вызове. Если вы хотите, чтобы обратный вызов вызывался с ключевыми словами, "
"используйте :func:`functools.partial`."

#: ../../library/asyncio-eventloop.rst:292
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Необязательный аргумент *context*, содержащий только ключевые слова, "
"позволяет указать собственный :class:`contextvars.Context` для выполнения "
"*обратного вызова*. Текущий контекст используется, когда *context* не указан."

#: ../../library/asyncio-eventloop.rst:300
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"*delay* could not exceed one day. This has been fixed in Python 3.8."
msgstr ""
"В Python 3.7 и более ранних версиях с реализацией цикла событий по умолчанию "
"*задержка* не могла превышать одного дня. Это было исправлено в Python 3.8."

#: ../../library/asyncio-eventloop.rst:307
msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* (an "
"int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"Запланируйте вызов *callback* в заданную абсолютную временную метку *when* "
"(int или float), используя ту же ссылку на время, что и :meth:`loop.time`."

#: ../../library/asyncio-eventloop.rst:311
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "Поведение этого метода такое же, как и у :meth:`call_later`."

#: ../../library/asyncio-eventloop.rst:320
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"difference between *when* and the current time could not exceed one day.  "
"This has been fixed in Python 3.8."
msgstr ""
"В Python 3.7 и более ранних версиях с реализацией цикла событий по умолчанию "
"разница между *when* и текущим временем не могла превышать одного дня. Это "
"было исправлено в Python 3.8."

#: ../../library/asyncio-eventloop.rst:327
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal monotonic clock."
msgstr ""
"Возвращает текущее время в виде значения :class:`float` в соответствии с "
"внутренними монотонными часами цикла событий."

#: ../../library/asyncio-eventloop.rst:331
msgid ""
"In Python 3.7 and earlier timeouts (relative *delay* or absolute *when*) "
"should not exceed one day.  This has been fixed in Python 3.8."
msgstr ""
"В Python 3.7 и более ранних версиях таймауты (относительная *задержка* или "
"абсолютные *когда*) не должны превышать один день. Это было исправлено в "
"Python 3.8."

#: ../../library/asyncio-eventloop.rst:337
msgid "The :func:`asyncio.sleep` function."
msgstr "Функция :func:`asyncio.sleep`"

#: ../../library/asyncio-eventloop.rst:341
msgid "Creating Futures and Tasks"
msgstr "Создание будущего и задач"

#: ../../library/asyncio-eventloop.rst:345
msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr ""
"Создайте объект :class:`asyncio.Future`, прикрепленный к циклу событий."

#: ../../library/asyncio-eventloop.rst:347
msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future object "
"(with better performance or instrumentation)."
msgstr ""
"Это предпочтительный способ создания фьючерсов в asyncio. Это позволяет "
"сторонним циклам событий предоставлять альтернативные реализации объекта "
"Future (с лучшей производительностью или инструментированием)."

#: ../../library/asyncio-eventloop.rst:355
msgid ""
"Schedule the execution of :ref:`coroutine <coroutine>` *coro*. Return a :"
"class:`Task` object."
msgstr ""
"Запланируйте выполнение :ref:`coroutine <coroutine>` *coro*. Верните объект :"
"class:`Task`."

#: ../../library/asyncio-eventloop.rst:358
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of :class:"
"`Task`."
msgstr ""
"Сторонние циклы событий могут использовать собственный подкласс :class:"
"`Task` для обеспечения совместимости. В этом случае тип результата является "
"подклассом :class:`Task`."

#: ../../library/asyncio-eventloop.rst:362
msgid ""
"If the *name* argument is provided and not ``None``, it is set as the name "
"of the task using :meth:`Task.set_name`."
msgstr ""
"Если указан аргумент *name*, а не ``None``, он устанавливается как имя "
"задачи с использованием :meth:`Task.set_name`."

#: ../../library/asyncio-eventloop.rst:365
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"Необязательный аргумент *context*, содержащий только ключевые слова, "
"позволяет указать собственный :class:`contextvars.Context` для запуска "
"*coro*. Текущая копия контекста создается, когда *context* не указан."

#: ../../library/asyncio-eventloop.rst:369
msgid "Added the *name* parameter."
msgstr "Добавлен параметр *имя*."

#: ../../library/asyncio-eventloop.rst:372
msgid "Added the *context* parameter."
msgstr "Добавлен параметр *context*."

#: ../../library/asyncio-eventloop.rst:377
msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr ""
"Установите фабрику задач, которая будет использоваться :meth:`loop."
"create_task`."

#: ../../library/asyncio-eventloop.rst:380
msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise, "
"*factory* must be a *callable* with the signature matching ``(loop, coro, "
"context=None)``, where *loop* is a reference to the active event loop, and "
"*coro* is a coroutine object.  The callable must return a :class:`asyncio."
"Future`-compatible object."
msgstr ""
"Если *factory* имеет значение ``None``, будет установлена ​​фабрика задач по "
"умолчанию. В противном случае *фабрика* должна быть *вызываемой* с "
"сигнатурой, соответствующей ``(loop, coro, context=None)``, где *loop* — это "
"ссылка на активный цикл событий, а *coro* — объект сопрограммы. . Вызываемый "
"объект должен возвращать объект, совместимый с :class:`asyncio.Future`."

#: ../../library/asyncio-eventloop.rst:388
msgid "Return a task factory or ``None`` if the default one is in use."
msgstr ""
"Возвращает фабрику задач или None, если используется фабрика по умолчанию."

#: ../../library/asyncio-eventloop.rst:392
msgid "Opening network connections"
msgstr "Открытие сетевых подключений"

#: ../../library/asyncio-eventloop.rst:403
msgid ""
"Open a streaming transport connection to a given address specified by *host* "
"and *port*."
msgstr ""
"Откройте потоковое транспортное соединение по заданному адресу, указанному "
"*host* и *port*."

#: ../../library/asyncio-eventloop.rst:406
msgid ""
"The socket family can be either :py:const:`~socket.AF_INET` or :py:const:"
"`~socket.AF_INET6` depending on *host* (or the *family* argument, if "
"provided)."
msgstr ""
"Семейство сокетов может быть либо :py:const:`~socket.AF_INET`, либо :py:"
"const:`~socket.AF_INET6` в зависимости от *host* (или аргумента *family*, "
"если он указан)."

#: ../../library/asyncio-eventloop.rst:410
msgid "The socket type will be :py:const:`~socket.SOCK_STREAM`."
msgstr "Тип сокета будет :py:const:`~socket.SOCK_STREAM`."

#: ../../library/asyncio-eventloop.rst:412
#: ../../library/asyncio-eventloop.rst:1164
#: ../../library/asyncio-eventloop.rst:1180
msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* должен быть вызываемым объектом, возвращающим реализацию "
"протокола asyncio <asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:415
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""
"Этот метод попытается установить соединение в фоновом режиме. В случае "
"успеха он возвращает пару ``(транспорт, протокол)``."

#: ../../library/asyncio-eventloop.rst:418
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "Хронологический синопсис основной операции следующий:"

#: ../../library/asyncio-eventloop.rst:420
msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` is "
"created for it."
msgstr ""
"Соединение устанавливается и для него создается транспорт <asyncio-"
"transport>`."

#: ../../library/asyncio-eventloop.rst:423
msgid ""
"*protocol_factory* is called without arguments and is expected to return a :"
"ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* вызывается без аргументов и, как ожидается, вернет "
"экземпляр протокола <asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:426
msgid ""
"The protocol instance is coupled with the transport by calling its :meth:"
"`~BaseProtocol.connection_made` method."
msgstr ""
"Экземпляр протокола соединяется с транспортом путем вызова его метода :meth:"
"`~BaseProtocol.connection_made`."

#: ../../library/asyncio-eventloop.rst:429
msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr "В случае успеха возвращается кортеж ``(транспорт, протокол)``."

#: ../../library/asyncio-eventloop.rst:431
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr ""
"Созданный транспорт представляет собой двунаправленный поток, зависящий от "
"реализации."

#: ../../library/asyncio-eventloop.rst:434
#: ../../library/asyncio-eventloop.rst:566
msgid "Other arguments:"
msgstr "Другие аргументы:"

#: ../../library/asyncio-eventloop.rst:436
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is :const:"
"`True`, a default context returned from :func:`ssl.create_default_context` "
"is used."
msgstr ""
"*ssl*: если задано и не является ложным, создается транспорт SSL/TLS (по "
"умолчанию создается простой транспорт TCP). Если *ssl* является объектом :"
"class:`ssl.SSLContext`, этот контекст используется для создания транспорта; "
"если *ssl* имеет значение :const:`True`, используется контекст по умолчанию, "
"возвращаемый из :func:`ssl.create_default_context`."

#: ../../library/asyncio-eventloop.rst:442
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`SSL/TLS security considerations <ssl-security>`"

#: ../../library/asyncio-eventloop.rst:444
msgid ""
"*server_hostname* sets or overrides the hostname that the target server's "
"certificate will be matched against.  Should only be passed if *ssl* is not "
"``None``.  By default the value of the *host* argument is used.  If *host* "
"is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname* устанавливает или переопределяет имя хоста, с которым "
"будет сопоставляться сертификат целевого сервера. Следует передавать только "
"в том случае, если *ssl* не равен None. По умолчанию используется значение "
"аргумента *host*. Если *host* пуст, значения по умолчанию нет, и вам "
"необходимо передать значение для *server_hostname*. Если *server_hostname* — "
"пустая строка, сопоставление имен хостов отключено (что представляет собой "
"серьезную угрозу безопасности, допускающую потенциальные атаки «человек "
"посередине»)."

#: ../../library/asyncio-eventloop.rst:452
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given, "
"these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* — это необязательное семейство адресов, протокол "
"и флаги, которые необходимо передать в getaddrinfo() для разрешения *host*. "
"Если они заданы, все они должны быть целыми числами из соответствующих "
"констант модуля :mod:`socket`."

#: ../../library/asyncio-eventloop.rst:457
msgid ""
"*happy_eyeballs_delay*, if given, enables Happy Eyeballs for this "
"connection. It should be a floating-point number representing the amount of "
"time in seconds to wait for a connection attempt to complete, before "
"starting the next attempt in parallel. This is the \"Connection Attempt "
"Delay\" as defined in :rfc:`8305`. A sensible default value recommended by "
"the RFC is ``0.25`` (250 milliseconds)."
msgstr ""
"*happy_eyeballs_delay*, если задано, включает функцию Happy Eyeballs для "
"этого соединения. Это должно быть число с плавающей запятой, обозначающее "
"время в секундах ожидания завершения попытки подключения перед параллельным "
"запуском следующей попытки. Это «Задержка попытки подключения», как "
"определено в :rfc:`8305`. Разумное значение по умолчанию, рекомендованное "
"RFC, составляет «0,25» (250 миллисекунд)."

#: ../../library/asyncio-eventloop.rst:465
msgid ""
"*interleave* controls address reordering when a host name resolves to "
"multiple IP addresses. If ``0`` or unspecified, no reordering is done, and "
"addresses are tried in the order returned by :meth:`getaddrinfo`. If a "
"positive integer is specified, the addresses are interleaved by address "
"family, and the given integer is interpreted as \"First Address Family "
"Count\" as defined in :rfc:`8305`. The default is ``0`` if "
"*happy_eyeballs_delay* is not specified, and ``1`` if it is."
msgstr ""
"*interleave* управляет переупорядочением адресов, когда имя хоста "
"преобразуется в несколько IP-адресов. Если ``0`` или не указано, "
"переупорядочение не производится, и адреса проверяются в порядке, "
"возвращаемом :meth:`getaddrinfo`. Если указано положительное целое число, "
"адреса чередуются по семействам адресов, и данное целое число "
"интерпретируется как «Счетчик первого семейства адресов», как определено в :"
"rfc:`8305`. По умолчанию установлено ``0``, если *happy_eyeballs_delay* не "
"указано, и ``1``, если оно указано."

#: ../../library/asyncio-eventloop.rst:474
msgid ""
"*sock*, if given, should be an existing, already connected :class:`socket."
"socket` object to be used by the transport. If *sock* is given, none of "
"*host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* and *local_addr* should be specified."
msgstr ""
"*sock*, если он указан, должен быть существующим, уже подключенным объектом :"
"class:`socket.socket`, который будет использоваться транспортом. Если указан "
"*sock*, не следует указывать ни одно из *host*, *port*, *family*, *proto*, "
"*flags*, *happy_eyeballs_delay*, *interleave* и *local_addr*."

#: ../../library/asyncio-eventloop.rst:482
#: ../../library/asyncio-eventloop.rst:597
#: ../../library/asyncio-eventloop.rst:825
msgid ""
"The *sock* argument transfers ownership of the socket to the transport "
"created. To close the socket, call the transport's :meth:`~asyncio."
"BaseTransport.close` method."
msgstr ""
"Аргумент *sock* передает право собственности на сокет созданному транспорту. "
"Чтобы закрыть сокет, вызовите метод транспорта :meth:`~asyncio.BaseTransport."
"close`."

#: ../../library/asyncio-eventloop.rst:486
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using "
"``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr*, если он указан, представляет собой кортеж ``(local_host, "
"local_port)``, используемый для локальной привязки сокета. *local_host* и "
"*local_port* ищутся с помощью ``getaddrinfo()``, аналогично *host* и *port*."

#: ../../library/asyncio-eventloop.rst:490
#: ../../library/asyncio-eventloop.rst:919
msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* — это (для TLS-соединения) время в секундах ожидания "
"завершения TLS-квитирования перед прерыванием соединения. ``60,0`` секунд, "
"если ``Нет`` (по умолчанию)."

#: ../../library/asyncio-eventloop.rst:494
#: ../../library/asyncio-eventloop.rst:742
#: ../../library/asyncio-eventloop.rst:836
#: ../../library/asyncio-eventloop.rst:923
msgid ""
"*ssl_shutdown_timeout* is the time in seconds to wait for the SSL shutdown "
"to complete before aborting the connection. ``30.0`` seconds if ``None`` "
"(default)."
msgstr ""
"*ssl_shutdown_timeout* — время в секундах ожидания завершения завершения "
"работы SSL перед прерыванием соединения. ``30,0`` секунд, если ``Нет`` (по "
"умолчанию)."

#: ../../library/asyncio-eventloop.rst:498
msgid ""
"*all_errors* determines what exceptions are raised when a connection cannot "
"be created. By default, only a single ``Exception`` is raised: the first "
"exception if there is only one or all errors have same message, or a single "
"``OSError`` with the error messages combined. When ``all_errors`` is "
"``True``, an ``ExceptionGroup`` will be raised containing all exceptions "
"(even if there is only one)."
msgstr ""
"*all_errors* определяет, какие исключения возникают, когда соединение не "
"может быть создано. По умолчанию возникает только одно исключение: первое "
"исключение, если есть только одна или все ошибки имеют одинаковое сообщение, "
"или одно исключение OSError с объединенными сообщениями об ошибках. Когда "
"``all_errors`` имеет значение ``True``, будет создана группа "
"``ExceptionGroup``, содержащая все исключения (даже если есть только одно)."

#: ../../library/asyncio-eventloop.rst:508
#: ../../library/asyncio-eventloop.rst:754
msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr "Добавлена ​​поддержка SSL/TLS в :class:`ProactorEventLoop`."

#: ../../library/asyncio-eventloop.rst:512
msgid ""
"The socket option :ref:`socket.TCP_NODELAY <socket-unix-constants>` is set "
"by default for all TCP connections."
msgstr ""
"Опция сокета :ref:`socket.TCP_NODELAY <socket-unix-constants>` установлена ​​"
"по умолчанию для всех TCP-соединений."

#: ../../library/asyncio-eventloop.rst:517
#: ../../library/asyncio-eventloop.rst:846
msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "Добавлен параметр *ssl_handshake_timeout*."

#: ../../library/asyncio-eventloop.rst:521
msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "Добавлены параметры *happy_eyeballs_delay* и *interleave*."

#: ../../library/asyncio-eventloop.rst:523
msgid ""
"Happy Eyeballs Algorithm: Success with Dual-Stack Hosts. When a server's "
"IPv4 path and protocol are working, but the server's IPv6 path and protocol "
"are not working, a dual-stack client application experiences significant "
"connection delay compared to an IPv4-only client.  This is undesirable "
"because it causes the dual-stack client to have a worse user experience.  "
"This document specifies requirements for algorithms that reduce this user-"
"visible delay and provides an algorithm."
msgstr ""
"Алгоритм счастливых глаз: успех с хостами с двумя стеками. Если путь и "
"протокол IPv4 сервера работают, но путь и протокол IPv6 сервера не работают, "
"клиентское приложение с двойным стеком испытывает значительную задержку "
"подключения по сравнению с клиентом, поддерживающим только IPv4. Это "
"нежелательно, поскольку это приводит к ухудшению пользовательского опыта "
"клиента с двойным стеком. Этот документ определяет требования к алгоритмам, "
"которые уменьшают эту видимую пользователю задержку, и предоставляет "
"алгоритм."

#: ../../library/asyncio-eventloop.rst:532
msgid "For more information: https://datatracker.ietf.org/doc/html/rfc6555"
msgstr ""
"Для получения дополнительной информации: https://datatracker.ietf.org/doc/"
"html/rfc6555."

#: ../../library/asyncio-eventloop.rst:536
#: ../../library/asyncio-eventloop.rst:660
#: ../../library/asyncio-eventloop.rst:768
#: ../../library/asyncio-eventloop.rst:803
#: ../../library/asyncio-eventloop.rst:850
#: ../../library/asyncio-eventloop.rst:931
msgid "Added the *ssl_shutdown_timeout* parameter."
msgstr "Добавлен параметр *ssl_shutdown_timeout*."

#: ../../library/asyncio-eventloop.rst:538
msgid "*all_errors* was added."
msgstr "Добавлено *all_errors*."

#: ../../library/asyncio-eventloop.rst:543
msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It "
"returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that can be "
"used directly in async/await code."
msgstr ""
"Функция :func:`open_connection` — это альтернативный API высокого уровня. Он "
"возвращает пару (:class:`StreamReader`, :class:`StreamWriter`), которую "
"можно использовать непосредственно в коде async/await."

#: ../../library/asyncio-eventloop.rst:553
msgid "Create a datagram connection."
msgstr "Создайте дейтаграммное соединение."

#: ../../library/asyncio-eventloop.rst:555
msgid ""
"The socket family can be either :py:const:`~socket.AF_INET`, :py:const:"
"`~socket.AF_INET6`, or :py:const:`~socket.AF_UNIX`, depending on *host* (or "
"the *family* argument, if provided)."
msgstr ""
"Семейство сокетов может быть :py:const:`~socket.AF_INET`, :py:const:`~socket."
"AF_INET6` или :py:const:`~socket.AF_UNIX`, в зависимости от *хоста* (или "
"аргумент *family*, если он указан)."

#: ../../library/asyncio-eventloop.rst:559
msgid "The socket type will be :py:const:`~socket.SOCK_DGRAM`."
msgstr "Тип сокета будет :py:const:`~socket.SOCK_DGRAM`."

#: ../../library/asyncio-eventloop.rst:561
#: ../../library/asyncio-eventloop.rst:685
#: ../../library/asyncio-eventloop.rst:817
msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol <asyncio-"
"protocol>` implementation."
msgstr ""
"*protocol_factory* должен быть вызываемым объектом, возвращающим реализацию "
"протокола <asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:564
#: ../../library/asyncio-eventloop.rst:642
msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr "В случае успеха возвращается кортеж ``(транспорт, протокол)``."

#: ../../library/asyncio-eventloop.rst:568
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using :"
"meth:`getaddrinfo`."
msgstr ""
"*local_addr*, если он указан, представляет собой кортеж ``(local_host, "
"local_port)``, используемый для локальной привязки сокета. *local_host* и "
"*local_port* ищутся с помощью :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:572
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port* "
"are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr*, если он указан, представляет собой кортеж ``(remote_host, "
"Remote_port)``, используемый для подключения сокета к удаленному адресу. "
"*remote_host* и *remote_port* ищутся с помощью :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:576
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* — это необязательное семейство адресов, протокол "
"и флаги, которые необходимо передать в :meth:`getaddrinfo` для разрешения "
"*host*. Если они заданы, все они должны быть целыми числами из "
"соответствующих констант модуля :mod:`socket`."

#: ../../library/asyncio-eventloop.rst:581
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows and some "
"Unixes. If the :ref:`socket.SO_REUSEPORT <socket-unix-constants>` constant "
"is not defined then this capability is unsupported."
msgstr ""
"*reuse_port* указывает ядру разрешить привязку этой конечной точки к тому же "
"порту, к которому привязаны другие существующие конечные точки, при условии, "
"что все они установили этот флаг при создании. Эта опция не поддерживается в "
"Windows и некоторых Unix-системах. Если константа :ref:`socket.SO_REUSEPORT "
"<socket-unix-constants>` не определена, то эта возможность не поддерживается."

#: ../../library/asyncio-eventloop.rst:587
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* сообщает ядру, что нужно разрешить этой конечной точке "
"отправлять сообщения на широковещательный адрес."

#: ../../library/asyncio-eventloop.rst:590
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be :const:"
"`None`)."
msgstr ""
"*sock* может быть указан дополнительно, чтобы использовать уже существующий, "
"уже подключенный объект :class:`socket.socket`, который будет использоваться "
"транспортом. Если указано, *local_addr* и *remote_addr* следует опустить "
"(должно быть :const:`None`)."

#: ../../library/asyncio-eventloop.rst:601
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and :"
"ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
"См. примеры протокола эхо-клиента UDP <asyncio-udp-echo-client-protocol> и "
"протокола эхо-сервера UDP <asyncio-udp-echo-server-protocol>."

#: ../../library/asyncio-eventloop.rst:604
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"Были добавлены параметры *family*, *proto*, *flags*, *reuse_address*, "
"*reuse_port*, *allow_broadcast* и *sock*."

#: ../../library/asyncio-eventloop.rst:608
msgid "Added support for Windows."
msgstr "Добавлена поддержка Windows."

#: ../../library/asyncio-eventloop.rst:611
msgid ""
"The *reuse_address* parameter is no longer supported, as using :ref:`socket."
"SO_REUSEADDR <socket-unix-constants>` poses a significant security concern "
"for UDP. Explicitly passing ``reuse_address=True`` will raise an exception."
msgstr ""
"Параметр *reuse_address* больше не поддерживается, поскольку использование :"
"ref:`socket.SO_REUSEADDR <socket-unix-constants>` представляет собой "
"серьезную проблему безопасности для UDP. Явная передача "
"``reuse_address=True`` вызовет исключение."

#: ../../library/asyncio-eventloop.rst:617
msgid ""
"When multiple processes with differing UIDs assign sockets to an identical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""
"Когда несколько процессов с разными UID назначают сокетам одинаковый адрес "
"сокета UDP с помощью SO_REUSEADDR, входящие пакеты могут случайным образом "
"распределяться между сокетами."

#: ../../library/asyncio-eventloop.rst:621
msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :ref:`socket.SO_REUSEPORT <socket-"
"unix-constants>` is used instead, which specifically prevents processes with "
"differing UIDs from assigning sockets to the same socket address."
msgstr ""
"Для поддерживаемых платформ *reuse_port* можно использовать в качестве "
"замены аналогичной функциональности. При использовании *reuse_port* вместо "
"этого используется :ref:`socket.SO_REUSEPORT <socket-unix-constants>`, что "
"специально предотвращает назначение процессами с разными UID сокетов одному "
"и тому же адресу сокета."

#: ../../library/asyncio-eventloop.rst:628
msgid ""
"The *reuse_address* parameter, disabled since Python 3.8.1, 3.7.6 and "
"3.6.10, has been entirely removed."
msgstr ""
"Параметр *reuse_address*, отключенный начиная с Python 3.8.1, 3.7.6 и "
"3.6.10, был полностью удален."

#: ../../library/asyncio-eventloop.rst:637
msgid "Create a Unix connection."
msgstr "Создайте соединение с Unix."

#: ../../library/asyncio-eventloop.rst:639
msgid ""
"The socket family will be :py:const:`~socket.AF_UNIX`; socket type will be :"
"py:const:`~socket.SOCK_STREAM`."
msgstr ""
"Семейство сокетов будет :py:const:`~socket.AF_UNIX`; тип сокета будет :py:"
"const:`~socket.SOCK_STREAM`."

#: ../../library/asyncio-eventloop.rst:644
msgid ""
"*path* is the name of a Unix domain socket and is required, unless a *sock* "
"parameter is specified.  Abstract Unix sockets, :class:`str`, :class:"
"`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* — это имя сокета домена Unix, оно является обязательным, если не "
"указан параметр *sock*. Поддерживаются абстрактные сокеты Unix, пути :class:"
"`str`, :class:`bytes` и :class:`~pathlib.Path`."

#: ../../library/asyncio-eventloop.rst:649
msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr ""
"См. документацию метода :meth:`loop.create_connection` для получения "
"информации об аргументах этого метода."

#: ../../library/asyncio-eventloop.rst:652
#: ../../library/asyncio-eventloop.rst:794
#: ../../library/asyncio-eventloop.rst:1233
#: ../../library/asyncio-eventloop.rst:1741
#: ../../library/asyncio-eventloop.rst:1748
msgid "Availability"
msgstr "Доступность"

#: ../../library/asyncio-eventloop.rst:654
msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be "
"a :term:`path-like object`."
msgstr ""
"Добавлен параметр *ssl_handshake_timeout*. Параметр *path* теперь может быть "
"объектом, похожим на путь."

#: ../../library/asyncio-eventloop.rst:664
msgid "Creating network servers"
msgstr "Создание сетевых серверов"

#: ../../library/asyncio-eventloop.rst:678
msgid ""
"Create a TCP server (socket type :const:`~socket.SOCK_STREAM`) listening on "
"*port* of the *host* address."
msgstr ""
"Создайте TCP-сервер (тип сокета :const:`~socket.SOCK_STREAM`), "
"прослушивающий *порт* адреса *хоста*."

#: ../../library/asyncio-eventloop.rst:681
msgid "Returns a :class:`Server` object."
msgstr "Возвращает объект :class:`Server`."

#: ../../library/asyncio-eventloop.rst:683
msgid "Arguments:"
msgstr "Аргументы:"

#: ../../library/asyncio-eventloop.rst:688
msgid ""
"The *host* parameter can be set to several types which determine where the "
"server would be listening:"
msgstr ""
"Параметру *host* можно задать несколько типов, которые определяют, где "
"сервер будет прослушивать:"

#: ../../library/asyncio-eventloop.rst:691
msgid ""
"If *host* is a string, the TCP server is bound to a single network interface "
"specified by *host*."
msgstr ""
"Если *host* — это строка, TCP-сервер привязан к одному сетевому интерфейсу, "
"указанному *host*."

#: ../../library/asyncio-eventloop.rst:694
msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all network "
"interfaces specified by the sequence."
msgstr ""
"Если *host* представляет собой последовательность строк, TCP-сервер привязан "
"ко всем сетевым интерфейсам, указанным в этой последовательности."

#: ../../library/asyncio-eventloop.rst:697
msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and a "
"list of multiple sockets will be returned (most likely one for IPv4 and "
"another one for IPv6)."
msgstr ""
"Если *host* — пустая строка или ``None``, предполагаются все интерфейсы и "
"будет возвращен список нескольких сокетов (скорее всего, один для IPv4, а "
"другой для IPv6)."

#: ../../library/asyncio-eventloop.rst:701
msgid ""
"The *port* parameter can be set to specify which port the server should "
"listen on. If ``0`` or ``None`` (the default), a random unused port will be "
"selected (note that if *host* resolves to multiple network interfaces, a "
"different random port will be selected for each interface)."
msgstr ""
"Параметр *port* можно установить, чтобы указать, какой порт должен "
"прослушивать сервер. Если ``0`` или ``None`` (по умолчанию), будет выбран "
"случайный неиспользуемый порт (обратите внимание, что если *host* "
"разрешается для нескольких сетевых интерфейсов, для каждого интерфейса будет "
"выбран другой случайный порт)."

#: ../../library/asyncio-eventloop.rst:706
msgid ""
"*family* can be set to either :const:`socket.AF_INET` or :const:`~socket."
"AF_INET6` to force the socket to use IPv4 or IPv6. If not set, the *family* "
"will be determined from host name (defaults to :const:`~socket.AF_UNSPEC`)."
msgstr ""
"Для *family* может быть установлено значение :const:`socket.AF_INET` или :"
"const:`~socket.AF_INET6`, чтобы заставить сокет использовать IPv4 или IPv6. "
"Если не установлено, *семейство* будет определяться по имени хоста (по "
"умолчанию :const:`~socket.AF_UNSPEC`)."

#: ../../library/asyncio-eventloop.rst:711
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* — это битовая маска для :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:713
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"*sock* можно указать дополнительно, чтобы использовать уже существующий "
"объект сокета. Если указано, *хост* и *порт* указывать нельзя."

#: ../../library/asyncio-eventloop.rst:718
msgid ""
"The *sock* argument transfers ownership of the socket to the server created. "
"To close the socket, call the server's :meth:`~asyncio.Server.close` method."
msgstr ""
"Аргумент *sock* передает право собственности на сокет созданному серверу. "
"Чтобы закрыть сокет, вызовите метод сервера :meth:`~asyncio.Server.close`."

#: ../../library/asyncio-eventloop.rst:722
msgid ""
"*backlog* is the maximum number of queued connections passed to :meth:"
"`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* — максимальное количество соединений в очереди, передаваемых в :"
"meth:`~socket.socket.listen` (по умолчанию 100)."

#: ../../library/asyncio-eventloop.rst:725
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS over "
"the accepted connections."
msgstr ""
"Для *ssl* может быть установлен экземпляр :class:`~ssl.SSLContext`, чтобы "
"включить TLS для принятых соединений."

#: ../../library/asyncio-eventloop.rst:728
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT`` "
"state, without waiting for its natural timeout to expire. If not specified "
"will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* сообщает ядру повторно использовать локальный сокет в "
"состоянии ``TIME_WAIT``, не дожидаясь истечения его естественного таймаута. "
"Если не указано, в Unix автоматически будет установлено значение «True»."

#: ../../library/asyncio-eventloop.rst:733
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* указывает ядру разрешить привязку этой конечной точки к тому же "
"порту, к которому привязаны другие существующие конечные точки, при условии, "
"что все они установили этот флаг при создании. Этот параметр не "
"поддерживается в Windows."

#: ../../library/asyncio-eventloop.rst:738
msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait "
"for the TLS handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* — это (для сервера TLS) время в секундах ожидания "
"завершения подтверждения TLS перед прерыванием соединения. ``60,0`` секунд, "
"если ``Нет`` (по умолчанию)."

#: ../../library/asyncio-eventloop.rst:746
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever` "
"to make the server to start accepting connections."
msgstr ""
"Для параметра *start_serving* установлено значение ``True`` (по умолчанию) "
"созданный сервер немедленно начинает принимать соединения. Если установлено "
"значение «False», пользователь должен дождаться :meth:`Server.start_serving` "
"или :meth:`Server.serve_forever`, чтобы сервер начал принимать соединения."

#: ../../library/asyncio-eventloop.rst:758
msgid "The *host* parameter can be a sequence of strings."
msgstr "Параметр *host* может представлять собой последовательность строк."

#: ../../library/asyncio-eventloop.rst:762
msgid ""
"Added *ssl_handshake_timeout* and *start_serving* parameters. The socket "
"option :ref:`socket.TCP_NODELAY <socket-unix-constants>` is set by default "
"for all TCP connections."
msgstr ""
"Добавлены параметры *ssl_handshake_timeout* и *start_serving*. Опция сокета :"
"ref:`socket.TCP_NODELAY <socket-unix-constants>` установлена ​​по умолчанию "
"для всех TCP-соединений."

#: ../../library/asyncio-eventloop.rst:772
msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that can "
"be used in an async/await code."
msgstr ""
"Функция :func:`start_server` — это альтернативный API более высокого уровня, "
"который возвращает пару :class:`StreamReader` и :class:`StreamWriter`, "
"которые можно использовать в асинхронном/ожидающем коде."

#: ../../library/asyncio-eventloop.rst:783
msgid ""
"Similar to :meth:`loop.create_server` but works with the :py:const:`~socket."
"AF_UNIX` socket family."
msgstr ""
"Похож на :meth:`loop.create_server`, но работает с семейством сокетов :py:"
"const:`~socket.AF_UNIX`."

#: ../../library/asyncio-eventloop.rst:786
msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a *sock* "
"argument is provided.  Abstract Unix sockets, :class:`str`, :class:`bytes`, "
"and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* — это имя сокета домена Unix. Оно является обязательным, если не "
"указан аргумент *sock*. Поддерживаются абстрактные сокеты Unix, пути :class:"
"`str`, :class:`bytes` и :class:`~pathlib.Path`."

#: ../../library/asyncio-eventloop.rst:791
msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr ""
"См. документацию метода :meth:`loop.create_server` для получения информации "
"об аргументах этого метода."

#: ../../library/asyncio-eventloop.rst:798
msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path* "
"parameter can now be a :class:`~pathlib.Path` object."
msgstr ""
"Добавлены параметры *ssl_handshake_timeout* и *start_serving*. Параметр "
"*path* теперь может быть объектом :class:`~pathlib.Path`."

#: ../../library/asyncio-eventloop.rst:810
msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr "Оберните уже принятое соединение в пару транспорт/протокол."

#: ../../library/asyncio-eventloop.rst:812
msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr ""
"Этот метод может использоваться серверами, которые принимают соединения вне "
"asyncio, но используют asyncio для их обработки."

#: ../../library/asyncio-eventloop.rst:815
#: ../../library/asyncio-eventloop.rst:905
msgid "Parameters:"
msgstr "Параметры:"

#: ../../library/asyncio-eventloop.rst:820
msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr ""
"*sock* — это уже существующий объект сокета, возвращаемый из :meth:`socket."
"accept <socket.socket.accept>`."

#: ../../library/asyncio-eventloop.rst:829
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"Для *ssl* можно установить :class:`~ssl.SSLContext`, чтобы включить SSL для "
"принятых соединений."

#: ../../library/asyncio-eventloop.rst:832
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* — это (для SSL-соединения) время в секундах ожидания "
"завершения SSL-квитирования перед прерыванием соединения. ``60,0`` секунд, "
"если ``Нет`` (по умолчанию)."

#: ../../library/asyncio-eventloop.rst:840
msgid "Returns a ``(transport, protocol)`` pair."
msgstr "Возвращает пару ``(транспорт, протокол)``."

#: ../../library/asyncio-eventloop.rst:854
msgid "Transferring files"
msgstr "Передача файлов"

#: ../../library/asyncio-eventloop.rst:859
msgid ""
"Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr ""
"Отправьте *файл* через *транспорт*. Возвращает общее количество отправленных "
"байтов."

#: ../../library/asyncio-eventloop.rst:862
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""
"Этот метод использует высокопроизводительный :meth:`os.sendfile`, если он "
"доступен."

#: ../../library/asyncio-eventloop.rst:864
msgid "*file* must be a regular file object opened in binary mode."
msgstr ""
"*файл* должен быть обычным файловым объектом, открытым в двоичном режиме."

#: ../../library/asyncio-eventloop.rst:866
#: ../../library/asyncio-eventloop.rst:1111
msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is always updated, even when this method "
"raises an error, and :meth:`file.tell() <io.IOBase.tell>` can be used to "
"obtain the actual number of bytes sent."
msgstr ""
"*offset* указывает, с чего начать чтение файла. Если указано, *count* — это "
"общее количество байтов для передачи вместо отправки файла до достижения "
"EOF. Позиция файла всегда обновляется, даже если этот метод вызывает ошибку, "
"и :meth:`file.tell() <io.IOBase.tell>` можно использовать для получения "
"фактического количества отправленных байтов."

#: ../../library/asyncio-eventloop.rst:873
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile system call (e.g. Windows or "
"SSL socket on Unix)."
msgstr ""
"*fallback*, установленный в ``True``, заставляет asyncio вручную читать и "
"отправлять файл, когда платформа не поддерживает системный вызов sendfile "
"(например, сокет Windows или SSL в Unix)."

#: ../../library/asyncio-eventloop.rst:877
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Поднимите :exc:`SendfileNotAvailableError`, если система не поддерживает "
"системный вызов *sendfile* и *fallback* имеет значение ``False``."

#: ../../library/asyncio-eventloop.rst:884
msgid "TLS Upgrade"
msgstr "Обновление TLS"

#: ../../library/asyncio-eventloop.rst:891
msgid "Upgrade an existing transport-based connection to TLS."
msgstr "Обновите существующее транспортное соединение до TLS."

#: ../../library/asyncio-eventloop.rst:893
msgid ""
"Create a TLS coder/decoder instance and insert it between the *transport* "
"and the *protocol*. The coder/decoder implements both *transport*-facing "
"protocol and *protocol*-facing transport."
msgstr ""
"Создайте экземпляр кодера/декодера TLS и вставьте его между *транспортом* и "
"*протоколом*. Кодер/декодер реализует как протокол, ориентированный на "
"*транспорт*, так и транспорт, ориентированный на *протокол*."

#: ../../library/asyncio-eventloop.rst:897
msgid ""
"Return the created two-interface instance. After *await*, the *protocol* "
"must stop using the original *transport* and communicate with the returned "
"object only because the coder caches *protocol*-side data and sporadically "
"exchanges extra TLS session packets with *transport*."
msgstr ""
"Верните созданный двухинтерфейсный экземпляр. После *await* *протокол* "
"должен прекратить использование исходного *транспорта* и взаимодействовать с "
"возвращаемым объектом только потому, что кодер кэширует данные на стороне "
"*протокола* и время от времени обменивается дополнительными пакетами сеанса "
"TLS с *транспортом*."

#: ../../library/asyncio-eventloop.rst:902
msgid ""
"In some situations (e.g. when the passed transport is already closing) this "
"may return ``None``."
msgstr ""
"В некоторых ситуациях (например, когда переданный транспорт уже закрывается) "
"это может возвращать None."

#: ../../library/asyncio-eventloop.rst:907
msgid ""
"*transport* and *protocol* instances that methods like :meth:`~loop."
"create_server` and :meth:`~loop.create_connection` return."
msgstr ""
"экземпляры *transport* и *protocol*, возвращаемые такими методами, как :meth:"
"`~loop.create_server` и :meth:`~loop.create_connection`."

#: ../../library/asyncio-eventloop.rst:911
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: настроенный экземпляр :class:`~ssl.SSLContext`."

#: ../../library/asyncio-eventloop.rst:913
msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~loop.create_server`)."
msgstr ""
"*server_side* передает ``True`` при обновлении соединения на стороне сервера "
"(например, созданного :meth:`~loop.create_server`)."

#: ../../library/asyncio-eventloop.rst:916
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname*: устанавливает или переопределяет имя хоста, с которым "
"будет сопоставляться сертификат целевого сервера."

#: ../../library/asyncio-eventloop.rst:936
msgid "Watching file descriptors"
msgstr "Наблюдение за дескрипторами файлов"

#: ../../library/asyncio-eventloop.rst:940
msgid ""
"Start monitoring the *fd* file descriptor for read availability and invoke "
"*callback* with the specified arguments once *fd* is available for reading."
msgstr ""
"Начните отслеживать файловый дескриптор *fd* на доступность чтения и "
"вызовите *callback* с указанными аргументами, как только *fd* станет "
"доступным для чтения."

#: ../../library/asyncio-eventloop.rst:946
msgid ""
"Stop monitoring the *fd* file descriptor for read availability. Returns "
"``True`` if *fd* was previously being monitored for reads."
msgstr ""
"Прекратите мониторинг файлового дескриптора *fd* на предмет доступности "
"чтения. Возвращает ``True``, если *fd* ранее отслеживался на предмет чтения."

#: ../../library/asyncio-eventloop.rst:951
msgid ""
"Start monitoring the *fd* file descriptor for write availability and invoke "
"*callback* with the specified arguments once *fd* is available for writing."
msgstr ""
"Начните отслеживать файловый дескриптор *fd* на доступность записи и "
"вызовите *callback* с указанными аргументами, как только *fd* станет "
"доступен для записи."

#: ../../library/asyncio-eventloop.rst:955
#: ../../library/asyncio-eventloop.rst:1220
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *callback*."
msgstr ""
"Используйте :func:`functools.partial` :ref:`для передачи аргументов "
"ключевого слова <asyncio-pass-keywords>` в *callback*."

#: ../../library/asyncio-eventloop.rst:960
msgid ""
"Stop monitoring the *fd* file descriptor for write availability. Returns "
"``True`` if *fd* was previously being monitored for writes."
msgstr ""
"Прекратите мониторинг файлового дескриптора *fd* на предмет доступности "
"записи. Возвращает ``True``, если *fd* ранее отслеживался на предмет записи."

#: ../../library/asyncio-eventloop.rst:963
msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for some "
"limitations of these methods."
msgstr ""
"См. также раздел :ref:`Поддержка платформы <asyncio-platform-support>`, где "
"описаны некоторые ограничения этих методов."

#: ../../library/asyncio-eventloop.rst:968
msgid "Working with socket objects directly"
msgstr "Работа с объектами сокетов напрямую"

#: ../../library/asyncio-eventloop.rst:970
msgid ""
"In general, protocol implementations that use transport-based APIs such as :"
"meth:`loop.create_connection` and :meth:`loop.create_server` are faster than "
"implementations that work with sockets directly. However, there are some use "
"cases when performance is not critical, and working with :class:`~socket."
"socket` objects directly is more convenient."
msgstr ""
"В общем, реализации протоколов, использующие API на основе транспорта, такие "
"как :meth:`loop.create_connection` и :meth:`loop.create_server`, работают "
"быстрее, чем реализации, которые работают с сокетами напрямую. Однако есть "
"случаи использования, когда производительность не критична и удобнее "
"работать напрямую с объектами :class:`~socket.socket`."

#: ../../library/asyncio-eventloop.rst:979
msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of :meth:`socket."
"recv() <socket.socket.recv>`."
msgstr ""
"Получите до *нбайт* от *sock*. Асинхронная версия :meth:`socket.recv() "
"<socket.socket.recv>`."

#: ../../library/asyncio-eventloop.rst:982
msgid "Return the received data as a bytes object."
msgstr "Верните полученные данные в виде байтового объекта."

#: ../../library/asyncio-eventloop.rst:984
#: ../../library/asyncio-eventloop.rst:998
#: ../../library/asyncio-eventloop.rst:1009
#: ../../library/asyncio-eventloop.rst:1021
#: ../../library/asyncio-eventloop.rst:1036
#: ../../library/asyncio-eventloop.rst:1051
#: ../../library/asyncio-eventloop.rst:1061
#: ../../library/asyncio-eventloop.rst:1087
#: ../../library/asyncio-eventloop.rst:1125
msgid "*sock* must be a non-blocking socket."
msgstr "*sock* должен быть неблокирующим сокетом."

#: ../../library/asyncio-eventloop.rst:986
msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 this "
"is an ``async def`` method."
msgstr ""
"Несмотря на то, что этот метод всегда документировался как метод "
"сопрограммы, версии до Python 3.7 возвращали :class:`Future`. Начиная с "
"Python 3.7, это метод ``async def``."

#: ../../library/asyncio-eventloop.rst:993
msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the blocking :"
"meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""
"Получите данные из *sock* в буфер *buf*. Создано по образцу блокирующего "
"метода :meth:`socket.recv_into() <socket.socket.recv_into>`."

#: ../../library/asyncio-eventloop.rst:996
msgid "Return the number of bytes written to the buffer."
msgstr "Возвращает количество байтов, записанных в буфер."

#: ../../library/asyncio-eventloop.rst:1004
msgid ""
"Receive a datagram of up to *bufsize* from *sock*.  Asynchronous version of :"
"meth:`socket.recvfrom() <socket.socket.recvfrom>`."
msgstr ""
"Получите датаграмму размером до *bufsize* от *sock*. Асинхронная версия :"
"meth:`socket.recvfrom() <socket.socket.recvfrom>`."

#: ../../library/asyncio-eventloop.rst:1007
msgid "Return a tuple of (received data, remote address)."
msgstr "Вернуть кортеж (полученные данные, удаленный адрес)."

#: ../../library/asyncio-eventloop.rst:1015
msgid ""
"Receive a datagram of up to *nbytes* from *sock* into *buf*. Asynchronous "
"version of :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."
msgstr ""
"Получите датаграмму размером до *nbytes* из *sock* в *buf*. Асинхронная "
"версия :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."

#: ../../library/asyncio-eventloop.rst:1019
msgid "Return a tuple of (number of bytes received, remote address)."
msgstr "Вернуть кортеж (количество полученных байтов, удаленный адрес)."

#: ../../library/asyncio-eventloop.rst:1027
msgid ""
"Send *data* to the *sock* socket. Asynchronous version of :meth:`socket."
"sendall() <socket.socket.sendall>`."
msgstr ""
"Отправьте *данные* в сокет *sock*. Асинхронная версия :meth:`socket."
"sendall() <socket.socket.sendall>`."

#: ../../library/asyncio-eventloop.rst:1030
msgid ""
"This method continues to send to the socket until either all data in *data* "
"has been sent or an error occurs.  ``None`` is returned on success.  On "
"error, an exception is raised. Additionally, there is no way to determine "
"how much data, if any, was successfully processed by the receiving end of "
"the connection."
msgstr ""
"Этот метод продолжает отправлять данные в сокет до тех пор, пока не будут "
"отправлены все данные в *data* или не произойдет ошибка. ``None`` "
"возвращается в случае успеха. В случае ошибки возникает исключение. Кроме "
"того, невозможно определить, какой объем данных (если таковые имеются) был "
"успешно обработан принимающей стороной соединения."

#: ../../library/asyncio-eventloop.rst:1038
#: ../../library/asyncio-eventloop.rst:1089
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"Несмотря на то, что этот метод всегда документировался как метод "
"сопрограммы, до Python 3.7 он возвращал :class:`Future`. Начиная с Python "
"3.7, это метод ``async def``."

#: ../../library/asyncio-eventloop.rst:1045
msgid ""
"Send a datagram from *sock* to *address*. Asynchronous version of :meth:"
"`socket.sendto() <socket.socket.sendto>`."
msgstr ""
"Отправьте датаграмму с *sock* на *address*. Асинхронная версия :meth:`socket."
"sendto() <socket.socket.sendto>`."

#: ../../library/asyncio-eventloop.rst:1049
msgid "Return the number of bytes sent."
msgstr "Возвращает количество отправленных байтов."

#: ../../library/asyncio-eventloop.rst:1057
msgid "Connect *sock* to a remote socket at *address*."
msgstr "Подключите *sock* к удаленному сокету по *адресу*."

#: ../../library/asyncio-eventloop.rst:1059
msgid ""
"Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr "Асинхронная версия :meth:`socket.connect() <socket.socket.connect>`."

#: ../../library/asyncio-eventloop.rst:1063
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling :func:`socket."
"inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used to resolve the "
"*address*."
msgstr ""
"``адрес`` больше не требует разрешения. ``sock_connect`` попытается "
"проверить, разрешен ли уже *адрес*, вызвав :func:`socket.inet_pton`. В "
"противном случае для разрешения *адреса* будет использоваться :meth:`loop."
"getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:1072
msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`loop.create_connection` и  :func:`asyncio.open_connection() "
"<open_connection>`."

#: ../../library/asyncio-eventloop.rst:1078
msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr ""
"Примите соединение. Создано по образцу блокирующего метода :meth:`socket."
"accept() <socket.socket.accept>`."

#: ../../library/asyncio-eventloop.rst:1081
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
"Сокет должен быть привязан к адресу и прослушивать соединения. Возвращаемое "
"значение представляет собой пару ``(conn, адрес)``, где *conn* — это *новый* "
"объект сокета, используемый для отправки и получения данных по соединению, а "
"*address* — это адрес, привязанный к сокету на другом конец соединения."

#: ../../library/asyncio-eventloop.rst:1096
msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`loop.create_server` и :func:`start_server`."

#: ../../library/asyncio-eventloop.rst:1101
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return "
"the total number of bytes sent."
msgstr ""
"Если возможно, отправьте файл, используя высокопроизводительный :mod:`os."
"sendfile`. Возвращает общее количество отправленных байтов."

#: ../../library/asyncio-eventloop.rst:1104
msgid ""
"Asynchronous version of :meth:`socket.sendfile() <socket.socket.sendfile>`."
msgstr "Асинхронная версия :meth:`socket.sendfile() <socket.socket.sendfile>`."

#: ../../library/asyncio-eventloop.rst:1106
msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` :class:`~socket."
"socket`."
msgstr ""
"*sock* должен быть неблокирующим :const:`socket.SOCK_STREAM` :class:`~socket."
"socket`."

#: ../../library/asyncio-eventloop.rst:1109
msgid "*file* must be a regular file object open in binary mode."
msgstr ""
"*файл* должен быть обычным файловым объектом, открытым в двоичном режиме."

#: ../../library/asyncio-eventloop.rst:1118
msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send the "
"file when the platform does not support the sendfile syscall (e.g. Windows "
"or SSL socket on Unix)."
msgstr ""
"*fallback*, если установлено значение ``True``, заставляет asyncio вручную "
"читать и отправлять файл, когда платформа не поддерживает системный вызов "
"sendfile (например, сокет Windows или SSL в Unix)."

#: ../../library/asyncio-eventloop.rst:1122
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Поднимите :exc:`SendfileNotAvailableError`, если система не поддерживает "
"системный вызов *sendfile* и *fallback* имеет значение ``False``."

#: ../../library/asyncio-eventloop.rst:1131
msgid "DNS"
msgstr "DNS"

#: ../../library/asyncio-eventloop.rst:1136
msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr "Асинхронная версия :meth:`socket.getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:1140
msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr "Асинхронная версия :meth:`socket.getnameinfo`."

#: ../../library/asyncio-eventloop.rst:1143
msgid ""
"Both *getaddrinfo* and *getnameinfo* internally utilize their synchronous "
"versions through the loop's default thread pool executor. When this executor "
"is saturated, these methods may experience delays, which higher-level "
"networking libraries may report as increased timeouts. To mitigate this, "
"consider using a custom executor for other user tasks, or setting a default "
"executor with a larger number of workers."
msgstr ""
"И *getaddrinfo*, и *getnameinfo* внутренне используют свои синхронные версии "
"через исполнителя пула потоков цикла по умолчанию. Когда этот исполнитель "
"насыщен, эти методы могут испытывать задержки, о которых сетевые библиотеки "
"более высокого уровня могут сообщать как увеличенные тайм-ауты. Чтобы "
"избежать этого, рассмотрите возможность использования специального "
"исполнителя для других пользовательских задач или установки исполнителя по "
"умолчанию с большим количеством рабочих процессов."

#: ../../library/asyncio-eventloop.rst:1150
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning :"
"class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""
"Оба метода *getaddrinfo* и *getnameinfo* всегда были документированы для "
"возврата сопрограммы, но до Python 3.7 они фактически возвращали объекты :"
"class:`asyncio.Future`. Начиная с Python 3.7, оба метода являются "
"сопрограммами."

#: ../../library/asyncio-eventloop.rst:1158
msgid "Working with pipes"
msgstr "Работа с трубами"

#: ../../library/asyncio-eventloop.rst:1162
msgid "Register the read end of *pipe* in the event loop."
msgstr "Зарегистрируйте конец чтения *pipe* в цикле событий."

#: ../../library/asyncio-eventloop.rst:1167
msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr "*pipe* — это :term:`файлоподобный объект <файловый объект>`."

#: ../../library/asyncio-eventloop.rst:1169
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the :class:"
"`ReadTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Возвращаемая пара ``(транспорт, протокол)``, где *transport* поддерживает "
"интерфейс :class:`ReadTransport`, а *protocol* — это объект, экземпляр "
"которого создается *protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1173
#: ../../library/asyncio-eventloop.rst:1189
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""
"В цикле событий :class:`SelectorEventLoop` *pipe* устанавливается в "
"неблокирующий режим."

#: ../../library/asyncio-eventloop.rst:1178
msgid "Register the write end of *pipe* in the event loop."
msgstr "Зарегистрируйте конец записи *pipe* в цикле событий."

#: ../../library/asyncio-eventloop.rst:1183
msgid "*pipe* is :term:`file-like object <file object>`."
msgstr "*pipe* — это :term:`файлоподобный объект <файловый объект>`."

#: ../../library/asyncio-eventloop.rst:1185
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports :class:"
"`WriteTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Возвращаемая пара ``(транспорт, протокол)``, где *transport* поддерживает "
"интерфейс :class:`WriteTransport`, а *protocol* — это объект, экземпляр "
"которого создается *protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1194
msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows.  "
"Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
":class:`SelectorEventLoop` не поддерживает вышеуказанные методы в Windows. "
"Вместо этого используйте :class:`ProactorEventLoop` для Windows."

#: ../../library/asyncio-eventloop.rst:1199
msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` methods."
msgstr "Методы :meth:`loop.subprocess_exec` и :meth:`loop.subprocess_shell`."

#: ../../library/asyncio-eventloop.rst:1204
msgid "Unix signals"
msgstr "Сигналы Unix"

#: ../../library/asyncio-eventloop.rst:1210
msgid "Set *callback* as the handler for the *signum* signal."
msgstr "Установите *callback* в качестве обработчика сигнала *signum*."

#: ../../library/asyncio-eventloop.rst:1212
msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks "
"and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""
"Обратный вызов будет вызван *loop* вместе с другими обратными вызовами в "
"очереди и выполняемыми сопрограммами этого цикла событий. В отличие от "
"обработчиков сигналов, зарегистрированных с помощью :func:`signal.signal`, "
"обратному вызову, зарегистрированному с помощью этой функции, разрешено "
"взаимодействовать с циклом событий."

#: ../../library/asyncio-eventloop.rst:1217
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"Поднимите :exc:`ValueError`, если номер сигнала недействителен или не может "
"быть перехвачен. Поднимите :exc:`RuntimeError`, если возникла проблема с "
"настройкой обработчика."

#: ../../library/asyncio-eventloop.rst:1223
msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main thread."
msgstr ""
"Как и :func:`signal.signal`, эта функция должна вызываться в основном потоке."

#: ../../library/asyncio-eventloop.rst:1228
msgid "Remove the handler for the *sig* signal."
msgstr "Удалите обработчик сигнала *sig*."

#: ../../library/asyncio-eventloop.rst:1230
msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr ""
"Верните True, если обработчик сигнала был удален, или False, если для "
"данного сигнала не был установлен обработчик."

#: ../../library/asyncio-eventloop.rst:1237
msgid "The :mod:`signal` module."
msgstr "Модуль :mod:`signal`"

#: ../../library/asyncio-eventloop.rst:1241
msgid "Executing code in thread or process pools"
msgstr "Выполнение кода в пулах потоков или процессов"

#: ../../library/asyncio-eventloop.rst:1245
msgid "Arrange for *func* to be called in the specified executor."
msgstr "Организуйте вызов *func* в указанном исполнителе."

#: ../../library/asyncio-eventloop.rst:1247
msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``. The "
"default executor can be set by :meth:`loop.set_default_executor`, otherwise, "
"a :class:`concurrent.futures.ThreadPoolExecutor` will be lazy-initialized "
"and used by :func:`run_in_executor` if needed."
msgstr ""
"Аргумент *executor* должен быть экземпляром :class:`concurrent.futures."
"Executor`. Исполнитель по умолчанию используется, если *executor* имеет "
"значение «None». Исполнитель по умолчанию может быть установлен с помощью :"
"meth:`loop.set_default_executor`, в противном случае :class:`concurrent."
"futures.ThreadPoolExecutor` будет лениво инициализирован и использован :func:"
"`run_in_executor` при необходимости."

#: ../../library/asyncio-eventloop.rst:1255
msgid ""
"import asyncio\n"
"import concurrent.futures\n"
"\n"
"def blocking_io():\n"
"    # File operations (such as logging) can block the\n"
"    # event loop: run them in a thread pool.\n"
"    with open('/dev/urandom', 'rb') as f:\n"
"        return f.read(100)\n"
"\n"
"def cpu_bound():\n"
"    # CPU-bound operations will block the event loop:\n"
"    # in general it is preferable to run them in a\n"
"    # process pool.\n"
"    return sum(i * i for i in range(10 ** 7))\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    ## Options:\n"
"\n"
"    # 1. Run in the default loop's executor:\n"
"    result = await loop.run_in_executor(\n"
"        None, blocking_io)\n"
"    print('default thread pool', result)\n"
"\n"
"    # 2. Run in a custom thread pool:\n"
"    with concurrent.futures.ThreadPoolExecutor() as pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, blocking_io)\n"
"        print('custom thread pool', result)\n"
"\n"
"    # 3. Run in a custom process pool:\n"
"    with concurrent.futures.ProcessPoolExecutor() as pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, cpu_bound)\n"
"        print('custom process pool', result)\n"
"\n"
"if __name__ == '__main__':\n"
"    asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import concurrent.futures\n"
"\n"
"def blocking_io():\n"
"    # File operations (such as logging) can block the\n"
"    # event loop: run them in a thread pool.\n"
"    with open('/dev/urandom', 'rb') as f:\n"
"        return f.read(100)\n"
"\n"
"def cpu_bound():\n"
"    # CPU-bound operations will block the event loop:\n"
"    # in general it is preferable to run them in a\n"
"    # process pool.\n"
"    return sum(i * i for i in range(10 ** 7))\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    ## Options:\n"
"\n"
"    # 1. Run in the default loop's executor:\n"
"    result = await loop.run_in_executor(\n"
"        None, blocking_io)\n"
"    print('default thread pool', result)\n"
"\n"
"    # 2. Run in a custom thread pool:\n"
"    with concurrent.futures.ThreadPoolExecutor() as pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, blocking_io)\n"
"        print('custom thread pool', result)\n"
"\n"
"    # 3. Run in a custom process pool:\n"
"    with concurrent.futures.ProcessPoolExecutor() as pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, cpu_bound)\n"
"        print('custom process pool', result)\n"
"\n"
"if __name__ == '__main__':\n"
"    asyncio.run(main())"

#: ../../library/asyncio-eventloop.rst:1295
msgid ""
"Note that the entry point guard (``if __name__ == '__main__'``) is required "
"for option 3 due to the peculiarities of :mod:`multiprocessing`, which is "
"used by :class:`~concurrent.futures.ProcessPoolExecutor`. See :ref:`Safe "
"importing of main module <multiprocessing-safe-main-import>`."
msgstr ""
"Обратите внимание, что защита точки входа (``if __name__ == '__main__'``) "
"требуется для варианта 3 из-за особенностей :mod:`multiprocessing`, который "
"используется :class:`~concurrent.futures.ProcessPoolExecutor `. См. :ref:"
"`Безопасный импорт основного модуля <multiprocessing-safe-main-import>`."

#: ../../library/asyncio-eventloop.rst:1300
msgid "This method returns a :class:`asyncio.Future` object."
msgstr "Этот метод возвращает объект :class:`asyncio.Future`."

#: ../../library/asyncio-eventloop.rst:1302
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *func*."
msgstr ""
"Используйте :func:`functools.partial` :ref:`для передачи аргументов "
"ключевого слова <asyncio-pass-keywords>` в *func*."

#: ../../library/asyncio-eventloop.rst:1305
msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of the "
"thread pool executor it creates, instead leaving it up to the thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the "
"default."
msgstr ""
":meth:`loop.run_in_executor` больше не настраивает ``max_workers`` "
"исполнителя пула потоков, который он создает, вместо этого оставляя это на "
"усмотрение исполнителя пула потоков (:class:`~concurrent.futures."
"ThreadPoolExecutor`) для установки по умолчанию."

#: ../../library/asyncio-eventloop.rst:1314
msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* must be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""
"Установите *executor* в качестве исполнителя по умолчанию, используемого :"
"meth:`run_in_executor`. *executor* должен быть экземпляром :class:"
"`~concurrent.futures.ThreadPoolExecutor`."

#: ../../library/asyncio-eventloop.rst:1318
msgid ""
"*executor* must be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""
"*executor* должен быть экземпляром :class:`~concurrent.futures."
"ThreadPoolExecutor`."

#: ../../library/asyncio-eventloop.rst:1324
msgid "Error Handling API"
msgstr "API для обработки ошибок"

#: ../../library/asyncio-eventloop.rst:1326
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr "Позволяет настраивать обработку исключений в цикле событий."

#: ../../library/asyncio-eventloop.rst:1330
msgid "Set *handler* as the new event loop exception handler."
msgstr ""
"Установите *handler* в качестве нового обработчика исключений цикла событий."

#: ../../library/asyncio-eventloop.rst:1332
msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching ``(loop, "
"context)``, where ``loop`` is a reference to the active event loop, and "
"``context`` is a ``dict`` object containing the details of the exception "
"(see :meth:`call_exception_handler` documentation for details about context)."
msgstr ""
"Если *handler* имеет значение «None», будет установлен обработчик исключений "
"по умолчанию. В противном случае *handler* должен быть вызываемым объектом с "
"сигнатурой, соответствующей ``(loop, context)``, где ``loop`` — это ссылка "
"на активный цикл событий, а ``context`` — это ``dict`. `объект, содержащий "
"подробную информацию об исключении (более подробную информацию о контексте "
"см. в документации :meth:`call_Exception_handler`)."

#: ../../library/asyncio-eventloop.rst:1340
msgid ""
"If the handler is called on behalf of a :class:`~asyncio.Task` or :class:"
"`~asyncio.Handle`, it is run in the :class:`contextvars.Context` of that "
"task or callback handle."
msgstr ""
"Если обработчик вызывается от имени :class:`~asyncio.Task` или :class:"
"`~asyncio.Handle`, он запускается в :class:`contextvars.Context` этой задачи "
"или дескриптора обратного вызова."

#: ../../library/asyncio-eventloop.rst:1346
msgid ""
"The handler may be called in the :class:`~contextvars.Context` of the task "
"or handle where the exception originated."
msgstr ""
"Обработчик может быть вызван в :class:`~contextvars.Context` задачи или "
"дескриптора, из которого возникло исключение."

#: ../../library/asyncio-eventloop.rst:1351
msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr ""
"Возвращает текущий обработчик исключений или None, если специальный "
"обработчик исключений не был установлен."

#: ../../library/asyncio-eventloop.rst:1358
msgid "Default exception handler."
msgstr "Обработчик исключений по умолчанию."

#: ../../library/asyncio-eventloop.rst:1360
msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to the "
"default handler behavior."
msgstr ""
"Он вызывается, когда возникает исключение и обработчик исключений не "
"установлен. Это может быть вызвано пользовательским обработчиком исключений, "
"который хочет перейти к поведению обработчика по умолчанию."

#: ../../library/asyncio-eventloop.rst:1364
msgid ""
"*context* parameter has the same meaning as in :meth:"
"`call_exception_handler`."
msgstr ""
"Параметр *context* имеет то же значение, что и в :meth:"
"`call_Exception_handler`."

#: ../../library/asyncio-eventloop.rst:1369
msgid "Call the current event loop exception handler."
msgstr "Вызовите текущий обработчик исключений цикла событий."

#: ../../library/asyncio-eventloop.rst:1371
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced in future Python versions):"
msgstr ""
"*context* — это объект ``dict``, содержащий следующие ключи (новые ключи "
"могут быть добавлены в будущих версиях Python):"

#: ../../library/asyncio-eventloop.rst:1374
msgid "'message': Error message;"
msgstr "«сообщение»: сообщение об ошибке;"

#: ../../library/asyncio-eventloop.rst:1375
msgid "'exception' (optional): Exception object;"
msgstr "«исключение» (необязательно): объект исключения;"

#: ../../library/asyncio-eventloop.rst:1376
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'future' (необязательно): экземпляр :class:`asyncio.Future`;"

#: ../../library/asyncio-eventloop.rst:1377
msgid "'task' (optional): :class:`asyncio.Task` instance;"
msgstr "'task' (необязательно): экземпляр :class:`asyncio.Task`;"

#: ../../library/asyncio-eventloop.rst:1378
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (необязательно): экземпляр :class:`asyncio.Handle`;"

#: ../../library/asyncio-eventloop.rst:1379
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr ""
"'protocol' (необязательно): :ref:`Protocol <asyncio-protocol>` экземпляр;"

#: ../../library/asyncio-eventloop.rst:1380
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""
"'transport' (необязательно): :ref:`Transport <asyncio-transport>` экземпляр;"

#: ../../library/asyncio-eventloop.rst:1381
msgid "'socket' (optional): :class:`socket.socket` instance;"
msgstr "'socket' (необязательно): экземпляр :class:`socket.socket`;"

#: ../../library/asyncio-eventloop.rst:1382
msgid "'asyncgen' (optional): Asynchronous generator that caused"
msgstr "'asyncgen' (необязательно): асинхронный генератор, вызвавший"

#: ../../library/asyncio-eventloop.rst:1383
msgid "the exception."
msgstr "Исключение."

#: ../../library/asyncio-eventloop.rst:1387
msgid ""
"This method should not be overloaded in subclassed event loops.  For custom "
"exception handling, use the :meth:`set_exception_handler` method."
msgstr ""
"Этот метод не следует перегружать в циклах событий подклассов. Для "
"пользовательской обработки исключений используйте метод :meth:"
"`set_Exception_handler`."

#: ../../library/asyncio-eventloop.rst:1392
msgid "Enabling debug mode"
msgstr "Включение режима отладки"

#: ../../library/asyncio-eventloop.rst:1396
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "Получите режим отладки (:class:`bool`) цикла событий."

#: ../../library/asyncio-eventloop.rst:1398
msgid ""
"The default value is ``True`` if the environment variable :envvar:"
"`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` otherwise."
msgstr ""
"Значением по умолчанию является ``True``, если для переменной среды :envvar:"
"`PYTHONASYNCIODEBUG` задана непустая строка, в противном случае ``False``."

#: ../../library/asyncio-eventloop.rst:1404
msgid "Set the debug mode of the event loop."
msgstr "Установите режим отладки цикла событий."

#: ../../library/asyncio-eventloop.rst:1408
msgid ""
"The new :ref:`Python Development Mode <devmode>` can now also be used to "
"enable the debug mode."
msgstr ""
"Новый :ref:`Режим разработки Python <devmode>` теперь также можно "
"использовать для включения режима отладки."

#: ../../library/asyncio-eventloop.rst:1413
msgid ""
"This attribute can be used to set the minimum execution duration in seconds "
"that is considered \"slow\". When debug mode is enabled, \"slow\" callbacks "
"are logged."
msgstr ""
"Этот атрибут можно использовать для установки минимальной продолжительности "
"выполнения в секундах, которая считается «медленной». Когда режим отладки "
"включен, регистрируются «медленные» обратные вызовы."

#: ../../library/asyncio-eventloop.rst:1417
msgid "Default value is 100 milliseconds."
msgstr "Значение по умолчанию — 100 миллисекунд."

#: ../../library/asyncio-eventloop.rst:1421
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ":ref:`Режим отладки asyncio <asyncio-debug-mode>`."

#: ../../library/asyncio-eventloop.rst:1425
msgid "Running Subprocesses"
msgstr "Исполняемые подпроцессы"

#: ../../library/asyncio-eventloop.rst:1427
msgid ""
"Methods described in this subsections are low-level.  In regular async/await "
"code consider using the high-level :func:`asyncio.create_subprocess_shell` "
"and :func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""
"Методы, описанные в этом подразделе, являются низкоуровневыми. В обычном "
"коде async/await вместо этого рассмотрите возможность использования "
"вспомогательных функций высокого уровня :func:`asyncio."
"create_subprocess_shell` и :func:`asyncio.create_subprocess_exec`."

#: ../../library/asyncio-eventloop.rst:1434
msgid ""
"On Windows, the default event loop :class:`ProactorEventLoop` supports "
"subprocesses, whereas :class:`SelectorEventLoop` does not. See :ref:"
"`Subprocess Support on Windows <asyncio-windows-subprocess>` for details."
msgstr ""
"В Windows цикл событий по умолчанию :class:`ProactorEventLoop` поддерживает "
"подпроцессы, а :class:`SelectorEventLoop` — нет. Подробности см. в разделе "
"«Поддержка подпроцессов в Windows <asyncio-windows-subprocess>»."

#: ../../library/asyncio-eventloop.rst:1445
msgid ""
"Create a subprocess from one or more string arguments specified by *args*."
msgstr ""
"Создайте подпроцесс из одного или нескольких строковых аргументов, указанных "
"в *args*."

#: ../../library/asyncio-eventloop.rst:1448
msgid "*args* must be a list of strings represented by:"
msgstr "*args* должен быть списком строк, представленных:"

#: ../../library/asyncio-eventloop.rst:1450
msgid ":class:`str`;"
msgstr ":class:`str`;"

#: ../../library/asyncio-eventloop.rst:1451
msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr ""
"или :class:`bytes`, закодированный в :ref:`кодировке файловой системы "
"<filesystem-encoding>`."

#: ../../library/asyncio-eventloop.rst:1454
msgid ""
"The first string specifies the program executable, and the remaining strings "
"specify the arguments.  Together, string arguments form the ``argv`` of the "
"program."
msgstr ""
"Первая строка указывает исполняемый файл программы, а остальные строки "
"указывают аргументы. Вместе строковые аргументы образуют argv программы."

#: ../../library/asyncio-eventloop.rst:1458
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single argument "
"which is list of strings, *subprocess_exec* takes multiple string arguments."
msgstr ""
"Это похоже на класс стандартной библиотеки :class:`subprocess.Popen`, "
"вызываемый с ``shell=False`` и списком строк, передаваемых в качестве "
"первого аргумента; однако, где :class:`~subprocess.Popen` принимает один "
"аргумент, который представляет собой список строк, *subprocess_exec* "
"принимает несколько строковых аргументов."

#: ../../library/asyncio-eventloop.rst:1464
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`asyncio.SubprocessProtocol` class."
msgstr ""
"*protocol_factory* должен быть вызываемым объектом, возвращающим подкласс "
"класса :class:`asyncio.SubprocessProtocol`."

#: ../../library/asyncio-eventloop.rst:1467
msgid "Other parameters:"
msgstr "Другие параметры:"

#: ../../library/asyncio-eventloop.rst:1469
msgid "*stdin* can be any of these:"
msgstr "*stdin* может быть любым из следующих:"

#: ../../library/asyncio-eventloop.rst:1471
#: ../../library/asyncio-eventloop.rst:1482
#: ../../library/asyncio-eventloop.rst:1492
msgid "a file-like object"
msgstr "файлоподобный объект"

#: ../../library/asyncio-eventloop.rst:1472
msgid ""
"an existing file descriptor (a positive integer), for example those created "
"with :meth:`os.pipe`"
msgstr ""
"существующий файловый дескриптор (положительное целое число), например "
"созданный с помощью :meth:`os.pipe`"

#: ../../library/asyncio-eventloop.rst:1473
#: ../../library/asyncio-eventloop.rst:1483
#: ../../library/asyncio-eventloop.rst:1493
msgid ""
"the :const:`subprocess.PIPE` constant (default) which will create a new pipe "
"and connect it,"
msgstr ""
"константа :const:`subprocess.PIPE` (по умолчанию), которая создаст новый "
"канал и подключит его,"

#: ../../library/asyncio-eventloop.rst:1475
#: ../../library/asyncio-eventloop.rst:1485
#: ../../library/asyncio-eventloop.rst:1495
msgid ""
"the value ``None`` which will make the subprocess inherit the file "
"descriptor from this process"
msgstr ""
"значение ``None``, которое заставит подпроцесс наследовать файловый "
"дескриптор от этого процесса"

#: ../../library/asyncio-eventloop.rst:1477
#: ../../library/asyncio-eventloop.rst:1487
#: ../../library/asyncio-eventloop.rst:1497
msgid ""
"the :const:`subprocess.DEVNULL` constant which indicates that the special :"
"data:`os.devnull` file will be used"
msgstr ""
"константа :const:`subprocess.DEVNULL`, которая указывает, что будет "
"использоваться специальный файл :data:`os.devnull`"

#: ../../library/asyncio-eventloop.rst:1480
msgid "*stdout* can be any of these:"
msgstr "*stdout* может быть любым из следующих:"

#: ../../library/asyncio-eventloop.rst:1490
msgid "*stderr* can be any of these:"
msgstr "*stderr* может быть любым из следующих:"

#: ../../library/asyncio-eventloop.rst:1499
msgid ""
"the :const:`subprocess.STDOUT` constant which will connect the standard "
"error stream to the process' standard output stream"
msgstr ""
"константа :const:`subprocess.STDOUT`, которая соединит стандартный поток "
"ошибок со стандартным потоком вывода процесса."

#: ../../library/asyncio-eventloop.rst:1502
msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` without "
"interpretation, except for *bufsize*, *universal_newlines*, *shell*, *text*, "
"*encoding* and *errors*, which should not be specified at all."
msgstr ""
"Все остальные аргументы ключевого слова передаются в :class:`subprocess."
"Popen` без интерпретации, за исключением *bufsize*, *universal_newlines*, "
"*shell*, *text*, *encoding* и *errors*, которые не следует указывать в все."

#: ../../library/asyncio-eventloop.rst:1507
msgid ""
"The ``asyncio`` subprocess API does not support decoding the streams as "
"text. :func:`bytes.decode` can be used to convert the bytes returned from "
"the stream to text."
msgstr ""
"API подпроцесса asyncio не поддерживает декодирование потоков в текст. :func:"
"`bytes.decode` можно использовать для преобразования байтов, возвращаемых из "
"потока, в текст."

#: ../../library/asyncio-eventloop.rst:1511
msgid ""
"If a file-like object passed as *stdin*, *stdout* or *stderr* represents a "
"pipe, then the other side of this pipe should be registered with :meth:"
"`~loop.connect_write_pipe` or :meth:`~loop.connect_read_pipe` for use with "
"the event loop."
msgstr ""
"Если файлоподобный объект, передаваемый как *stdin*, *stdout* или *stderr*, "
"представляет канал, то другая сторона этого канала должна быть "
"зарегистрирована с помощью :meth:`~loop.connect_write_pipe` или :meth:"
"`~loop. .connect_read_pipe` для использования с циклом событий."

#: ../../library/asyncio-eventloop.rst:1516
msgid ""
"See the constructor of the :class:`subprocess.Popen` class for documentation "
"on other arguments."
msgstr ""
"См. конструктор класса :class:`subprocess.Popen` для получения документации "
"по другим аргументам."

#: ../../library/asyncio-eventloop.rst:1519
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`asyncio.SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""
"Возвращает пару ``(транспорт, протокол)``, где *transport* соответствует "
"базовому классу :class:`asyncio.SubprocessTransport`, а *protocol* — это "
"объект, экземпляр которого создается *protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1527
msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a :class:"
"`bytes` string encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`, using the platform's \"shell\" syntax."
msgstr ""
"Создайте подпроцесс из *cmd*, который может представлять собой строку :class:"
"`str` или :class:`bytes`, закодированную в :ref:`кодировку файловой системы "
"<filesystem-encoding>`, используя синтаксис оболочки платформы. ."

#: ../../library/asyncio-eventloop.rst:1532
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""
"Это похоже на класс стандартной библиотеки :class:`subprocess.Popen`, "
"вызываемый с ``shell=True``."

#: ../../library/asyncio-eventloop.rst:1535
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`SubprocessProtocol` class."
msgstr ""
"*protocol_factory* должен быть вызываемым объектом, возвращающим подкласс "
"класса :class:`SubprocessProtocol`."

#: ../../library/asyncio-eventloop.rst:1538
msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr ""
"См. :meth:`~loop.subprocess_exec` для получения более подробной информации "
"об остальных аргументах."

#: ../../library/asyncio-eventloop.rst:1541
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`SubprocessTransport` base class and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""
"Возвращает пару ``(транспорт, протокол)``, где *transport* соответствует "
"базовому классу :class:`SubprocessTransport`, а *protocol* — это объект, "
"экземпляр которого создается *protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1546
msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special characters in strings that are going to be "
"used to construct shell commands."
msgstr ""
"Приложение несет ответственность за то, чтобы все пробелы и специальные "
"символы были заключены в кавычки соответствующим образом, чтобы избежать `_ "
"уязвимостей внедрения оболочки <https://en.wikipedia.org/wiki/"
"Shell_injection#Shell_injection>`_. Функцию :func:`shlex.quote` можно "
"использовать для правильного экранирования пробелов и специальных символов в "
"строках, которые будут использоваться для создания команд оболочки."

#: ../../library/asyncio-eventloop.rst:1555
msgid "Callback Handles"
msgstr "Дескрипторы обратного вызова"

#: ../../library/asyncio-eventloop.rst:1559
msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, :meth:`loop."
"call_soon_threadsafe`."
msgstr ""
"Объект-оболочка обратного вызова, возвращаемый :meth:`loop.call_soon`, :meth:"
"`loop.call_soon_threadsafe`."

#: ../../library/asyncio-eventloop.rst:1564
msgid ""
"Return the :class:`contextvars.Context` object associated with the handle."
msgstr "Верните объект :class:`contextvars.Context`, связанный с дескриптором."

#: ../../library/asyncio-eventloop.rst:1571
msgid ""
"Cancel the callback.  If the callback has already been canceled or executed, "
"this method has no effect."
msgstr ""
"Отмените обратный звонок. Если обратный вызов уже был отменен или выполнен, "
"этот метод не имеет никакого эффекта."

#: ../../library/asyncio-eventloop.rst:1576
msgid "Return ``True`` if the callback was cancelled."
msgstr "Верните True, если обратный вызов был отменен."

#: ../../library/asyncio-eventloop.rst:1582
msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and :meth:"
"`loop.call_at`."
msgstr ""
"Объект-оболочка обратного вызова, возвращаемый :meth:`loop.call_later` и :"
"meth:`loop.call_at`."

#: ../../library/asyncio-eventloop.rst:1585
msgid "This class is a subclass of :class:`Handle`."
msgstr "Этот класс является подклассом :class:`Handle`."

#: ../../library/asyncio-eventloop.rst:1589
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr ""
"Возвращает запланированное время обратного вызова в виде :class:`float` "
"секунд."

#: ../../library/asyncio-eventloop.rst:1591
msgid ""
"The time is an absolute timestamp, using the same time reference as :meth:"
"`loop.time`."
msgstr ""
"Время представляет собой абсолютную временную метку, использующую ту же "
"ссылку времени, что и :meth:`loop.time`."

#: ../../library/asyncio-eventloop.rst:1598
msgid "Server Objects"
msgstr "Объекты сервера"

#: ../../library/asyncio-eventloop.rst:1600
msgid ""
"Server objects are created by :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :func:`start_server`, and :func:`start_unix_server` "
"functions."
msgstr ""
"Объекты сервера создаются функциями :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :func:`start_server` и :func:`start_unix_server`."

#: ../../library/asyncio-eventloop.rst:1604
msgid "Do not instantiate the :class:`Server` class directly."
msgstr "Не создавайте экземпляр класса :class:`Server` напрямую."

#: ../../library/asyncio-eventloop.rst:1608
msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async "
"with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""
"Объекты *Server* представляют собой асинхронные менеджеры контекста. При "
"использовании в операторе ``async with`` гарантируется, что объект Сервер "
"закроется и не будет принимать новые соединения после завершения оператора "
"``async with``:"

#: ../../library/asyncio-eventloop.rst:1613
msgid ""
"srv = await loop.create_server(...)\n"
"\n"
"async with srv:\n"
"    # some code\n"
"\n"
"# At this point, srv is closed and no longer accepts new connections."
msgstr ""
"srv = await loop.create_server(...)\n"
"\n"
"async with srv:\n"
"    # some code\n"
"\n"
"# At this point, srv is closed and no longer accepts new connections."

#: ../../library/asyncio-eventloop.rst:1621
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr ""
"Объект сервера является асинхронным контекстным менеджером, начиная с Python "
"3.7."

#: ../../library/asyncio-eventloop.rst:1624
msgid ""
"This class was exposed publicly as ``asyncio.Server`` in Python 3.9.11, "
"3.10.3 and 3.11."
msgstr ""
"Этот класс был публично представлен как asyncio.Server в Python 3.9.11, "
"3.10.3 и 3.11."

#: ../../library/asyncio-eventloop.rst:1629
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""
"Прекратите обслуживание: закройте сокеты прослушивания и установите для "
"атрибута :attr:`sockets` значение ``None``."

#: ../../library/asyncio-eventloop.rst:1632
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr ""
"Сокеты, представляющие существующие входящие клиентские соединения, остаются "
"открытыми."

#: ../../library/asyncio-eventloop.rst:1635
msgid ""
"The server is closed asynchronously; use the :meth:`wait_closed` coroutine "
"to wait until the server is closed (and no more connections are active)."
msgstr ""
"Сервер закрывается асинхронно; используйте сопрограмму :meth:`wait_closed`, "
"чтобы дождаться закрытия сервера (и отсутствия активных соединений)."

#: ../../library/asyncio-eventloop.rst:1641
msgid "Return the event loop associated with the server object."
msgstr "Верните цикл событий, связанный с объектом сервера."

#: ../../library/asyncio-eventloop.rst:1647
msgid "Start accepting connections."
msgstr "Начните принимать соединения."

#: ../../library/asyncio-eventloop.rst:1649
msgid ""
"This method is idempotent, so it can be called when the server is already "
"serving."
msgstr ""
"Этот метод идемпотентен, поэтому его можно вызвать, когда сервер уже "
"обслуживает."

#: ../../library/asyncio-eventloop.rst:1652
msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` "
"and :meth:`asyncio.start_server` allows creating a Server object that is not "
"accepting connections initially.  In this case ``Server.start_serving()``, "
"or :meth:`Server.serve_forever` can be used to make the Server start "
"accepting connections."
msgstr ""
"Параметр *start_serving*, содержащий только ключевые слова, для :meth:`loop."
"create_server` и :meth:`asyncio.start_server` позволяет создать объект "
"Сервера, который изначально не принимает соединения. В этом случае можно "
"использовать ``Server.start_serving()`` или :meth:`Server.serve_forever`, "
"чтобы заставить Сервер начать принимать соединения."

#: ../../library/asyncio-eventloop.rst:1663
msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""
"Начните принимать соединения, пока сопрограмма не будет отменена. Отмена "
"задачи «serve_forever» приводит к закрытию сервера."

#: ../../library/asyncio-eventloop.rst:1667
msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""
"Этот метод можно вызвать, если сервер уже принимает соединения. Для одного "
"объекта *Server* может существовать только одна задача ``serve_forever``."

#: ../../library/asyncio-eventloop.rst:1673
msgid ""
"async def client_connected(reader, writer):\n"
"    # Communicate with the client with\n"
"    # reader/writer streams.  For example:\n"
"    await reader.readline()\n"
"\n"
"async def main(host, port):\n"
"    srv = await asyncio.start_server(\n"
"        client_connected, host, port)\n"
"    await srv.serve_forever()\n"
"\n"
"asyncio.run(main('127.0.0.1', 0))"
msgstr ""
"async def client_connected(reader, writer):\n"
"    # Communicate with the client with\n"
"    # reader/writer streams.  For example:\n"
"    await reader.readline()\n"
"\n"
"async def main(host, port):\n"
"    srv = await asyncio.start_server(\n"
"        client_connected, host, port)\n"
"    await srv.serve_forever()\n"
"\n"
"asyncio.run(main('127.0.0.1', 0))"

#: ../../library/asyncio-eventloop.rst:1689
msgid "Return ``True`` if the server is accepting new connections."
msgstr "Верните True, если сервер принимает новые соединения."

#: ../../library/asyncio-eventloop.rst:1695
msgid ""
"Wait until the :meth:`close` method completes and all active connections "
"have finished."
msgstr ""
"Подождите, пока метод :meth:`close` завершится и все активные соединения не "
"завершится."

#: ../../library/asyncio-eventloop.rst:1700
msgid ""
"List of socket-like objects, ``asyncio.trsock.TransportSocket``, which the "
"server is listening on."
msgstr ""
"Список объектов, подобных сокетам, asyncio.trsock.TransportSocket, которые "
"прослушивает сервер."

#: ../../library/asyncio-eventloop.rst:1703
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of "
"server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""
"До Python 3.7 ``Server.sockets`` использовался для прямого возврата "
"внутреннего списка сокетов сервера. В версии 3.7 возвращается копия этого "
"списка."

#: ../../library/asyncio-eventloop.rst:1713
msgid "Event Loop Implementations"
msgstr "Реализации цикла событий"

#: ../../library/asyncio-eventloop.rst:1715
msgid ""
"asyncio ships with two different event loop implementations: :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"asyncio поставляется с двумя различными реализациями цикла событий: :class:"
"`SelectorEventLoop` и :class:`ProactorEventLoop`."

#: ../../library/asyncio-eventloop.rst:1718
msgid ""
"By default asyncio is configured to use :class:`SelectorEventLoop` on Unix "
"and :class:`ProactorEventLoop` on Windows."
msgstr ""
"По умолчанию asyncio настроен на использование :class:`SelectorEventLoop` в "
"Unix и :class:`ProactorEventLoop` в Windows."

#: ../../library/asyncio-eventloop.rst:1724
msgid "An event loop based on the :mod:`selectors` module."
msgstr "Цикл событий, основанный на модуле :mod:`selectors`."

#: ../../library/asyncio-eventloop.rst:1726
msgid ""
"Uses the most efficient *selector* available for the given platform.  It is "
"also possible to manually configure the exact selector implementation to be "
"used::"
msgstr ""
"Использует наиболее эффективный *селектор*, доступный для данной платформы. "
"Также можно вручную настроить конкретную реализацию селектора, которая будет "
"использоваться:"

#: ../../library/asyncio-eventloop.rst:1730
msgid ""
"import asyncio\n"
"import selectors\n"
"\n"
"class MyPolicy(asyncio.DefaultEventLoopPolicy):\n"
"   def new_event_loop(self):\n"
"      selector = selectors.SelectSelector()\n"
"      return asyncio.SelectorEventLoop(selector)\n"
"\n"
"asyncio.set_event_loop_policy(MyPolicy())"
msgstr ""
"import asyncio\n"
"import selectors\n"
"\n"
"class MyPolicy(asyncio.DefaultEventLoopPolicy):\n"
"   def new_event_loop(self):\n"
"      selector = selectors.SelectSelector()\n"
"      return asyncio.SelectorEventLoop(selector)\n"
"\n"
"asyncio.set_event_loop_policy(MyPolicy())"

#: ../../library/asyncio-eventloop.rst:1746
msgid "An event loop for Windows that uses \"I/O Completion Ports\" (IOCP)."
msgstr ""
"Цикл событий для Windows, использующий «Порты завершения ввода-"
"вывода» (IOCP)."

#: ../../library/asyncio-eventloop.rst:1752
msgid ""
"`MSDN documentation on I/O Completion Ports <https://docs.microsoft.com/en-"
"ca/windows/desktop/FileIO/i-o-completion-ports>`_."
msgstr ""
"`Документация MSDN по портам завершения ввода-вывода <https://docs.microsoft."
"com/en-ca/windows/desktop/FileIO/io-completion-ports>`_."

#: ../../library/asyncio-eventloop.rst:1758
msgid "Abstract base class for asyncio-compliant event loops."
msgstr "Абстрактный базовый класс для асинхронных циклов событий."

#: ../../library/asyncio-eventloop.rst:1760
msgid ""
"The :ref:`asyncio-event-loop-methods` section lists all methods that an "
"alternative implementation of ``AbstractEventLoop`` should have defined."
msgstr ""
"В разделе :ref:`asyncio-event-loop-methods` перечислены все методы, которые "
"должна была определить альтернативная реализация ``AbstractEventLoop``."

#: ../../library/asyncio-eventloop.rst:1766
msgid "Examples"
msgstr "Примеры"

#: ../../library/asyncio-eventloop.rst:1768
msgid ""
"Note that all examples in this section **purposefully** show how to use the "
"low-level event loop APIs, such as :meth:`loop.run_forever` and :meth:`loop."
"call_soon`.  Modern asyncio applications rarely need to be written this way; "
"consider using the high-level functions like :func:`asyncio.run`."
msgstr ""
"Обратите внимание, что все примеры в этом разделе **целенаправленно** "
"показывают, как использовать API-интерфейсы низкоуровневого цикла событий, "
"такие как :meth:`loop.run_forever` и :meth:`loop.call_soon`. Современные "
"асинхронные приложения редко требуют написания таким образом; рассмотрите "
"возможность использования функций высокого уровня, таких как :func:`asyncio."
"run`."

#: ../../library/asyncio-eventloop.rst:1778
msgid "Hello World with call_soon()"
msgstr "Привет, мир с помощью call_soon()"

#: ../../library/asyncio-eventloop.rst:1780
msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a callback. "
"The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr ""
"Пример использования метода :meth:`loop.call_soon` для планирования "
"обратного вызова. Обратный вызов отображает ``Hello World'`, а затем "
"останавливает цикл обработки событий::"

#: ../../library/asyncio-eventloop.rst:1784
msgid ""
"import asyncio\n"
"\n"
"def hello_world(loop):\n"
"    \"\"\"A callback to print 'Hello World' and stop the event loop\"\"\"\n"
"    print('Hello World')\n"
"    loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schedule a call to hello_world()\n"
"loop.call_soon(hello_world, loop)\n"
"\n"
"# Blocking call interrupted by loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"
msgstr ""
"import asyncio\n"
"\n"
"def hello_world(loop):\n"
"    \"\"\"A callback to print 'Hello World' and stop the event loop\"\"\"\n"
"    print('Hello World')\n"
"    loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schedule a call to hello_world()\n"
"loop.call_soon(hello_world, loop)\n"
"\n"
"# Blocking call interrupted by loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"

#: ../../library/asyncio-eventloop.rst:1804
msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine "
"and the :func:`run` function."
msgstr ""
"Аналогичный пример Hello World <coroutine>, созданный с помощью сопрограммы "
"и функции :func:`run`."

#: ../../library/asyncio-eventloop.rst:1811
msgid "Display the current date with call_later()"
msgstr "Отобразите текущую дату с помощью call_later()"

#: ../../library/asyncio-eventloop.rst:1813
msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself after "
"5 seconds, and then stops the event loop::"
msgstr ""
"Пример обратного вызова, отображающего текущую дату каждую секунду. Обратный "
"вызов использует метод :meth:`loop.call_later` для перепланирования себя "
"через 5 секунд, а затем останавливает цикл событий::"

#: ../../library/asyncio-eventloop.rst:1817
msgid ""
"import asyncio\n"
"import datetime\n"
"\n"
"def display_date(end_time, loop):\n"
"    print(datetime.datetime.now())\n"
"    if (loop.time() + 1.0) < end_time:\n"
"        loop.call_later(1, display_date, end_time, loop)\n"
"    else:\n"
"        loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schedule the first call to display_date()\n"
"end_time = loop.time() + 5.0\n"
"loop.call_soon(display_date, end_time, loop)\n"
"\n"
"# Blocking call interrupted by loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"
msgstr ""
"import asyncio\n"
"import datetime\n"
"\n"
"def display_date(end_time, loop):\n"
"    print(datetime.datetime.now())\n"
"    if (loop.time() + 1.0) < end_time:\n"
"        loop.call_later(1, display_date, end_time, loop)\n"
"    else:\n"
"        loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schedule the first call to display_date()\n"
"end_time = loop.time() + 5.0\n"
"loop.call_soon(display_date, end_time, loop)\n"
"\n"
"# Blocking call interrupted by loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"

#: ../../library/asyncio-eventloop.rst:1841
msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created with a "
"coroutine and the :func:`run` function."
msgstr ""
"Аналогичный пример текущей даты <asyncio_example_sleep>, созданный с помощью "
"сопрограммы и функции :func:`run`."

#: ../../library/asyncio-eventloop.rst:1848
msgid "Watch a file descriptor for read events"
msgstr "Следите за дескриптором файла на предмет событий чтения"

#: ../../library/asyncio-eventloop.rst:1850
msgid ""
"Wait until a file descriptor received some data using the :meth:`loop."
"add_reader` method and then close the event loop::"
msgstr ""
"Подождите, пока дескриптор файла не получит некоторые данные с помощью "
"метода :meth:`loop.add_reader`, а затем закройте цикл обработки событий::"

#: ../../library/asyncio-eventloop.rst:1853
msgid ""
"import asyncio\n"
"from socket import socketpair\n"
"\n"
"# Create a pair of connected file descriptors\n"
"rsock, wsock = socketpair()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"def reader():\n"
"    data = rsock.recv(100)\n"
"    print(\"Received:\", data.decode())\n"
"\n"
"    # We are done: unregister the file descriptor\n"
"    loop.remove_reader(rsock)\n"
"\n"
"    # Stop the event loop\n"
"    loop.stop()\n"
"\n"
"# Register the file descriptor for read event\n"
"loop.add_reader(rsock, reader)\n"
"\n"
"# Simulate the reception of data from the network\n"
"loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"try:\n"
"    # Run the event loop\n"
"    loop.run_forever()\n"
"finally:\n"
"    # We are done. Close sockets and the event loop.\n"
"    rsock.close()\n"
"    wsock.close()\n"
"    loop.close()"
msgstr ""
"import asyncio\n"
"from socket import socketpair\n"
"\n"
"# Create a pair of connected file descriptors\n"
"rsock, wsock = socketpair()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"def reader():\n"
"    data = rsock.recv(100)\n"
"    print(\"Received:\", data.decode())\n"
"\n"
"    # We are done: unregister the file descriptor\n"
"    loop.remove_reader(rsock)\n"
"\n"
"    # Stop the event loop\n"
"    loop.stop()\n"
"\n"
"# Register the file descriptor for read event\n"
"loop.add_reader(rsock, reader)\n"
"\n"
"# Simulate the reception of data from the network\n"
"loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"try:\n"
"    # Run the event loop\n"
"    loop.run_forever()\n"
"finally:\n"
"    # We are done. Close sockets and the event loop.\n"
"    rsock.close()\n"
"    wsock.close()\n"
"    loop.close()"

#: ../../library/asyncio-eventloop.rst:1888
msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""
"Аналогичный :ref:`пример <asyncio_example_create_connection>` с "
"использованием транспортов, протоколов и метода :meth:`loop."
"create_connection`."

#: ../../library/asyncio-eventloop.rst:1892
msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-streams>` "
"using the high-level :func:`asyncio.open_connection` function and streams."
msgstr ""
"Другой похожий :ref:`пример <asyncio_example_create_connection-streams>` с "
"использованием высокоуровневой :func:`asyncio.open_connection` функции и "
"потоков."

#: ../../library/asyncio-eventloop.rst:1900
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "Установите обработчики сигналов для SIGINT и SIGTERM"

#: ../../library/asyncio-eventloop.rst:1902
msgid "(This ``signals`` example only works on Unix.)"
msgstr "(Этот пример сигналов работает только в Unix.)"

#: ../../library/asyncio-eventloop.rst:1904
msgid ""
"Register handlers for signals :const:`~signal.SIGINT` and :const:`~signal."
"SIGTERM` using the :meth:`loop.add_signal_handler` method::"
msgstr ""
"Зарегистрируйте обработчики сигналов :const:`~signal.SIGINT` и :const:"
"`~signal.SIGTERM` с помощью метода :meth:`loop.add_signal_handler`::"

#: ../../library/asyncio-eventloop.rst:1907
msgid ""
"import asyncio\n"
"import functools\n"
"import os\n"
"import signal\n"
"\n"
"def ask_exit(signame, loop):\n"
"    print(\"got signal %s: exit\" % signame)\n"
"    loop.stop()\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    for signame in {'SIGINT', 'SIGTERM'}:\n"
"        loop.add_signal_handler(\n"
"            getattr(signal, signame),\n"
"            functools.partial(ask_exit, signame, loop))\n"
"\n"
"    await asyncio.sleep(3600)\n"
"\n"
"print(\"Event loop running for 1 hour, press Ctrl+C to interrupt.\")\n"
"print(f\"pid {os.getpid()}: send SIGINT or SIGTERM to exit.\")\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import functools\n"
"import os\n"
"import signal\n"
"\n"
"def ask_exit(signame, loop):\n"
"    print(\"got signal %s: exit\" % signame)\n"
"    loop.stop()\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    for signame in {'SIGINT', 'SIGTERM'}:\n"
"        loop.add_signal_handler(\n"
"            getattr(signal, signame),\n"
"            functools.partial(ask_exit, signame, loop))\n"
"\n"
"    await asyncio.sleep(3600)\n"
"\n"
"print(\"Event loop running for 1 hour, press Ctrl+C to interrupt.\")\n"
"print(f\"pid {os.getpid()}: send SIGINT or SIGTERM to exit.\")\n"
"\n"
"asyncio.run(main())"
