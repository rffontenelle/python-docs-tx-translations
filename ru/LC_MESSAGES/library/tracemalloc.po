# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Kristina Mironova, 2021
# Daniil Kolesnikov, 2024
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:16+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/tracemalloc.rst:2
msgid ":mod:`!tracemalloc` --- Trace memory allocations"
msgstr ":mod:`!tracemalloc` --- Отслеживание распределения памяти"

#: ../../library/tracemalloc.rst:9
msgid "**Source code:** :source:`Lib/tracemalloc.py`"
msgstr "**Исходный код:** :source:`Lib/tracemalloc.py`"

#: ../../library/tracemalloc.rst:13
msgid ""
"The tracemalloc module is a debug tool to trace memory blocks allocated by "
"Python. It provides the following information:"
msgstr ""
"Модуль Tracemalloc — это инструмент отладки для отслеживания блоков памяти, "
"выделенных Python. Он предоставляет следующую информацию:"

#: ../../library/tracemalloc.rst:16
msgid "Traceback where an object was allocated"
msgstr "Отслеживание места размещения объекта"

#: ../../library/tracemalloc.rst:17
msgid ""
"Statistics on allocated memory blocks per filename and per line number: "
"total size, number and average size of allocated memory blocks"
msgstr ""
"Статистика по выделенным блокам памяти по имени файла и по номеру строки: "
"общий размер, количество и средний размер выделенных блоков памяти."

#: ../../library/tracemalloc.rst:19
msgid "Compute the differences between two snapshots to detect memory leaks"
msgstr ""
"Вычисление различий между двумя снимками для обнаружения утечек памяти."

#: ../../library/tracemalloc.rst:21
msgid ""
"To trace most memory blocks allocated by Python, the module should be "
"started as early as possible by setting the :envvar:`PYTHONTRACEMALLOC` "
"environment variable to ``1``, or by using :option:`-X` ``tracemalloc`` "
"command line option. The :func:`tracemalloc.start` function can be called at "
"runtime to start tracing Python memory allocations."
msgstr ""
"Чтобы отслеживать большинство блоков памяти, выделенных Python, модуль "
"следует запустить как можно раньше, установив для переменной среды :envvar:"
"`PYTHONTRACEMALLOC` значение ``1`` или используя :option:`-X` ``tracemalloc` "
"`параметр командной строки. Функцию :func:`tracemalloc.start` можно вызвать "
"во время выполнения, чтобы начать отслеживание распределения памяти Python."

#: ../../library/tracemalloc.rst:27
msgid ""
"By default, a trace of an allocated memory block only stores the most recent "
"frame (1 frame). To store 25 frames at startup: set the :envvar:"
"`PYTHONTRACEMALLOC` environment variable to ``25``, or use the :option:`-X` "
"``tracemalloc=25`` command line option."
msgstr ""
"По умолчанию трассировка выделенного блока памяти сохраняет только самый "
"последний кадр (1 кадр). Чтобы сохранить 25 кадров при запуске: установите "
"для переменной среды :envvar:`PYTHONTRACEMALLOC` значение ``25`` или "
"используйте параметр командной строки :option:`-X` ``tracemalloc=25``."

#: ../../library/tracemalloc.rst:34
msgid "Examples"
msgstr "Примеры"

#: ../../library/tracemalloc.rst:37
msgid "Display the top 10"
msgstr "Отобразить 10 лучших"

#: ../../library/tracemalloc.rst:39
msgid "Display the 10 files allocating the most memory::"
msgstr "Отображение 10 файлов, занимающих больше всего памяти::"

#: ../../library/tracemalloc.rst:41
msgid ""
"import tracemalloc\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"top_stats = snapshot.statistics('lineno')\n"
"\n"
"print(\"[ Top 10 ]\")\n"
"for stat in top_stats[:10]:\n"
"    print(stat)"
msgstr ""
"import tracemalloc\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"top_stats = snapshot.statistics('lineno')\n"
"\n"
"print(\"[ Top 10 ]\")\n"
"for stat in top_stats[:10]:\n"
"    print(stat)"

#: ../../library/tracemalloc.rst:55 ../../library/tracemalloc.rst:225
msgid "Example of output of the Python test suite::"
msgstr "Пример вывода набора тестов Python:"

#: ../../library/tracemalloc.rst:57
msgid ""
"[ Top 10 ]\n"
"<frozen importlib._bootstrap>:716: size=4855 KiB, count=39328, average=126 "
"B\n"
"<frozen importlib._bootstrap>:284: size=521 KiB, count=3199, average=167 B\n"
"/usr/lib/python3.4/collections/__init__.py:368: size=244 KiB, count=2315, "
"average=108 B\n"
"/usr/lib/python3.4/unittest/case.py:381: size=185 KiB, count=779, "
"average=243 B\n"
"/usr/lib/python3.4/unittest/case.py:402: size=154 KiB, count=378, "
"average=416 B\n"
"/usr/lib/python3.4/abc.py:133: size=88.7 KiB, count=347, average=262 B\n"
"<frozen importlib._bootstrap>:1446: size=70.4 KiB, count=911, average=79 B\n"
"<frozen importlib._bootstrap>:1454: size=52.0 KiB, count=25, average=2131 B\n"
"<string>:5: size=49.7 KiB, count=148, average=344 B\n"
"/usr/lib/python3.4/sysconfig.py:411: size=48.0 KiB, count=1, average=48.0 KiB"
msgstr ""
"[ Top 10 ]\n"
"<frozen importlib._bootstrap>:716: size=4855 KiB, count=39328, average=126 "
"B\n"
"<frozen importlib._bootstrap>:284: size=521 KiB, count=3199, average=167 B\n"
"/usr/lib/python3.4/collections/__init__.py:368: size=244 KiB, count=2315, "
"average=108 B\n"
"/usr/lib/python3.4/unittest/case.py:381: size=185 KiB, count=779, "
"average=243 B\n"
"/usr/lib/python3.4/unittest/case.py:402: size=154 KiB, count=378, "
"average=416 B\n"
"/usr/lib/python3.4/abc.py:133: size=88.7 KiB, count=347, average=262 B\n"
"<frozen importlib._bootstrap>:1446: size=70.4 KiB, count=911, average=79 B\n"
"<frozen importlib._bootstrap>:1454: size=52.0 KiB, count=25, average=2131 B\n"
"<string>:5: size=49.7 KiB, count=148, average=344 B\n"
"/usr/lib/python3.4/sysconfig.py:411: size=48.0 KiB, count=1, average=48.0 KiB"

#: ../../library/tracemalloc.rst:69
msgid ""
"We can see that Python loaded ``4855 KiB`` data (bytecode and constants) "
"from modules and that the :mod:`collections` module allocated ``244 KiB`` to "
"build :class:`~collections.namedtuple` types."
msgstr ""
"Мы видим, что Python загрузил данные ``4855 КиБ`` (байт-код и константы) из "
"модулей и что модуль :mod:`collections` выделил ``244 КиБ`` для построения "
"типов :class:`~collections.namedtuple`."

#: ../../library/tracemalloc.rst:73 ../../library/tracemalloc.rst:250
msgid "See :meth:`Snapshot.statistics` for more options."
msgstr "См. :meth:`Snapshot.statistics` для получения дополнительных опций."

#: ../../library/tracemalloc.rst:77
msgid "Compute differences"
msgstr "Вычисление различий"

#: ../../library/tracemalloc.rst:79
msgid "Take two snapshots and display the differences::"
msgstr "Сделайте два снимка и отобразите различия::"

#: ../../library/tracemalloc.rst:81
msgid ""
"import tracemalloc\n"
"tracemalloc.start()\n"
"# ... start your application ...\n"
"\n"
"snapshot1 = tracemalloc.take_snapshot()\n"
"# ... call the function leaking memory ...\n"
"snapshot2 = tracemalloc.take_snapshot()\n"
"\n"
"top_stats = snapshot2.compare_to(snapshot1, 'lineno')\n"
"\n"
"print(\"[ Top 10 differences ]\")\n"
"for stat in top_stats[:10]:\n"
"    print(stat)"
msgstr ""
"import tracemalloc\n"
"tracemalloc.start()\n"
"# ... start your application ...\n"
"\n"
"snapshot1 = tracemalloc.take_snapshot()\n"
"# ... call the function leaking memory ...\n"
"snapshot2 = tracemalloc.take_snapshot()\n"
"\n"
"top_stats = snapshot2.compare_to(snapshot1, 'lineno')\n"
"\n"
"print(\"[ Top 10 differences ]\")\n"
"for stat in top_stats[:10]:\n"
"    print(stat)"

#: ../../library/tracemalloc.rst:95
msgid ""
"Example of output before/after running some tests of the Python test suite::"
msgstr "Пример вывода до/после запуска некоторых тестов набора тестов Python:"

#: ../../library/tracemalloc.rst:97
msgid ""
"[ Top 10 differences ]\n"
"<frozen importlib._bootstrap>:716: size=8173 KiB (+4428 KiB), count=71332 "
"(+39369), average=117 B\n"
"/usr/lib/python3.4/linecache.py:127: size=940 KiB (+940 KiB), count=8106 "
"(+8106), average=119 B\n"
"/usr/lib/python3.4/unittest/case.py:571: size=298 KiB (+298 KiB), count=589 "
"(+589), average=519 B\n"
"<frozen importlib._bootstrap>:284: size=1005 KiB (+166 KiB), count=7423 "
"(+1526), average=139 B\n"
"/usr/lib/python3.4/mimetypes.py:217: size=112 KiB (+112 KiB), count=1334 "
"(+1334), average=86 B\n"
"/usr/lib/python3.4/http/server.py:848: size=96.0 KiB (+96.0 KiB), count=1 "
"(+1), average=96.0 KiB\n"
"/usr/lib/python3.4/inspect.py:1465: size=83.5 KiB (+83.5 KiB), count=109 "
"(+109), average=784 B\n"
"/usr/lib/python3.4/unittest/mock.py:491: size=77.7 KiB (+77.7 KiB), "
"count=143 (+143), average=557 B\n"
"/usr/lib/python3.4/urllib/parse.py:476: size=71.8 KiB (+71.8 KiB), count=969 "
"(+969), average=76 B\n"
"/usr/lib/python3.4/contextlib.py:38: size=67.2 KiB (+67.2 KiB), count=126 "
"(+126), average=546 B"
msgstr ""
"[ Top 10 differences ]\n"
"<frozen importlib._bootstrap>:716: size=8173 KiB (+4428 KiB), count=71332 "
"(+39369), average=117 B\n"
"/usr/lib/python3.4/linecache.py:127: size=940 KiB (+940 KiB), count=8106 "
"(+8106), average=119 B\n"
"/usr/lib/python3.4/unittest/case.py:571: size=298 KiB (+298 KiB), count=589 "
"(+589), average=519 B\n"
"<frozen importlib._bootstrap>:284: size=1005 KiB (+166 KiB), count=7423 "
"(+1526), average=139 B\n"
"/usr/lib/python3.4/mimetypes.py:217: size=112 KiB (+112 KiB), count=1334 "
"(+1334), average=86 B\n"
"/usr/lib/python3.4/http/server.py:848: size=96.0 KiB (+96.0 KiB), count=1 "
"(+1), average=96.0 KiB\n"
"/usr/lib/python3.4/inspect.py:1465: size=83.5 KiB (+83.5 KiB), count=109 "
"(+109), average=784 B\n"
"/usr/lib/python3.4/unittest/mock.py:491: size=77.7 KiB (+77.7 KiB), "
"count=143 (+143), average=557 B\n"
"/usr/lib/python3.4/urllib/parse.py:476: size=71.8 KiB (+71.8 KiB), count=969 "
"(+969), average=76 B\n"
"/usr/lib/python3.4/contextlib.py:38: size=67.2 KiB (+67.2 KiB), count=126 "
"(+126), average=546 B"

#: ../../library/tracemalloc.rst:109
msgid ""
"We can see that Python has loaded ``8173 KiB`` of module data (bytecode and "
"constants), and that this is ``4428 KiB`` more than had been loaded before "
"the tests, when the previous snapshot was taken. Similarly, the :mod:"
"`linecache` module has cached ``940 KiB`` of Python source code to format "
"tracebacks, all of it since the previous snapshot."
msgstr ""
"Мы видим, что Python загрузил «8173 КиБ» данных модуля (байт-код и "
"константы), и что это на «4428 КиБ» больше, чем было загружено до тестов, "
"когда был сделан предыдущий снимок. Аналогичным образом, модуль :mod:"
"`linecache` кэширует 940 КиБ исходного кода Python для форматирования "
"обратных трассировок, причем все это со времени предыдущего снимка."

#: ../../library/tracemalloc.rst:115
msgid ""
"If the system has little free memory, snapshots can be written on disk using "
"the :meth:`Snapshot.dump` method to analyze the snapshot offline. Then use "
"the :meth:`Snapshot.load` method reload the snapshot."
msgstr ""
"Если в системе мало свободной памяти, снимки можно записать на диск с "
"помощью метода Snapshot.dump для анализа снимка в автономном режиме. Затем "
"используйте метод :meth:`Snapshot.load`, чтобы перезагрузить снимок."

#: ../../library/tracemalloc.rst:121
msgid "Get the traceback of a memory block"
msgstr "Получить обратную связь блока памяти"

#: ../../library/tracemalloc.rst:123
msgid "Code to display the traceback of the biggest memory block::"
msgstr "Код для отображения трассировки самого большого блока памяти::"

#: ../../library/tracemalloc.rst:125
msgid ""
"import tracemalloc\n"
"\n"
"# Store 25 frames\n"
"tracemalloc.start(25)\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"top_stats = snapshot.statistics('traceback')\n"
"\n"
"# pick the biggest memory block\n"
"stat = top_stats[0]\n"
"print(\"%s memory blocks: %.1f KiB\" % (stat.count, stat.size / 1024))\n"
"for line in stat.traceback.format():\n"
"    print(line)"
msgstr ""
"import tracemalloc\n"
"\n"
"# Store 25 frames\n"
"tracemalloc.start(25)\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"top_stats = snapshot.statistics('traceback')\n"
"\n"
"# pick the biggest memory block\n"
"stat = top_stats[0]\n"
"print(\"%s memory blocks: %.1f KiB\" % (stat.count, stat.size / 1024))\n"
"for line in stat.traceback.format():\n"
"    print(line)"

#: ../../library/tracemalloc.rst:141
msgid ""
"Example of output of the Python test suite (traceback limited to 25 frames)::"
msgstr ""
"Пример вывода набора тестов Python (отслеживание ограничено 25 кадрами):"

#: ../../library/tracemalloc.rst:143
msgid ""
"903 memory blocks: 870.1 KiB\n"
"  File \"<frozen importlib._bootstrap>\", line 716\n"
"  File \"<frozen importlib._bootstrap>\", line 1036\n"
"  File \"<frozen importlib._bootstrap>\", line 934\n"
"  File \"<frozen importlib._bootstrap>\", line 1068\n"
"  File \"<frozen importlib._bootstrap>\", line 619\n"
"  File \"<frozen importlib._bootstrap>\", line 1581\n"
"  File \"<frozen importlib._bootstrap>\", line 1614\n"
"  File \"/usr/lib/python3.4/doctest.py\", line 101\n"
"    import pdb\n"
"  File \"<frozen importlib._bootstrap>\", line 284\n"
"  File \"<frozen importlib._bootstrap>\", line 938\n"
"  File \"<frozen importlib._bootstrap>\", line 1068\n"
"  File \"<frozen importlib._bootstrap>\", line 619\n"
"  File \"<frozen importlib._bootstrap>\", line 1581\n"
"  File \"<frozen importlib._bootstrap>\", line 1614\n"
"  File \"/usr/lib/python3.4/test/support/__init__.py\", line 1728\n"
"    import doctest\n"
"  File \"/usr/lib/python3.4/test/test_pickletools.py\", line 21\n"
"    support.run_doctest(pickletools)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 1276\n"
"    test_runner()\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 976\n"
"    display_failure=not verbose)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 761\n"
"    match_tests=ns.match_tests)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 1563\n"
"    main()\n"
"  File \"/usr/lib/python3.4/test/__main__.py\", line 3\n"
"    regrtest.main_in_temp_cwd()\n"
"  File \"/usr/lib/python3.4/runpy.py\", line 73\n"
"    exec(code, run_globals)\n"
"  File \"/usr/lib/python3.4/runpy.py\", line 160\n"
"    \"__main__\", fname, loader, pkg_name)"
msgstr ""
"903 memory blocks: 870.1 KiB\n"
"  File \"<frozen importlib._bootstrap>\", line 716\n"
"  File \"<frozen importlib._bootstrap>\", line 1036\n"
"  File \"<frozen importlib._bootstrap>\", line 934\n"
"  File \"<frozen importlib._bootstrap>\", line 1068\n"
"  File \"<frozen importlib._bootstrap>\", line 619\n"
"  File \"<frozen importlib._bootstrap>\", line 1581\n"
"  File \"<frozen importlib._bootstrap>\", line 1614\n"
"  File \"/usr/lib/python3.4/doctest.py\", line 101\n"
"    import pdb\n"
"  File \"<frozen importlib._bootstrap>\", line 284\n"
"  File \"<frozen importlib._bootstrap>\", line 938\n"
"  File \"<frozen importlib._bootstrap>\", line 1068\n"
"  File \"<frozen importlib._bootstrap>\", line 619\n"
"  File \"<frozen importlib._bootstrap>\", line 1581\n"
"  File \"<frozen importlib._bootstrap>\", line 1614\n"
"  File \"/usr/lib/python3.4/test/support/__init__.py\", line 1728\n"
"    import doctest\n"
"  File \"/usr/lib/python3.4/test/test_pickletools.py\", line 21\n"
"    support.run_doctest(pickletools)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 1276\n"
"    test_runner()\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 976\n"
"    display_failure=not verbose)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 761\n"
"    match_tests=ns.match_tests)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 1563\n"
"    main()\n"
"  File \"/usr/lib/python3.4/test/__main__.py\", line 3\n"
"    regrtest.main_in_temp_cwd()\n"
"  File \"/usr/lib/python3.4/runpy.py\", line 73\n"
"    exec(code, run_globals)\n"
"  File \"/usr/lib/python3.4/runpy.py\", line 160\n"
"    \"__main__\", fname, loader, pkg_name)"

#: ../../library/tracemalloc.rst:178
msgid ""
"We can see that the most memory was allocated in the :mod:`importlib` module "
"to load data (bytecode and constants) from modules: ``870.1 KiB``. The "
"traceback is where the :mod:`importlib` loaded data most recently: on the "
"``import pdb`` line of the :mod:`doctest` module. The traceback may change "
"if a new module is loaded."
msgstr ""
"Мы видим, что большая часть памяти была выделена в модуле :mod:`importlib` "
"для загрузки данных (байт-кода и констант) из модулей: ``870,1 КиБ``. "
"Обратная трассировка – это место, где :mod:`importlib` загружал данные "
"последним: в строке ``import pdb`` модуля :mod:`doctest`. Обратная "
"трассировка может измениться, если загружен новый модуль."

#: ../../library/tracemalloc.rst:186
msgid "Pretty top"
msgstr "Довольно топ"

#: ../../library/tracemalloc.rst:188
msgid ""
"Code to display the 10 lines allocating the most memory with a pretty "
"output, ignoring ``<frozen importlib._bootstrap>`` and ``<unknown>`` files::"
msgstr ""
"Код для отображения 10 строк, выделяющих больше всего памяти, с красивым "
"выводом, игнорируя файлы ``<frozen importlib._bootstrap>`` и ``<unknown>``::"

#: ../../library/tracemalloc.rst:191
msgid ""
"import linecache\n"
"import os\n"
"import tracemalloc\n"
"\n"
"def display_top(snapshot, key_type='lineno', limit=10):\n"
"    snapshot = snapshot.filter_traces((\n"
"        tracemalloc.Filter(False, \"<frozen importlib._bootstrap>\"),\n"
"        tracemalloc.Filter(False, \"<unknown>\"),\n"
"    ))\n"
"    top_stats = snapshot.statistics(key_type)\n"
"\n"
"    print(\"Top %s lines\" % limit)\n"
"    for index, stat in enumerate(top_stats[:limit], 1):\n"
"        frame = stat.traceback[0]\n"
"        print(\"#%s: %s:%s: %.1f KiB\"\n"
"              % (index, frame.filename, frame.lineno, stat.size / 1024))\n"
"        line = linecache.getline(frame.filename, frame.lineno).strip()\n"
"        if line:\n"
"            print('    %s' % line)\n"
"\n"
"    other = top_stats[limit:]\n"
"    if other:\n"
"        size = sum(stat.size for stat in other)\n"
"        print(\"%s other: %.1f KiB\" % (len(other), size / 1024))\n"
"    total = sum(stat.size for stat in top_stats)\n"
"    print(\"Total allocated size: %.1f KiB\" % (total / 1024))\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"display_top(snapshot)"
msgstr ""
"import linecache\n"
"import os\n"
"import tracemalloc\n"
"\n"
"def display_top(snapshot, key_type='lineno', limit=10):\n"
"    snapshot = snapshot.filter_traces((\n"
"        tracemalloc.Filter(False, \"<frozen importlib._bootstrap>\"),\n"
"        tracemalloc.Filter(False, \"<unknown>\"),\n"
"    ))\n"
"    top_stats = snapshot.statistics(key_type)\n"
"\n"
"    print(\"Top %s lines\" % limit)\n"
"    for index, stat in enumerate(top_stats[:limit], 1):\n"
"        frame = stat.traceback[0]\n"
"        print(\"#%s: %s:%s: %.1f KiB\"\n"
"              % (index, frame.filename, frame.lineno, stat.size / 1024))\n"
"        line = linecache.getline(frame.filename, frame.lineno).strip()\n"
"        if line:\n"
"            print('    %s' % line)\n"
"\n"
"    other = top_stats[limit:]\n"
"    if other:\n"
"        size = sum(stat.size for stat in other)\n"
"        print(\"%s other: %.1f KiB\" % (len(other), size / 1024))\n"
"    total = sum(stat.size for stat in top_stats)\n"
"    print(\"Total allocated size: %.1f KiB\" % (total / 1024))\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"display_top(snapshot)"

#: ../../library/tracemalloc.rst:227
msgid ""
"Top 10 lines\n"
"#1: Lib/base64.py:414: 419.8 KiB\n"
"    _b85chars2 = [(a + b) for a in _b85chars for b in _b85chars]\n"
"#2: Lib/base64.py:306: 419.8 KiB\n"
"    _a85chars2 = [(a + b) for a in _a85chars for b in _a85chars]\n"
"#3: collections/__init__.py:368: 293.6 KiB\n"
"    exec(class_definition, namespace)\n"
"#4: Lib/abc.py:133: 115.2 KiB\n"
"    cls = super().__new__(mcls, name, bases, namespace)\n"
"#5: unittest/case.py:574: 103.1 KiB\n"
"    testMethod()\n"
"#6: Lib/linecache.py:127: 95.4 KiB\n"
"    lines = fp.readlines()\n"
"#7: urllib/parse.py:476: 71.8 KiB\n"
"    for a in _hexdig for b in _hexdig}\n"
"#8: <string>:5: 62.0 KiB\n"
"#9: Lib/_weakrefset.py:37: 60.0 KiB\n"
"    self.data = set()\n"
"#10: Lib/base64.py:142: 59.8 KiB\n"
"    _b32tab2 = [a + b for a in _b32tab for b in _b32tab]\n"
"6220 other: 3602.8 KiB\n"
"Total allocated size: 5303.1 KiB"
msgstr ""
"Top 10 lines\n"
"#1: Lib/base64.py:414: 419.8 KiB\n"
"    _b85chars2 = [(a + b) for a in _b85chars for b in _b85chars]\n"
"#2: Lib/base64.py:306: 419.8 KiB\n"
"    _a85chars2 = [(a + b) for a in _a85chars for b in _a85chars]\n"
"#3: collections/__init__.py:368: 293.6 KiB\n"
"    exec(class_definition, namespace)\n"
"#4: Lib/abc.py:133: 115.2 KiB\n"
"    cls = super().__new__(mcls, name, bases, namespace)\n"
"#5: unittest/case.py:574: 103.1 KiB\n"
"    testMethod()\n"
"#6: Lib/linecache.py:127: 95.4 KiB\n"
"    lines = fp.readlines()\n"
"#7: urllib/parse.py:476: 71.8 KiB\n"
"    for a in _hexdig for b in _hexdig}\n"
"#8: <string>:5: 62.0 KiB\n"
"#9: Lib/_weakrefset.py:37: 60.0 KiB\n"
"    self.data = set()\n"
"#10: Lib/base64.py:142: 59.8 KiB\n"
"    _b32tab2 = [a + b for a in _b32tab for b in _b32tab]\n"
"6220 other: 3602.8 KiB\n"
"Total allocated size: 5303.1 KiB"

#: ../../library/tracemalloc.rst:253
msgid "Record the current and peak size of all traced memory blocks"
msgstr "Запишите текущий и пиковый размер всех отслеживаемых блоков памяти."

#: ../../library/tracemalloc.rst:255
msgid ""
"The following code computes two sums like ``0 + 1 + 2 + ...`` inefficiently, "
"by creating a list of those numbers. This list consumes a lot of memory "
"temporarily. We can use :func:`get_traced_memory` and :func:`reset_peak` to "
"observe the small memory usage after the sum is computed as well as the peak "
"memory usage during the computations::"
msgstr ""
"Следующий код вычисляет две суммы типа «0 + 1 + 2 + ...» неэффективно, "
"создавая список этих чисел. Этот список временно потребляет много памяти. Мы "
"можем использовать :func:`get_traced_memory` и :func:`reset_peak` для "
"наблюдения за небольшим использованием памяти после вычисления суммы, а "
"также за пиковым использованием памяти во время вычислений::"

#: ../../library/tracemalloc.rst:261
msgid ""
"import tracemalloc\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# Example code: compute a sum with a large temporary list\n"
"large_sum = sum(list(range(100000)))\n"
"\n"
"first_size, first_peak = tracemalloc.get_traced_memory()\n"
"\n"
"tracemalloc.reset_peak()\n"
"\n"
"# Example code: compute a sum with a small temporary list\n"
"small_sum = sum(list(range(1000)))\n"
"\n"
"second_size, second_peak = tracemalloc.get_traced_memory()\n"
"\n"
"print(f\"{first_size=}, {first_peak=}\")\n"
"print(f\"{second_size=}, {second_peak=}\")"
msgstr ""
"import tracemalloc\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# Example code: compute a sum with a large temporary list\n"
"large_sum = sum(list(range(100000)))\n"
"\n"
"first_size, first_peak = tracemalloc.get_traced_memory()\n"
"\n"
"tracemalloc.reset_peak()\n"
"\n"
"# Example code: compute a sum with a small temporary list\n"
"small_sum = sum(list(range(1000)))\n"
"\n"
"second_size, second_peak = tracemalloc.get_traced_memory()\n"
"\n"
"print(f\"{first_size=}, {first_peak=}\")\n"
"print(f\"{second_size=}, {second_peak=}\")"

#: ../../library/tracemalloc.rst:280 ../../library/tracemalloc.rst:759
msgid "Output::"
msgstr "Вывод::"

#: ../../library/tracemalloc.rst:282
msgid ""
"first_size=664, first_peak=3592984\n"
"second_size=804, second_peak=29704"
msgstr ""
"first_size=664, first_peak=3592984\n"
"second_size=804, second_peak=29704"

#: ../../library/tracemalloc.rst:285
msgid ""
"Using :func:`reset_peak` ensured we could accurately record the peak during "
"the computation of ``small_sum``, even though it is much smaller than the "
"overall peak size of memory blocks since the :func:`start` call. Without the "
"call to :func:`reset_peak`, ``second_peak`` would still be the peak from the "
"computation ``large_sum`` (that is, equal to ``first_peak``). In this case, "
"both peaks are much higher than the final memory usage, and which suggests "
"we could optimise (by removing the unnecessary call to :class:`list`, and "
"writing ``sum(range(...))``)."
msgstr ""
"Использование :func:`reset_peak` гарантировало, что мы сможем точно записать "
"пик во время вычисления ``small_sum``, хотя он намного меньше, чем общий "
"пиковый размер блоков памяти с момента вызова :func:`start`. Без вызова :"
"func:`reset_peak` `` Second_peak`` всё равно будет пиком вычисления "
"``large_sum`` (то есть равным ``first_peak``). В данном случае оба пика "
"намного превышают итоговое использование памяти, что предполагает, что мы "
"могли бы оптимизировать (удалив ненужный вызов :class:`list` и написав "
"``sum(range(...))`` )."

#: ../../library/tracemalloc.rst:295
msgid "API"
msgstr "API"

#: ../../library/tracemalloc.rst:298
msgid "Functions"
msgstr "Функции"

#: ../../library/tracemalloc.rst:302
msgid "Clear traces of memory blocks allocated by Python."
msgstr "Очистите следы блоков памяти, выделенных Python."

#: ../../library/tracemalloc.rst:304
msgid "See also :func:`stop`."
msgstr "См. также :func:`stop`."

#: ../../library/tracemalloc.rst:309
msgid ""
"Get the traceback where the Python object *obj* was allocated. Return a :"
"class:`Traceback` instance, or ``None`` if the :mod:`tracemalloc` module is "
"not tracing memory allocations or did not trace the allocation of the object."
msgstr ""
"Получите обратную трассировку, в которой был выделен объект Python *obj*. "
"Возвращает экземпляр :class:`Traceback` или ``None``, если модуль :mod:"
"`tracemalloc` не отслеживает выделение памяти или не отслеживает выделение "
"объекта."

#: ../../library/tracemalloc.rst:314
msgid "See also :func:`gc.get_referrers` and :func:`sys.getsizeof` functions."
msgstr "См. также функции :func:`gc.get_referrers` и :func:`sys.getsizeof`."

#: ../../library/tracemalloc.rst:319
msgid "Get the maximum number of frames stored in the traceback of a trace."
msgstr ""
"Получите максимальное количество кадров, хранящихся в обратной трассировке "
"трассировки."

#: ../../library/tracemalloc.rst:321
msgid ""
"The :mod:`tracemalloc` module must be tracing memory allocations to get the "
"limit, otherwise an exception is raised."
msgstr ""
"Модуль :mod:`tracemalloc` должен отслеживать выделение памяти, чтобы "
"получить предел, в противном случае будет выдано исключение."

#: ../../library/tracemalloc.rst:324
msgid "The limit is set by the :func:`start` function."
msgstr "Предел устанавливается функцией :func:`start`."

#: ../../library/tracemalloc.rst:329
msgid ""
"Get the current size and peak size of memory blocks traced by the :mod:"
"`tracemalloc` module as a tuple: ``(current: int, peak: int)``."
msgstr ""
"Получите текущий размер и пиковый размер блоков памяти, отслеживаемых "
"модулем :mod:`tracemalloc`, в виде кортежа: ``(current: int,peak: int)``."

#: ../../library/tracemalloc.rst:335
msgid ""
"Set the peak size of memory blocks traced by the :mod:`tracemalloc` module "
"to the current size."
msgstr ""
"Установите максимальный размер блоков памяти, отслеживаемых модулем :mod:"
"`tracemalloc`, равным текущему размеру."

#: ../../library/tracemalloc.rst:338
msgid ""
"Do nothing if the :mod:`tracemalloc` module is not tracing memory "
"allocations."
msgstr ""
"Ничего не делайте, если модуль :mod:`tracemalloc` не отслеживает "
"распределение памяти."

#: ../../library/tracemalloc.rst:341
msgid ""
"This function only modifies the recorded peak size, and does not modify or "
"clear any traces, unlike :func:`clear_traces`. Snapshots taken with :func:"
"`take_snapshot` before a call to :func:`reset_peak` can be meaningfully "
"compared to snapshots taken after the call."
msgstr ""
"Эта функция только изменяет размер записанного пика и не изменяет и не "
"очищает какие-либо кривые, в отличие от :func:`clear_traces`. Снимки, "
"сделанные с помощью :func:`take_snapshot` до вызова :func:`reset_peak`, "
"можно осмысленно сравнивать со снимками, сделанными после вызова."

#: ../../library/tracemalloc.rst:346
msgid "See also :func:`get_traced_memory`."
msgstr "См. также :func:`get_traced_memory`."

#: ../../library/tracemalloc.rst:353
msgid ""
"Get the memory usage in bytes of the :mod:`tracemalloc` module used to store "
"traces of memory blocks. Return an :class:`int`."
msgstr ""
"Получите использование памяти в байтах модуля :mod:`tracemalloc`, "
"используемого для хранения следов блоков памяти. Верните :class:`int`."

#: ../../library/tracemalloc.rst:360
msgid ""
"``True`` if the :mod:`tracemalloc` module is tracing Python memory "
"allocations, ``False`` otherwise."
msgstr ""
"``True``, если модуль :mod:`tracemalloc` отслеживает распределение памяти "
"Python, ``False`` в противном случае."

#: ../../library/tracemalloc.rst:363
msgid "See also :func:`start` and :func:`stop` functions."
msgstr "См. также функции :func:`start` и :func:`stop`."

#: ../../library/tracemalloc.rst:368
msgid ""
"Start tracing Python memory allocations: install hooks on Python memory "
"allocators. Collected tracebacks of traces will be limited to *nframe* "
"frames. By default, a trace of a memory block only stores the most recent "
"frame: the limit is ``1``. *nframe* must be greater or equal to ``1``."
msgstr ""
"Начните отслеживать распределение памяти Python: установите перехватчики на "
"распределители памяти Python. Собранные обратные трассировки будут "
"ограничены кадрами *nframe*. По умолчанию трассировка блока памяти сохраняет "
"только самый последний кадр: предел равен «1». *nframe* должен быть больше "
"или равен ``1``."

#: ../../library/tracemalloc.rst:373
msgid ""
"You can still read the original number of total frames that composed the "
"traceback by looking at the :attr:`Traceback.total_nframe` attribute."
msgstr ""
"Вы по-прежнему можете прочитать исходное общее количество кадров, "
"составляющих обратную трассировку, посмотрев атрибут :attr:`Traceback."
"total_nframe`."

#: ../../library/tracemalloc.rst:376
msgid ""
"Storing more than ``1`` frame is only useful to compute statistics grouped "
"by ``'traceback'`` or to compute cumulative statistics: see the :meth:"
"`Snapshot.compare_to` and :meth:`Snapshot.statistics` methods."
msgstr ""
"Сохранение более одного кадра полезно только для вычисления статистики, "
"сгруппированной по ``traceback'``, или для вычисления совокупной статистики: "
"см. методы :meth:`Snapshot.compare_to` и :meth:`Snapshot.statistics` ."

#: ../../library/tracemalloc.rst:380
msgid ""
"Storing more frames increases the memory and CPU overhead of the :mod:"
"`tracemalloc` module. Use the :func:`get_tracemalloc_memory` function to "
"measure how much memory is used by the :mod:`tracemalloc` module."
msgstr ""
"Сохранение большего количества кадров увеличивает нагрузку на память и "
"процессор модуля :mod:`tracemalloc`. Используйте функцию :func:"
"`get_tracemalloc_memory`, чтобы измерить, сколько памяти используется "
"модулем :mod:`tracemalloc`."

#: ../../library/tracemalloc.rst:384
msgid ""
"The :envvar:`PYTHONTRACEMALLOC` environment variable "
"(``PYTHONTRACEMALLOC=NFRAME``) and the :option:`-X` ``tracemalloc=NFRAME`` "
"command line option can be used to start tracing at startup."
msgstr ""
"Переменная среды :envvar:`PYTHONTRACEMALLOC` (``PYTHONTRACEMALLOC=NFRAME``) "
"и параметр командной строки :option:`-X` ``tracemalloc=NFRAME`` могут "
"использоваться для запуска трассировки при запуске."

#: ../../library/tracemalloc.rst:388
msgid ""
"See also :func:`stop`, :func:`is_tracing` and :func:`get_traceback_limit` "
"functions."
msgstr ""
"См. также функции :func:`stop`, :func:`is_tracing` и :func:"
"`get_traceback_limit`."

#: ../../library/tracemalloc.rst:394
msgid ""
"Stop tracing Python memory allocations: uninstall hooks on Python memory "
"allocators. Also clears all previously collected traces of memory blocks "
"allocated by Python."
msgstr ""
"Прекратите отслеживать распределение памяти Python: удалите перехватчики на "
"распределителях памяти Python. Также очищает все ранее собранные следы "
"блоков памяти, выделенных Python."

#: ../../library/tracemalloc.rst:398
msgid ""
"Call :func:`take_snapshot` function to take a snapshot of traces before "
"clearing them."
msgstr ""
"Вызовите функцию :func:`take_snapshot`, чтобы сделать снимок трасс перед их "
"очисткой."

#: ../../library/tracemalloc.rst:401
msgid ""
"See also :func:`start`, :func:`is_tracing` and :func:`clear_traces` "
"functions."
msgstr ""
"См. также функции :func:`start`, :func:`is_tracing` и :func:`clear_traces`."

#: ../../library/tracemalloc.rst:407
msgid ""
"Take a snapshot of traces of memory blocks allocated by Python. Return a "
"new :class:`Snapshot` instance."
msgstr ""
"Сделайте снимок следов блоков памяти, выделенных Python. Верните новый "
"экземпляр :class:`Snapshot`."

#: ../../library/tracemalloc.rst:410
msgid ""
"The snapshot does not include memory blocks allocated before the :mod:"
"`tracemalloc` module started to trace memory allocations."
msgstr ""
"Снимок не включает блоки памяти, выделенные до того, как модуль :mod:"
"`tracemalloc` начал отслеживать распределение памяти."

#: ../../library/tracemalloc.rst:413
msgid ""
"Tracebacks of traces are limited to :func:`get_traceback_limit` frames. Use "
"the *nframe* parameter of the :func:`start` function to store more frames."
msgstr ""
"Обратные трассировки ограничены кадрами :func:`get_traceback_limit`. "
"Используйте параметр *nframe* функции :func:`start` для хранения большего "
"количества кадров."

#: ../../library/tracemalloc.rst:416
msgid ""
"The :mod:`tracemalloc` module must be tracing memory allocations to take a "
"snapshot, see the :func:`start` function."
msgstr ""
"Модуль :mod:`tracemalloc` должен отслеживать распределение памяти, чтобы "
"сделать снимок, см. функцию :func:`start`."

#: ../../library/tracemalloc.rst:419
msgid "See also the :func:`get_object_traceback` function."
msgstr "См. также функцию :func:`get_object_traceback`."

#: ../../library/tracemalloc.rst:423
msgid "DomainFilter"
msgstr "DomainFilter"

#: ../../library/tracemalloc.rst:427
msgid "Filter traces of memory blocks by their address space (domain)."
msgstr "Фильтровать следы блоков памяти по их адресному пространству (домену)."

#: ../../library/tracemalloc.rst:433
msgid ""
"If *inclusive* is ``True`` (include), match memory blocks allocated in the "
"address space :attr:`domain`."
msgstr ""
"Если *inclusive* имеет значение True (include), сопоставьте блоки памяти, "
"выделенные в адресном пространстве :attr:`domain`."

#: ../../library/tracemalloc.rst:436
msgid ""
"If *inclusive* is ``False`` (exclude), match memory blocks not allocated in "
"the address space :attr:`domain`."
msgstr ""
"Если *inclusive* имеет значение «False» (исключить), совпадают блоки памяти, "
"не выделенные в адресном пространстве :attr:`domain`."

#: ../../library/tracemalloc.rst:441 ../../library/tracemalloc.rst:693
msgid "Address space of a memory block (``int``). Read-only property."
msgstr ""
"Адресное пространство блока памяти (``int``). Свойство только для чтения."

#: ../../library/tracemalloc.rst:445
msgid "Filter"
msgstr "Фильтр"

#: ../../library/tracemalloc.rst:449
msgid "Filter on traces of memory blocks."
msgstr "Фильтрация по следам блоков памяти."

#: ../../library/tracemalloc.rst:451
msgid ""
"See the :func:`fnmatch.fnmatch` function for the syntax of "
"*filename_pattern*. The ``'.pyc'`` file extension is replaced with ``'.py'``."
msgstr ""
"Синтаксис *filename_pattern* см. в функции :func:`fnmatch.fnmatch`. "
"Расширение файла ``'.pyc'`` заменяется на ``'.py'``."

#: ../../library/tracemalloc.rst:455
msgid "Examples:"
msgstr "Примеры:"

#: ../../library/tracemalloc.rst:457
msgid ""
"``Filter(True, subprocess.__file__)`` only includes traces of the :mod:"
"`subprocess` module"
msgstr ""
"``Filter(True, subprocess.__file__)`` включает только следы модуля :mod:"
"`subprocess`"

#: ../../library/tracemalloc.rst:459
msgid ""
"``Filter(False, tracemalloc.__file__)`` excludes traces of the :mod:"
"`tracemalloc` module"
msgstr ""
"``Filter(False,tracemalloc.__file__)`` исключает следы модуля :mod:"
"`tracemalloc`"

#: ../../library/tracemalloc.rst:461
msgid "``Filter(False, \"<unknown>\")`` excludes empty tracebacks"
msgstr "``Filter(False, \"<unknown>\")`` исключает пустые обратные трассировки"

#: ../../library/tracemalloc.rst:464
msgid "The ``'.pyo'`` file extension is no longer replaced with ``'.py'``."
msgstr "Расширение файла ``'.pyo'`` больше не заменяется на ``'.py'``."

#: ../../library/tracemalloc.rst:467 ../../library/tracemalloc.rst:688
msgid "Added the :attr:`domain` attribute."
msgstr "Добавлен атрибут :attr:`domain`."

#: ../../library/tracemalloc.rst:473
msgid "Address space of a memory block (``int`` or ``None``)."
msgstr "Адресное пространство блока памяти («int» или «None»)."

#: ../../library/tracemalloc.rst:475 ../../library/tracemalloc.rst:695
msgid ""
"tracemalloc uses the domain ``0`` to trace memory allocations made by "
"Python. C extensions can use other domains to trace other resources."
msgstr ""
"Tracemalloc использует домен ``0`` для отслеживания распределения памяти, "
"выполняемого Python. Расширения C могут использовать другие домены для "
"отслеживания других ресурсов."

#: ../../library/tracemalloc.rst:480
msgid ""
"If *inclusive* is ``True`` (include), only match memory blocks allocated in "
"a file with a name matching :attr:`filename_pattern` at line number :attr:"
"`lineno`."
msgstr ""
"Если *inclusive* имеет значение ``True`` (include), сопоставлять только "
"блоки памяти, выделенные в файле с именем, соответствующим :attr:"
"`filename_pattern` по номеру строки :attr:`lineno`."

#: ../../library/tracemalloc.rst:484
msgid ""
"If *inclusive* is ``False`` (exclude), ignore memory blocks allocated in a "
"file with a name matching :attr:`filename_pattern` at line number :attr:"
"`lineno`."
msgstr ""
"Если *inclusive* имеет значение False (исключить), игнорируйте блоки памяти, "
"выделенные в файле с именем, соответствующим :attr:`filename_pattern` в "
"номере строки :attr:`lineno`."

#: ../../library/tracemalloc.rst:490
msgid ""
"Line number (``int``) of the filter. If *lineno* is ``None``, the filter "
"matches any line number."
msgstr ""
"Номер строки (``int``) фильтра. Если *lineno* имеет значение «Нет», фильтр "
"соответствует любому номеру строки."

#: ../../library/tracemalloc.rst:495
msgid "Filename pattern of the filter (``str``). Read-only property."
msgstr "Шаблон имени файла фильтра (``str``). Свойство только для чтения."

#: ../../library/tracemalloc.rst:499
msgid ""
"If *all_frames* is ``True``, all frames of the traceback are checked. If "
"*all_frames* is ``False``, only the most recent frame is checked."
msgstr ""
"Если *all_frames* имеет значение True, проверяются все кадры обратной "
"трассировки. Если *all_frames* имеет значение «False», проверяется только "
"самый последний кадр."

#: ../../library/tracemalloc.rst:502
msgid ""
"This attribute has no effect if the traceback limit is ``1``.  See the :func:"
"`get_traceback_limit` function and :attr:`Snapshot.traceback_limit` "
"attribute."
msgstr ""
"Этот атрибут не имеет никакого эффекта, если предел трассировки равен «1». "
"См. функцию :func:`get_traceback_limit` и атрибут :attr:`Snapshot."
"traceback_limit`."

#: ../../library/tracemalloc.rst:508
msgid "Frame"
msgstr "Рамка"

#: ../../library/tracemalloc.rst:512
msgid "Frame of a traceback."
msgstr "Кадр обратной трассировки."

#: ../../library/tracemalloc.rst:514
msgid "The :class:`Traceback` class is a sequence of :class:`Frame` instances."
msgstr ""
"Класс :class:`Traceback` представляет собой последовательность экземпляров :"
"class:`Frame`."

#: ../../library/tracemalloc.rst:518
msgid "Filename (``str``)."
msgstr "Имя файла (``str``)."

#: ../../library/tracemalloc.rst:522
msgid "Line number (``int``)."
msgstr "Номер строки (``int``)."

#: ../../library/tracemalloc.rst:526
msgid "Snapshot"
msgstr "Снимок"

#: ../../library/tracemalloc.rst:530
msgid "Snapshot of traces of memory blocks allocated by Python."
msgstr "Снимок следов блоков памяти, выделенных Python."

#: ../../library/tracemalloc.rst:532
msgid "The :func:`take_snapshot` function creates a snapshot instance."
msgstr "Функция :func:`take_snapshot` создает экземпляр моментального снимка."

#: ../../library/tracemalloc.rst:536
msgid ""
"Compute the differences with an old snapshot. Get statistics as a sorted "
"list of :class:`StatisticDiff` instances grouped by *key_type*."
msgstr ""
"Вычислите различия, используя старый снимок. Получите статистику в виде "
"отсортированного списка экземпляров :class:`StatisticDiff`, сгруппированных "
"по *key_type*."

#: ../../library/tracemalloc.rst:539
msgid ""
"See the :meth:`Snapshot.statistics` method for *key_type* and *cumulative* "
"parameters."
msgstr ""
"См. метод :meth:`Snapshot.statistics` для параметров *key_type* и "
"*cumulative*."

#: ../../library/tracemalloc.rst:542
msgid ""
"The result is sorted from the biggest to the smallest by: absolute value of :"
"attr:`StatisticDiff.size_diff`, :attr:`StatisticDiff.size`, absolute value "
"of :attr:`StatisticDiff.count_diff`, :attr:`Statistic.count` and then by :"
"attr:`StatisticDiff.traceback`."
msgstr ""
"Результат сортируется от наибольшего к наименьшему по: абсолютному значению :"
"attr:`StatisticDiff.size_diff`, :attr:`StatisticDiff.size`, абсолютному "
"значению :attr:`StatisticDiff.count_diff`, :attr:`Statistic .count`, а "
"затем :attr:`StatisticDiff.traceback`."

#: ../../library/tracemalloc.rst:550
msgid "Write the snapshot into a file."
msgstr "Запишите снимок в файл."

#: ../../library/tracemalloc.rst:552
msgid "Use :meth:`load` to reload the snapshot."
msgstr "Используйте :meth:`load`, чтобы перезагрузить снимок."

#: ../../library/tracemalloc.rst:557
msgid ""
"Create a new :class:`Snapshot` instance with a filtered :attr:`traces` "
"sequence, *filters* is a list of :class:`DomainFilter` and :class:`Filter` "
"instances.  If *filters* is an empty list, return a new :class:`Snapshot` "
"instance with a copy of the traces."
msgstr ""
"Создайте новый экземпляр :class:`Snapshot` с отфильтрованной "
"последовательностью :attr:`traces`, *filters* — это список экземпляров :"
"class:`DomainFilter` и :class:`Filter`. Если *filters* — пустой список, "
"верните новый экземпляр :class:`Snapshot` с копией трассировок."

#: ../../library/tracemalloc.rst:562
msgid ""
"All inclusive filters are applied at once, a trace is ignored if no "
"inclusive filters match it. A trace is ignored if at least one exclusive "
"filter matches it."
msgstr ""
"Все включающие фильтры применяются одновременно; трассировка игнорируется, "
"если ей не соответствует ни один включающий фильтр. Трассировка "
"игнорируется, если ей соответствует хотя бы один эксклюзивный фильтр."

#: ../../library/tracemalloc.rst:566
msgid ":class:`DomainFilter` instances are now also accepted in *filters*."
msgstr "Экземпляры :class:`DomainFilter` теперь также принимаются в *filters*."

#: ../../library/tracemalloc.rst:572
msgid "Load a snapshot from a file."
msgstr "Загрузите снимок из файла."

#: ../../library/tracemalloc.rst:574
msgid "See also :meth:`dump`."
msgstr "См. также :meth:`dump`."

#: ../../library/tracemalloc.rst:579
msgid ""
"Get statistics as a sorted list of :class:`Statistic` instances grouped by "
"*key_type*:"
msgstr ""
"Получите статистику в виде отсортированного списка экземпляров :class:"
"`Statistic`, сгруппированных по *key_type*:"

#: ../../library/tracemalloc.rst:583
msgid "key_type"
msgstr "key_type"

#: ../../library/tracemalloc.rst:583
msgid "description"
msgstr "описание"

#: ../../library/tracemalloc.rst:585
msgid "``'filename'``"
msgstr "``'filename'``"

#: ../../library/tracemalloc.rst:585
msgid "filename"
msgstr "имя файла"

#: ../../library/tracemalloc.rst:586
msgid "``'lineno'``"
msgstr "``'lineno'``"

#: ../../library/tracemalloc.rst:586
msgid "filename and line number"
msgstr "имя файла и номер строки"

#: ../../library/tracemalloc.rst:587
msgid "``'traceback'``"
msgstr "``'traceback'``"

#: ../../library/tracemalloc.rst:587
msgid "traceback"
msgstr "трассировка"

#: ../../library/tracemalloc.rst:590
msgid ""
"If *cumulative* is ``True``, cumulate size and count of memory blocks of all "
"frames of the traceback of a trace, not only the most recent frame. The "
"cumulative mode can only be used with *key_type* equals to ``'filename'`` "
"and ``'lineno'``."
msgstr ""
"Если *cumulative* имеет значение True, суммируется размер и количество "
"блоков памяти всех кадров обратной трассировки, а не только самого "
"последнего кадра. Накопительный режим можно использовать только с "
"*key_type*, равным ``'filename'`` и ``'lineno'``."

#: ../../library/tracemalloc.rst:595
msgid ""
"The result is sorted from the biggest to the smallest by: :attr:`Statistic."
"size`, :attr:`Statistic.count` and then by :attr:`Statistic.traceback`."
msgstr ""
"Результат сортируется от наибольшего к наименьшему по: :attr:`Statistic."
"size`, :attr:`Statistic.count`, а затем по :attr:`Statistic.traceback`."

#: ../../library/tracemalloc.rst:602
msgid ""
"Maximum number of frames stored in the traceback of :attr:`traces`: result "
"of the :func:`get_traceback_limit` when the snapshot was taken."
msgstr ""
"Максимальное количество кадров, хранящихся в обратной трассировке :attr:"
"`traces`: результата :func:`get_traceback_limit` при создании моментального "
"снимка."

#: ../../library/tracemalloc.rst:607
msgid ""
"Traces of all memory blocks allocated by Python: sequence of :class:`Trace` "
"instances."
msgstr ""
"Трассировки всех блоков памяти, выделенных Python: последовательность "
"экземпляров :class:`Trace`."

#: ../../library/tracemalloc.rst:610
msgid ""
"The sequence has an undefined order. Use the :meth:`Snapshot.statistics` "
"method to get a sorted list of statistics."
msgstr ""
"Последовательность имеет неопределенный порядок. Используйте метод :meth:"
"`Snapshot.statistics`, чтобы получить отсортированный список статистики."

#: ../../library/tracemalloc.rst:615
msgid "Statistic"
msgstr "Статистика"

#: ../../library/tracemalloc.rst:619
msgid "Statistic on memory allocations."
msgstr "Статистика распределения памяти."

#: ../../library/tracemalloc.rst:621
msgid ""
":func:`Snapshot.statistics` returns a list of :class:`Statistic` instances."
msgstr ""
":func:`Snapshot.statistics` возвращает список экземпляров :class:`Statistic`."

#: ../../library/tracemalloc.rst:623
msgid "See also the :class:`StatisticDiff` class."
msgstr "См. также класс :class:`StatisticDiff`."

#: ../../library/tracemalloc.rst:627
msgid "Number of memory blocks (``int``)."
msgstr "Количество блоков памяти (``int``)."

#: ../../library/tracemalloc.rst:631
msgid "Total size of memory blocks in bytes (``int``)."
msgstr "Общий размер блоков памяти в байтах (int)."

#: ../../library/tracemalloc.rst:635 ../../library/tracemalloc.rst:704
msgid ""
"Traceback where the memory block was allocated, :class:`Traceback` instance."
msgstr "Traceback, где был выделен блок памяти, экземпляр :class:`Traceback`."

#: ../../library/tracemalloc.rst:640
msgid "StatisticDiff"
msgstr "StatisticDiff"

#: ../../library/tracemalloc.rst:644
msgid ""
"Statistic difference on memory allocations between an old and a new :class:"
"`Snapshot` instance."
msgstr ""
"Статистическая разница в распределении памяти между старым и новым "
"экземпляром :class:`Snapshot`."

#: ../../library/tracemalloc.rst:647
msgid ""
":func:`Snapshot.compare_to` returns a list of :class:`StatisticDiff` "
"instances. See also the :class:`Statistic` class."
msgstr ""
":func:`Snapshot.compare_to` возвращает список экземпляров :class:"
"`StatisticDiff`. См. также класс :class:`Statistic`."

#: ../../library/tracemalloc.rst:652
msgid ""
"Number of memory blocks in the new snapshot (``int``): ``0`` if the memory "
"blocks have been released in the new snapshot."
msgstr ""
"Количество блоков памяти в новом снимке («int»): «0», если блоки памяти были "
"освобождены в новом снимке."

#: ../../library/tracemalloc.rst:657
msgid ""
"Difference of number of memory blocks between the old and the new snapshots "
"(``int``): ``0`` if the memory blocks have been allocated in the new "
"snapshot."
msgstr ""
"Разница в количестве блоков памяти между старым и новым снимками («int»): "
"«0», если блоки памяти были выделены в новом снимке."

#: ../../library/tracemalloc.rst:663
msgid ""
"Total size of memory blocks in bytes in the new snapshot (``int``): ``0`` if "
"the memory blocks have been released in the new snapshot."
msgstr ""
"Общий размер блоков памяти в байтах в новом снимке («int»): «0», если блоки "
"памяти были освобождены в новом снимке."

#: ../../library/tracemalloc.rst:668
msgid ""
"Difference of total size of memory blocks in bytes between the old and the "
"new snapshots (``int``): ``0`` if the memory blocks have been allocated in "
"the new snapshot."
msgstr ""
"Разница общего размера блоков памяти в байтах между старым и новым снимками "
"(«int»): «0», если блоки памяти были выделены в новом снимке."

#: ../../library/tracemalloc.rst:674
msgid ""
"Traceback where the memory blocks were allocated, :class:`Traceback` "
"instance."
msgstr ""
"Traceback, где были выделены блоки памяти, экземпляр :class:`Traceback`."

#: ../../library/tracemalloc.rst:679
msgid "Trace"
msgstr "Trace"

#: ../../library/tracemalloc.rst:683
msgid "Trace of a memory block."
msgstr "Трассировка блока памяти."

#: ../../library/tracemalloc.rst:685
msgid ""
"The :attr:`Snapshot.traces` attribute is a sequence of :class:`Trace` "
"instances."
msgstr ""
"Атрибут :attr:`Snapshot.traces` представляет собой последовательность "
"экземпляров :class:`Trace`."

#: ../../library/tracemalloc.rst:700
msgid "Size of the memory block in bytes (``int``)."
msgstr "Размер блока памяти в байтах (int)."

#: ../../library/tracemalloc.rst:709
msgid "Traceback"
msgstr "трассировка"

#: ../../library/tracemalloc.rst:713
msgid ""
"Sequence of :class:`Frame` instances sorted from the oldest frame to the "
"most recent frame."
msgstr ""
"Последовательность экземпляров :class:`Frame`, отсортированная от самого "
"старого кадра до самого последнего."

#: ../../library/tracemalloc.rst:716
msgid ""
"A traceback contains at least ``1`` frame. If the ``tracemalloc`` module "
"failed to get a frame, the filename ``\"<unknown>\"`` at line number ``0`` "
"is used."
msgstr ""
"Обратная трассировка содержит как минимум 1 кадр. Если модулю "
"``tracemalloc`` не удалось получить кадр, используется имя файла "
"``\"<unknown>\"`` в строке с номером ``0``."

#: ../../library/tracemalloc.rst:720
msgid ""
"When a snapshot is taken, tracebacks of traces are limited to :func:"
"`get_traceback_limit` frames. See the :func:`take_snapshot` function. The "
"original number of frames of the traceback is stored in the :attr:`Traceback."
"total_nframe` attribute. That allows to know if a traceback has been "
"truncated by the traceback limit."
msgstr ""
"При создании моментального снимка обратные трассировки ограничиваются "
"кадрами :func:`get_traceback_limit`. См. функцию :func:`take_snapshot`. "
"Исходное количество кадров обратной трассировки хранится в атрибуте :attr:"
"`Traceback.total_nframe`. Это позволяет узнать, была ли обратная трассировка "
"усечена пределом трассировки."

#: ../../library/tracemalloc.rst:726
msgid ""
"The :attr:`Trace.traceback` attribute is an instance of :class:`Traceback` "
"instance."
msgstr ""
"Атрибут :attr:`Trace.traceback` является экземпляром экземпляра :class:"
"`Traceback`."

#: ../../library/tracemalloc.rst:729
msgid ""
"Frames are now sorted from the oldest to the most recent, instead of most "
"recent to oldest."
msgstr ""
"Кадры теперь сортируются от самых старых к самым последним, а не от самых "
"последних к самым старым."

#: ../../library/tracemalloc.rst:734
msgid ""
"Total number of frames that composed the traceback before truncation. This "
"attribute can be set to ``None`` if the information is not available."
msgstr ""
"Общее количество кадров, составлявших обратную трассировку до усечения. Для "
"этого атрибута можно установить значение «Нет», если информация недоступна."

#: ../../library/tracemalloc.rst:738
msgid "The :attr:`Traceback.total_nframe` attribute was added."
msgstr "Добавлен атрибут :attr:`Traceback.total_nframe`."

#: ../../library/tracemalloc.rst:743
msgid ""
"Format the traceback as a list of lines. Use the :mod:`linecache` module to "
"retrieve lines from the source code. If *limit* is set, format the *limit* "
"most recent frames if *limit* is positive. Otherwise, format the "
"``abs(limit)`` oldest frames. If *most_recent_first* is ``True``, the order "
"of the formatted frames is reversed, returning the most recent frame first "
"instead of last."
msgstr ""
"Отформатируйте обратную трассировку как список строк. Используйте модуль :"
"mod:`linecache` для получения строк из исходного кода. Если установлен "
"*limit*, отформатируйте *limit* самые последние кадры, если *limit* "
"положителен. В противном случае отформатируйте самые старые кадры "
"abs(limit). Если *most_recent_first* имеет значение True, порядок "
"форматируемых кадров меняется на обратный, и первым возвращается самый "
"последний кадр, а не последний."

#: ../../library/tracemalloc.rst:750
msgid ""
"Similar to the :func:`traceback.format_tb` function, except that :meth:`."
"format` does not include newlines."
msgstr ""
"Аналогично функции :func:`traceback.format_tb`, за исключением того, что :"
"meth:`.format` не включает символы новой строки."

#: ../../library/tracemalloc.rst:753
msgid "Example::"
msgstr "Пример::"

#: ../../library/tracemalloc.rst:755
msgid ""
"print(\"Traceback (most recent call first):\")\n"
"for line in traceback:\n"
"    print(line)"
msgstr ""
"print(\"Traceback (most recent call first):\")\n"
"for line in traceback:\n"
"    print(line)"

#: ../../library/tracemalloc.rst:761
msgid ""
"Traceback (most recent call first):\n"
"  File \"test.py\", line 9\n"
"    obj = Object()\n"
"  File \"test.py\", line 12\n"
"    tb = tracemalloc.get_object_traceback(f())"
msgstr ""
"Traceback (most recent call first):\n"
"  File \"test.py\", line 9\n"
"    obj = Object()\n"
"  File \"test.py\", line 12\n"
"    tb = tracemalloc.get_object_traceback(f())"
