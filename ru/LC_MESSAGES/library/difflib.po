# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Kristina Mironova, 2021
# decorator_factory <decorator-factory+transifex@yandex.ru>, 2021
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:04+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/difflib.rst:2
msgid ":mod:`!difflib` --- Helpers for computing deltas"
msgstr ":mod:`!difflib` --- Помощники для вычисления дельт"

#: ../../library/difflib.rst:11
msgid "**Source code:** :source:`Lib/difflib.py`"
msgstr "**Исходный код:** :source:`Lib/difflib.py`"

#: ../../library/difflib.rst:20
msgid ""
"This module provides classes and functions for comparing sequences. It can "
"be used for example, for comparing files, and can produce information about "
"file differences in various formats, including HTML and context and unified "
"diffs. For comparing directories and files, see also, the :mod:`filecmp` "
"module."
msgstr ""
"Этот модуль предоставляет классы и функции для сравнения "
"последовательностей. Его можно использовать, например, для сравнения файлов "
"и предоставлять информацию о различиях файлов в различных форматах, включая "
"HTML, контекст и унифицированные различия. Для сравнения каталогов и файлов "
"см. также модуль :mod:`filecmp`."

#: ../../library/difflib.rst:29
msgid ""
"This is a flexible class for comparing pairs of sequences of any type, so "
"long as the sequence elements are :term:`hashable`.  The basic algorithm "
"predates, and is a little fancier than, an algorithm published in the late "
"1980's by Ratcliff and Obershelp under the hyperbolic name \"gestalt pattern "
"matching.\"  The idea is to find the longest contiguous matching subsequence "
"that contains no \"junk\" elements; these \"junk\" elements are ones that "
"are uninteresting in some sense, such as blank lines or whitespace.  "
"(Handling junk is an extension to the Ratcliff and Obershelp algorithm.) The "
"same idea is then applied recursively to the pieces of the sequences to the "
"left and to the right of the matching subsequence.  This does not yield "
"minimal edit sequences, but does tend to yield matches that \"look right\" "
"to people."
msgstr ""
"Это гибкий класс для сравнения пар последовательностей любого типа, при "
"условии, что элементы последовательности являются :term:`hashable`. Базовый "
"алгоритм предшествует алгоритму, опубликованному в конце 1980-х годов "
"Рэтклиффом и Оберсхелпом под гиперболическим названием «сопоставление "
"гештальт-образцов» и является немного более сложным, чем алгоритм. Идея "
"состоит в том, чтобы найти самую длинную непрерывную совпадающую "
"подпоследовательность, которая не содержит «мусорных» элементов; эти "
"«мусорные» элементы в некотором смысле неинтересны, например, пустые строки "
"или пробелы. (Обработка мусора является расширением алгоритма Рэтклиффа и "
"Оберсхелпа.) Затем та же идея рекурсивно применяется к частям "
"последовательностей слева и справа от совпадающей подпоследовательности. Это "
"не дает минимальных последовательностей редактирования, но имеет тенденцию "
"давать совпадения, которые «выглядят правильно» для людей."

#: ../../library/difflib.rst:41
msgid ""
"**Timing:** The basic Ratcliff-Obershelp algorithm is cubic time in the "
"worst case and quadratic time in the expected case. :class:`SequenceMatcher` "
"is quadratic time for the worst case and has expected-case behavior "
"dependent in a complicated way on how many elements the sequences have in "
"common; best case time is linear."
msgstr ""
"**Время.** Основной алгоритм Рэтклиффа-Оберсхелпа использует кубическое "
"время в худшем случае и квадратичное время в ожидаемом случае. :class:"
"`SequenceMatcher` представляет собой квадратичное время для наихудшего "
"случая и имеет ожидаемое поведение, сложным образом зависящее от того, "
"сколько общих элементов имеют последовательности; в лучшем случае время "
"линейно."

#: ../../library/difflib.rst:47
msgid ""
"**Automatic junk heuristic:** :class:`SequenceMatcher` supports a heuristic "
"that automatically treats certain sequence items as junk. The heuristic "
"counts how many times each individual item appears in the sequence. If an "
"item's duplicates (after the first one) account for more than 1% of the "
"sequence and the sequence is at least 200 items long, this item is marked as "
"\"popular\" and is treated as junk for the purpose of sequence matching. "
"This heuristic can be turned off by setting the ``autojunk`` argument to "
"``False`` when creating the :class:`SequenceMatcher`."
msgstr ""
"**Автоматическая эвристика нежелательной почты:** :class:`SequenceMatcher` "
"поддерживает эвристику, которая автоматически рассматривает определенные "
"элементы последовательности как ненужную. Эвристика подсчитывает, сколько "
"раз каждый отдельный элемент появляется в последовательности. Если дубликаты "
"элемента (после первого) составляют более 1% последовательности и длина "
"последовательности составляет не менее 200 элементов, этот элемент "
"помечается как «популярный» и рассматривается как мусор для целей "
"сопоставления последовательностей. Эту эвристику можно отключить, установив "
"для аргумента autojunk значение False при создании :class:`SequenceMatcher`."

#: ../../library/difflib.rst:55 ../../library/difflib.rst:386
msgid "Added the *autojunk* parameter."
msgstr "Добавлен параметр *autojunk*."

#: ../../library/difflib.rst:61
msgid ""
"This is a class for comparing sequences of lines of text, and producing "
"human-readable differences or deltas.  Differ uses :class:`SequenceMatcher` "
"both to compare sequences of lines, and to compare sequences of characters "
"within similar (near-matching) lines."
msgstr ""
"Это класс для сравнения последовательностей строк текста и создания "
"удобочитаемых различий или дельт. Differ использует :class:`SequenceMatcher` "
"как для сравнения последовательностей строк, так и для сравнения "
"последовательностей символов в похожих (почти совпадающих) строках."

#: ../../library/difflib.rst:66
msgid "Each line of a :class:`Differ` delta begins with a two-letter code:"
msgstr ""
"Каждая строка дельты :class:`Different` начинается с двухбуквенного кода:"

#: ../../library/difflib.rst:69
msgid "Code"
msgstr "Код"

#: ../../library/difflib.rst:69 ../../library/difflib.rst:496
msgid "Meaning"
msgstr "Значение"

#: ../../library/difflib.rst:71
msgid "``'- '``"
msgstr "``'- '``"

#: ../../library/difflib.rst:71
msgid "line unique to sequence 1"
msgstr "строка, уникальная для последовательности 1"

#: ../../library/difflib.rst:73
msgid "``'+ '``"
msgstr "``'+ '``"

#: ../../library/difflib.rst:73
msgid "line unique to sequence 2"
msgstr "строка, уникальная для последовательности 2"

#: ../../library/difflib.rst:75
msgid "``'  '``"
msgstr "``'  '``"

#: ../../library/difflib.rst:75
msgid "line common to both sequences"
msgstr "линия, общая для обеих последовательностей"

#: ../../library/difflib.rst:77
msgid "``'? '``"
msgstr "``'? '``"

#: ../../library/difflib.rst:77
msgid "line not present in either input sequence"
msgstr "строка не представлена ни в одной входной последовательности"

#: ../../library/difflib.rst:80
msgid ""
"Lines beginning with '``?``' attempt to guide the eye to intraline "
"differences, and were not present in either input sequence. These lines can "
"be confusing if the sequences contain whitespace characters, such as spaces, "
"tabs or line breaks."
msgstr ""
"Строки, начинающиеся с '``?``', пытаются привлечь внимание к внутристрочным "
"различиям и не присутствуют ни в одной входной последовательности. Эти "
"строки могут сбивать с толку, если последовательности содержат пробельные "
"символы, такие как пробелы, табуляции или разрывы строк."

#: ../../library/difflib.rst:87
msgid ""
"This class can be used to create an HTML table (or a complete HTML file "
"containing the table) showing a side by side, line by line comparison of "
"text with inter-line and intra-line change highlights.  The table can be "
"generated in either full or contextual difference mode."
msgstr ""
"Этот класс можно использовать для создания HTML-таблицы (или полного HTML-"
"файла, содержащего таблицу), показывающего параллельное, построчное "
"сравнение текста с выделением межстрочных и внутристрочных изменений. "
"Таблица может быть создана как в режиме полной, так и в режиме контекстной "
"разницы."

#: ../../library/difflib.rst:92
msgid "The constructor for this class is:"
msgstr "Конструктор этого класса:"

#: ../../library/difflib.rst:97
msgid "Initializes instance of :class:`HtmlDiff`."
msgstr "Инициализирует экземпляр :class:`HtmlDiff`."

#: ../../library/difflib.rst:99
msgid ""
"*tabsize* is an optional keyword argument to specify tab stop spacing and "
"defaults to ``8``."
msgstr ""
"*tabsize* — это необязательный аргумент ключевого слова, определяющий "
"расстояние между позициями табуляции. По умолчанию он равен ``8``."

#: ../../library/difflib.rst:102
msgid ""
"*wrapcolumn* is an optional keyword to specify column number where lines are "
"broken and wrapped, defaults to ``None`` where lines are not wrapped."
msgstr ""
"*wrapcolumn* — необязательное ключевое слово, позволяющее указать номер "
"столбца, в котором строки разрываются и переносятся. По умолчанию "
"используется значение «Нет», если строки не переносятся."

#: ../../library/difflib.rst:105
msgid ""
"*linejunk* and *charjunk* are optional keyword arguments passed into :func:"
"`ndiff` (used by :class:`HtmlDiff` to generate the side by side HTML "
"differences).  See :func:`ndiff` documentation for argument default values "
"and descriptions."
msgstr ""
"*linejunk* и *charjunk* — это необязательные аргументы ключевых слов, "
"передаваемые в :func:`ndiff` (используемые :class:`HtmlDiff` для генерации "
"параллельных различий HTML). См. документацию :func:`ndiff` для получения "
"значений и описаний аргументов по умолчанию."

#: ../../library/difflib.rst:109
msgid "The following methods are public:"
msgstr "Следующие методы являются общедоступными:"

#: ../../library/difflib.rst:114
msgid ""
"Compares *fromlines* and *tolines* (lists of strings) and returns a string "
"which is a complete HTML file containing a table showing line by line "
"differences with inter-line and intra-line changes highlighted."
msgstr ""
"Сравнивает *fromlines* и *tolines* (списки строк) и возвращает строку, "
"которая представляет собой полный HTML-файл, содержащий таблицу, "
"показывающую построчные различия с выделенными межстрочными и "
"внутристрочными изменениями."

#: ../../library/difflib.rst:118
msgid ""
"*fromdesc* and *todesc* are optional keyword arguments to specify from/to "
"file column header strings (both default to an empty string)."
msgstr ""
"*fromdesc* и *todesc* — необязательные аргументы ключевых слов для указания "
"строк заголовков столбцов из/в файл (оба по умолчанию представляют собой "
"пустую строку)."

#: ../../library/difflib.rst:121
msgid ""
"*context* and *numlines* are both optional keyword arguments. Set *context* "
"to ``True`` when contextual differences are to be shown, else the default is "
"``False`` to show the full files. *numlines* defaults to ``5``.  When "
"*context* is ``True`` *numlines* controls the number of context lines which "
"surround the difference highlights.  When *context* is ``False`` *numlines* "
"controls the number of lines which are shown before a difference highlight "
"when using the \"next\" hyperlinks (setting to zero would cause the \"next\" "
"hyperlinks to place the next difference highlight at the top of the browser "
"without any leading context)."
msgstr ""
"*context* и *numlines* являются необязательными аргументами ключевых слов. "
"Установите для параметра *context* значение «True», если необходимо показать "
"контекстные различия, иначе по умолчанию установлено значение «False», чтобы "
"отображались полные файлы. *numlines* по умолчанию равно ``5``. Когда "
"*context* имеет значение ``True``, *numlines* управляет количеством "
"контекстных строк, окружающих выделение различий. Когда *context* имеет "
"значение ``False``, *numlines* управляет количеством строк, которые "
"отображаются перед выделением различия при использовании гиперссылок "
"«следующие» (установка в ноль приведет к тому, что гиперссылки «следующие» "
"поместят следующее выделение различия в верхнюю часть браузера без какого-"
"либо ведущего контекста)."

#: ../../library/difflib.rst:132
msgid ""
"*fromdesc* and *todesc* are interpreted as unescaped HTML and should be "
"properly escaped while receiving input from untrusted sources."
msgstr ""
"*fromdesc* и *todesc* интерпретируются как неэкранированный HTML и должны "
"быть правильно экранированы при получении входных данных из ненадежных "
"источников."

#: ../../library/difflib.rst:135
msgid ""
"*charset* keyword-only argument was added.  The default charset of HTML "
"document changed from ``'ISO-8859-1'`` to ``'utf-8'``."
msgstr ""
"Добавлен аргумент *charset*, содержащий только ключевые слова. Кодировка "
"HTML-документа по умолчанию изменена с ``'ISO-8859-1'`` на ``'utf-8'``."

#: ../../library/difflib.rst:141
msgid ""
"Compares *fromlines* and *tolines* (lists of strings) and returns a string "
"which is a complete HTML table showing line by line differences with inter-"
"line and intra-line changes highlighted."
msgstr ""
"Сравнивает *fromlines* и *tolines* (списки строк) и возвращает строку, "
"которая представляет собой полную таблицу HTML, показывающую построчные "
"различия с выделенными межстрочными и внутристрочными изменениями."

#: ../../library/difflib.rst:145
msgid ""
"The arguments for this method are the same as those for the :meth:"
"`make_file` method."
msgstr "Аргументы этого метода такие же, как и у метода :meth:`make_file`."

#: ../../library/difflib.rst:152
msgid ""
"Compare *a* and *b* (lists of strings); return a delta (a :term:`generator` "
"generating the delta lines) in context diff format."
msgstr ""
"Сравнить *a* и *b* (списки строк); вернуть дельту (генератор, генерирующий "
"дельта-линии) в формате контекстного различия."

#: ../../library/difflib.rst:155
msgid ""
"Context diffs are a compact way of showing just the lines that have changed "
"plus a few lines of context.  The changes are shown in a before/after "
"style.  The number of context lines is set by *n* which defaults to three."
msgstr ""
"Контекстные различия — это компактный способ показать только измененные "
"строки плюс несколько строк контекста. Изменения показаны в стиле «до/"
"после». Количество контекстных строк задается параметром *n*, который по "
"умолчанию равен трем."

#: ../../library/difflib.rst:159
msgid ""
"By default, the diff control lines (those with ``***`` or ``---``) are "
"created with a trailing newline.  This is helpful so that inputs created "
"from :func:`io.IOBase.readlines` result in diffs that are suitable for use "
"with :func:`io.IOBase.writelines` since both the inputs and outputs have "
"trailing newlines."
msgstr ""
"По умолчанию строки управления различиями (с ``***`` или ``---``) создаются "
"с завершающим символом новой строки. Это полезно, поскольку входные данные, "
"созданные из :func:`io.IOBase.readlines`, приводят к результатам различий, "
"которые подходят для использования с :func:`io.IOBase.writelines`, поскольку "
"и входные, и выходные данные имеют завершающие символы новой строки."

#: ../../library/difflib.rst:165 ../../library/difflib.rst:297
msgid ""
"For inputs that do not have trailing newlines, set the *lineterm* argument "
"to ``\"\"`` so that the output will be uniformly newline free."
msgstr ""
"Для входных данных, которые не имеют завершающих символов новой строки, "
"установите для аргумента *lineterm* значение ``\"\"``, чтобы выходные данные "
"были равномерно свободны от новой строки."

#: ../../library/difflib.rst:168
msgid ""
"The context diff format normally has a header for filenames and modification "
"times.  Any or all of these may be specified using strings for *fromfile*, "
"*tofile*, *fromfiledate*, and *tofiledate*.  The modification times are "
"normally expressed in the ISO 8601 format. If not specified, the strings "
"default to blanks."
msgstr ""
"Формат контекстного различия обычно имеет заголовок для имен файлов и "
"времени модификации. Любое или все из них можно указать с помощью строк "
"*fromfile*, *tofile*, *fromfiledate* и *tofiledate*. Время модификации "
"обычно выражается в формате ISO 8601. Если не указано, строки по умолчанию "
"пустые."

#: ../../library/difflib.rst:194 ../../library/difflib.rst:320
msgid "See :ref:`difflib-interface` for a more detailed example."
msgstr "См. более подробный пример в :ref:`difflib-interface`."

#: ../../library/difflib.rst:199
msgid ""
"Return a list of the best \"good enough\" matches.  *word* is a sequence for "
"which close matches are desired (typically a string), and *possibilities* is "
"a list of sequences against which to match *word* (typically a list of "
"strings)."
msgstr ""
"Вернуть список лучших «достаточно хороших» совпадений. *слово* — это "
"последовательность, для которой желательны близкие совпадения (обычно "
"строка), а *возможности* — это список последовательностей, с которыми можно "
"сопоставить *слово* (обычно список строк)."

#: ../../library/difflib.rst:203
msgid ""
"Optional argument *n* (default ``3``) is the maximum number of close matches "
"to return; *n* must be greater than ``0``."
msgstr ""
"Необязательный аргумент *n* (по умолчанию ``3``) — это максимальное "
"количество возвращаемых близких совпадений; *n* должно быть больше ``0``."

#: ../../library/difflib.rst:206
msgid ""
"Optional argument *cutoff* (default ``0.6``) is a float in the range [0, 1]. "
"Possibilities that don't score at least that similar to *word* are ignored."
msgstr ""
"Необязательный аргумент *cutoff* (по умолчанию ``0,6``) представляет собой "
"число с плавающей запятой в диапазоне [0, 1]. Возможности, которые не имеют "
"хотя бы такого же значения, как *word*, игнорируются."

#: ../../library/difflib.rst:209
msgid ""
"The best (no more than *n*) matches among the possibilities are returned in "
"a list, sorted by similarity score, most similar first."
msgstr ""
"Лучшие (не более *n*) совпадения среди возможных возвращаются в списке, "
"отсортированном по показателю сходства, начиная с наиболее похожего."

#: ../../library/difflib.rst:225
msgid ""
"Compare *a* and *b* (lists of strings); return a :class:`Differ`\\ -style "
"delta (a :term:`generator` generating the delta lines)."
msgstr ""
"Сравнить *a* и *b* (списки строк); вернуть :class:`Differ`\\ дельту в стиле "
"(:term:`generator`, генерирующий дельта-линии)."

#: ../../library/difflib.rst:228
msgid ""
"Optional keyword parameters *linejunk* and *charjunk* are filtering "
"functions (or ``None``):"
msgstr ""
"Необязательные параметры ключевых слов *linejunk* и *charjunk* являются "
"функциями фильтрации (или «Нет»):"

#: ../../library/difflib.rst:231
msgid ""
"*linejunk*: A function that accepts a single string argument, and returns "
"true if the string is junk, or false if not. The default is ``None``. There "
"is also a module-level function :func:`IS_LINE_JUNK`, which filters out "
"lines without visible characters, except for at most one pound character "
"(``'#'``) -- however the underlying :class:`SequenceMatcher` class does a "
"dynamic analysis of which lines are so frequent as to constitute noise, and "
"this usually works better than using this function."
msgstr ""
"*linejunk*: функция, которая принимает один строковый аргумент и возвращает "
"true, если строка является мусорной, или false в противном случае. По "
"умолчанию установлено значение «Нет». Существует также функция уровня "
"модуля :func:`IS_LINE_JUNK`, которая отфильтровывает строки без видимых "
"символов, за исключением не более одного символа решетки (``'#'``), однако "
"базовый :class:`SequenceMatcher` class выполняет динамический анализ того, "
"какие строки встречаются настолько часто, что представляют собой шум, и это "
"обычно работает лучше, чем использование этой функции."

#: ../../library/difflib.rst:239
msgid ""
"*charjunk*: A function that accepts a character (a string of length 1), and "
"returns if the character is junk, or false if not. The default is module-"
"level function :func:`IS_CHARACTER_JUNK`, which filters out whitespace "
"characters (a blank or tab; it's a bad idea to include newline in this!)."
msgstr ""
"*charjunk*: функция, которая принимает символ (строку длиной 1) и возвращает "
"значение, если символ является мусорным, или возвращает значение false в "
"противном случае. По умолчанию используется функция уровня модуля :func:"
"`IS_CHARACTER_JUNK`, которая отфильтровывает пробельные символы (пробел или "
"табуляцию; включать в это новую строку - плохая идея!)."

#: ../../library/difflib.rst:260
msgid "Return one of the two sequences that generated a delta."
msgstr "Верните одну из двух последовательностей, создавших дельту."

#: ../../library/difflib.rst:262
msgid ""
"Given a *sequence* produced by :meth:`Differ.compare` or :func:`ndiff`, "
"extract lines originating from file 1 or 2 (parameter *which*), stripping "
"off line prefixes."
msgstr ""
"Учитывая *последовательность*, созданную :meth:`Differ.compare` или :func:"
"`ndiff`, извлеките строки, происходящие из файла 1 или 2 (параметр "
"*который*), удалив префиксы строк."

#: ../../library/difflib.rst:266
msgid "Example:"
msgstr "Пример:"

#: ../../library/difflib.rst:283
msgid ""
"Compare *a* and *b* (lists of strings); return a delta (a :term:`generator` "
"generating the delta lines) in unified diff format."
msgstr ""
"Сравнить *a* и *b* (списки строк); вернуть дельту (:term:`генератор`, "
"генерирующий дельта-линии) в унифицированном формате различий."

#: ../../library/difflib.rst:286
msgid ""
"Unified diffs are a compact way of showing just the lines that have changed "
"plus a few lines of context.  The changes are shown in an inline style "
"(instead of separate before/after blocks).  The number of context lines is "
"set by *n* which defaults to three."
msgstr ""
"Унифицированные различия — это компактный способ показать только измененные "
"строки плюс несколько строк контекста. Изменения отображаются в виде строки "
"(вместо отдельных блоков «до» и «после»). Количество контекстных строк "
"задается параметром *n*, который по умолчанию равен трем."

#: ../../library/difflib.rst:291
msgid ""
"By default, the diff control lines (those with ``---``, ``+++``, or ``@@``) "
"are created with a trailing newline.  This is helpful so that inputs created "
"from :func:`io.IOBase.readlines` result in diffs that are suitable for use "
"with :func:`io.IOBase.writelines` since both the inputs and outputs have "
"trailing newlines."
msgstr ""
"По умолчанию строки управления различиями (с ``---``, ``+++`` или ``@@``) "
"создаются с завершающим символом новой строки. Это полезно, поскольку "
"входные данные, созданные из :func:`io.IOBase.readlines`, приводят к "
"результатам различий, которые подходят для использования с :func:`io.IOBase."
"writelines`, поскольку и входные, и выходные данные имеют завершающие "
"символы новой строки."

#: ../../library/difflib.rst:300
msgid ""
"The unified diff format normally has a header for filenames and modification "
"times.  Any or all of these may be specified using strings for *fromfile*, "
"*tofile*, *fromfiledate*, and *tofiledate*.  The modification times are "
"normally expressed in the ISO 8601 format. If not specified, the strings "
"default to blanks."
msgstr ""
"Унифицированный формат различий обычно имеет заголовок для имен файлов и "
"времени модификации. Любое или все из них можно указать с помощью строк "
"*fromfile*, *tofile*, *fromfiledate* и *tofiledate*. Время модификации "
"обычно выражается в формате ISO 8601. Если не указано, строки по умолчанию "
"пустые."

#: ../../library/difflib.rst:324
msgid ""
"Compare *a* and *b* (lists of bytes objects) using *dfunc*; yield a sequence "
"of delta lines (also bytes) in the format returned by *dfunc*. *dfunc* must "
"be a callable, typically either :func:`unified_diff` or :func:`context_diff`."
msgstr ""
"Сравните *a* и *b* (списки байтовых объектов) с помощью *dfunc*; выдать "
"последовательность дельта-строк (также байтов) в формате, возвращаемом "
"*dfunc*. *dfunc* должен быть вызываемым объектом, обычно либо :func:"
"`unified_diff`, либо :func:`context_diff`."

#: ../../library/difflib.rst:329
msgid ""
"Allows you to compare data with unknown or inconsistent encoding. All inputs "
"except *n* must be bytes objects, not str. Works by losslessly converting "
"all inputs (except *n*) to str, and calling ``dfunc(a, b, fromfile, tofile, "
"fromfiledate, tofiledate, n, lineterm)``. The output of *dfunc* is then "
"converted back to bytes, so the delta lines that you receive have the same "
"unknown/inconsistent encodings as *a* and *b*."
msgstr ""
"Позволяет сравнивать данные с неизвестной или противоречивой кодировкой. Все "
"входные данные, кроме *n*, должны быть байтовыми объектами, а не строковыми. "
"Работает путем преобразования всех входных данных (кроме *n*) в str без "
"потерь и вызова ``dfunc(a, b, fromfile, tofile, fromfiledate, tofiledate, n, "
"lineterm)``. Вывод *dfunc* затем преобразуется обратно в байты, поэтому "
"получаемые вами дельта-строки имеют те же неизвестные/несовместимые "
"кодировки, что и *a* и *b*."

#: ../../library/difflib.rst:340
msgid ""
"Return ``True`` for ignorable lines.  The line *line* is ignorable if *line* "
"is blank or contains a single ``'#'``, otherwise it is not ignorable.  Used "
"as a default for parameter *linejunk* in :func:`ndiff` in older versions."
msgstr ""
"Верните True для игнорируемых строк. Строка *line* игнорируется, если *line* "
"пуста или содержит одиночный ``'#'``, в противном случае она не "
"игнорируется. Используется по умолчанию для параметра *linejunk* в :func:"
"`ndiff` в старых версиях."

#: ../../library/difflib.rst:347
msgid ""
"Return ``True`` for ignorable characters.  The character *ch* is ignorable "
"if *ch* is a space or tab, otherwise it is not ignorable.  Used as a default "
"for parameter *charjunk* in :func:`ndiff`."
msgstr ""
"Верните True для игнорируемых символов. Символ *ch* игнорируется, если *ch* "
"является пробелом или табуляцией, в противном случае он не игнорируется. "
"Используется по умолчанию для параметра *charjunk* в :func:`ndiff`."

#: ../../library/difflib.rst:354
msgid ""
"`Pattern Matching: The Gestalt Approach <https://www.drdobbs.com/database/"
"pattern-matching-the-gestalt-approach/184407970>`_"
msgstr ""
"`Сопоставление с образцом: гештальт-подход <https://www.drdobbs.com/database/"
"pattern-matching-the-gestalt-approach/184407970>`_"

#: ../../library/difflib.rst:355
msgid ""
"Discussion of a similar algorithm by John W. Ratcliff and D. E. Metzener. "
"This was published in `Dr. Dobb's Journal <https://www.drdobbs.com/>`_ in "
"July, 1988."
msgstr ""
"Обсуждение аналогичного алгоритма Джоном В. Рэтклиффом и Д. Е. Метценером. "
"Это было опубликовано в журнале «Dr. Журнал Добба <https://www.drdobbs.com/"
">`_ в июле 1988 г."

#: ../../library/difflib.rst:362
msgid "SequenceMatcher Objects"
msgstr "Объекты SequenceMatcher"

#: ../../library/difflib.rst:364
msgid "The :class:`SequenceMatcher` class has this constructor:"
msgstr "Класс :class:`SequenceMatcher` имеет этот конструктор:"

#: ../../library/difflib.rst:369
msgid ""
"Optional argument *isjunk* must be ``None`` (the default) or a one-argument "
"function that takes a sequence element and returns true if and only if the "
"element is \"junk\" and should be ignored. Passing ``None`` for *isjunk* is "
"equivalent to passing ``lambda x: False``; in other words, no elements are "
"ignored. For example, pass::"
msgstr ""
"Необязательный аргумент *isjunk* должен иметь значение None (по умолчанию) "
"или функцию с одним аргументом, которая принимает элемент последовательности "
"и возвращает true тогда и только тогда, когда элемент является «мусорным» и "
"его следует игнорировать. Передача ``None`` для *isjunk* эквивалентна "
"передаче ``lambda x: False``; другими словами, ни один элемент не "
"игнорируется. Например, передайте::"

#: ../../library/difflib.rst:375
msgid "lambda x: x in \" \\t\""
msgstr "lambda x: x in \" \\t\""

#: ../../library/difflib.rst:377
msgid ""
"if you're comparing lines as sequences of characters, and don't want to "
"synch up on blanks or hard tabs."
msgstr ""
"если вы сравниваете строки как последовательности символов и не хотите "
"синхронизироваться по пробелам или жестким табуляциям."

#: ../../library/difflib.rst:380
msgid ""
"The optional arguments *a* and *b* are sequences to be compared; both "
"default to empty strings.  The elements of both sequences must be :term:"
"`hashable`."
msgstr ""
"Необязательные аргументы *a* и *b* представляют собой сравниваемые "
"последовательности; оба по умолчанию имеют пустые строки. Элементы обеих "
"последовательностей должны быть :term:`hashable`."

#: ../../library/difflib.rst:383
msgid ""
"The optional argument *autojunk* can be used to disable the automatic junk "
"heuristic."
msgstr ""
"Необязательный аргумент *autojunk* можно использовать для отключения "
"автоматической эвристики нежелательной почты."

#: ../../library/difflib.rst:389
msgid ""
"SequenceMatcher objects get three data attributes: *bjunk* is the set of "
"elements of *b* for which *isjunk* is ``True``; *bpopular* is the set of non-"
"junk elements considered popular by the heuristic (if it is not disabled); "
"*b2j* is a dict mapping the remaining elements of *b* to a list of positions "
"where they occur. All three are reset whenever *b* is reset with :meth:"
"`set_seqs` or :meth:`set_seq2`."
msgstr ""
"Объекты SequenceMatcher получают три атрибута данных: *bjunk* — это набор "
"элементов *b*, для которых *isjunk* имеет значение ``True``; *bpopular* — "
"набор ненужных элементов, которые эвристика считает популярными (если она не "
"отключена); *b2j* — это словарь, отображающий оставшиеся элементы *b* в "
"список позиций, где они встречаются. Все три сбрасываются каждый раз, когда "
"*b* сбрасывается с помощью :meth:`set_seqs` или :meth:`set_seq2`."

#: ../../library/difflib.rst:396
msgid "The *bjunk* and *bpopular* attributes."
msgstr "Атрибуты *bjunk* и *bpopular*."

#: ../../library/difflib.rst:399
msgid ":class:`SequenceMatcher` objects have the following methods:"
msgstr "Объекты :class:`SequenceMatcher` имеют следующие методы:"

#: ../../library/difflib.rst:403
msgid "Set the two sequences to be compared."
msgstr "Установите две последовательности для сравнения."

#: ../../library/difflib.rst:405
msgid ""
":class:`SequenceMatcher` computes and caches detailed information about the "
"second sequence, so if you want to compare one sequence against many "
"sequences, use :meth:`set_seq2` to set the commonly used sequence once and "
"call :meth:`set_seq1` repeatedly, once for each of the other sequences."
msgstr ""
":class:`SequenceMatcher` вычисляет и кэширует подробную информацию о второй "
"последовательности, поэтому, если вы хотите сравнить одну последовательность "
"со многими последовательностями, используйте :meth:`set_seq2`, чтобы один "
"раз установить часто используемую последовательность, и вызовите :meth:"
"`set_seq1` неоднократно, по одному разу для каждой из остальных "
"последовательностей."

#: ../../library/difflib.rst:413
msgid ""
"Set the first sequence to be compared.  The second sequence to be compared "
"is not changed."
msgstr ""
"Установите первую последовательность для сравнения. Вторая сравниваемая "
"последовательность не изменяется."

#: ../../library/difflib.rst:419
msgid ""
"Set the second sequence to be compared.  The first sequence to be compared "
"is not changed."
msgstr ""
"Установите вторую последовательность для сравнения. Первая сравниваемая "
"последовательность не изменяется."

#: ../../library/difflib.rst:425
msgid "Find longest matching block in ``a[alo:ahi]`` and ``b[blo:bhi]``."
msgstr ""
"Найдите самый длинный соответствующий блок в ``a[alo:ahi]`` и ``b[blo:bhi]``."

#: ../../library/difflib.rst:427
msgid ""
"If *isjunk* was omitted or ``None``, :meth:`find_longest_match` returns "
"``(i, j, k)`` such that ``a[i:i+k]`` is equal to ``b[j:j+k]``, where ``alo "
"<= i <= i+k <= ahi`` and ``blo <= j <= j+k <= bhi``. For all ``(i', j', "
"k')`` meeting those conditions, the additional conditions ``k >= k'``, ``i "
"<= i'``, and if ``i == i'``, ``j <= j'`` are also met. In other words, of "
"all maximal matching blocks, return one that starts earliest in *a*, and of "
"all those maximal matching blocks that start earliest in *a*, return the one "
"that starts earliest in *b*."
msgstr ""
"Если *isjunk* опущен или ``Нет``, :meth:`find_longest_match` возвращает "
"``(i, j, k)``, такой что ``a[i:i+k]`` равен `` b[j:j+k]``, где ``alo <= i <= "
"i+k <= ahi`` и ``blo <= j <= j+k <= bhi``. Для всех ``(i', j', k')``, "
"удовлетворяющих этим условиям, дополнительные условия ``k >= k'``, ``i <= "
"i'``, и если ``i == i'``, ``j <= j'`` также встречаются. Другими словами, из "
"всех блоков максимального соответствия верните тот, который начинается "
"раньше всего в *a*, а из всех блоков максимального соответствия, которые "
"начинаются раньше всего в *a*, верните тот, который начинается раньше в *b*."

#: ../../library/difflib.rst:440
msgid ""
"If *isjunk* was provided, first the longest matching block is determined as "
"above, but with the additional restriction that no junk element appears in "
"the block.  Then that block is extended as far as possible by matching "
"(only) junk elements on both sides. So the resulting block never matches on "
"junk except as identical junk happens to be adjacent to an interesting match."
msgstr ""
"Если было указано *isjunk*, сначала определяется самый длинный "
"соответствующий блок, как указано выше, но с дополнительным ограничением, "
"заключающимся в том, что в блоке не появляется ненужный элемент. Затем этот "
"блок расширяется, насколько это возможно, путем сопоставления (только) "
"ненужных элементов с обеих сторон. Таким образом, полученный блок никогда не "
"соответствует мусору, за исключением тех случаев, когда идентичный мусор "
"оказывается рядом с интересным совпадением."

#: ../../library/difflib.rst:447
msgid ""
"Here's the same example as before, but considering blanks to be junk. That "
"prevents ``' abcd'`` from matching the ``' abcd'`` at the tail end of the "
"second sequence directly.  Instead only the ``'abcd'`` can match, and "
"matches the leftmost ``'abcd'`` in the second sequence:"
msgstr ""
"Вот тот же пример, что и раньше, но пробелы считаются мусором. Это "
"предотвращает прямое сопоставление ``' abcd'`` с ``' abcd'`` в конце второй "
"последовательности. Вместо этого может совпадать только ``'abcd'``, и он "
"соответствует самому левому ``'abcd'`` во второй последовательности:"

#: ../../library/difflib.rst:456
msgid "If no blocks match, this returns ``(alo, blo, 0)``."
msgstr "Если ни один блок не совпадает, возвращается ``(alo, blo, 0)``."

#: ../../library/difflib.rst:458
msgid "This method returns a :term:`named tuple` ``Match(a, b, size)``."
msgstr "Этот метод возвращает кортеж с именем ``Match(a, b, size)``."

#: ../../library/difflib.rst:460
msgid "Added default arguments."
msgstr "Добавлены аргументы по умолчанию."

#: ../../library/difflib.rst:466
msgid ""
"Return list of triples describing non-overlapping matching subsequences. "
"Each triple is of the form ``(i, j, n)``, and means that ``a[i:i+n] == b[j:"
"j+n]``.  The triples are monotonically increasing in *i* and *j*."
msgstr ""
"Возвращаемый список троек, описывающих непересекающиеся совпадающие "
"подпоследовательности. Каждая тройка имеет форму ``(i, j, n)`` и означает, "
"что ``a[i:i+n] == b[j:j+n]``. Тройки монотонно возрастают в *i* и *j*."

#: ../../library/difflib.rst:471
msgid ""
"The last triple is a dummy, and has the value ``(len(a), len(b), 0)``.  It "
"is the only triple with ``n == 0``.  If ``(i, j, n)`` and ``(i', j', n')`` "
"are adjacent triples in the list, and the second is not the last triple in "
"the list, then ``i+n < i'`` or ``j+n < j'``; in other words, adjacent "
"triples always describe non-adjacent equal blocks."
msgstr ""
"Последняя тройка является фиктивной и имеет значение ``(len(a), len(b), "
"0)``. Это единственная тройка с ``n == 0``. Если ``(i, j, n)`` и ``(i', j', "
"n')`` являются соседними тройками в списке, а вторая не последняя тройка в "
"списке, то ``i +n < i'`` или ``j+n < j'``; другими словами, соседние тройки "
"всегда описывают несмежные равные блоки."

#: ../../library/difflib.rst:479
msgid ""
">>> s = SequenceMatcher(None, \"abxcd\", \"abcd\")\n"
">>> s.get_matching_blocks()\n"
"[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]"
msgstr ""
">>> s = SequenceMatcher(None, \"abxcd\", \"abcd\")\n"
">>> s.get_matching_blocks()\n"
"[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]"

#: ../../library/difflib.rst:488
msgid ""
"Return list of 5-tuples describing how to turn *a* into *b*. Each tuple is "
"of the form ``(tag, i1, i2, j1, j2)``.  The first tuple has ``i1 == j1 == "
"0``, and remaining tuples have *i1* equal to the *i2* from the preceding "
"tuple, and, likewise, *j1* equal to the previous *j2*."
msgstr ""
"Возвращаемый список из 5 кортежей, описывающий, как превратить *a* в *b*. "
"Каждый кортеж имеет вид ``(tag, i1, i2, j1, j2)``. Первый кортеж имеет ``i1 "
"== j1 == 0``, а остальные кортежи имеют *i1*, равный *i2* из предыдущего "
"кортежа, и, аналогично, *j1* равен предыдущему *j2*."

#: ../../library/difflib.rst:493
msgid "The *tag* values are strings, with these meanings:"
msgstr "Значения *tag* представляют собой строки со следующими значениями:"

#: ../../library/difflib.rst:496
msgid "Value"
msgstr "Значение"

#: ../../library/difflib.rst:498
msgid "``'replace'``"
msgstr "``'replace'``"

#: ../../library/difflib.rst:498
msgid "``a[i1:i2]`` should be replaced by ``b[j1:j2]``."
msgstr "``a[i1:i2]`` следует заменить на ``b[j1:j2]``."

#: ../../library/difflib.rst:501
msgid "``'delete'``"
msgstr "``'delete'``"

#: ../../library/difflib.rst:501
msgid "``a[i1:i2]`` should be deleted.  Note that ``j1 == j2`` in this case."
msgstr ""
"``a[i1:i2]`` следует удалить. Обратите внимание, что в этом случае ``j1 == "
"j2``."

#: ../../library/difflib.rst:504
msgid "``'insert'``"
msgstr "``'insert'``"

#: ../../library/difflib.rst:504
msgid ""
"``b[j1:j2]`` should be inserted at ``a[i1:i1]``. Note that ``i1 == i2`` in "
"this case."
msgstr ""
"`b[j1:j2]` следует вставить в `a[i1:i11]`. Обратите внимание, что в этом "
"случае `i1 == i2`."

#: ../../library/difflib.rst:508
msgid "``'equal'``"
msgstr "``'equal'``"

#: ../../library/difflib.rst:508
msgid "``a[i1:i2] == b[j1:j2]`` (the sub-sequences are equal)."
msgstr "``a[i1:i2] == b[j1:j2]`` (подпоследовательности равны)."

#: ../../library/difflib.rst:512
msgid "For example::"
msgstr "Например::"

#: ../../library/difflib.rst:514
msgid ""
">>> a = \"qabxcd\"\n"
">>> b = \"abycdf\"\n"
">>> s = SequenceMatcher(None, a, b)\n"
">>> for tag, i1, i2, j1, j2 in s.get_opcodes():\n"
"...     print('{:7}   a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format(\n"
"...         tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2]))\n"
"delete    a[0:1] --> b[0:0]      'q' --> ''\n"
"equal     a[1:3] --> b[0:2]     'ab' --> 'ab'\n"
"replace   a[3:4] --> b[2:3]      'x' --> 'y'\n"
"equal     a[4:6] --> b[3:5]     'cd' --> 'cd'\n"
"insert    a[6:6] --> b[5:6]       '' --> 'f'"
msgstr ""
">>> a = \"qabxcd\"\n"
">>> b = \"abycdf\"\n"
">>> s = SequenceMatcher(None, a, b)\n"
">>> for tag, i1, i2, j1, j2 in s.get_opcodes():\n"
"...     print('{:7}   a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format(\n"
"...         tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2]))\n"
"delete    a[0:1] --> b[0:0]      'q' --> ''\n"
"equal     a[1:3] --> b[0:2]     'ab' --> 'ab'\n"
"replace   a[3:4] --> b[2:3]      'x' --> 'y'\n"
"equal     a[4:6] --> b[3:5]     'cd' --> 'cd'\n"
"insert    a[6:6] --> b[5:6]       '' --> 'f'"

#: ../../library/difflib.rst:529
msgid "Return a :term:`generator` of groups with up to *n* lines of context."
msgstr "Возвращает :term:`генератор` групп, содержащих до *n* строк контекста."

#: ../../library/difflib.rst:531
msgid ""
"Starting with the groups returned by :meth:`get_opcodes`, this method splits "
"out smaller change clusters and eliminates intervening ranges which have no "
"changes."
msgstr ""
"Начиная с групп, возвращаемых :meth:`get_opcodes`, этот метод разделяет "
"более мелкие кластеры изменений и исключает промежуточные диапазоны, в "
"которых нет изменений."

#: ../../library/difflib.rst:535
msgid "The groups are returned in the same format as :meth:`get_opcodes`."
msgstr "Группы возвращаются в том же формате, что и :meth:`get_opcodes`."

#: ../../library/difflib.rst:540
msgid ""
"Return a measure of the sequences' similarity as a float in the range [0, 1]."
msgstr ""
"Возвращает меру сходства последовательностей в виде числа с плавающей "
"запятой в диапазоне [0, 1]."

#: ../../library/difflib.rst:543
msgid ""
"Where T is the total number of elements in both sequences, and M is the "
"number of matches, this is 2.0\\*M / T. Note that this is ``1.0`` if the "
"sequences are identical, and ``0.0`` if they have nothing in common."
msgstr ""
"Где T — общее количество элементов в обеих последовательностях, а M — "
"количество совпадений, это 2,0\\*M / T. Обратите внимание, что это «1,0», "
"если последовательности идентичны, и «0,0». если у них нет ничего общего."

#: ../../library/difflib.rst:547
msgid ""
"This is expensive to compute if :meth:`get_matching_blocks` or :meth:"
"`get_opcodes` hasn't already been called, in which case you may want to try :"
"meth:`quick_ratio` or :meth:`real_quick_ratio` first to get an upper bound."
msgstr ""
"Вычислить это будет дорого, если :meth:`get_matching_blocks` или :meth:"
"`get_opcodes` еще не был вызван, и в этом случае вы можете сначала "
"попробовать :meth:`quick_ratio` или :meth:`real_quick_ratio`, чтобы получить "
"верхняя граница."

#: ../../library/difflib.rst:554
msgid ""
"Caution: The result of a :meth:`ratio` call may depend on the order of the "
"arguments. For instance::"
msgstr ""
"Внимание: результат вызова :meth:`ratio` может зависеть от порядка "
"аргументов. Например::"

#: ../../library/difflib.rst:557
msgid ""
">>> SequenceMatcher(None, 'tide', 'diet').ratio()\n"
"0.25\n"
">>> SequenceMatcher(None, 'diet', 'tide').ratio()\n"
"0.5"
msgstr ""
">>> SequenceMatcher(None, 'tide', 'diet').ratio()\n"
"0.25\n"
">>> SequenceMatcher(None, 'diet', 'tide').ratio()\n"
"0.5"

#: ../../library/difflib.rst:565
msgid "Return an upper bound on :meth:`ratio` relatively quickly."
msgstr "Возвращает верхнюю границу :meth:`ratio` относительно быстро."

#: ../../library/difflib.rst:570
msgid "Return an upper bound on :meth:`ratio` very quickly."
msgstr "Возвращает верхнюю границу :meth:`ratio` очень быстро."

#: ../../library/difflib.rst:573
msgid ""
"The three methods that return the ratio of matching to total characters can "
"give different results due to differing levels of approximation, although :"
"meth:`~SequenceMatcher.quick_ratio` and :meth:`~SequenceMatcher."
"real_quick_ratio` are always at least as large as :meth:`~SequenceMatcher."
"ratio`:"
msgstr ""
"Три метода, которые возвращают соотношение совпадений к общему количеству "
"символов, могут давать разные результаты из-за разных уровней аппроксимации, "
"хотя :meth:`~SequenceMatcher.quick_ratio` и :meth:`~SequenceMatcher."
"real_quick_ratio` всегда имеют размер не меньше, чем :meth:`~SequenceMatcher."
"ratio`:"

#: ../../library/difflib.rst:590
msgid "SequenceMatcher Examples"
msgstr "Примеры SequenceMatcher"

#: ../../library/difflib.rst:592
msgid "This example compares two strings, considering blanks to be \"junk\":"
msgstr "В этом примере сравниваются две строки, считая пробелы «мусором»:"

#: ../../library/difflib.rst:598
msgid ""
":meth:`~SequenceMatcher.ratio` returns a float in [0, 1], measuring the "
"similarity of the sequences.  As a rule of thumb, a :meth:`~SequenceMatcher."
"ratio` value over 0.6 means the sequences are close matches:"
msgstr ""
":meth:`~SequenceMatcher.ratio` возвращает число с плавающей запятой в [0, "
"1], измеряя сходство последовательностей. Как правило, значение :meth:"
"`~SequenceMatcher.ratio` больше 0,6 означает, что последовательности имеют "
"близкое совпадение:"

#: ../../library/difflib.rst:605
msgid ""
"If you're only interested in where the sequences match, :meth:"
"`~SequenceMatcher.get_matching_blocks` is handy:"
msgstr ""
"Если вас интересует только совпадение последовательностей, вам пригодится :"
"meth:`~SequenceMatcher.get_matching_blocks`:"

#: ../../library/difflib.rst:614
msgid ""
"Note that the last tuple returned by :meth:`~SequenceMatcher."
"get_matching_blocks` is always a dummy, ``(len(a), len(b), 0)``, and this is "
"the only case in which the last tuple element (number of elements matched) "
"is ``0``."
msgstr ""
"Обратите внимание, что последний кортеж, возвращаемый :meth:"
"`~SequenceMatcher.get_matching_blocks`, всегда является фиктивным, "
"``(len(a), len(b), 0)``, и это единственный случай, в котором последний "
"кортеж элемент (количество совпадающих элементов) равен ``0``."

#: ../../library/difflib.rst:618
msgid ""
"If you want to know how to change the first sequence into the second, use :"
"meth:`~SequenceMatcher.get_opcodes`:"
msgstr ""
"Если вы хотите узнать, как изменить первую последовательность на вторую, "
"используйте :meth:`~SequenceMatcher.get_opcodes`:"

#: ../../library/difflib.rst:629
msgid ""
"The :func:`get_close_matches` function in this module which shows how simple "
"code building on :class:`SequenceMatcher` can be used to do useful work."
msgstr ""
"Функция :func:`get_close_matches` в этом модуле показывает, как простое "
"построение кода на :class:`SequenceMatcher` можно использовать для "
"выполнения полезной работы."

#: ../../library/difflib.rst:633
msgid ""
"`Simple version control recipe <https://code.activestate.com/recipes/576729-"
"simple-version-control/>`_ for a small application built with :class:"
"`SequenceMatcher`."
msgstr ""
"`Простой рецепт контроля версий <https://code.activestate.com/recipes/576729-"
"simple-version-control/>`_ для небольшого приложения, созданного с помощью :"
"class:`SequenceMatcher`."

#: ../../library/difflib.rst:641
msgid "Differ Objects"
msgstr "Разные объекты"

#: ../../library/difflib.rst:643
msgid ""
"Note that :class:`Differ`\\ -generated deltas make no claim to be "
"**minimal** diffs. To the contrary, minimal diffs are often counter-"
"intuitive, because they synch up anywhere possible, sometimes accidental "
"matches 100 pages apart. Restricting synch points to contiguous matches "
"preserves some notion of locality, at the occasional cost of producing a "
"longer diff."
msgstr ""
"Обратите внимание, что :class:`Differ`\\ дельты, сгенерированные :class:"
"`Differ`\\, не претендуют на звание **минимальных** различий. Напротив, "
"минимальные различия часто нелогичны, потому что они синхронизируются везде, "
"где это возможно, иногда случайные совпадения с интервалом в 100 страниц. "
"Ограничение точек синхронизации смежными совпадениями сохраняет некоторое "
"представление о локальности, хотя иногда приходится платить за создание "
"более длинных различий."

#: ../../library/difflib.rst:649
msgid "The :class:`Differ` class has this constructor:"
msgstr "Класс :class:`Differ` имеет такой конструктор:"

#: ../../library/difflib.rst:655
msgid ""
"Optional keyword parameters *linejunk* and *charjunk* are for filter "
"functions (or ``None``):"
msgstr ""
"Необязательные параметры ключевых слов *linejunk* и *charjunk* предназначены "
"для функций фильтра (или ``None``):"

#: ../../library/difflib.rst:658
msgid ""
"*linejunk*: A function that accepts a single string argument, and returns "
"true if the string is junk.  The default is ``None``, meaning that no line "
"is considered junk."
msgstr ""
"*linejunk*: функция, которая принимает один строковый аргумент и возвращает "
"true, если строка является мусорной. По умолчанию установлено значение "
"«Нет», что означает, что ни одна строка не считается ненужной."

#: ../../library/difflib.rst:662
msgid ""
"*charjunk*: A function that accepts a single character argument (a string of "
"length 1), and returns true if the character is junk. The default is "
"``None``, meaning that no character is considered junk."
msgstr ""
"*charjunk*: функция, которая принимает в качестве аргумента один символ "
"(строку длиной 1) и возвращает true, если символ является мусорным. По "
"умолчанию установлено значение «Нет», что означает, что ни один символ не "
"считается мусором."

#: ../../library/difflib.rst:666
msgid ""
"These junk-filtering functions speed up matching to find differences and do "
"not cause any differing lines or characters to be ignored.  Read the "
"description of the :meth:`~SequenceMatcher.find_longest_match` method's "
"*isjunk* parameter for an explanation."
msgstr ""
"Эти функции фильтрации нежелательной почты ускоряют сопоставление при поиске "
"различий и не приводят к игнорированию отличающихся строк или символов. "
"Прочтите описание параметра *isjunk* метода :meth:`~SequenceMatcher."
"find_longest_match` для получения пояснения."

#: ../../library/difflib.rst:672
msgid ""
":class:`Differ` objects are used (deltas generated) via a single method:"
msgstr ""
"Объекты :class:`Differ` используются (генерируются дельты) с помощью одного "
"метода:"

#: ../../library/difflib.rst:677
msgid ""
"Compare two sequences of lines, and generate the delta (a sequence of lines)."
msgstr ""
"Сравните две последовательности строк и сгенерируйте дельту "
"(последовательность строк)."

#: ../../library/difflib.rst:679
msgid ""
"Each sequence must contain individual single-line strings ending with "
"newlines.  Such sequences can be obtained from the :meth:`~io.IOBase."
"readlines` method of file-like objects.  The delta generated also consists "
"of newline-terminated strings, ready to be printed as-is via the :meth:`~io."
"IOBase.writelines` method of a file-like object."
msgstr ""
"Каждая последовательность должна содержать отдельные однострочные строки, "
"заканчивающиеся символами новой строки. Такие последовательности можно "
"получить из метода файловоподобных объектов :meth:`~io.IOBase.readlines`. "
"Сгенерированная дельта также состоит из строк, заканчивающихся символом "
"новой строки, готовых к печати как есть с помощью метода :meth:`~io.IOBase."
"writelines` файлового объекта."

#: ../../library/difflib.rst:690
msgid "Differ Example"
msgstr "Другой пример"

#: ../../library/difflib.rst:692
msgid ""
"This example compares two texts. First we set up the texts, sequences of "
"individual single-line strings ending with newlines (such sequences can also "
"be obtained from the :meth:`~io.IOBase.readlines` method of file-like "
"objects):"
msgstr ""
"В этом примере сравниваются два текста. Сначала мы настраиваем тексты, "
"последовательности отдельных однострочных строк, заканчивающихся символами "
"новой строки (такие последовательности также можно получить из метода "
"файловоподобных объектов :meth:`~io.IOBase.readlines`):"

#: ../../library/difflib.rst:711
msgid "Next we instantiate a Differ object:"
msgstr "Далее мы создаем экземпляр объекта Differ:"

#: ../../library/difflib.rst:715
msgid ""
"Note that when instantiating a :class:`Differ` object we may pass functions "
"to filter out line and character \"junk.\"  See the :meth:`Differ` "
"constructor for details."
msgstr ""
"Обратите внимание, что при создании экземпляра объекта :class:`Differ` мы "
"можем передавать функции для фильтрации строкового и символьного «мусора». "
"Подробности смотрите в конструкторе :meth:`Differ`."

#: ../../library/difflib.rst:719
msgid "Finally, we compare the two:"
msgstr "Наконец, мы сравним их:"

#: ../../library/difflib.rst:723
msgid "``result`` is a list of strings, so let's pretty-print it:"
msgstr "``result`` — это список строк, поэтому давайте его распечатаем:"

#: ../../library/difflib.rst:738
msgid "As a single multi-line string it looks like this:"
msgstr "В виде одной многострочной строки это выглядит так:"

#: ../../library/difflib.rst:757
msgid "A command-line interface to difflib"
msgstr "Интерфейс командной строки для difflib"

#: ../../library/difflib.rst:759
msgid ""
"This example shows how to use difflib to create a ``diff``-like utility."
msgstr ""
"В этом примере показано, как использовать difflib для создания утилиты, "
"похожей на diff."

#: ../../library/difflib.rst:761
msgid ""
"\"\"\" Command line interface to difflib.py providing diffs in four "
"formats:\n"
"\n"
"* ndiff:    lists every line and highlights interline changes.\n"
"* context:  highlights clusters of changes in a before/after format.\n"
"* unified:  highlights clusters of changes in an inline format.\n"
"* html:     generates side by side comparison with change highlights.\n"
"\n"
"\"\"\"\n"
"\n"
"import sys, os, difflib, argparse\n"
"from datetime import datetime, timezone\n"
"\n"
"def file_mtime(path):\n"
"    t = datetime.fromtimestamp(os.stat(path).st_mtime,\n"
"                               timezone.utc)\n"
"    return t.astimezone().isoformat()\n"
"\n"
"def main():\n"
"\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-c', action='store_true', default=False,\n"
"                        help='Produce a context format diff (default)')\n"
"    parser.add_argument('-u', action='store_true', default=False,\n"
"                        help='Produce a unified format diff')\n"
"    parser.add_argument('-m', action='store_true', default=False,\n"
"                        help='Produce HTML side by side diff '\n"
"                             '(can use -c and -l in conjunction)')\n"
"    parser.add_argument('-n', action='store_true', default=False,\n"
"                        help='Produce a ndiff format diff')\n"
"    parser.add_argument('-l', '--lines', type=int, default=3,\n"
"                        help='Set number of context lines (default 3)')\n"
"    parser.add_argument('fromfile')\n"
"    parser.add_argument('tofile')\n"
"    options = parser.parse_args()\n"
"\n"
"    n = options.lines\n"
"    fromfile = options.fromfile\n"
"    tofile = options.tofile\n"
"\n"
"    fromdate = file_mtime(fromfile)\n"
"    todate = file_mtime(tofile)\n"
"    with open(fromfile) as ff:\n"
"        fromlines = ff.readlines()\n"
"    with open(tofile) as tf:\n"
"        tolines = tf.readlines()\n"
"\n"
"    if options.u:\n"
"        diff = difflib.unified_diff(fromlines, tolines, fromfile, tofile, "
"fromdate, todate, n=n)\n"
"    elif options.n:\n"
"        diff = difflib.ndiff(fromlines, tolines)\n"
"    elif options.m:\n"
"        diff = difflib.HtmlDiff().make_file(fromlines,tolines,fromfile,"
"tofile,context=options.c,numlines=n)\n"
"    else:\n"
"        diff = difflib.context_diff(fromlines, tolines, fromfile, tofile, "
"fromdate, todate, n=n)\n"
"\n"
"    sys.stdout.writelines(diff)\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""
"\"\"\" Command line interface to difflib.py providing diffs in four "
"formats:\n"
"\n"
"* ndiff:    lists every line and highlights interline changes.\n"
"* context:  highlights clusters of changes in a before/after format.\n"
"* unified:  highlights clusters of changes in an inline format.\n"
"* html:     generates side by side comparison with change highlights.\n"
"\n"
"\"\"\"\n"
"\n"
"import sys, os, difflib, argparse\n"
"from datetime import datetime, timezone\n"
"\n"
"def file_mtime(path):\n"
"    t = datetime.fromtimestamp(os.stat(path).st_mtime,\n"
"                               timezone.utc)\n"
"    return t.astimezone().isoformat()\n"
"\n"
"def main():\n"
"\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-c', action='store_true', default=False,\n"
"                        help='Produce a context format diff (default)')\n"
"    parser.add_argument('-u', action='store_true', default=False,\n"
"                        help='Produce a unified format diff')\n"
"    parser.add_argument('-m', action='store_true', default=False,\n"
"                        help='Produce HTML side by side diff '\n"
"                             '(can use -c and -l in conjunction)')\n"
"    parser.add_argument('-n', action='store_true', default=False,\n"
"                        help='Produce a ndiff format diff')\n"
"    parser.add_argument('-l', '--lines', type=int, default=3,\n"
"                        help='Set number of context lines (default 3)')\n"
"    parser.add_argument('fromfile')\n"
"    parser.add_argument('tofile')\n"
"    options = parser.parse_args()\n"
"\n"
"    n = options.lines\n"
"    fromfile = options.fromfile\n"
"    tofile = options.tofile\n"
"\n"
"    fromdate = file_mtime(fromfile)\n"
"    todate = file_mtime(tofile)\n"
"    with open(fromfile) as ff:\n"
"        fromlines = ff.readlines()\n"
"    with open(tofile) as tf:\n"
"        tolines = tf.readlines()\n"
"\n"
"    if options.u:\n"
"        diff = difflib.unified_diff(fromlines, tolines, fromfile, tofile, "
"fromdate, todate, n=n)\n"
"    elif options.n:\n"
"        diff = difflib.ndiff(fromlines, tolines)\n"
"    elif options.m:\n"
"        diff = difflib.HtmlDiff().make_file(fromlines,tolines,fromfile,"
"tofile,context=options.c,numlines=n)\n"
"    else:\n"
"        diff = difflib.context_diff(fromlines, tolines, fromfile, tofile, "
"fromdate, todate, n=n)\n"
"\n"
"    sys.stdout.writelines(diff)\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"

#: ../../library/difflib.rst:764
msgid "ndiff example"
msgstr "пример ndiff"

#: ../../library/difflib.rst:766
msgid "This example shows how to use :func:`difflib.ndiff`."
msgstr "В этом примере показано, как использовать :func:`difflib.ndiff`."

#: ../../library/difflib.rst:768
msgid ""
"\"\"\"ndiff [-q] file1 file2\n"
"    or\n"
"ndiff (-r1 | -r2) < ndiff_output > file1_or_file2\n"
"\n"
"Print a human-friendly file difference report to stdout.  Both inter-\n"
"and intra-line differences are noted.  In the second form, recreate file1\n"
"(-r1) or file2 (-r2) on stdout, from an ndiff report on stdin.\n"
"\n"
"In the first form, if -q (\"quiet\") is not specified, the first two lines\n"
"of output are\n"
"\n"
"-: file1\n"
"+: file2\n"
"\n"
"Each remaining line begins with a two-letter code:\n"
"\n"
"    \"- \"    line unique to file1\n"
"    \"+ \"    line unique to file2\n"
"    \"  \"    line common to both files\n"
"    \"? \"    line not present in either input file\n"
"\n"
"Lines beginning with \"? \" attempt to guide the eye to intraline\n"
"differences, and were not present in either input file.  These lines can be\n"
"confusing if the source files contain tab characters.\n"
"\n"
"The first file can be recovered by retaining only lines that begin with\n"
"\"  \" or \"- \", and deleting those 2-character prefixes; use ndiff with -"
"r1.\n"
"\n"
"The second file can be recovered similarly, but by retaining only \"  \" "
"and\n"
"\"+ \" lines; use ndiff with -r2; or, on Unix, the second file can be\n"
"recovered by piping the output through\n"
"\n"
"    sed -n '/^[+ ] /s/^..//p'\n"
"\"\"\"\n"
"\n"
"__version__ = 1, 7, 0\n"
"\n"
"import difflib, sys\n"
"\n"
"def fail(msg):\n"
"    out = sys.stderr.write\n"
"    out(msg + \"\\n\\n\")\n"
"    out(__doc__)\n"
"    return 0\n"
"\n"
"# open a file & return the file object; gripe and return 0 if it\n"
"# couldn't be opened\n"
"def fopen(fname):\n"
"    try:\n"
"        return open(fname)\n"
"    except IOError as detail:\n"
"        return fail(\"couldn't open \" + fname + \": \" + str(detail))\n"
"\n"
"# open two files & spray the diff to stdout; return false iff a problem\n"
"def fcompare(f1name, f2name):\n"
"    f1 = fopen(f1name)\n"
"    f2 = fopen(f2name)\n"
"    if not f1 or not f2:\n"
"        return 0\n"
"\n"
"    a = f1.readlines(); f1.close()\n"
"    b = f2.readlines(); f2.close()\n"
"    for line in difflib.ndiff(a, b):\n"
"        print(line, end=' ')\n"
"\n"
"    return 1\n"
"\n"
"# crack args (sys.argv[1:] is normal) & compare;\n"
"# return false iff a problem\n"
"\n"
"def main(args):\n"
"    import getopt\n"
"    try:\n"
"        opts, args = getopt.getopt(args, \"qr:\")\n"
"    except getopt.error as detail:\n"
"        return fail(str(detail))\n"
"    noisy = 1\n"
"    qseen = rseen = 0\n"
"    for opt, val in opts:\n"
"        if opt == \"-q\":\n"
"            qseen = 1\n"
"            noisy = 0\n"
"        elif opt == \"-r\":\n"
"            rseen = 1\n"
"            whichfile = val\n"
"    if qseen and rseen:\n"
"        return fail(\"can't specify both -q and -r\")\n"
"    if rseen:\n"
"        if args:\n"
"            return fail(\"no args allowed with -r option\")\n"
"        if whichfile in (\"1\", \"2\"):\n"
"            restore(whichfile)\n"
"            return 1\n"
"        return fail(\"-r value must be 1 or 2\")\n"
"    if len(args) != 2:\n"
"        return fail(\"need 2 filename args\")\n"
"    f1name, f2name = args\n"
"    if noisy:\n"
"        print('-:', f1name)\n"
"        print('+:', f2name)\n"
"    return fcompare(f1name, f2name)\n"
"\n"
"# read ndiff output from stdin, and print file1 (which=='1') or\n"
"# file2 (which=='2') to stdout\n"
"\n"
"def restore(which):\n"
"    restored = difflib.restore(sys.stdin.readlines(), which)\n"
"    sys.stdout.writelines(restored)\n"
"\n"
"if __name__ == '__main__':\n"
"    main(sys.argv[1:])\n"
msgstr ""
"\"\"\"ndiff [-q] file1 file2\n"
"    or\n"
"ndiff (-r1 | -r2) < ndiff_output > file1_or_file2\n"
"\n"
"Print a human-friendly file difference report to stdout.  Both inter-\n"
"and intra-line differences are noted.  In the second form, recreate file1\n"
"(-r1) or file2 (-r2) on stdout, from an ndiff report on stdin.\n"
"\n"
"In the first form, if -q (\"quiet\") is not specified, the first two lines\n"
"of output are\n"
"\n"
"-: file1\n"
"+: file2\n"
"\n"
"Each remaining line begins with a two-letter code:\n"
"\n"
"    \"- \"    line unique to file1\n"
"    \"+ \"    line unique to file2\n"
"    \"  \"    line common to both files\n"
"    \"? \"    line not present in either input file\n"
"\n"
"Lines beginning with \"? \" attempt to guide the eye to intraline\n"
"differences, and were not present in either input file.  These lines can be\n"
"confusing if the source files contain tab characters.\n"
"\n"
"The first file can be recovered by retaining only lines that begin with\n"
"\"  \" or \"- \", and deleting those 2-character prefixes; use ndiff with -"
"r1.\n"
"\n"
"The second file can be recovered similarly, but by retaining only \"  \" "
"and\n"
"\"+ \" lines; use ndiff with -r2; or, on Unix, the second file can be\n"
"recovered by piping the output through\n"
"\n"
"    sed -n '/^[+ ] /s/^..//p'\n"
"\"\"\"\n"
"\n"
"__version__ = 1, 7, 0\n"
"\n"
"import difflib, sys\n"
"\n"
"def fail(msg):\n"
"    out = sys.stderr.write\n"
"    out(msg + \"\\n\\n\")\n"
"    out(__doc__)\n"
"    return 0\n"
"\n"
"# open a file & return the file object; gripe and return 0 if it\n"
"# couldn't be opened\n"
"def fopen(fname):\n"
"    try:\n"
"        return open(fname)\n"
"    except IOError as detail:\n"
"        return fail(\"couldn't open \" + fname + \": \" + str(detail))\n"
"\n"
"# open two files & spray the diff to stdout; return false iff a problem\n"
"def fcompare(f1name, f2name):\n"
"    f1 = fopen(f1name)\n"
"    f2 = fopen(f2name)\n"
"    if not f1 or not f2:\n"
"        return 0\n"
"\n"
"    a = f1.readlines(); f1.close()\n"
"    b = f2.readlines(); f2.close()\n"
"    for line in difflib.ndiff(a, b):\n"
"        print(line, end=' ')\n"
"\n"
"    return 1\n"
"\n"
"# crack args (sys.argv[1:] is normal) & compare;\n"
"# return false iff a problem\n"
"\n"
"def main(args):\n"
"    import getopt\n"
"    try:\n"
"        opts, args = getopt.getopt(args, \"qr:\")\n"
"    except getopt.error as detail:\n"
"        return fail(str(detail))\n"
"    noisy = 1\n"
"    qseen = rseen = 0\n"
"    for opt, val in opts:\n"
"        if opt == \"-q\":\n"
"            qseen = 1\n"
"            noisy = 0\n"
"        elif opt == \"-r\":\n"
"            rseen = 1\n"
"            whichfile = val\n"
"    if qseen and rseen:\n"
"        return fail(\"can't specify both -q and -r\")\n"
"    if rseen:\n"
"        if args:\n"
"            return fail(\"no args allowed with -r option\")\n"
"        if whichfile in (\"1\", \"2\"):\n"
"            restore(whichfile)\n"
"            return 1\n"
"        return fail(\"-r value must be 1 or 2\")\n"
"    if len(args) != 2:\n"
"        return fail(\"need 2 filename args\")\n"
"    f1name, f2name = args\n"
"    if noisy:\n"
"        print('-:', f1name)\n"
"        print('+:', f2name)\n"
"    return fcompare(f1name, f2name)\n"
"\n"
"# read ndiff output from stdin, and print file1 (which=='1') or\n"
"# file2 (which=='2') to stdout\n"
"\n"
"def restore(which):\n"
"    restored = difflib.restore(sys.stdin.readlines(), which)\n"
"    sys.stdout.writelines(restored)\n"
"\n"
"if __name__ == '__main__':\n"
"    main(sys.argv[1:])\n"
