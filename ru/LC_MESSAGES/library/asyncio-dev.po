# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/asyncio-dev.rst:7
msgid "Developing with asyncio"
msgstr "Разработка с помощью asyncio"

#: ../../library/asyncio-dev.rst:9
msgid ""
"Asynchronous programming is different from classic \"sequential\" "
"programming."
msgstr ""
"Асинхронное программирование отличается от классического «последовательного» "
"программирования."

#: ../../library/asyncio-dev.rst:12
msgid ""
"This page lists common mistakes and traps and explains how to avoid them."
msgstr ""
"На этой странице перечислены распространенные ошибки и ловушки, а также "
"объясняется, как их избежать."

#: ../../library/asyncio-dev.rst:19
msgid "Debug Mode"
msgstr "Режим отладки"

#: ../../library/asyncio-dev.rst:21
msgid ""
"By default asyncio runs in production mode.  In order to ease the "
"development asyncio has a *debug mode*."
msgstr ""
"По умолчанию asyncio работает в производственном режиме. Чтобы облегчить "
"разработку, в asyncio предусмотрен *режим отладки*."

#: ../../library/asyncio-dev.rst:24
msgid "There are several ways to enable asyncio debug mode:"
msgstr "Есть несколько способов включить режим отладки asyncio:"

#: ../../library/asyncio-dev.rst:26
msgid "Setting the :envvar:`PYTHONASYNCIODEBUG` environment variable to ``1``."
msgstr ""
"Установка переменной среды :envvar:`PYTHONASYNCIODEBUG` в значение ``1``."

#: ../../library/asyncio-dev.rst:28
msgid "Using the :ref:`Python Development Mode <devmode>`."
msgstr "Использование :ref:`Режима разработки Python <devmode>`."

#: ../../library/asyncio-dev.rst:30
msgid "Passing ``debug=True`` to :func:`asyncio.run`."
msgstr "Передача ``debug=True`` в :func:`asyncio.run`."

#: ../../library/asyncio-dev.rst:32
msgid "Calling :meth:`loop.set_debug`."
msgstr "Вызов :meth:`loop.set_debug`."

#: ../../library/asyncio-dev.rst:34
msgid "In addition to enabling the debug mode, consider also:"
msgstr "Помимо включения режима отладки, учтите также:"

#: ../../library/asyncio-dev.rst:36
msgid ""
"setting the log level of the :ref:`asyncio logger <asyncio-logger>` to :py:"
"const:`logging.DEBUG`, for example the following snippet of code can be run "
"at startup of the application::"
msgstr ""
"установка уровня журнала :ref:`asyncio logger <asyncio-logger>` на :py:const:"
"`logging.DEBUG`, например, следующий фрагмент кода может быть запущен при "
"запуске приложения:"

#: ../../library/asyncio-dev.rst:40
msgid "logging.basicConfig(level=logging.DEBUG)"
msgstr "logging.basicConfig(level=logging.DEBUG)"

#: ../../library/asyncio-dev.rst:42
msgid ""
"configuring the :mod:`warnings` module to display :exc:`ResourceWarning` "
"warnings.  One way of doing that is by using the :option:`-W` ``default`` "
"command line option."
msgstr ""
"настройка модуля :mod:`warnings` для отображения предупреждений :exc:"
"`ResourceWarning`. Один из способов сделать это — использовать параметр "
"командной строки :option:`-W` ``default``."

#: ../../library/asyncio-dev.rst:47
msgid "When the debug mode is enabled:"
msgstr "Когда режим отладки включен:"

#: ../../library/asyncio-dev.rst:49
msgid ""
"asyncio checks for :ref:`coroutines that were not awaited <asyncio-coroutine-"
"not-scheduled>` and logs them; this mitigates the \"forgotten await\" "
"pitfall."
msgstr ""
"asyncio проверяет наличие неожиданных сопрограмм <asyncio-coroutine-not-"
"scheduled>` и записывает их в журнал; это смягчает ловушку «забытого "
"ожидания»."

#: ../../library/asyncio-dev.rst:53
msgid ""
"Many non-threadsafe asyncio APIs (such as :meth:`loop.call_soon` and :meth:"
"`loop.call_at` methods) raise an exception if they are called from a wrong "
"thread."
msgstr ""
"Многие непотокобезопасные асинхронные API (например, методы :meth:`loop."
"call_soon` и :meth:`loop.call_at`) вызывают исключение, если они вызываются "
"из неправильного потока."

#: ../../library/asyncio-dev.rst:57
msgid ""
"The execution time of the I/O selector is logged if it takes too long to "
"perform an I/O operation."
msgstr ""
"Время выполнения селектора ввода-вывода регистрируется, если выполнение "
"операции ввода-вывода занимает слишком много времени."

#: ../../library/asyncio-dev.rst:60
msgid ""
"Callbacks taking longer than 100 milliseconds are logged.  The :attr:`loop."
"slow_callback_duration` attribute can be used to set the minimum execution "
"duration in seconds that is considered \"slow\"."
msgstr ""
"Обратные вызовы, занимающие более 100 миллисекунд, регистрируются. Атрибут :"
"attr:`loop.slow_callback_duration` можно использовать для установки "
"минимальной продолжительности выполнения в секундах, которая считается "
"«медленной»."

#: ../../library/asyncio-dev.rst:68
msgid "Concurrency and Multithreading"
msgstr "Параллелизм и многопоточность"

#: ../../library/asyncio-dev.rst:70
msgid ""
"An event loop runs in a thread (typically the main thread) and executes all "
"callbacks and Tasks in its thread.  While a Task is running in the event "
"loop, no other Tasks can run in the same thread.  When a Task executes an "
"``await`` expression, the running Task gets suspended, and the event loop "
"executes the next Task."
msgstr ""
"Цикл событий выполняется в потоке (обычно в основном потоке) и выполняет все "
"обратные вызовы и задачи в своем потоке. Пока задача выполняется в цикле "
"событий, никакие другие задачи не могут выполняться в том же потоке. Когда "
"Задача выполняет выражение ``await``, выполняющаяся Задача "
"приостанавливается, и цикл событий выполняет следующую Задача."

#: ../../library/asyncio-dev.rst:76
msgid ""
"To schedule a :term:`callback` from another OS thread, the :meth:`loop."
"call_soon_threadsafe` method should be used. Example::"
msgstr ""
"Чтобы запланировать обратный вызов :term:`call` из другого потока ОС, "
"следует использовать метод :meth:`loop.call_soon_threadsafe`. Пример::"

#: ../../library/asyncio-dev.rst:79
msgid "loop.call_soon_threadsafe(callback, *args)"
msgstr "loop.call_soon_threadsafe(callback, *args)"

#: ../../library/asyncio-dev.rst:81
msgid ""
"Almost all asyncio objects are not thread safe, which is typically not a "
"problem unless there is code that works with them from outside of a Task or "
"a callback.  If there's a need for such code to call a low-level asyncio "
"API, the :meth:`loop.call_soon_threadsafe` method should be used, e.g.::"
msgstr ""
"Почти все объекты asyncio не являются потокобезопасными, что обычно не "
"является проблемой, если нет кода, который работает с ними вне задачи или "
"обратного вызова. Если необходимо, чтобы такой код вызывал низкоуровневый "
"асинхронный API, следует использовать метод :meth:`loop."
"call_soon_threadsafe`, например::"

#: ../../library/asyncio-dev.rst:87
msgid "loop.call_soon_threadsafe(fut.cancel)"
msgstr "loop.call_soon_threadsafe(fut.cancel)"

#: ../../library/asyncio-dev.rst:89
msgid ""
"To schedule a coroutine object from a different OS thread, the :func:"
"`run_coroutine_threadsafe` function should be used. It returns a :class:"
"`concurrent.futures.Future` to access the result::"
msgstr ""
"Чтобы запланировать объект сопрограммы из другого потока ОС, следует "
"использовать функцию :func:`run_coroutine_threadsafe`. Он возвращает :class:"
"`concurrent.futures.Future` для доступа к результату::"

#: ../../library/asyncio-dev.rst:93
msgid ""
"async def coro_func():\n"
"     return await asyncio.sleep(1, 42)\n"
"\n"
"# Later in another OS thread:\n"
"\n"
"future = asyncio.run_coroutine_threadsafe(coro_func(), loop)\n"
"# Wait for the result:\n"
"result = future.result()"
msgstr ""
"async def coro_func():\n"
"     return await asyncio.sleep(1, 42)\n"
"\n"
"# Later in another OS thread:\n"
"\n"
"future = asyncio.run_coroutine_threadsafe(coro_func(), loop)\n"
"# Wait for the result:\n"
"result = future.result()"

#: ../../library/asyncio-dev.rst:102
msgid "To handle signals the event loop must be run in the main thread."
msgstr ""
"Для обработки сигналов цикл событий должен запускаться в основном потоке."

#: ../../library/asyncio-dev.rst:105
msgid ""
"The :meth:`loop.run_in_executor` method can be used with a :class:"
"`concurrent.futures.ThreadPoolExecutor` to execute blocking code in a "
"different OS thread without blocking the OS thread that the event loop runs "
"in."
msgstr ""
"Метод :meth:`loop.run_in_executor` можно использовать с :class:`concurrent."
"futures.ThreadPoolExecutor` для выполнения блокирующего кода в другом потоке "
"ОС без блокировки потока ОС, в котором выполняется цикл событий."

#: ../../library/asyncio-dev.rst:110
msgid ""
"There is currently no way to schedule coroutines or callbacks directly from "
"a different process (such as one started with :mod:`multiprocessing`). The :"
"ref:`asyncio-event-loop-methods` section lists APIs that can read from pipes "
"and watch file descriptors without blocking the event loop. In addition, "
"asyncio's :ref:`Subprocess <asyncio-subprocess>` APIs provide a way to start "
"a process and communicate with it from the event loop. Lastly, the "
"aforementioned :meth:`loop.run_in_executor` method can also be used with a :"
"class:`concurrent.futures.ProcessPoolExecutor` to execute code in a "
"different process."
msgstr ""
"В настоящее время невозможно запланировать сопрограммы или обратные вызовы "
"непосредственно из другого процесса (например, запущенного с :mod:"
"`multiprocessing`). В разделе :ref:`asyncio-event-loop-methods` перечислены "
"API, которые могут читать из каналов и просматривать файловые дескрипторы, "
"не блокируя цикл событий. Кроме того, API-интерфейсы :ref:`Subprocess "
"<asyncio-subprocess>` asyncio предоставляют способ запустить процесс и "
"взаимодействовать с ним из цикла событий. Наконец, вышеупомянутый метод :"
"meth:`loop.run_in_executor` также можно использовать с :class:`concurrent."
"futures.ProcessPoolExecutor` для выполнения кода в другом процессе."

#: ../../library/asyncio-dev.rst:124
msgid "Running Blocking Code"
msgstr "Запуск блокирующего кода"

#: ../../library/asyncio-dev.rst:126
msgid ""
"Blocking (CPU-bound) code should not be called directly.  For example, if a "
"function performs a CPU-intensive calculation for 1 second, all concurrent "
"asyncio Tasks and IO operations would be delayed by 1 second."
msgstr ""
"Блокирующий (привязанный к процессору) код не следует вызывать напрямую. "
"Например, если функция выполняет вычисления с интенсивным использованием ЦП "
"в течение 1 секунды, все одновременные асинхронные задачи и операции ввода-"
"вывода будут задержаны на 1 секунду."

#: ../../library/asyncio-dev.rst:131
msgid ""
"An executor can be used to run a task in a different thread or even in a "
"different process to avoid blocking the OS thread with the event loop.  See "
"the :meth:`loop.run_in_executor` method for more details."
msgstr ""
"Исполнитель можно использовать для запуска задачи в другом потоке или даже в "
"другом процессе, чтобы избежать блокировки потока ОС с помощью цикла "
"событий. Подробнее см. в методе :meth:`loop.run_in_executor`."

#: ../../library/asyncio-dev.rst:140
msgid "Logging"
msgstr "Логирование"

#: ../../library/asyncio-dev.rst:142
msgid ""
"asyncio uses the :mod:`logging` module and all logging is performed via the "
"``\"asyncio\"`` logger."
msgstr ""
"asyncio использует модуль :mod:`logging`, и все журналирование выполняется с "
"помощью регистратора ``\"asyncio\"``."

#: ../../library/asyncio-dev.rst:145
msgid ""
"The default log level is :py:const:`logging.INFO`, which can be easily "
"adjusted::"
msgstr ""
"Уровень журнала по умолчанию — :py:const:`logging.INFO`, который можно легко "
"настроить::"

#: ../../library/asyncio-dev.rst:148
msgid "logging.getLogger(\"asyncio\").setLevel(logging.WARNING)"
msgstr "logging.getLogger(\"asyncio\").setLevel(logging.WARNING)"

#: ../../library/asyncio-dev.rst:151
msgid ""
"Network logging can block the event loop. It is recommended to use a "
"separate thread for handling logs or use non-blocking IO. For example, see :"
"ref:`blocking-handlers`."
msgstr ""
"Ведение журнала сети может заблокировать цикл событий. Рекомендуется "
"использовать отдельный поток для обработки логов или использовать "
"неблокирующий ввод-вывод. Например, см. :ref:`blocking-handlers`."

#: ../../library/asyncio-dev.rst:159
msgid "Detect never-awaited coroutines"
msgstr "Обнаружение неожиданных сопрограмм"

#: ../../library/asyncio-dev.rst:161
msgid ""
"When a coroutine function is called, but not awaited (e.g. ``coro()`` "
"instead of ``await coro()``) or the coroutine is not scheduled with :meth:"
"`asyncio.create_task`, asyncio will emit a :exc:`RuntimeWarning`::"
msgstr ""
"Когда функция сопрограммы вызывается, но не ожидается (например, ``coro()`` "
"вместо ``await coro()``) или сопрограмма не запланирована с помощью :meth:"
"`asyncio.create_task`, asyncio выдаст сообщение :exc:`RuntimeWarning`::"

#: ../../library/asyncio-dev.rst:166
msgid ""
"import asyncio\n"
"\n"
"async def test():\n"
"    print(\"never scheduled\")\n"
"\n"
"async def main():\n"
"    test()\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def test():\n"
"    print(\"never scheduled\")\n"
"\n"
"async def main():\n"
"    test()\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-dev.rst:176 ../../library/asyncio-dev.rst:221
msgid "Output::"
msgstr "Вывод::"

#: ../../library/asyncio-dev.rst:178
msgid ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"  test()"
msgstr ""
"test.py:7: RuntimeWarning: сопрограмма «тест» никогда не ожидалась тест()"

#: ../../library/asyncio-dev.rst:181 ../../library/asyncio-dev.rst:237
msgid "Output in debug mode::"
msgstr "Вывод в режиме отладки::"

#: ../../library/asyncio-dev.rst:183
msgid ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"Coroutine created at (most recent call last)\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"  < .. >\n"
"\n"
"  File \"../t.py\", line 7, in main\n"
"    test()\n"
"  test()"
msgstr ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"Coroutine created at (most recent call last)\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"  < .. >\n"
"\n"
"  File \"../t.py\", line 7, in main\n"
"    test()\n"
"  test()"

#: ../../library/asyncio-dev.rst:194
msgid ""
"The usual fix is to either await the coroutine or call the :meth:`asyncio."
"create_task` function::"
msgstr ""
"Обычное решение — либо дождаться сопрограммы, либо вызвать функцию :meth:"
"`asyncio.create_task`::"

#: ../../library/asyncio-dev.rst:197
msgid ""
"async def main():\n"
"    await test()"
msgstr ""
"async def main():\n"
"    await test()"

#: ../../library/asyncio-dev.rst:202
msgid "Detect never-retrieved exceptions"
msgstr "Обнаружение никогда не извлекаемых исключений"

#: ../../library/asyncio-dev.rst:204
msgid ""
"If a :meth:`Future.set_exception` is called but the Future object is never "
"awaited on, the exception would never be propagated to the user code.  In "
"this case, asyncio would emit a log message when the Future object is "
"garbage collected."
msgstr ""
"Если :meth:`Future.set_Exception` вызывается, но объект Future никогда не "
"ожидается, исключение никогда не будет распространено на пользовательский "
"код. В этом случае asyncio выдаст сообщение журнала, когда объект Future "
"будет собран мусором."

#: ../../library/asyncio-dev.rst:209
msgid "Example of an unhandled exception::"
msgstr "Пример необработанного исключения::"

#: ../../library/asyncio-dev.rst:211
msgid ""
"import asyncio\n"
"\n"
"async def bug():\n"
"    raise Exception(\"not consumed\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(bug())\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def bug():\n"
"    raise Exception(\"not consumed\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(bug())\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-dev.rst:223
msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"  exception=Exception('not consumed')>\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"test.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""
"Исключение задачи никогда не было получено будущее: <Задача завершена "
"coro=<bug() выполнена, определено в test.py:3> исключение=Исключение('не "
"используется')> Traceback (последний вызов последний): Файл «test.py», "
"строка 4, в ошибке поднять исключение («не использовано») Исключение: не "
"потребляется"

#: ../../library/asyncio-dev.rst:232
msgid ""
":ref:`Enable the debug mode <asyncio-debug-mode>` to get the traceback where "
"the task was created::"
msgstr ""
":ref:`Включите режим отладки <asyncio-debug-mode>`, чтобы получить обратную "
"трассировку места создания задачи::"

#: ../../library/asyncio-dev.rst:235
msgid "asyncio.run(main(), debug=True)"
msgstr "asyncio.run(main(), debug=True)"

#: ../../library/asyncio-dev.rst:239
msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"    exception=Exception('not consumed') created at asyncio/tasks.py:321>\n"
"\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"< .. >\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"../t.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"    exception=Exception('not consumed') created at asyncio/tasks.py:321>\n"
"\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"< .. >\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"../t.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
