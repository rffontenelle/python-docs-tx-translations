# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# alex alev <alex.alev@bk.ru>, 2021
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:11+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/pickle.rst:2
msgid ":mod:`!pickle` --- Python object serialization"
msgstr ":mod:`!pickle` --- Сериализация объектов Python"

#: ../../library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**Исходный код:** :source:`Lib/pickle.py`"

#: ../../library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a :"
"term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
"Модуль :mod:`pickle` реализует двоичные протоколы для сериализации и "
"десериализации объектной структуры Python. *\"Пиклинг\"* — это процесс, при "
"котором иерархия объектов Python преобразуется в поток байтов, а "
"*\"распаковка\"* — это обратная операция, при которой поток байтов (из :term:"
"`двоичного файла` или :term:` байтовый объект`) преобразуется обратно в "
"иерархию объектов. Маринование (и демаринование) также известно как "
"«сериализация», «маршалинг». [#]_ или «сглаживание»; однако, чтобы избежать "
"путаницы, здесь используются термины «маринование» и «расмаринование»."

#: ../../library/pickle.rst:33
msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr ""
"Модуль ``pickle`` **небезопасен**. Распаковывайте только те данные, которым "
"вы доверяете."

#: ../../library/pickle.rst:35
msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have come "
"from an untrusted source, or that could have been tampered with."
msgstr ""
"Можно создать вредоносные данные травления, которые будут **выполнять "
"произвольный код во время распаковки**. Никогда не анализируйте данные, "
"которые могли быть получены из ненадежного источника или которые могли быть "
"подделаны."

#: ../../library/pickle.rst:39
msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has not "
"been tampered with."
msgstr ""
"Рассмотрите возможность подписания данных с помощью :mod:`hmac`, если вам "
"нужно убедиться, что они не были подделаны."

#: ../../library/pickle.rst:42
msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate if "
"you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""
"Более безопасные форматы сериализации, такие как :mod:`json`, могут быть "
"более подходящими, если вы обрабатываете ненадежные данные. См. :ref:"
"`сравнение-с-json`."

#: ../../library/pickle.rst:47
msgid "Relationship to other Python modules"
msgstr "Связь с другими модулями Python"

#: ../../library/pickle.rst:50
msgid "Comparison with ``marshal``"
msgstr "Сравнение с ``marshal``"

#: ../../library/pickle.rst:52
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""
"В Python есть более примитивный модуль сериализации, называемый :mod:"
"`marshal`, но в целом :mod:`pickle` всегда должен быть предпочтительным "
"способом сериализации объектов Python. :mod:`marshal` существует в первую "
"очередь для поддержки файлов Python :file:`.pyc`."

#: ../../library/pickle.rst:57
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ""
"Модуль :mod:`pickle` отличается от :mod:`marshal` по нескольким важным "
"параметрам:"

#: ../../library/pickle.rst:59
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
"Модуль :mod:`pickle` отслеживает объекты, которые он уже сериализовал, "
"поэтому последующие ссылки на тот же объект не будут сериализоваться снова. :"
"mod:`marshal` этого не делает."

#: ../../library/pickle.rst:63
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"Это имеет значение как для рекурсивных объектов, так и для совместного "
"использования объектов. Рекурсивные объекты — это объекты, содержащие ссылки "
"на себя. Они не обрабатываются маршалом, и фактически попытка маршалирования "
"рекурсивных объектов приведет к сбою вашего интерпретатора Python. "
"Совместное использование объектов происходит, когда существует несколько "
"ссылок на один и тот же объект в разных местах сериализуемой иерархии "
"объектов. :mod:`pickle` сохраняет такие объекты только один раз и "
"гарантирует, что все остальные ссылки указывают на мастер-копию. Общие "
"объекты остаются общими, что может быть очень важно для изменяемых объектов."

#: ../../library/pickle.rst:72
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` нельзя использовать для сериализации пользовательских классов "
"и их экземпляров. :mod:`pickle` может сохранять и восстанавливать экземпляры "
"классов прозрачно, однако определение класса должно быть импортируемым и "
"находиться в том же модуле, в котором был сохранен объект."

#: ../../library/pickle.rst:77
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type "
"differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""
"Переносимость формата сериализации :mod:`marshal` не гарантируется между "
"версиями Python. Поскольку его основной задачей в жизни является поддержка "
"файлов :file:`.pyc`, разработчики Python оставляют за собой право изменять "
"формат сериализации способами, не имеющими обратной совместимости, если "
"возникнет такая необходимость. Формат сериализации :mod:`pickle` "
"гарантированно будет обратно совместим между выпусками Python при условии, "
"что выбран совместимый протокол Pickle, а код травления и распаковки "
"обрабатывает различия типов Python 2 и Python 3, если ваши данные пересекают "
"эту уникальную границу языка критических изменений. ."

#: ../../library/pickle.rst:90
msgid "Comparison with ``json``"
msgstr "Сравнение с ``json``"

#: ../../library/pickle.rst:92
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <https://json.org>`_:"
msgstr ""
"Существуют фундаментальные различия между протоколами Pickle и `JSON "
"(JavaScript Object Notation) <https://json.org>`_:"

#: ../../library/pickle.rst:95
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON — это формат сериализации текста (он выводит текст в формате Юникода, "
"хотя большую часть времени он кодируется в «utf-8»), тогда как Pickle — это "
"формат двоичной сериализации;"

#: ../../library/pickle.rst:99
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON удобен для чтения человеком, а Pickle — нет;"

#: ../../library/pickle.rst:101
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while "
"pickle is Python-specific;"
msgstr ""
"JSON совместим и широко используется за пределами экосистемы Python, тогда "
"как Pickle специфичен для Python;"

#: ../../library/pickle.rst:104
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing :ref:"
"`specific object APIs <pickle-inst>`);"
msgstr ""
"JSON по умолчанию может представлять только подмножество встроенных типов "
"Python и не может представлять пользовательские классы; Pickle может "
"представлять чрезвычайно большое количество типов Python (многие из них "
"автоматически, за счет умелого использования средств интроспекции Python; "
"сложные случаи можно решать, реализуя API конкретных объектов <pickle-"
"inst>`);"

#: ../../library/pickle.rst:110
msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr ""
"В отличие от Pickle, десериализация ненадежного JSON сама по себе не создает "
"уязвимости, связанной с выполнением произвольного кода."

#: ../../library/pickle.rst:114
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ""
"Модуль :mod:`json`: стандартный библиотечный модуль, позволяющий "
"сериализацию и десериализацию JSON."

#: ../../library/pickle.rst:121
msgid "Data stream format"
msgstr "Формат потока данных"

#: ../../library/pickle.rst:126
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON (which can't represent pointer sharing); however it means that non-"
"Python programs may not be able to reconstruct pickled Python objects."
msgstr ""
"Формат данных, используемый :mod:`pickle`, зависит от Python. Преимущество "
"этого подхода состоит в том, что не существует ограничений, налагаемых "
"внешними стандартами, такими как JSON (который не может представлять "
"совместное использование указателей); однако это означает, что программы, "
"отличные от Python, могут быть не в состоянии реконструировать "
"консервированные объекты Python."

#: ../../library/pickle.rst:131
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"По умолчанию формат данных :mod:`pickle` использует относительно компактное "
"двоичное представление. Если вам нужны оптимальные характеристики размера, "
"вы можете эффективно :doc:`сжать <архивирование>` маринованные данные."

#: ../../library/pickle.rst:135
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
"Модуль :mod:`pickletools` содержит инструменты для анализа потоков данных, "
"генерируемых :mod:`pickle`. Исходный код :mod:`pickletools` содержит "
"подробные комментарии о кодах операций, используемых протоколами Pickle."

#: ../../library/pickle.rst:139
msgid ""
"There are currently 6 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr ""
"В настоящее время существует 6 различных протоколов травления. Чем выше "
"используемый протокол, тем более поздняя версия Python необходима для чтения "
"полученного рассола."

#: ../../library/pickle.rst:143
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr ""
"Протокол версии 0 — это оригинальный «удобочитаемый» протокол, обратно "
"совместимый с более ранними версиями Python."

#: ../../library/pickle.rst:146
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr ""
"Протокол версии 1 — это старый двоичный формат, который также совместим с "
"более ранними версиями Python."

#: ../../library/pickle.rst:149
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style classes <new-style class>`.  Refer "
"to :pep:`307` for information about improvements brought by protocol 2."
msgstr ""
"Протокол версии 2 был представлен в Python 2.3. Это обеспечивает гораздо "
"более эффективное травление :term:`классов нового стиля <класс нового "
"стиля>`. Обратитесь к :pep:`307` для получения информации об улучшениях, "
"внесенных протоколом 2."

#: ../../library/pickle.rst:153
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for :"
"class:`bytes` objects and cannot be unpickled by Python 2.x.  This was the "
"default protocol in Python 3.0--3.7."
msgstr ""
"Протокол версии 3 был добавлен в Python 3.0. Он имеет явную поддержку "
"объектов :class:`bytes` и не может быть распакован Python 2.x. Это был "
"протокол по умолчанию в Python 3.0–3.7."

#: ../../library/pickle.rst:157
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format "
"optimizations.  It is the default protocol starting with Python 3.8. Refer "
"to :pep:`3154` for information about improvements brought by protocol 4."
msgstr ""
"Протокол версии 4 был добавлен в Python 3.4. Он добавляет поддержку очень "
"больших объектов, выбор большего количества типов объектов и некоторую "
"оптимизацию формата данных. Это протокол по умолчанию, начиная с Python 3.8. "
"Обратитесь к :pep:`3154` для получения информации об улучшениях, внесенных "
"протоколом 4."

#: ../../library/pickle.rst:163
msgid ""
"Protocol version 5 was added in Python 3.8.  It adds support for out-of-band "
"data and speedup for in-band data.  Refer to :pep:`574` for information "
"about improvements brought by protocol 5."
msgstr ""
"Протокол версии 5 был добавлен в Python 3.8. Он добавляет поддержку "
"внеполосных данных и ускорение внутриполосных данных. Обратитесь к :pep:"
"`574` для получения информации об улучшениях, внесенных протоколом 5."

#: ../../library/pickle.rst:168
msgid ""
"Serialization is a more primitive notion than persistence; although :mod:"
"`pickle` reads and writes file objects, it does not handle the issue of "
"naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"Сериализация — более примитивное понятие, чем постоянство; хотя :mod:"
"`pickle` читает и записывает файловые объекты, он не решает ни проблему "
"именования постоянных объектов, ни (еще более сложную) проблему "
"одновременного доступа к постоянным объектам. Модуль :mod:`pickle` может "
"преобразовать сложный объект в поток байтов, а также преобразовать поток "
"байтов в объект с той же внутренней структурой. Возможно, самое очевидное, "
"что можно сделать с этими потоками байтов, — это записать их в файл, но их "
"также можно отправить по сети или сохранить в базе данных. Модуль :mod:"
"`shelve` предоставляет простой интерфейс для выбора и удаления объектов в "
"файлах базы данных в стиле DBM."

#: ../../library/pickle.rst:181
msgid "Module Interface"
msgstr "Интерфейс модуля"

#: ../../library/pickle.rst:183
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the :func:"
"`loads` function. However, if you want more control over serialization and "
"de-serialization, you can create a :class:`Pickler` or an :class:`Unpickler` "
"object, respectively."
msgstr ""
"Чтобы сериализовать иерархию объектов, вы просто вызываете функцию :func:"
"`dumps`. Аналогично, чтобы десериализовать поток данных, вы вызываете "
"функцию :func:`loads`. Однако, если вам нужен больший контроль над "
"сериализацией и десериализацией, вы можете создать объект :class:`Pickler` "
"или :class:`Unpickler` соответственно."

#: ../../library/pickle.rst:188
msgid "The :mod:`pickle` module provides the following constants:"
msgstr "Модуль :mod:`pickle` предоставляет следующие константы:"

#: ../../library/pickle.rst:193
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions :"
"func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"Целое число, наивысшая доступная версия протокола <pickle-protocols>`. Это "
"значение можно передать как значение *протокола* в функции :func:`dump` и :"
"func:`dumps`, а также в конструктор :class:`Pickler`."

#: ../../library/pickle.rst:200
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default "
"protocol is 4, first introduced in Python 3.4 and incompatible with previous "
"versions."
msgstr ""
"Целое число, версия протокола по умолчанию <pickle-protocols>, используемая "
"для травления. Может быть меньше :data:`HIGHEST_PROTOCOL`. В настоящее время "
"протоколом по умолчанию является 4, впервые представленный в Python 3.4 и "
"несовместимый с предыдущими версиями."

#: ../../library/pickle.rst:207
msgid "The default protocol is 3."
msgstr "Протокол по умолчанию — 3."

#: ../../library/pickle.rst:211
msgid "The default protocol is 4."
msgstr "Протокол по умолчанию — 4."

#: ../../library/pickle.rst:213
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ""
"Модуль :mod:`pickle` предоставляет следующие функции, делающие процесс "
"маринования более удобным:"

#: ../../library/pickle.rst:218
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file "
"object` *file*.  This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"Запишите маринованное представление объекта *obj* в открытый :term:`file "
"object` *file*. Это эквивалентно ``Pickler(файл, протокол).dump(obj)``."

#: ../../library/pickle.rst:222
msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have the "
"same meaning as in the :class:`Pickler` constructor."
msgstr ""
"Аргументы *file*, *protocol*, *fix_imports* и *buffer_callback* имеют то же "
"значение, что и в конструкторе :class:`Pickler`."

#: ../../library/pickle.rst:225 ../../library/pickle.rst:236
#: ../../library/pickle.rst:328
msgid "The *buffer_callback* argument was added."
msgstr "Был добавлен аргумент *buffer_callback*."

#: ../../library/pickle.rst:230
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr ""
"Верните обработанное представление объекта *obj* как объект :class:`bytes` "
"вместо записи его в файл."

#: ../../library/pickle.rst:233
msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr ""
"Аргументы *protocol*, *fix_imports* и *buffer_callback* имеют то же "
"значение, что и в конструкторе :class:`Pickler`."

#: ../../library/pickle.rst:241
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"Считайте маринованное представление объекта из открытого :term:`file object` "
"*file* и верните указанную в нем восстановленную иерархию объектов. Это "
"эквивалентно ``Unpickler(file).load()``."

#: ../../library/pickle.rst:245 ../../library/pickle.rst:260
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled representation of the object are "
"ignored."
msgstr ""
"Версия протокола рассола определяется автоматически, поэтому аргумент "
"протокола не требуется. Байты после маринованного представления объекта "
"игнорируются."

#: ../../library/pickle.rst:249
msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"Аргументы *file*, *fix_imports*, *encoding*, *errors*, *strict* и *buffers* "
"имеют то же значение, что и в конструкторе :class:`Unpickler`."

#: ../../library/pickle.rst:252 ../../library/pickle.rst:267
#: ../../library/pickle.rst:433
msgid "The *buffers* argument was added."
msgstr "Был добавлен аргумент *buffers*."

#: ../../library/pickle.rst:257
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""
"Возвращает восстановленную иерархию объектов маринованного представления "
"*данных* объекта. *данные* должны быть :term:`байтоподобным объектом`."

#: ../../library/pickle.rst:264
msgid ""
"Arguments *fix_imports*, *encoding*, *errors*, *strict* and *buffers* have "
"the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"Аргументы *fix_imports*, *encoding*, *errors*, *strict* и *buffers* имеют то "
"же значение, что и в конструкторе :class:`Unpickler`."

#: ../../library/pickle.rst:271
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr "Модуль :mod:`pickle` определяет три исключения:"

#: ../../library/pickle.rst:275
msgid ""
"Common base class for the other pickling exceptions.  It inherits from :exc:"
"`Exception`."
msgstr ""
"Общий базовый класс для других исключений травления. Он наследуется от :exc:"
"`Exception`."

#: ../../library/pickle.rst:280
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits from :exc:`PickleError`."
msgstr ""
"Ошибка возникает, когда :class:`Pickler` обнаруживает неподдающийся "
"пикированию объект. Он наследуется от :exc:`PickleError`."

#: ../../library/pickle.rst:283
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr ""
"Обратитесь к :ref:`pickle-picklable`, чтобы узнать, какие типы объектов "
"можно мариновать."

#: ../../library/pickle.rst:288
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits from :exc:`PickleError`."
msgstr ""
"Ошибка возникает, когда возникает проблема с распаковкой объекта, например "
"повреждение данных или нарушение безопасности. Он наследуется от :exc:"
"`PickleError`."

#: ../../library/pickle.rst:291
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"Обратите внимание, что во время распаковки также могут быть вызваны другие "
"исключения, включая (но не обязательно ограничиваясь ими) AttributeError, "
"EOFError, ImportError и IndexError."

#: ../../library/pickle.rst:296
msgid ""
"The :mod:`pickle` module exports three classes, :class:`Pickler`, :class:"
"`Unpickler` and :class:`PickleBuffer`:"
msgstr ""
"Модуль :mod:`pickle` экспортирует три класса: :class:`Pickler`, :class:"
"`Unpickler` и :class:`PickleBuffer`:"

#: ../../library/pickle.rst:301
msgid "This takes a binary file for writing a pickle data stream."
msgstr "Для записи потока данных Pickle требуется двоичный файл."

#: ../../library/pickle.rst:303
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"Необязательный аргумент *protocol*, целое число, сообщает сборщику "
"использовать данный протокол; поддерживаемые протоколы от 0 до :data:"
"`HIGHEST_PROTOCOL`. Если не указано, по умолчанию используется :data:"
"`DEFAULT_PROTOCOL`. Если указано отрицательное число, выбирается :data:"
"`HIGHEST_PROTOCOL`."

#: ../../library/pickle.rst:308
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an :"
"class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"Аргумент *file* должен иметь метод write(), который принимает аргумент в "
"один байт. Таким образом, это может быть файл на диске, открытый для "
"двоичной записи, экземпляр :class:`io.BytesIO` или любой другой "
"пользовательский объект, соответствующий этому интерфейсу."

#: ../../library/pickle.rst:313
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that "
"the pickle data stream is readable with Python 2."
msgstr ""
"Если *fix_imports* имеет значение true и *protocol* меньше 3, Pickle "
"попытается сопоставить новые имена Python 3 со старыми именами модулей, "
"используемыми в Python 2, чтобы поток данных Pickle был доступен для чтения "
"с помощью Python 2."

#: ../../library/pickle.rst:317
msgid ""
"If *buffer_callback* is ``None`` (the default), buffer views are serialized "
"into *file* as part of the pickle stream."
msgstr ""
"Если *buffer_callback* имеет значение «None» (по умолчанию), представления "
"буфера сериализуются в *file* как часть потока Pickle."

#: ../../library/pickle.rst:320
msgid ""
"If *buffer_callback* is not ``None``, then it can be called any number of "
"times with a buffer view.  If the callback returns a false value (such as "
"``None``), the given buffer is :ref:`out-of-band <pickle-oob>`; otherwise "
"the buffer is serialized in-band, i.e. inside the pickle stream."
msgstr ""
"Если *buffer_callback* не равен None, то его можно вызывать любое количество "
"раз с представлением буфера. Если обратный вызов возвращает ложное значение "
"(например, None), данный буфер является :ref:`внеполосным <pickle-oob>`; в "
"противном случае буфер сериализуется внутри полосы, т. е. внутри потока "
"травления."

#: ../../library/pickle.rst:325
msgid ""
"It is an error if *buffer_callback* is not ``None`` and *protocol* is "
"``None`` or smaller than 5."
msgstr ""
"Это ошибка, если *buffer_callback* не равен None, а *protocol* равен None "
"или меньше 5."

#: ../../library/pickle.rst:333
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr ""
"Запишите маринованное представление *obj* в объект открытого файла, "
"указанный в конструкторе."

#: ../../library/pickle.rst:338
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr ""
"По умолчанию ничего не делать. Это существует для того, чтобы подкласс мог "
"его переопределить."

#: ../../library/pickle.rst:340
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
"Если :meth:`persistent_id` возвращает ``None``, *obj* маринуется как обычно. "
"Любое другое значение приводит к тому, что :class:`Pickler` выдает "
"возвращаемое значение как постоянный идентификатор для *obj*. Значение этого "
"постоянного идентификатора должно определяться :meth:`Unpickler."
"persistent_load`. Обратите внимание, что значение, возвращаемое :meth:"
"`persistent_id`, само по себе не может иметь постоянный идентификатор."

#: ../../library/pickle.rst:346 ../../library/pickle.rst:451
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr ""
"Подробности и примеры использования см. в разделе :ref:`pickle-persistent`."

#: ../../library/pickle.rst:348
msgid ""
"Add the default implementation of this method in the C implementation of :"
"class:`!Pickler`."
msgstr ""
"Добавьте реализацию этого метода по умолчанию в реализацию C :class:`!"
"Pickler`."

#: ../../library/pickle.rst:354
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`~object.__reduce__` method."
msgstr ""
"Таблица диспетчеризации объекта пиклера представляет собой реестр *функций "
"сокращения* того типа, который можно объявить с помощью :func:`copyreg."
"pickle`. Это отображение, ключами которого являются классы, а значениями — "
"функции редукции. Функция сокращения принимает один аргумент связанного "
"класса и должна соответствовать тому же интерфейсу, что и метод :meth:"
"`~object.__reduce__`."

#: ../../library/pickle.rst:362
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the :"
"mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a :attr:"
"`dispatch_table` attribute then this will be used as the default dispatch "
"table for instances of that class."
msgstr ""
"По умолчанию объект выбора не будет иметь атрибута :attr:`dispatch_table`, и "
"вместо этого он будет использовать глобальную таблицу диспетчеризации, "
"управляемую модулем :mod:`copyreg`. Однако, чтобы настроить травление для "
"конкретного объекта пиклера, можно установить атрибут :attr:`dispatch_table` "
"для объекта, похожего на dict. Альтернативно, если подкласс :class:`Pickler` "
"имеет атрибут :attr:`dispatch_table`, то он будет использоваться в качестве "
"таблицы отправки по умолчанию для экземпляров этого класса."

#: ../../library/pickle.rst:371
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "См. примеры использования в :ref:`pickle-dispatch`."

#: ../../library/pickle.rst:377
msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`~object.__reduce__` method, "
"and can optionally return :data:`NotImplemented` to fallback on :attr:"
"`dispatch_table`-registered reducers to pickle ``obj``."
msgstr ""
"Специальный редуктор, который можно определить в подклассах :class:"
"`Pickler`. Этот метод имеет приоритет над любым редуктором в таблице :attr:"
"`dispatch_table`. Он должен соответствовать тому же интерфейсу, что и метод :"
"meth:`~object.__reduce__`, и может опционально возвращать :data:"
"`NotImplemented` для отката к зарегистрированным в :attr:`dispatch_table` "
"редьюсерам для выбора ``obj``."

#: ../../library/pickle.rst:383
msgid "For a detailed example, see :ref:`reducer_override`."
msgstr "Подробный пример см. в разделе :ref:`reducer_override`."

#: ../../library/pickle.rst:389
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""
"Устарело. Включите быстрый режим, если установлено истинное значение. "
"Быстрый режим отключает использование memo, что ускоряет процесс травления "
"за счет отсутствия генерации лишних кодов операций PUT. Его не следует "
"использовать с самореферентными объектами, иначе это приведет к бесконечной "
"рекурсии :class:`Pickler`."

#: ../../library/pickle.rst:395
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr ""
"Используйте :func:`pickletools.optimize`, если вам нужны более компактные "
"соленья."

#: ../../library/pickle.rst:400
msgid "This takes a binary file for reading a pickle data stream."
msgstr "Для чтения потока данных Pickle требуется двоичный файл."

#: ../../library/pickle.rst:402
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr ""
"Версия протокола рассола определяется автоматически, поэтому аргумент "
"протокола не требуется."

#: ../../library/pickle.rst:405
msgid ""
"The argument *file* must have three methods, a read() method that takes an "
"integer argument, a readinto() method that takes a buffer argument and a "
"readline() method that requires no arguments, as in the :class:`io."
"BufferedIOBase` interface.  Thus *file* can be an on-disk file opened for "
"binary reading, an :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""
"Аргумент *file* должен иметь три метода: метод read(), который принимает "
"целочисленный аргумент, метод readinto(), который принимает аргумент буфера, "
"и метод readline(), который не требует аргументов, как в :class:`io. "
"Интерфейс .BufferedIOBase. Таким образом, *file* может быть файлом на диске, "
"открытым для двоичного чтения, объектом :class:`io.BytesIO` или любым другим "
"пользовательским объектом, который соответствует этому интерфейсу."

#: ../../library/pickle.rst:412
msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to "
"control compatibility support for pickle stream generated by Python 2. If "
"*fix_imports* is true, pickle will try to map the old Python 2 names to the "
"new names used in Python 3.  The *encoding* and *errors* tell pickle how to "
"decode 8-bit string instances pickled by Python 2; these default to 'ASCII' "
"and 'strict', respectively.  The *encoding* can be 'bytes' to read these 8-"
"bit string instances as bytes objects. Using ``encoding='latin1'`` is "
"required for unpickling NumPy arrays and instances of :class:`~datetime."
"datetime`, :class:`~datetime.date` and :class:`~datetime.time` pickled by "
"Python 2."
msgstr ""
"Необязательные аргументы *fix_imports*, *encoding* и *errors* используются "
"для управления поддержкой совместимости потока Pickle, сгенерированного "
"Python 2. Если *fix_imports* имеет значение true, Pickle попытается "
"сопоставить старые имена Python 2 с новыми используемыми именами. в Python "
"3. *encoding* и *errors* сообщают Pickle, как декодировать экземпляры 8-"
"битных строк, обработанные Python 2; по умолчанию они имеют значения «ASCII» "
"и «строгий» соответственно. *Кодировка* может быть «байтовой» для чтения "
"этих экземпляров 8-битной строки как байтовых объектов. Использование "
"``encoding='latin1'`` необходимо для распаковки массивов NumPy и "
"экземпляров :class:`~datetime.datetime`, :class:`~datetime.date` и :class:"
"`~datetime.time`, маринованных Питон 2."

#: ../../library/pickle.rst:423
msgid ""
"If *buffers* is ``None`` (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that the "
"*buffer_callback* argument was ``None`` when a :class:`Pickler` was "
"instantiated (or when :func:`dump` or :func:`dumps` was called)."
msgstr ""
"Если *buffers* имеет значение None (по умолчанию), то все данные, "
"необходимые для десериализации, должны содержаться в потоке Pickle. Это "
"означает, что аргумент *buffer_callback* был ``None``, когда был создан "
"экземпляр :class:`Pickler` (или когда был вызван :func:`dump` или :func:"
"`dumps`)."

#: ../../library/pickle.rst:428
msgid ""
"If *buffers* is not ``None``, it should be an iterable of buffer-enabled "
"objects that is consumed each time the pickle stream references an :ref:`out-"
"of-band <pickle-oob>` buffer view.  Such buffers have been given in order to "
"the *buffer_callback* of a Pickler object."
msgstr ""
"Если *buffers* не имеет значения None, это должна быть итерация объектов с "
"включенным буфером, которая используется каждый раз, когда поток Pickle "
"ссылается на представление буфера :ref:`out-of-band <pickle-oob>`. Такие "
"буферы даны для *buffer_callback* объекта Pickler."

#: ../../library/pickle.rst:438
msgid ""
"Read the pickled representation of an object from the open file object given "
"in the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""
"Считайте маринованное представление объекта из объекта открытого файла, "
"заданного в конструкторе, и верните указанную в нем восстановленную иерархию "
"объектов. Байты после маринованного представления объекта игнорируются."

#: ../../library/pickle.rst:445
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "По умолчанию вызовите :exc:`UnpicklingError`."

#: ../../library/pickle.rst:447
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an :"
"exc:`UnpicklingError` should be raised."
msgstr ""
"Если определено, :meth:`persistent_load` должен возвращать объект, указанный "
"постоянным идентификатором *pid*. Если обнаружен неверный постоянный "
"идентификатор, должно быть выдано :exc:`UnpicklingError`."

#: ../../library/pickle.rst:453
msgid ""
"Add the default implementation of this method in the C implementation of :"
"class:`!Unpickler`."
msgstr ""
"Добавьте реализацию этого метода по умолчанию в реализацию C :class:`!"
"Unpickler`."

#: ../../library/pickle.rst:459
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"Импортируйте *module*, если необходимо, и верните из него объект с именем "
"*name*, где аргументы *module* и *name* являются объектами :class:`str`. "
"Обратите внимание: в отличие от названия, :meth:`find_class` также "
"используется для поиска функций."

#: ../../library/pickle.rst:464
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref:"
"`pickle-restrict` for details."
msgstr ""
"Подклассы могут переопределить это, чтобы получить контроль над тем, какие "
"типы объектов и как они могут быть загружены, что потенциально снижает риски "
"безопасности. Подробности см. в разделе :ref:`pickle-restrict`."

#: ../../library/pickle.rst:468
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""
"Вызывает событие аудита <auditing>` ``pickle.find_class`` с аргументами "
"``module``, ``name``."

#: ../../library/pickle.rst:472
msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be a :ref:"
"`buffer-providing <bufferobjects>` object, such as a :term:`bytes-like "
"object` or a N-dimensional array."
msgstr ""
"Обертка для буфера, представляющего поддающиеся выборке данные. *buffer* "
"должен быть объектом <bufferobjects>, предоставляющим буфер, например :term:"
"`bytes-like object` или N-мерным массивом."

#: ../../library/pickle.rst:476
msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is possible "
"to pass it to other APIs expecting a buffer-providing object, such as :class:"
"`memoryview`."
msgstr ""
":class:`PickleBuffer` сам по себе является поставщиком буфера, поэтому его "
"можно передать другим API, ожидающим объект, предоставляющий буфер, "
"например :class:`memoryview`."

#: ../../library/pickle.rst:480
msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle protocol 5 "
"or higher.  They are eligible for :ref:`out-of-band serialization <pickle-"
"oob>`."
msgstr ""
"Объекты :class:`PickleBuffer` могут быть сериализованы только с "
"использованием протокола Pickle 5 или выше. Они имеют право на внеполосную "
"сериализацию <pickle-oob>`."

#: ../../library/pickle.rst:488
msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. The "
"returned object is a one-dimensional, C-contiguous memoryview with format "
"``B`` (unsigned bytes).  :exc:`BufferError` is raised if the buffer is "
"neither C- nor Fortran-contiguous."
msgstr ""
"Возвращает :class:`memoryview` области памяти, лежащей в основе этого "
"буфера. Возвращаемый объект представляет собой одномерное C-непрерывное "
"представление памяти в формате B (беззнаковые байты). :exc:`BufferError` "
"возникает, если буфер не является смежным ни с C, ни с Fortran."

#: ../../library/pickle.rst:495
msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr "Освободите базовый буфер, предоставленный объектом PickleBuffer."

#: ../../library/pickle.rst:501
msgid "What can be pickled and unpickled?"
msgstr "Что можно мариновать и немариновать?"

#: ../../library/pickle.rst:503
msgid "The following types can be pickled:"
msgstr "Можно мариновать следующие виды:"

#: ../../library/pickle.rst:505
msgid ""
"built-in constants (``None``, ``True``, ``False``, ``Ellipsis``, and :data:"
"`NotImplemented`);"
msgstr ""
"встроенные константы (``None``, ``True``, ``False``, ``Многоточие`` и :data:"
"`NotImplemented``);"

#: ../../library/pickle.rst:508
msgid "integers, floating-point numbers, complex numbers;"
msgstr "целые числа, числа с плавающей запятой, комплексные числа;"

#: ../../library/pickle.rst:510
msgid "strings, bytes, bytearrays;"
msgstr "строки, байты, массивы байтов;"

#: ../../library/pickle.rst:512
msgid ""
"tuples, lists, sets, and dictionaries containing only picklable objects;"
msgstr ""
"кортежи, списки, наборы и словари, содержащие только поддающиеся выборке "
"объекты;"

#: ../../library/pickle.rst:514
msgid ""
"functions (built-in and user-defined) accessible from the top level of a "
"module (using :keyword:`def`, not :keyword:`lambda`);"
msgstr ""
"функции (встроенные и определяемые пользователем), доступные с верхнего "
"уровня модуля (с использованием :keyword:`def`, а не :keyword:`lambda`);"

#: ../../library/pickle.rst:517
msgid "classes accessible from the top level of a module;"
msgstr "классы, доступные с верхнего уровня модуля;"

#: ../../library/pickle.rst:519
msgid ""
"instances of such classes whose the result of calling :meth:`~object."
"__getstate__` is picklable  (see section :ref:`pickle-inst` for details)."
msgstr ""
"экземпляры таких классов, результат вызова :meth:`~object.__getstate__` "
"можно выбрать (подробности см. в разделе :ref:`pickle-inst`)."

#: ../../library/pickle.rst:522
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RecursionError` will be raised in this case.  You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""
"Попытки мариновать неконфигурируемые объекты вызовут исключение :exc:"
"`PicklingError`; когда это происходит, неопределенное количество байтов "
"может быть уже записано в базовый файл. Попытка выбрать высокорекурсивную "
"структуру данных может превысить максимальную глубину рекурсии, в этом "
"случае будет выдано сообщение :exc:`RecursionError`. Вы можете осторожно "
"увеличить этот предел с помощью :func:`sys.setrecursionlimit`."

#: ../../library/pickle.rst:529
msgid ""
"Note that functions (built-in and user-defined) are pickled by fully :term:"
"`qualified name`, not by value. [#]_  This means that only the function name "
"is pickled, along with the name of the containing module and classes.  "
"Neither the function's code, nor any of its function attributes are "
"pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""
"Обратите внимание, что функции (встроенные и определяемые пользователем) "
"выбираются по полному имени, а не по значению. [#]_ Это означает, что "
"маринуется только имя функции, а также имя содержащего ее модуля и классов. "
"Ни код функции, ни какой-либо из ее атрибутов функции не маринуются. Таким "
"образом, определяющий модуль должен быть доступен для импорта в среду "
"распаковки, и модуль должен содержать именованный объект, в противном случае "
"будет возбуждено исключение. [#]_"

#: ../../library/pickle.rst:536
msgid ""
"Similarly, classes are pickled by fully qualified name, so the same "
"restrictions in the unpickling environment apply.  Note that none of the "
"class's code or data is pickled, so in the following example the class "
"attribute ``attr`` is not restored in the unpickling environment::"
msgstr ""
"Аналогично, классы маринуются по полному имени, поэтому в среде распаковки "
"применяются те же ограничения. Обратите внимание, что ни один код или данные "
"класса не маринуются, поэтому в следующем примере атрибут класса attr не "
"восстанавливается в среде распаковки:"

#: ../../library/pickle.rst:541
msgid ""
"class Foo:\n"
"    attr = 'A class attribute'\n"
"\n"
"picklestring = pickle.dumps(Foo)"
msgstr ""
"class Foo:\n"
"    attr = 'A class attribute'\n"
"\n"
"picklestring = pickle.dumps(Foo)"

#: ../../library/pickle.rst:546
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"at the top level of a module."
msgstr ""
"Эти ограничения объясняют, почему поддающиеся выбору функции и классы должны "
"определяться на верхнем уровне модуля."

#: ../../library/pickle.rst:549
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`~object."
"__setstate__` method."
msgstr ""
"Аналогичным образом, когда экземпляры класса маринуются, код и данные их "
"класса не маринуются вместе с ними. Маринуются только данные экземпляра. Это "
"сделано специально, чтобы вы могли исправлять ошибки в классе или добавлять "
"в класс методы и при этом загружать объекты, созданные с помощью более "
"ранней версии класса. Если вы планируете иметь долгоживущие объекты, которые "
"будут видеть множество версий класса, возможно, стоит поместить в объекты "
"номер версии, чтобы можно было выполнить подходящие преобразования с помощью "
"метода :meth:`~object.__setstate__` класса. ."

#: ../../library/pickle.rst:561
msgid "Pickling Class Instances"
msgstr "Экземпляры классов травления"

#: ../../library/pickle.rst:565
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr ""
"В этом разделе мы описываем общие механизмы, доступные вам для определения, "
"настройки и управления способом консервирования и расконсервации экземпляров "
"классов."

#: ../../library/pickle.rst:568
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`~object."
"__init__` method is usually *not* invoked.  The default behaviour first "
"creates an uninitialized instance and then restores the saved attributes.  "
"The following code shows an implementation of this behaviour::"
msgstr ""
"В большинстве случаев для возможности выбора экземпляров не требуется "
"никакого дополнительного кода. По умолчанию Pickle извлекает класс и "
"атрибуты экземпляра посредством самоанализа. Когда экземпляр класса не "
"маринован, его метод :meth:`~object.__init__` обычно *не* вызывается. "
"Поведение по умолчанию сначала создает неинициализированный экземпляр, а "
"затем восстанавливает сохраненные атрибуты. Следующий код демонстрирует "
"реализацию этого поведения:"

#: ../../library/pickle.rst:575
msgid ""
"def save(obj):\n"
"    return (obj.__class__, obj.__dict__)\n"
"\n"
"def restore(cls, attributes):\n"
"    obj = cls.__new__(cls)\n"
"    obj.__dict__.update(attributes)\n"
"    return obj"
msgstr ""
"def save(obj):\n"
"    return (obj.__class__, obj.__dict__)\n"
"\n"
"def restore(cls, attributes):\n"
"    obj = cls.__new__(cls)\n"
"    obj.__dict__.update(attributes)\n"
"    return obj"

#: ../../library/pickle.rst:583
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr ""
"Классы могут изменять поведение по умолчанию, предоставляя один или "
"несколько специальных методов:"

#: ../../library/pickle.rst:588
msgid ""
"In protocols 2 and newer, classes that implements the :meth:"
"`__getnewargs_ex__` method can dictate the values passed to the :meth:"
"`__new__` method upon unpickling.  The method must return a pair ``(args, "
"kwargs)`` where *args* is a tuple of positional arguments and *kwargs* a "
"dictionary of named arguments for constructing the object.  Those will be "
"passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"В протоколах 2 и новее классы, реализующие метод :meth:`__getnewargs_ex__`, "
"могут определять значения, передаваемые методу :meth:`__new__` при "
"распаковке. Метод должен возвращать пару ``(args, kwargs)``, где *args* — "
"это кортеж позиционных аргументов, а *kwargs* — словарь именованных "
"аргументов для построения объекта. Они будут переданы методу :meth:`__new__` "
"при распаковке."

#: ../../library/pickle.rst:596
msgid ""
"You should implement this method if the :meth:`__new__` method of your class "
"requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"Вам следует реализовать этот метод, если метод :meth:`__new__` вашего класса "
"требует аргументов, содержащих только ключевые слова. В противном случае для "
"совместимости рекомендуется реализовать :meth:`__getnewargs__`."

#: ../../library/pickle.rst:600
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ":meth:`__getnewargs_ex__` теперь используется в протоколах 2 и 3."

#: ../../library/pickle.rst:606
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"Этот метод служит той же цели, что и :meth:`__getnewargs_ex__`, но "
"поддерживает только позиционные аргументы. Он должен вернуть кортеж "
"аргументов ``args``, который будет передан методу :meth:`__new__` при "
"распаковке."

#: ../../library/pickle.rst:610
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""
":meth:`__getnewargs__` не будет вызываться, если :meth:`__getnewargs_ex__` "
"определен."

#: ../../library/pickle.rst:613
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of :meth:"
"`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"До Python 3.6 вместо :meth:`__getnewargs_ex__` в протоколах 2 и 3 вызывался :"
"meth:`__getnewargs__`."

#: ../../library/pickle.rst:620
msgid ""
"Classes can further influence how their instances are pickled by overriding "
"the method :meth:`__getstate__`.  It is called and the returned object is "
"pickled as the contents for the instance, instead of a default state. There "
"are several cases:"
msgstr ""
"Классы могут дополнительно влиять на то, как их экземпляры обрабатываются, "
"переопределяя метод :meth:`__getstate__`. Он вызывается, и возвращаемый "
"объект маринуется как содержимое экземпляра, а не как состояние по "
"умолчанию. Есть несколько случаев:"

#: ../../library/pickle.rst:625
msgid ""
"For a class that has no instance :attr:`~object.__dict__` and no :attr:"
"`~object.__slots__`, the default state is ``None``."
msgstr ""
"Для класса, у которого нет экземпляра :attr:`~object.__dict__` и :attr:"
"`~object.__slots__`, состоянием по умолчанию является ``None``."

#: ../../library/pickle.rst:628
msgid ""
"For a class that has an instance :attr:`~object.__dict__` and no :attr:"
"`~object.__slots__`, the default state is ``self.__dict__``."
msgstr ""
"Для класса, у которого есть экземпляр :attr:`~object.__dict__` и нет :attr:"
"`~object.__slots__`, состоянием по умолчанию является ``self.__dict__``."

#: ../../library/pickle.rst:631
msgid ""
"For a class that has an instance :attr:`~object.__dict__` and :attr:`~object."
"__slots__`, the default state is a tuple consisting of two dictionaries:  "
"``self.__dict__``, and a dictionary mapping slot names to slot values.  Only "
"slots that have a value are included in the latter."
msgstr ""
"Для класса, имеющего экземпляры :attr:`~object.__dict__` и :attr:`~object."
"__slots__`, состоянием по умолчанию является кортеж, состоящий из двух "
"словарей: ``self.__dict__`` и сопоставления словаря. имена слотов в значения "
"слотов. В последний включены только слоты, имеющие значение."

#: ../../library/pickle.rst:637
msgid ""
"For a class that has :attr:`~object.__slots__` and no instance :attr:"
"`~object.__dict__`, the default state is a tuple whose first item is "
"``None`` and whose second item is a dictionary mapping slot names to slot "
"values described in the previous bullet."
msgstr ""
"Для класса, который имеет :attr:`~object.__slots__` и не имеет экземпляра :"
"attr:`~object.__dict__`, состоянием по умолчанию является кортеж, первый "
"элемент которого равен ``None``, а второй элемент является сопоставлением "
"словаря. имена слотов в значения слотов, описанные в предыдущем пункте."

#: ../../library/pickle.rst:642
msgid ""
"Added the default implementation of the ``__getstate__()`` method in the :"
"class:`object` class."
msgstr ""
"Добавлена ​​реализация по умолчанию метода ``__getstate__()`` в классе :class:"
"`object`."

#: ../../library/pickle.rst:649
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"Если при распаковке класс определяет :meth:`__setstate__`, он вызывается с "
"немаринованным состоянием. В этом случае нет необходимости, чтобы объект "
"состояния был словарем. В противном случае маринованное состояние должно "
"быть словарем, а его элементы присваиваются словарю нового экземпляра."

#: ../../library/pickle.rst:656
msgid ""
"If :meth:`__reduce__` returns a state with value ``None`` at pickling, the :"
"meth:`__setstate__` method will not be called upon unpickling."
msgstr ""
"Если :meth:`__reduce__` возвращает состояние со значением ``None`` при "
"травлении, метод :meth:`__setstate__` не будет вызываться при распаковке."

#: ../../library/pickle.rst:660
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`~object.__getstate__` and :meth:`~object."
"__setstate__`."
msgstr ""
"Обратитесь к разделу :ref:`pickle-state` для получения дополнительной "
"информации о том, как использовать методы :meth:`~object.__getstate__` и :"
"meth:`~object.__setstate__`."

#: ../../library/pickle.rst:665
msgid ""
"At unpickling time, some methods like :meth:`~object.__getattr__`, :meth:"
"`~object.__getattribute__`, or :meth:`~object.__setattr__` may be called "
"upon the instance.  In case those methods rely on some internal invariant "
"being true, the type should implement :meth:`~object.__new__` to establish "
"such an invariant, as :meth:`~object.__init__` is not called when unpickling "
"an instance."
msgstr ""
"Во время распаковки для экземпляра могут быть вызваны некоторые методы, "
"такие как :meth:`~object.__getattr__`, :meth:`~object.__getattribute__` или :"
"meth:`~object.__setattr__`. В случае, если эти методы полагаются на "
"истинность некоторого внутреннего инварианта, тип должен реализовать :meth:"
"`~object.__new__` для установления такого инварианта, поскольку :meth:"
"`~object.__init__` не вызывается при распаковке экземпляра."

#: ../../library/pickle.rst:674
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the :"
"meth:`~object.__reduce__` special method.  The copy protocol provides a "
"unified interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""
"Как мы увидим, Pickle не использует напрямую методы, описанные выше. "
"Фактически, эти методы являются частью протокола копирования, который "
"реализует специальный метод :meth:`~object.__reduce__`. Протокол копирования "
"предоставляет унифицированный интерфейс для получения данных, необходимых "
"для травления и копирования объектов. [#]_"

#: ../../library/pickle.rst:680
msgid ""
"Although powerful, implementing :meth:`~object.__reduce__` directly in your "
"classes is error prone.  For this reason, class designers should use the "
"high-level interface (i.e., :meth:`~object.__getnewargs_ex__`, :meth:"
"`~object.__getstate__` and :meth:`~object.__setstate__`) whenever possible.  "
"We will show, however, cases where using :meth:`!__reduce__` is the only "
"option or leads to more efficient pickling or both."
msgstr ""
"Несмотря на свою эффективность, реализация :meth:`~object.__reduce__` "
"непосредственно в ваших классах чревата ошибками. По этой причине "
"проектировщикам классов следует по возможности использовать высокоуровневый "
"интерфейс (т. е. :meth:`~object.__getnewargs_ex__`, :meth:`~object."
"__getstate__` и :meth:`~object.__setstate__`). Однако мы покажем случаи, "
"когда использование :meth:`!__reduce__` является единственным вариантом или "
"приводит к более эффективному травлению, или и то, и другое."

#: ../../library/pickle.rst:689
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""
"В настоящее время интерфейс определен следующим образом. Метод :meth:"
"`__reduce__` не принимает аргументов и должен возвращать либо строку, либо, "
"предпочтительно, кортеж (возвращаемый объект часто называют «снижающим "
"значением»)."

#: ../../library/pickle.rst:693
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"Если возвращается строка, ее следует интерпретировать как имя глобальной "
"переменной. Это должно быть локальное имя объекта относительно его модуля; "
"модуль Pickle ищет пространство имен модуля, чтобы определить модуль "
"объекта. Такое поведение обычно полезно для одиночных объектов."

#: ../../library/pickle.rst:698
msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""
"Когда возвращается кортеж, его длина должна составлять от двух до шести "
"элементов. Необязательные элементы можно либо опустить, либо указать в "
"качестве значения «Нет». Семантика каждого элемента следующая:"

#: ../../library/pickle.rst:704
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr ""
"Вызываемый объект, который будет вызываться для создания начальной версии "
"объекта."

#: ../../library/pickle.rst:707
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""
"Кортеж аргументов для вызываемого объекта. Должен быть указан пустой кортеж, "
"если вызываемый объект не принимает никаких аргументов."

#: ../../library/pickle.rst:710
msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as previously described.  If the object has no such "
"method then, the value must be a dictionary and it will be added to the "
"object's :attr:`~object.__dict__` attribute."
msgstr ""
"Необязательно, состояние объекта, которое будет передано в метод объекта :"
"meth:`__setstate__`, как описано ранее. Если у объекта нет такого метода, "
"значение должно быть словарем, и оно будет добавлено к атрибуту :attr:"
"`~object.__dict__` объекта."

#: ../../library/pickle.rst:715
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have :"
"ref:`append and extend methods <typesseq-common>` with the appropriate "
"signature.  (Whether :meth:`!append` or :meth:`!extend` is used depends on "
"which pickle protocol version is used as well as the number of items to "
"append, so both must be supported.)"
msgstr ""
"Необязательно, итератор (а не последовательность), дающий последовательные "
"элементы. Эти элементы будут добавлены к объекту либо с помощью ``obj."
"append(item)``, либо, в пакетном режиме, с помощью ``obj."
"extend(list_of_items)``. В основном это используется для подклассов списков, "
"но может использоваться и другими классами, если у них есть методы "
"добавления и расширения <typesseq-common> с соответствующей сигнатурой. "
"(Использование :meth:`!append` или :meth:`!extend` зависит от того, какая "
"версия протокола Pickle используется, а также от количества добавляемых "
"элементов, поэтому оба должны поддерживаться.)"

#: ../../library/pickle.rst:725
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"Необязательно, итератор (не последовательность), дающий последовательные "
"пары ключ-значение. Эти элементы будут сохранены в объекте с использованием "
"``obj[key] = value``. В основном это используется для подклассов словарей, "
"но может использоваться и другими классами, если они реализуют :meth:"
"`__setitem__`."

#: ../../library/pickle.rst:730
msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior of a "
"specific object, instead of using ``obj``'s static :meth:`__setstate__` "
"method. If not ``None``, this callable will have priority over ``obj``'s :"
"meth:`__setstate__`."
msgstr ""
"Необязательно, вызываемый объект с сигнатурой ``(obj,state)``. Этот "
"вызываемый объект позволяет пользователю программно управлять поведением "
"обновления состояния конкретного объекта вместо использования статического "
"метода :meth:`__setstate__` ``obj``. Если не ``None``, этот вызываемый "
"объект будет иметь приоритет над :meth:`__setstate__` ``obj``."

#: ../../library/pickle.rst:736
msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr "Был добавлен необязательный шестой элемент кортежа ``(obj,state)``."

#: ../../library/pickle.rst:742
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the :meth:"
"`__reduce__` method.  In addition, :meth:`__reduce__` automatically becomes "
"a synonym for the extended version.  The main use for this method is to "
"provide backwards-compatible reduce values for older Python releases."
msgstr ""
"В качестве альтернативы можно определить метод :meth:`__reduce_ex__`. "
"Единственное отличие состоит в том, что этот метод должен принимать один "
"целочисленный аргумент — версию протокола. Если он определен, Pickle "
"предпочтет его методу :meth:`__reduce__`. Кроме того, :meth:`__reduce__` "
"автоматически становится синонимом расширенной версии. Основное "
"использование этого метода — предоставление обратно совместимых значений "
"сокращения для старых версий Python."

#: ../../library/pickle.rst:754
msgid "Persistence of External Objects"
msgstr "Сохранение внешних объектов"

#: ../../library/pickle.rst:760
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""
"В целях сохранения объекта модуль :mod:`pickle` поддерживает идею ссылки на "
"объект вне маринованного потока данных. На такие объекты ссылается "
"постоянный идентификатор, который должен представлять собой строку буквенно-"
"цифровых символов (для протокола 0). [#]_ или просто произвольный объект "
"(для любого нового протокола)."

#: ../../library/pickle.rst:766
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and :meth:`~Unpickler."
"persistent_load` respectively."
msgstr ""
"Разрешение таких постоянных идентификаторов не определяется модулем :mod:"
"`pickle`; он делегирует это разрешение определяемым пользователем методам "
"сборщика и разблокировщика: :meth:`~Pickler.persistent_id` и :meth:"
"`~Unpickler.persistent_load` соответственно."

#: ../../library/pickle.rst:771
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have "
"a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"Чтобы выбрать объекты, имеющие внешний постоянный идентификатор, сборщик "
"должен иметь специальный метод :meth:`~Pickler.persistent_id`, который "
"принимает объект в качестве аргумента и возвращает либо ``None``, либо "
"постоянный идентификатор для этого объекта. Когда возвращается None, сборщик "
"просто выбирает объект как обычно. Когда возвращается строка постоянного "
"идентификатора, сборщик выбирает этот объект вместе с маркером, чтобы "
"средство отмены выбора распознало его как постоянный идентификатор."

#: ../../library/pickle.rst:778
msgid ""
"To unpickle external objects, the unpickler must have a custom :meth:"
"`~Unpickler.persistent_load` method that takes a persistent ID object and "
"returns the referenced object."
msgstr ""
"Чтобы распаковать внешние объекты, у распаковщика должен быть специальный "
"метод :meth:`~Unpickler.persistent_load`, который принимает объект "
"постоянного идентификатора и возвращает объект, на который ссылается."

#: ../../library/pickle.rst:782
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr ""
"Вот подробный пример, показывающий, как можно использовать постоянный "
"идентификатор для выбора внешних объектов по ссылке."

#: ../../library/pickle.rst:785
msgid ""
"# Simple example presenting how persistent ID can be used to pickle\n"
"# external objects by reference.\n"
"\n"
"import pickle\n"
"import sqlite3\n"
"from collections import namedtuple\n"
"\n"
"# Simple class representing a record in our database.\n"
"MemoRecord = namedtuple(\"MemoRecord\", \"key, task\")\n"
"\n"
"class DBPickler(pickle.Pickler):\n"
"\n"
"    def persistent_id(self, obj):\n"
"        # Instead of pickling MemoRecord as a regular class instance, we "
"emit a\n"
"        # persistent ID.\n"
"        if isinstance(obj, MemoRecord):\n"
"            # Here, our persistent ID is simply a tuple, containing a tag "
"and a\n"
"            # key, which refers to a specific record in the database.\n"
"            return (\"MemoRecord\", obj.key)\n"
"        else:\n"
"            # If obj does not have a persistent ID, return None. This means "
"obj\n"
"            # needs to be pickled as usual.\n"
"            return None\n"
"\n"
"\n"
"class DBUnpickler(pickle.Unpickler):\n"
"\n"
"    def __init__(self, file, connection):\n"
"        super().__init__(file)\n"
"        self.connection = connection\n"
"\n"
"    def persistent_load(self, pid):\n"
"        # This method is invoked whenever a persistent ID is encountered.\n"
"        # Here, pid is the tuple returned by DBPickler.\n"
"        cursor = self.connection.cursor()\n"
"        type_tag, key_id = pid\n"
"        if type_tag == \"MemoRecord\":\n"
"            # Fetch the referenced record from the database and return it.\n"
"            cursor.execute(\"SELECT * FROM memos WHERE key=?\", "
"(str(key_id),))\n"
"            key, task = cursor.fetchone()\n"
"            return MemoRecord(key, task)\n"
"        else:\n"
"            # Always raises an error if you cannot return the correct "
"object.\n"
"            # Otherwise, the unpickler will think None is the object "
"referenced\n"
"            # by the persistent ID.\n"
"            raise pickle.UnpicklingError(\"unsupported persistent object\")\n"
"\n"
"\n"
"def main():\n"
"    import io\n"
"    import pprint\n"
"\n"
"    # Initialize and populate our database.\n"
"    conn = sqlite3.connect(\":memory:\")\n"
"    cursor = conn.cursor()\n"
"    cursor.execute(\"CREATE TABLE memos(key INTEGER PRIMARY KEY, task "
"TEXT)\")\n"
"    tasks = (\n"
"        'give food to fish',\n"
"        'prepare group meeting',\n"
"        'fight with a zebra',\n"
"        )\n"
"    for task in tasks:\n"
"        cursor.execute(\"INSERT INTO memos VALUES(NULL, ?)\", (task,))\n"
"\n"
"    # Fetch the records to be pickled.\n"
"    cursor.execute(\"SELECT * FROM memos\")\n"
"    memos = [MemoRecord(key, task) for key, task in cursor]\n"
"    # Save the records using our custom DBPickler.\n"
"    file = io.BytesIO()\n"
"    DBPickler(file).dump(memos)\n"
"\n"
"    print(\"Pickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"    # Update a record, just for good measure.\n"
"    cursor.execute(\"UPDATE memos SET task='learn italian' WHERE key=1\")\n"
"\n"
"    # Load the records from the pickle data stream.\n"
"    file.seek(0)\n"
"    memos = DBUnpickler(file, conn).load()\n"
"\n"
"    print(\"Unpickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""
"# Simple example presenting how persistent ID can be used to pickle\n"
"# external objects by reference.\n"
"\n"
"import pickle\n"
"import sqlite3\n"
"from collections import namedtuple\n"
"\n"
"# Simple class representing a record in our database.\n"
"MemoRecord = namedtuple(\"MemoRecord\", \"key, task\")\n"
"\n"
"class DBPickler(pickle.Pickler):\n"
"\n"
"    def persistent_id(self, obj):\n"
"        # Instead of pickling MemoRecord as a regular class instance, we "
"emit a\n"
"        # persistent ID.\n"
"        if isinstance(obj, MemoRecord):\n"
"            # Here, our persistent ID is simply a tuple, containing a tag "
"and a\n"
"            # key, which refers to a specific record in the database.\n"
"            return (\"MemoRecord\", obj.key)\n"
"        else:\n"
"            # If obj does not have a persistent ID, return None. This means "
"obj\n"
"            # needs to be pickled as usual.\n"
"            return None\n"
"\n"
"\n"
"class DBUnpickler(pickle.Unpickler):\n"
"\n"
"    def __init__(self, file, connection):\n"
"        super().__init__(file)\n"
"        self.connection = connection\n"
"\n"
"    def persistent_load(self, pid):\n"
"        # This method is invoked whenever a persistent ID is encountered.\n"
"        # Here, pid is the tuple returned by DBPickler.\n"
"        cursor = self.connection.cursor()\n"
"        type_tag, key_id = pid\n"
"        if type_tag == \"MemoRecord\":\n"
"            # Fetch the referenced record from the database and return it.\n"
"            cursor.execute(\"SELECT * FROM memos WHERE key=?\", "
"(str(key_id),))\n"
"            key, task = cursor.fetchone()\n"
"            return MemoRecord(key, task)\n"
"        else:\n"
"            # Always raises an error if you cannot return the correct "
"object.\n"
"            # Otherwise, the unpickler will think None is the object "
"referenced\n"
"            # by the persistent ID.\n"
"            raise pickle.UnpicklingError(\"unsupported persistent object\")\n"
"\n"
"\n"
"def main():\n"
"    import io\n"
"    import pprint\n"
"\n"
"    # Initialize and populate our database.\n"
"    conn = sqlite3.connect(\":memory:\")\n"
"    cursor = conn.cursor()\n"
"    cursor.execute(\"CREATE TABLE memos(key INTEGER PRIMARY KEY, task "
"TEXT)\")\n"
"    tasks = (\n"
"        'give food to fish',\n"
"        'prepare group meeting',\n"
"        'fight with a zebra',\n"
"        )\n"
"    for task in tasks:\n"
"        cursor.execute(\"INSERT INTO memos VALUES(NULL, ?)\", (task,))\n"
"\n"
"    # Fetch the records to be pickled.\n"
"    cursor.execute(\"SELECT * FROM memos\")\n"
"    memos = [MemoRecord(key, task) for key, task in cursor]\n"
"    # Save the records using our custom DBPickler.\n"
"    file = io.BytesIO()\n"
"    DBPickler(file).dump(memos)\n"
"\n"
"    print(\"Pickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"    # Update a record, just for good measure.\n"
"    cursor.execute(\"UPDATE memos SET task='learn italian' WHERE key=1\")\n"
"\n"
"    # Load the records from the pickle data stream.\n"
"    file.seek(0)\n"
"    memos = DBUnpickler(file, conn).load()\n"
"\n"
"    print(\"Unpickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"

#: ../../library/pickle.rst:790
msgid "Dispatch Tables"
msgstr "Таблица отправки"

#: ../../library/pickle.rst:792
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""
"Если вы хотите настроить травление некоторых классов, не нарушая какой-либо "
"другой код, который зависит от травления, то можно создать сборщик с частной "
"таблицей диспетчеризации."

#: ../../library/pickle.rst:796
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`!copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`!copyreg.dispatch_table` as a private dispatch table."
msgstr ""
"Глобальная таблица диспетчеризации, управляемая модулем :mod:`copyreg`, "
"доступна как :data:`!copyreg.dispatch_table`. Поэтому можно использовать "
"измененную копию :data:`!copyreg.dispatch_table` в качестве частной таблицы "
"диспетчеризации."

#: ../../library/pickle.rst:801
msgid "For example ::"
msgstr "Например ::"

#: ../../library/pickle.rst:803
msgid ""
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)\n"
"p.dispatch_table = copyreg.dispatch_table.copy()\n"
"p.dispatch_table[SomeClass] = reduce_SomeClass"
msgstr ""
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)\n"
"p.dispatch_table = copyreg.dispatch_table.copy()\n"
"p.dispatch_table[SomeClass] = reduce_SomeClass"

#: ../../library/pickle.rst:808
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table "
"which handles the ``SomeClass`` class specially.  Alternatively, the code ::"
msgstr ""
"создает экземпляр :class:`pickle.Pickler` с частной таблицей "
"диспетчеризации, которая специально обрабатывает класс ``SomeClass``. "
"Альтернативно, код::"

#: ../../library/pickle.rst:812
msgid ""
"class MyPickler(pickle.Pickler):\n"
"    dispatch_table = copyreg.dispatch_table.copy()\n"
"    dispatch_table[SomeClass] = reduce_SomeClass\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)"
msgstr ""
"class MyPickler(pickle.Pickler):\n"
"    dispatch_table = copyreg.dispatch_table.copy()\n"
"    dispatch_table[SomeClass] = reduce_SomeClass\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)"

#: ../../library/pickle.rst:818
msgid ""
"does the same but all instances of ``MyPickler`` will by default share the "
"private dispatch table.  On the other hand, the code ::"
msgstr ""
"делает то же самое, но все экземпляры MyPickler по умолчанию будут совместно "
"использовать частную таблицу отправки. С другой стороны, код::"

#: ../../library/pickle.rst:821
msgid ""
"copyreg.pickle(SomeClass, reduce_SomeClass)\n"
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)"
msgstr ""
"copyreg.pickle(SomeClass, reduce_SomeClass)\n"
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)"

#: ../../library/pickle.rst:825
msgid ""
"modifies the global dispatch table shared by all users of the :mod:`copyreg` "
"module."
msgstr ""
"изменяет глобальную таблицу диспетчеризации, общую для всех пользователей "
"модуля :mod:`copyreg`."

#: ../../library/pickle.rst:830
msgid "Handling Stateful Objects"
msgstr "Обработка объектов с отслеживаемым состоянием"

#: ../../library/pickle.rst:836
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`!TextReader` class below opens a text file, and returns the line "
"number and line contents each time its :meth:`!readline` method is called. "
"If a :class:`!TextReader` instance is pickled, all attributes *except* the "
"file object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:`!"
"__setstate__` and :meth:`!__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""
"Вот пример, показывающий, как изменить поведение травления для класса. "
"Класс :class:`!TextReader` ниже открывает текстовый файл и возвращает номер "
"строки и ее содержимое каждый раз, когда вызывается его метод :meth:`!"
"readline`. Если экземпляр :class:`!TextReader` маринован, все атрибуты "
"*кроме* члена файлового объекта сохраняются. Когда экземпляр "
"распаковывается, файл открывается повторно, и чтение возобновляется с "
"последнего места. Для реализации этого поведения используются методы :meth:`!"
"__setstate__` и :meth:`!__getstate__`. ::"

#: ../../library/pickle.rst:844
msgid ""
"class TextReader:\n"
"    \"\"\"Print and number lines in a text file.\"\"\"\n"
"\n"
"    def __init__(self, filename):\n"
"        self.filename = filename\n"
"        self.file = open(filename)\n"
"        self.lineno = 0\n"
"\n"
"    def readline(self):\n"
"        self.lineno += 1\n"
"        line = self.file.readline()\n"
"        if not line:\n"
"            return None\n"
"        if line.endswith('\\n'):\n"
"            line = line[:-1]\n"
"        return \"%i: %s\" % (self.lineno, line)\n"
"\n"
"    def __getstate__(self):\n"
"        # Copy the object's state from self.__dict__ which contains\n"
"        # all our instance attributes. Always use the dict.copy()\n"
"        # method to avoid modifying the original state.\n"
"        state = self.__dict__.copy()\n"
"        # Remove the unpicklable entries.\n"
"        del state['file']\n"
"        return state\n"
"\n"
"    def __setstate__(self, state):\n"
"        # Restore instance attributes (i.e., filename and lineno).\n"
"        self.__dict__.update(state)\n"
"        # Restore the previously opened file's state. To do so, we need to\n"
"        # reopen it and read from it until the line count is restored.\n"
"        file = open(self.filename)\n"
"        for _ in range(self.lineno):\n"
"            file.readline()\n"
"        # Finally, save the file.\n"
"        self.file = file"
msgstr ""
"class TextReader:\n"
"    \"\"\"Print and number lines in a text file.\"\"\"\n"
"\n"
"    def __init__(self, filename):\n"
"        self.filename = filename\n"
"        self.file = open(filename)\n"
"        self.lineno = 0\n"
"\n"
"    def readline(self):\n"
"        self.lineno += 1\n"
"        line = self.file.readline()\n"
"        if not line:\n"
"            return None\n"
"        if line.endswith('\\n'):\n"
"            line = line[:-1]\n"
"        return \"%i: %s\" % (self.lineno, line)\n"
"\n"
"    def __getstate__(self):\n"
"        # Copy the object's state from self.__dict__ which contains\n"
"        # all our instance attributes. Always use the dict.copy()\n"
"        # method to avoid modifying the original state.\n"
"        state = self.__dict__.copy()\n"
"        # Remove the unpicklable entries.\n"
"        del state['file']\n"
"        return state\n"
"\n"
"    def __setstate__(self, state):\n"
"        # Restore instance attributes (i.e., filename and lineno).\n"
"        self.__dict__.update(state)\n"
"        # Restore the previously opened file's state. To do so, we need to\n"
"        # reopen it and read from it until the line count is restored.\n"
"        file = open(self.filename)\n"
"        for _ in range(self.lineno):\n"
"            file.readline()\n"
"        # Finally, save the file.\n"
"        self.file = file"

#: ../../library/pickle.rst:882
msgid "A sample usage might be something like this::"
msgstr "Пример использования может быть примерно таким::"

#: ../../library/pickle.rst:884
msgid ""
">>> reader = TextReader(\"hello.txt\")\n"
">>> reader.readline()\n"
"'1: Hello world!'\n"
">>> reader.readline()\n"
"'2: I am line number two.'\n"
">>> new_reader = pickle.loads(pickle.dumps(reader))\n"
">>> new_reader.readline()\n"
"'3: Goodbye!'"
msgstr ""
">>> reader = TextReader(\"hello.txt\")\n"
">>> reader.readline()\n"
"'1: Hello world!'\n"
">>> reader.readline()\n"
"'2: I am line number two.'\n"
">>> new_reader = pickle.loads(pickle.dumps(reader))\n"
">>> new_reader.readline()\n"
"'3: Goodbye!'"

#: ../../library/pickle.rst:896
msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr "Пользовательское сокращение типов, функций и других объектов"

#: ../../library/pickle.rst:900
msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In "
"particular we may want to customize pickling based on another criterion than "
"the object's type, or we may want to customize the pickling of functions and "
"classes."
msgstr ""
"Иногда :attr:`~Pickler.dispatch_table` может быть недостаточно гибким. В "
"частности, мы можем захотеть настроить травление на основе другого критерия, "
"кроме типа объекта, или мы можем захотеть настроить травление функций и "
"классов."

#: ../../library/pickle.rst:905
msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` class "
"and implement a :meth:`~Pickler.reducer_override` method. This method can "
"return an arbitrary reduction tuple (see :meth:`~object.__reduce__`). It can "
"alternatively return :data:`NotImplemented` to fallback to the traditional "
"behavior."
msgstr ""
"В таких случаях можно создать подкласс класса :class:`Pickler` и реализовать "
"метод :meth:`~Pickler.reducer_override`. Этот метод может возвращать "
"произвольный кортеж сокращения (см. :meth:`~object.__reduce__`). В качестве "
"альтернативы он может вернуть :data:`NotImplemented` для возврата к "
"традиционному поведению."

#: ../../library/pickle.rst:910
msgid ""
"If both the :attr:`~Pickler.dispatch_table` and :meth:`~Pickler."
"reducer_override` are defined, then :meth:`~Pickler.reducer_override` method "
"takes priority."
msgstr ""
"В таких случаях можно создать подкласс класса :class:`Pickler` и реализовать "
"метод :meth:`~Pickler.reducer_override`. Этот метод может возвращать "
"произвольный кортеж сокращения (см. :meth:`~object.__reduce__`). В качестве "
"альтернативы он может вернуть :data:`NotImplemented` для возврата к "
"традиционному поведению."

#: ../../library/pickle.rst:915
msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be called "
"for the following objects: ``None``, ``True``, ``False``, and exact "
"instances of :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :"
"class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` and :class:"
"`tuple`."
msgstr ""
"По соображениям производительности :meth:`~Pickler.reducer_override` не "
"может вызываться для следующих объектов: ``None``, ``True``, ``False`` и "
"точных экземпляров :class:`int` , :class:`float`, :class:`bytes`, :class:"
"`str`, :class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` и :"
"class:`кортеж`."

#: ../../library/pickle.rst:921
msgid ""
"Here is a simple example where we allow pickling and reconstructing a given "
"class::"
msgstr ""
"Вот простой пример, где мы разрешаем травление и реконструкцию данного "
"класса:"

#: ../../library/pickle.rst:924
msgid ""
"import io\n"
"import pickle\n"
"\n"
"class MyClass:\n"
"    my_attribute = 1\n"
"\n"
"class MyPickler(pickle.Pickler):\n"
"    def reducer_override(self, obj):\n"
"        \"\"\"Custom reducer for MyClass.\"\"\"\n"
"        if getattr(obj, \"__name__\", None) == \"MyClass\":\n"
"            return type, (obj.__name__, obj.__bases__,\n"
"                          {'my_attribute': obj.my_attribute})\n"
"        else:\n"
"            # For any other object, fallback to usual reduction\n"
"            return NotImplemented\n"
"\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)\n"
"p.dump(MyClass)\n"
"\n"
"del MyClass\n"
"\n"
"unpickled_class = pickle.loads(f.getvalue())\n"
"\n"
"assert isinstance(unpickled_class, type)\n"
"assert unpickled_class.__name__ == \"MyClass\"\n"
"assert unpickled_class.my_attribute == 1"
msgstr ""
"import io\n"
"import pickle\n"
"\n"
"class MyClass:\n"
"    my_attribute = 1\n"
"\n"
"class MyPickler(pickle.Pickler):\n"
"    def reducer_override(self, obj):\n"
"        \"\"\"Custom reducer for MyClass.\"\"\"\n"
"        if getattr(obj, \"__name__\", None) == \"MyClass\":\n"
"            return type, (obj.__name__, obj.__bases__,\n"
"                          {'my_attribute': obj.my_attribute})\n"
"        else:\n"
"            # For any other object, fallback to usual reduction\n"
"            return NotImplemented\n"
"\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)\n"
"p.dump(MyClass)\n"
"\n"
"del MyClass\n"
"\n"
"unpickled_class = pickle.loads(f.getvalue())\n"
"\n"
"assert isinstance(unpickled_class, type)\n"
"assert unpickled_class.__name__ == \"MyClass\"\n"
"assert unpickled_class.my_attribute == 1"

#: ../../library/pickle.rst:956
msgid "Out-of-band Buffers"
msgstr "Внеполосные буферы"

#: ../../library/pickle.rst:960
msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number of "
"memory copies, to preserve performance and resource consumption.  However, "
"normal operation of the :mod:`pickle` module, as it transforms a graph-like "
"structure of objects into a sequential stream of bytes, intrinsically "
"involves copying data to and from the pickle stream."
msgstr ""
"В некоторых контекстах модуль :mod:`pickle` используется для передачи "
"огромных объемов данных. Поэтому может быть важно минимизировать количество "
"копий памяти, чтобы сохранить производительность и потребление ресурсов. "
"Однако нормальная работа модуля :mod:`pickle`, поскольку он преобразует "
"графоподобную структуру объектов в последовательный поток байтов, по своей "
"сути включает копирование данных в поток Pickle и из него."

#: ../../library/pickle.rst:967
msgid ""
"This constraint can be eschewed if both the *provider* (the implementation "
"of the object types to be transferred) and the *consumer* (the "
"implementation of the communications system) support the out-of-band "
"transfer facilities provided by pickle protocol 5 and higher."
msgstr ""
"Этого ограничения можно избежать, если и *поставщик* (реализация типов "
"объектов, подлежащих передаче), и *потребитель* (реализация системы связи) "
"поддерживают средства внеполосной передачи, предоставляемые протоколом "
"Pickle 5 и выше."

#: ../../library/pickle.rst:973
msgid "Provider API"
msgstr "API провайдера"

#: ../../library/pickle.rst:975
msgid ""
"The large data objects to be pickled must implement a :meth:`~object."
"__reduce_ex__` method specialized for protocol 5 and higher, which returns "
"a :class:`PickleBuffer` instance (instead of e.g. a :class:`bytes` object) "
"for any large data."
msgstr ""
"Большие объекты данных, подлежащие маринованию, должны реализовывать метод :"
"meth:`~object.__reduce_ex__`, специализированный для протокола 5 и выше, "
"который возвращает экземпляр :class:`PickleBuffer` (вместо, например, "
"объекта :class:`bytes`). для любых больших данных."

#: ../../library/pickle.rst:980
msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can also "
"opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""
"Объект :class:`PickleBuffer` *сигнализирует* о том, что базовый буфер имеет "
"право на внеполосную передачу данных. Эти объекты остаются совместимыми при "
"обычном использовании модуля :mod:`pickle`. Однако потребители также могут "
"указать :mod:`pickle`, что они будут обрабатывать эти буферы самостоятельно."

#: ../../library/pickle.rst:987
msgid "Consumer API"
msgstr "Потребительский API"

#: ../../library/pickle.rst:989
msgid ""
"A communications system can enable custom handling of the :class:"
"`PickleBuffer` objects generated when serializing an object graph."
msgstr ""
"Система связи может обеспечить индивидуальную обработку объектов :class:"
"`PickleBuffer`, генерируемых при сериализации графа объектов."

#: ../../library/pickle.rst:992
msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument to :class:"
"`Pickler` (or to the :func:`dump` or :func:`dumps` function), which will be "
"called with each :class:`PickleBuffer` generated while pickling the object "
"graph.  Buffers accumulated by the *buffer_callback* will not see their data "
"copied into the pickle stream, only a cheap marker will be inserted."
msgstr ""
"На стороне отправки ему необходимо передать аргумент *buffer_callback* в :"
"class:`Pickler` (или в функцию :func:`dump` или :func:`dumps`), которая "
"будет вызываться с каждым :class: `PickleBuffer` генерируется при травлении "
"графа объекта. Буферы, накопленные с помощью *buffer_callback*, не будут "
"видеть свои данные, скопированные в поток Pickle, будет вставлен только "
"дешевый маркер."

#: ../../library/pickle.rst:999
msgid ""
"On the receiving side, it needs to pass a *buffers* argument to :class:"
"`Unpickler` (or to the :func:`load` or :func:`loads` function), which is an "
"iterable of the buffers which were passed to *buffer_callback*. That "
"iterable should produce buffers in the same order as they were passed to "
"*buffer_callback*.  Those buffers will provide the data expected by the "
"reconstructors of the objects whose pickling produced the original :class:"
"`PickleBuffer` objects."
msgstr ""
"На принимающей стороне ему необходимо передать аргумент *buffers* в :class:"
"`Unpickler` (или в функцию :func:`load` или :func:`loads`), которая "
"представляет собой итерацию буферов, которые были передается в "
"*buffer_callback*. Эта итерация должна создавать буферы в том же порядке, в "
"котором они были переданы в *buffer_callback*. Эти буферы будут "
"предоставлять данные, ожидаемые реконструкторами объектов, травление которых "
"привело к созданию исходных объектов :class:`PickleBuffer`."

#: ../../library/pickle.rst:1007
msgid ""
"Between the sending side and the receiving side, the communications system "
"is free to implement its own transfer mechanism for out-of-band buffers. "
"Potential optimizations include the use of shared memory or datatype-"
"dependent compression."
msgstr ""
"Между отправляющей стороной и принимающей стороной система связи может "
"реализовать собственный механизм передачи для внеполосных буферов. "
"Потенциальные оптимизации включают использование общей памяти или сжатие в "
"зависимости от типа данных."

#: ../../library/pickle.rst:1013
msgid "Example"
msgstr "Пример"

#: ../../library/pickle.rst:1015
msgid ""
"Here is a trivial example where we implement a :class:`bytearray` subclass "
"able to participate in out-of-band buffer pickling::"
msgstr ""
"Вот тривиальный пример, в котором мы реализуем подкласс :class:`bytearray`, "
"способный участвовать во внеполосном травлении буфера:"

#: ../../library/pickle.rst:1018
msgid ""
"class ZeroCopyByteArray(bytearray):\n"
"\n"
"    def __reduce_ex__(self, protocol):\n"
"        if protocol >= 5:\n"
"            return type(self)._reconstruct, (PickleBuffer(self),), None\n"
"        else:\n"
"            # PickleBuffer is forbidden with pickle protocols <= 4.\n"
"            return type(self)._reconstruct, (bytearray(self),)\n"
"\n"
"    @classmethod\n"
"    def _reconstruct(cls, obj):\n"
"        with memoryview(obj) as m:\n"
"            # Get a handle over the original buffer object\n"
"            obj = m.obj\n"
"            if type(obj) is cls:\n"
"                # Original buffer object is a ZeroCopyByteArray, return it\n"
"                # as-is.\n"
"                return obj\n"
"            else:\n"
"                return cls(obj)"
msgstr ""
"class ZeroCopyByteArray(bytearray):\n"
"\n"
"    def __reduce_ex__(self, protocol):\n"
"        if protocol >= 5:\n"
"            return type(self)._reconstruct, (PickleBuffer(self),), None\n"
"        else:\n"
"            # PickleBuffer is forbidden with pickle protocols <= 4.\n"
"            return type(self)._reconstruct, (bytearray(self),)\n"
"\n"
"    @classmethod\n"
"    def _reconstruct(cls, obj):\n"
"        with memoryview(obj) as m:\n"
"            # Get a handle over the original buffer object\n"
"            obj = m.obj\n"
"            if type(obj) is cls:\n"
"                # Original buffer object is a ZeroCopyByteArray, return it\n"
"                # as-is.\n"
"                return obj\n"
"            else:\n"
"                return cls(obj)"

#: ../../library/pickle.rst:1039
msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the buffer's "
"providing object if it has the right type.  This is an easy way to simulate "
"zero-copy behaviour on this toy example."
msgstr ""
"Реконструктор (метод класса ``_reconstruct``) возвращает объект, "
"предоставляющий буфер, если он имеет правильный тип. Это простой способ "
"смоделировать поведение нулевого копирования на этом игрушечном примере."

#: ../../library/pickle.rst:1043
msgid ""
"On the consumer side, we can pickle those objects the usual way, which when "
"unserialized will give us a copy of the original object::"
msgstr ""
"На стороне потребителя мы можем выбрать эти объекты обычным способом, "
"который при десериализации даст нам копию исходного объекта:"

#: ../../library/pickle.rst:1046
msgid ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"data = pickle.dumps(b, protocol=5)\n"
"new_b = pickle.loads(data)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # False: a copy was made"
msgstr ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"data = pickle.dumps(b, protocol=5)\n"
"new_b = pickle.loads(data)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # False: a copy was made"

#: ../../library/pickle.rst:1052
msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr ""
"Но если мы передадим *buffer_callback*, а затем вернем накопленные буферы "
"при десериализации, мы сможем вернуть исходный объект:"

#: ../../library/pickle.rst:1055
msgid ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"buffers = []\n"
"data = pickle.dumps(b, protocol=5, buffer_callback=buffers.append)\n"
"new_b = pickle.loads(data, buffers=buffers)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # True: no copy was made"
msgstr ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"buffers = []\n"
"data = pickle.dumps(b, protocol=5, buffer_callback=buffers.append)\n"
"new_b = pickle.loads(data, buffers=buffers)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # True: no copy was made"

#: ../../library/pickle.rst:1062
msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its "
"own memory: you cannot create a :class:`bytearray` instance that is backed "
"by another object's memory.  However, third-party datatypes such as NumPy "
"arrays do not have this limitation, and allow use of zero-copy pickling (or "
"making as few copies as possible) when transferring between distinct "
"processes or systems."
msgstr ""
"Этот пример ограничен тем фактом, что :class:`bytearray` выделяет свою "
"собственную память: вы не можете создать экземпляр :class:`bytearray`, "
"который поддерживается памятью другого объекта. Однако сторонние типы "
"данных, такие как массивы NumPy, не имеют этого ограничения и позволяют "
"использовать травление с нулевым копированием (или создание как можно "
"меньшего количества копий) при передаче между отдельными процессами или "
"системами."

#: ../../library/pickle.rst:1069
msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ":pep:`574` -- Протокол Pickle 5 с внеполосными данными"

#: ../../library/pickle.rst:1075
msgid "Restricting Globals"
msgstr "Ограничение глобальных переменных"

#: ../../library/pickle.rst:1080
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"По умолчанию распаковка импортирует любой класс или функцию, найденную в "
"данных рассола. Для многих приложений такое поведение неприемлемо, поскольку "
"оно позволяет сборщику импортировать и вызывать произвольный код. Просто "
"подумайте, что делает этот созданный вручную поток данных Pickle при "
"загрузке:"

#: ../../library/pickle.rst:1085
msgid ""
">>> import pickle\n"
">>> pickle.loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"hello world\n"
"0"
msgstr ""
">>> import pickle\n"
">>> pickle.loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"hello world\n"
"0"

#: ../../library/pickle.rst:1090
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""
"В этом примере сборщик импортирует функцию :func:`os.system`, а затем "
"применяет строковый аргумент «echo hello world». Хотя этот пример безобиден, "
"нетрудно представить себе такой, который может повредить вашу систему."

#: ../../library/pickle.rst:1094
msgid ""
"For this reason, you may want to control what gets unpickled by customizing :"
"meth:`Unpickler.find_class`.  Unlike its name suggests, :meth:`Unpickler."
"find_class` is called whenever a global (i.e., a class or a function) is "
"requested.  Thus it is possible to either completely forbid globals or "
"restrict them to a safe subset."
msgstr ""
"По этой причине вы можете контролировать, что будет распаковываться, "
"настроив :meth:`Unpickler.find_class`. В отличие от названия, :meth:"
"`Unpickler.find_class` вызывается всякий раз, когда запрашивается глобальный "
"объект (т. е. класс или функция). Таким образом, можно либо полностью "
"запретить глобальные переменные, либо ограничить их безопасным подмножеством."

#: ../../library/pickle.rst:1100
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the :"
"mod:`builtins` module to be loaded::"
msgstr ""
"Вот пример распаковщика, позволяющего загружать только несколько безопасных "
"классов из модуля :mod:`builtins`::"

#: ../../library/pickle.rst:1103
msgid ""
"import builtins\n"
"import io\n"
"import pickle\n"
"\n"
"safe_builtins = {\n"
"    'range',\n"
"    'complex',\n"
"    'set',\n"
"    'frozenset',\n"
"    'slice',\n"
"}\n"
"\n"
"class RestrictedUnpickler(pickle.Unpickler):\n"
"\n"
"    def find_class(self, module, name):\n"
"        # Only allow safe classes from builtins.\n"
"        if module == \"builtins\" and name in safe_builtins:\n"
"            return getattr(builtins, name)\n"
"        # Forbid everything else.\n"
"        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %\n"
"                                     (module, name))\n"
"\n"
"def restricted_loads(s):\n"
"    \"\"\"Helper function analogous to pickle.loads().\"\"\"\n"
"    return RestrictedUnpickler(io.BytesIO(s)).load()"
msgstr ""
"import builtins\n"
"import io\n"
"import pickle\n"
"\n"
"safe_builtins = {\n"
"    'range',\n"
"    'complex',\n"
"    'set',\n"
"    'frozenset',\n"
"    'slice',\n"
"}\n"
"\n"
"class RestrictedUnpickler(pickle.Unpickler):\n"
"\n"
"    def find_class(self, module, name):\n"
"        # Only allow safe classes from builtins.\n"
"        if module == \"builtins\" and name in safe_builtins:\n"
"            return getattr(builtins, name)\n"
"        # Forbid everything else.\n"
"        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %\n"
"                                     (module, name))\n"
"\n"
"def restricted_loads(s):\n"
"    \"\"\"Helper function analogous to pickle.loads().\"\"\"\n"
"    return RestrictedUnpickler(io.BytesIO(s)).load()"

#: ../../library/pickle.rst:1129
msgid "A sample usage of our unpickler working as intended::"
msgstr "Пример использования нашего сборщика, работающего по назначению:"

#: ../../library/pickle.rst:1131
msgid ""
">>> restricted_loads(pickle.dumps([1, 2, range(15)]))\n"
"[1, 2, range(0, 15)]\n"
">>> restricted_loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'os.system' is forbidden\n"
">>> restricted_loads(b'cbuiltins\\neval\\n'\n"
"...                  b'(S\\'getattr(__import__(\"os\"), \"system\")'\n"
"...                  b'(\"echo hello world\")\\'\\ntR.')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'builtins.eval' is forbidden"
msgstr ""
">>> restricted_loads(pickle.dumps([1, 2, range(15)]))\n"
"[1, 2, range(0, 15)]\n"
">>> restricted_loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'os.system' is forbidden\n"
">>> restricted_loads(b'cbuiltins\\neval\\n'\n"
"...                  b'(S\\'getattr(__import__(\"os\"), \"system\")'\n"
"...                  b'(\"echo hello world\")\\'\\ntR.')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'builtins.eval' is forbidden"

#: ../../library/pickle.rst:1148
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""
"Как показывают наши примеры, нужно быть осторожным с тем, что вы позволяете "
"немариновать. Поэтому, если безопасность вызывает беспокойство, вы можете "
"рассмотреть альтернативы, такие как API маршалинга в :mod:`xmlrpc.client` "
"или сторонние решения."

#: ../../library/pickle.rst:1155
msgid "Performance"
msgstr "Производительность"

#: ../../library/pickle.rst:1157
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature "
"efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""
"Последние версии протокола Pickle (начиная с протокола 2 и выше) "
"обеспечивают эффективное двоичное кодирование для нескольких общих функций и "
"встроенных типов. Также модуль :mod:`pickle` имеет прозрачный оптимизатор, "
"написанный на C."

#: ../../library/pickle.rst:1165
msgid "Examples"
msgstr "Примеры"

#: ../../library/pickle.rst:1167
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr ""
"Для простейшего кода используйте функции :func:`dump` и :func:`load`. ::"

#: ../../library/pickle.rst:1169
msgid ""
"import pickle\n"
"\n"
"# An arbitrary collection of objects supported by pickle.\n"
"data = {\n"
"    'a': [1, 2.0, 3+4j],\n"
"    'b': (\"character string\", b\"byte string\"),\n"
"    'c': {None, True, False}\n"
"}\n"
"\n"
"with open('data.pickle', 'wb') as f:\n"
"    # Pickle the 'data' dictionary using the highest protocol available.\n"
"    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)"
msgstr ""
"import pickle\n"
"\n"
"# An arbitrary collection of objects supported by pickle.\n"
"data = {\n"
"    'a': [1, 2.0, 3+4j],\n"
"    'b': (\"character string\", b\"byte string\"),\n"
"    'c': {None, True, False}\n"
"}\n"
"\n"
"with open('data.pickle', 'wb') as f:\n"
"    # Pickle the 'data' dictionary using the highest protocol available.\n"
"    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)"

#: ../../library/pickle.rst:1183
msgid "The following example reads the resulting pickled data. ::"
msgstr "В следующем примере считываются полученные маринованные данные. ::"

#: ../../library/pickle.rst:1185
msgid ""
"import pickle\n"
"\n"
"with open('data.pickle', 'rb') as f:\n"
"    # The protocol version used is detected automatically, so we do not\n"
"    # have to specify it.\n"
"    data = pickle.load(f)"
msgstr ""
"import pickle\n"
"\n"
"with open('data.pickle', 'rb') as f:\n"
"    # The protocol version used is detected automatically, so we do not\n"
"    # have to specify it.\n"
"    data = pickle.load(f)"

#: ../../library/pickle.rst:1199
msgid "Module :mod:`copyreg`"
msgstr "Модуль :mod:`copyreg`"

#: ../../library/pickle.rst:1200
msgid "Pickle interface constructor registration for extension types."
msgstr "Регистрация конструктора интерфейса Pickle для типов расширений."

#: ../../library/pickle.rst:1202
msgid "Module :mod:`pickletools`"
msgstr "Модуль :mod:`pickletools`"

#: ../../library/pickle.rst:1203
msgid "Tools for working with and analyzing pickled data."
msgstr "Инструменты для работы и анализа маринованных данных."

#: ../../library/pickle.rst:1205
msgid "Module :mod:`shelve`"
msgstr "Модуль :mod:`shelve`"

#: ../../library/pickle.rst:1206
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "Индексированные базы данных объектов; использует :mod:`pickle`."

#: ../../library/pickle.rst:1208
msgid "Module :mod:`copy`"
msgstr "Модуль :mod:`copy`"

#: ../../library/pickle.rst:1209
msgid "Shallow and deep object copying."
msgstr "Мелкое и глубокое копирование объектов."

#: ../../library/pickle.rst:1211
msgid "Module :mod:`marshal`"
msgstr "Модуль :mod:`marshal`"

#: ../../library/pickle.rst:1212
msgid "High-performance serialization of built-in types."
msgstr "Высокопроизводительная сериализация встроенных типов."

#: ../../library/pickle.rst:1216
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/pickle.rst:1217
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr "Не путайте это с модулем :mod:`marshal`."

#: ../../library/pickle.rst:1219
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all :keyword:`!"
"lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"Вот почему функции :keyword:`lambda` не могут быть маринованы: все функции :"
"keyword:`!lambda` имеют одно и то же имя: ``<lambda>``."

#: ../../library/pickle.rst:1222
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr ""
"Вызванное исключение, скорее всего, будет :exc:`ImportError` или :exc:"
"`AttributeError`, но это может быть и что-то другое."

#: ../../library/pickle.rst:1225
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""
"Модуль :mod:`copy` использует этот протокол для операций поверхностного и "
"глубокого копирования."

#: ../../library/pickle.rst:1228
msgid ""
"The limitation on alphanumeric characters is due to the fact that persistent "
"IDs in protocol 0 are delimited by the newline character.  Therefore if any "
"kind of newline characters occurs in persistent IDs, the resulting pickled "
"data will become unreadable."
msgstr ""
"Ограничение на буквенно-цифровые символы связано с тем, что постоянные "
"идентификаторы в протоколе 0 разделяются символом новой строки. Поэтому, "
"если в постоянных идентификаторах встречаются какие-либо символы новой "
"строки, полученные маринованные данные станут нечитаемыми."

#: ../../library/pickle.rst:12
msgid "persistence"
msgstr "persistence"

#: ../../library/pickle.rst:12
msgid "persistent"
msgstr "persistent"

#: ../../library/pickle.rst:12
msgid "objects"
msgstr "объекты"

#: ../../library/pickle.rst:12
msgid "serializing"
msgstr "serializing"

#: ../../library/pickle.rst:12
msgid "marshalling"
msgstr "marshalling"

#: ../../library/pickle.rst:12
msgid "flattening"
msgstr "flattening"

#: ../../library/pickle.rst:12
msgid "pickling"
msgstr "pickling"

#: ../../library/pickle.rst:123
msgid "External Data Representation"
msgstr "Представление внешних данных"

#: ../../library/pickle.rst:672
msgid "copy"
msgstr "копировать"

#: ../../library/pickle.rst:672
msgid "protocol"
msgstr "протокол"

#: ../../library/pickle.rst:756
msgid "persistent_id (pickle protocol)"
msgstr "persistent_id (pickle protocol)"

#: ../../library/pickle.rst:756
msgid "persistent_load (pickle protocol)"
msgstr "persistent_load (pickle protocol)"

#: ../../library/pickle.rst:832
msgid "__getstate__() (copy protocol)"
msgstr "__getstate__() (copy protocol)"

#: ../../library/pickle.rst:832
msgid "__setstate__() (copy protocol)"
msgstr "__setstate__() (copy protocol)"

#: ../../library/pickle.rst:1077
msgid "find_class() (pickle protocol)"
msgstr "find_class() (pickle protocol)"
