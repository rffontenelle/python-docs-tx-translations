# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Илья Панфилов, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:16+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/unittest.mock-examples.rst:2
msgid ":mod:`!unittest.mock` --- getting started"
msgstr ":mod:`!unittest.mock` --- начало работы"

#: ../../library/unittest.mock-examples.rst:27
msgid "Using Mock"
msgstr "Использование макета"

#: ../../library/unittest.mock-examples.rst:30
msgid "Mock Patching Methods"
msgstr "Методы ложного исправления"

#: ../../library/unittest.mock-examples.rst:32
msgid "Common uses for :class:`Mock` objects include:"
msgstr "Обычное использование объектов :class:`Mock` включает в себя:"

#: ../../library/unittest.mock-examples.rst:34
msgid "Patching methods"
msgstr "Методы исправления"

#: ../../library/unittest.mock-examples.rst:35
msgid "Recording method calls on objects"
msgstr "Запись вызовов методов на объектах"

#: ../../library/unittest.mock-examples.rst:37
msgid ""
"You might want to replace a method on an object to check that it is called "
"with the correct arguments by another part of the system:"
msgstr ""
"Возможно, вы захотите заменить метод объекта, чтобы проверить, что он "
"вызывается с правильными аргументами из другой части системы:"

#: ../../library/unittest.mock-examples.rst:45
msgid ""
"Once our mock has been used (``real.method`` in this example) it has methods "
"and attributes that allow you to make assertions about how it has been used."
msgstr ""
"После использования нашего макета (в этом примере «real.method») у него "
"появляются методы и атрибуты, которые позволяют вам делать утверждения о "
"том, как он использовался."

#: ../../library/unittest.mock-examples.rst:50
msgid ""
"In most of these examples the :class:`Mock` and :class:`MagicMock` classes "
"are interchangeable. As the ``MagicMock`` is the more capable class it makes "
"a sensible one to use by default."
msgstr ""
"В большинстве этих примеров классы :class:`Mock` и :class:`MagicMock` "
"взаимозаменяемы. Поскольку MagicMock является более функциональным классом, "
"его разумнее использовать по умолчанию."

#: ../../library/unittest.mock-examples.rst:54
msgid ""
"Once the mock has been called its :attr:`~Mock.called` attribute is set to "
"``True``. More importantly we can use the :meth:`~Mock.assert_called_with` "
"or :meth:`~Mock.assert_called_once_with` method to check that it was called "
"with the correct arguments."
msgstr ""
"После вызова макета его атрибуту :attr:`~Mock.called` присваивается значение "
"``True``. Что еще более важно, мы можем использовать метод :meth:`~Mock."
"assert_ Called_with` или :meth:`~Mock.assert_collect_once_with`, чтобы "
"проверить, что он был вызван с правильными аргументами."

#: ../../library/unittest.mock-examples.rst:59
msgid ""
"This example tests that calling ``ProductionClass().method`` results in a "
"call to the ``something`` method:"
msgstr ""
"В этом примере проверяется, что вызов метода ProductionClass().method "
"приводит к вызову метода Something:"

#: ../../library/unittest.mock-examples.rst:76
msgid "Mock for Method Calls on an Object"
msgstr "Макет для вызовов методов объекта"

#: ../../library/unittest.mock-examples.rst:78
msgid ""
"In the last example we patched a method directly on an object to check that "
"it was called correctly. Another common use case is to pass an object into a "
"method (or some part of the system under test) and then check that it is "
"used in the correct way."
msgstr ""
"В последнем примере мы исправили метод непосредственно на объекте, чтобы "
"проверить правильность его вызова. Другой распространенный вариант "
"использования — передать объект в метод (или некоторую часть тестируемой "
"системы), а затем проверить, правильно ли он используется."

#: ../../library/unittest.mock-examples.rst:83
msgid ""
"The simple ``ProductionClass`` below has a ``closer`` method. If it is "
"called with an object then it calls ``close`` on it."
msgstr ""
"Простой «ProductionClass» ниже имеет метод «Closer». Если он вызывается с "
"объектом, он вызывает для него `` close``."

#: ../../library/unittest.mock-examples.rst:91
msgid ""
"So to test it we need to pass in an object with a ``close`` method and check "
"that it was called correctly."
msgstr ""
"Итак, чтобы протестировать, нам нужно передать объект с помощью метода close "
"и проверить, правильно ли он был вызван."

#: ../../library/unittest.mock-examples.rst:99
msgid ""
"We don't have to do any work to provide the 'close' method on our mock. "
"Accessing close creates it. So, if 'close' hasn't already been called then "
"accessing it in the test will create it, but :meth:`~Mock."
"assert_called_with` will raise a failure exception."
msgstr ""
"Нам не нужно ничего делать, чтобы предоставить метод close в нашем макете. "
"Доступ к close создает его. Таким образом, если «закрыть» еще не было "
"вызвано, то доступ к нему в тесте создаст его, но :meth:`~Mock."
"assert_known_with` вызовет исключение сбоя."

#: ../../library/unittest.mock-examples.rst:106
msgid "Mocking Classes"
msgstr "Mocking Classes"

#: ../../library/unittest.mock-examples.rst:108
msgid ""
"A common use case is to mock out classes instantiated by your code under "
"test. When you patch a class, then that class is replaced with a mock. "
"Instances are created by *calling the class*. This means you access the "
"\"mock instance\" by looking at the return value of the mocked class."
msgstr ""
"Распространенный вариант использования — макетирование классов, экземпляры "
"которых создаются тестируемым кодом. Когда вы исправляете класс, этот класс "
"заменяется макетом. Экземпляры создаются путем *вызова класса*. Это "
"означает, что вы получаете доступ к «фиктивному экземпляру», просматривая "
"возвращаемое значение имитируемого класса."

#: ../../library/unittest.mock-examples.rst:113
msgid ""
"In the example below we have a function ``some_function`` that instantiates "
"``Foo`` and calls a method on it. The call to :func:`patch` replaces the "
"class ``Foo`` with a mock. The ``Foo`` instance is the result of calling the "
"mock, so it is configured by modifying the mock :attr:`~Mock."
"return_value`. ::"
msgstr ""
"В примере ниже у нас есть функция some_function, которая создает экземпляр "
"Foo и вызывает для него метод. Вызов :func:`patch` заменяет класс ``Foo`` на "
"макет. Экземпляр ``Foo`` является результатом вызова макета, поэтому он "
"настраивается путем изменения макета :attr:`~Mock.return_value`. ::"

#: ../../library/unittest.mock-examples.rst:118
msgid ""
">>> def some_function():\n"
"...     instance = module.Foo()\n"
"...     return instance.method()\n"
"...\n"
">>> with patch('module.Foo') as mock:\n"
"...     instance = mock.return_value\n"
"...     instance.method.return_value = 'the result'\n"
"...     result = some_function()\n"
"...     assert result == 'the result'"
msgstr ""
">>> def some_function():\n"
"...     instance = module.Foo()\n"
"...     return instance.method()\n"
"...\n"
">>> with patch('module.Foo') as mock:\n"
"...     instance = mock.return_value\n"
"...     instance.method.return_value = 'the result'\n"
"...     result = some_function()\n"
"...     assert result == 'the result'"

#: ../../library/unittest.mock-examples.rst:130
msgid "Naming your mocks"
msgstr "Назовите свои mocks"

#: ../../library/unittest.mock-examples.rst:132
msgid ""
"It can be useful to give your mocks a name. The name is shown in the repr of "
"the mock and can be helpful when the mock appears in test failure messages. "
"The name is also propagated to attributes or methods of the mock:"
msgstr ""
"Может быть полезно дать вашим макетам имя. Имя отображается в копии макета и "
"может быть полезно, когда макет появляется в сообщениях о сбоях теста. Имя "
"также передается атрибутам или методам макета:"

#: ../../library/unittest.mock-examples.rst:144
msgid "Tracking all Calls"
msgstr "Отслеживание всех вызовов"

#: ../../library/unittest.mock-examples.rst:146
msgid ""
"Often you want to track more than a single call to a method. The :attr:"
"`~Mock.mock_calls` attribute records all calls to child attributes of the "
"mock - and also to their children."
msgstr ""
"Часто требуется отслеживать более одного вызова метода. Атрибут :attr:`~Mock."
"mock_calls` записывает все вызовы дочерних атрибутов макета, а также их "
"дочерних элементов."

#: ../../library/unittest.mock-examples.rst:158
msgid ""
"If you make an assertion about ``mock_calls`` and any unexpected methods "
"have been called, then the assertion will fail. This is useful because as "
"well as asserting that the calls you expected have been made, you are also "
"checking that they were made in the right order and with no additional calls:"
msgstr ""
"Если вы сделаете утверждение о ``mock_calls`` и будут вызваны какие-либо "
"неожиданные методы, то утверждение завершится неудачно. Это полезно, "
"поскольку вы не только подтверждаете, что ожидаемые вами вызовы были "
"сделаны, но и проверяете, что они были сделаны в правильном порядке и без "
"каких-либо дополнительных вызовов:"

#: ../../library/unittest.mock-examples.rst:163
msgid ""
"You use the :data:`call` object to construct lists for comparing with "
"``mock_calls``:"
msgstr ""
"Вы используете объект :data:`call` для создания списков для сравнения с "
"``mock_calls``:"

#: ../../library/unittest.mock-examples.rst:170
msgid ""
"However, parameters to calls that return mocks are not recorded, which means "
"it is not possible to track nested calls where the parameters used to create "
"ancestors are important:"
msgstr ""
"Однако параметры вызовов, возвращающих макеты, не записываются, а это "
"означает, что невозможно отслеживать вложенные вызовы, в которых важны "
"параметры, используемые для создания предков:"

#: ../../library/unittest.mock-examples.rst:181
msgid "Setting Return Values and Attributes"
msgstr "Установка возвращаемых значений и атрибутов"

#: ../../library/unittest.mock-examples.rst:183
msgid "Setting the return values on a mock object is trivially easy:"
msgstr ""
"Установить возвращаемые значения для фиктивного объекта тривиально просто:"

#: ../../library/unittest.mock-examples.rst:190
msgid "Of course you can do the same for methods on the mock:"
msgstr "Конечно, вы можете сделать то же самое для методов макета:"

#: ../../library/unittest.mock-examples.rst:197
msgid "The return value can also be set in the constructor:"
msgstr "Возвращаемое значение также можно установить в конструкторе:"

#: ../../library/unittest.mock-examples.rst:203
msgid "If you need an attribute setting on your mock, just do it:"
msgstr "Если вам нужна настройка атрибута в макете, просто сделайте это:"

#: ../../library/unittest.mock-examples.rst:210
msgid ""
"Sometimes you want to mock up a more complex situation, like for example "
"``mock.connection.cursor().execute(\"SELECT 1\")``. If we wanted this call "
"to return a list, then we have to configure the result of the nested call."
msgstr ""
"Иногда вам нужно смоделировать более сложную ситуацию, например ``mock."
"connection.cursor().execute(\"SELECT 1\")``. Если мы хотим, чтобы этот вызов "
"возвращал список, нам нужно настроить результат вложенного вызова."

#: ../../library/unittest.mock-examples.rst:214
msgid ""
"We can use :data:`call` to construct the set of calls in a \"chained call\" "
"like this for easy assertion afterwards:"
msgstr ""
"Мы можем использовать :data:`call` для создания набора вызовов в «цепочке "
"вызовов», например, для облегчения последующего утверждения:"

#: ../../library/unittest.mock-examples.rst:228
msgid ""
"It is the call to ``.call_list()`` that turns our call object into a list of "
"calls representing the chained calls."
msgstr ""
"Именно вызов ``.call_list()`` превращает наш объект вызова в список вызовов, "
"представляющий связанные вызовы."

#: ../../library/unittest.mock-examples.rst:233
msgid "Raising exceptions with mocks"
msgstr "Вызов исключений с помощью макетов"

#: ../../library/unittest.mock-examples.rst:235
msgid ""
"A useful attribute is :attr:`~Mock.side_effect`. If you set this to an "
"exception class or instance then the exception will be raised when the mock "
"is called."
msgstr ""
"Полезным атрибутом является :attr:`~Mock.side_effect`. Если вы установите "
"для этого класса или экземпляра исключения, тогда исключение будет вызвано "
"при вызове макета."

#: ../../library/unittest.mock-examples.rst:247
msgid "Side effect functions and iterables"
msgstr "Функции и итерации побочных эффектов"

#: ../../library/unittest.mock-examples.rst:249
msgid ""
"``side_effect`` can also be set to a function or an iterable. The use case "
"for ``side_effect`` as an iterable is where your mock is going to be called "
"several times, and you want each call to return a different value. When you "
"set ``side_effect`` to an iterable every call to the mock returns the next "
"value from the iterable:"
msgstr ""
"``side_effect`` также может быть установлен как функция или итерируемый "
"объект. Вариант использования Side_effect в качестве итерируемого объекта "
"заключается в том, что ваш макет будет вызываться несколько раз, и вы "
"хотите, чтобы каждый вызов возвращал другое значение. Когда вы "
"устанавливаете ``side_effect`` для итерируемого объекта, каждый вызов макета "
"возвращает следующее значение из итерируемого объекта:"

#: ../../library/unittest.mock-examples.rst:264
msgid ""
"For more advanced use cases, like dynamically varying the return values "
"depending on what the mock is called with, ``side_effect`` can be a "
"function. The function will be called with the same arguments as the mock. "
"Whatever the function returns is what the call returns:"
msgstr ""
"Для более сложных случаев использования, таких как динамическое изменение "
"возвращаемых значений в зависимости от того, с чем вызывается макет, "
"Side_effect может быть функцией. Функция будет вызываться с теми же "
"аргументами, что и макет. Что бы ни возвращала функция, это то, что "
"возвращает вызов:"

#: ../../library/unittest.mock-examples.rst:281
msgid "Mocking asynchronous iterators"
msgstr "Mocking asynchronous iterators"

#: ../../library/unittest.mock-examples.rst:283
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-iterators` through ``__aiter__``. The :attr:`~Mock.return_value` "
"attribute of ``__aiter__`` can be used to set the return values to be used "
"for iteration."
msgstr ""
"Начиная с Python 3.8, AsyncMock и MagicMock поддерживают имитацию async-"
"итераторов через __aiter__. Атрибут :attr:`~Mock.return_value` ``__aiter__`` "
"может использоваться для установки возвращаемых значений, которые будут "
"использоваться для итерации."

#: ../../library/unittest.mock-examples.rst:298
msgid "Mocking asynchronous context manager"
msgstr "Mocking asynchronous context manager"

#: ../../library/unittest.mock-examples.rst:300
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-context-managers` through ``__aenter__`` and ``__aexit__``. By "
"default, ``__aenter__`` and ``__aexit__`` are ``AsyncMock`` instances that "
"return an async function."
msgstr ""
"Начиная с Python 3.8, AsyncMock и MagicMock поддерживают имитацию async-"
"context-manager через __aenter__ и __aexit__. По умолчанию __aenter__ и "
"__aexit__ являются экземплярами AsyncMock, которые возвращают асинхронную "
"функцию."

#: ../../library/unittest.mock-examples.rst:322
msgid "Creating a Mock from an Existing Object"
msgstr "Создание a Mock из существующего объекта "

#: ../../library/unittest.mock-examples.rst:324
msgid ""
"One problem with over use of mocking is that it couples your tests to the "
"implementation of your mocks rather than your real code. Suppose you have a "
"class that implements ``some_method``. In a test for another class, you "
"provide a mock of this object that *also* provides ``some_method``. If later "
"you refactor the first class, so that it no longer has ``some_method`` - "
"then your tests will continue to pass even though your code is now broken!"
msgstr ""
"Одна из проблем с чрезмерным использованием макетов заключается в том, что "
"они связывают ваши тесты с реализацией макетов, а не с вашим реальным кодом. "
"Предположим, у вас есть класс, реализующий ``some_method``. В тесте для "
"другого класса вы предоставляете макет этого объекта, который *также* "
"предоставляет ``some_method``. Если позже вы выполните рефакторинг первого "
"класса так, что он больше не будет иметь ``some_method`` - тогда ваши тесты "
"продолжат проходить, даже если ваш код теперь сломан!"

#: ../../library/unittest.mock-examples.rst:331
msgid ""
":class:`Mock` allows you to provide an object as a specification for the "
"mock, using the *spec* keyword argument. Accessing methods / attributes on "
"the mock that don't exist on your specification object will immediately "
"raise an attribute error. If you change the implementation of your "
"specification, then tests that use that class will start failing immediately "
"without you having to instantiate the class in those tests."
msgstr ""
":class:`Mock` позволяет вам предоставить объект в качестве спецификации "
"макета, используя аргумент ключевого слова *spec*. Доступ к методам/"
"атрибутам макета, которые не существуют в вашем объекте спецификации, "
"немедленно вызовет ошибку атрибута. Если вы измените реализацию своей "
"спецификации, то тесты, использующие этот класс, сразу же начнут давать "
"сбой, и вам не придется создавать экземпляр класса в этих тестах."

#: ../../library/unittest.mock-examples.rst:344
msgid ""
"Using a specification also enables a smarter matching of calls made to the "
"mock, regardless of whether some parameters were passed as positional or "
"named arguments::"
msgstr ""
"Использование спецификации также обеспечивает более разумное сопоставление "
"вызовов макета, независимо от того, были ли некоторые параметры переданы как "
"позиционные или именованные аргументы:"

#: ../../library/unittest.mock-examples.rst:348
msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, 3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, 3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"

#: ../../library/unittest.mock-examples.rst:355
msgid ""
"If you want this smarter matching to also work with method calls on the "
"mock, you can use :ref:`auto-speccing <auto-speccing>`."
msgstr ""
"Если вы хотите, чтобы это более разумное сопоставление также работало с "
"вызовами методов в макете, вы можете использовать :ref:`auto-speccing <auto-"
"speccing>`."

#: ../../library/unittest.mock-examples.rst:358
msgid ""
"If you want a stronger form of specification that prevents the setting of "
"arbitrary attributes as well as the getting of them then you can use "
"*spec_set* instead of *spec*."
msgstr ""
"Если вам нужна более строгая форма спецификации, которая предотвращает "
"установку произвольных атрибутов, а также их получение, вы можете "
"использовать *spec_set* вместо *spec*."

#: ../../library/unittest.mock-examples.rst:364
msgid "Using side_effect to return per file content"
msgstr "Использование Side_effect для возврата содержимого файла"

#: ../../library/unittest.mock-examples.rst:366
msgid ""
":func:`mock_open` is used to patch :func:`open` method. :attr:`~Mock."
"side_effect` can be used to return a new Mock object per call. This can be "
"used to return different contents per file stored in a dictionary::"
msgstr ""
":func:`mock_open` используется для исправления метода :func:`open`. :attr:"
"`~Mock.side_effect` можно использовать для возврата нового объекта Mock при "
"каждом вызове. Это можно использовать для возврата различного содержимого "
"для каждого файла, хранящегося в словаре::"

#: ../../library/unittest.mock-examples.rst:370
msgid ""
"DEFAULT = \"default\"\n"
"data_dict = {\"file1\": \"data1\",\n"
"             \"file2\": \"data2\"}\n"
"\n"
"def open_side_effect(name):\n"
"    return mock_open(read_data=data_dict.get(name, DEFAULT))()\n"
"\n"
"with patch(\"builtins.open\", side_effect=open_side_effect):\n"
"    with open(\"file1\") as file1:\n"
"        assert file1.read() == \"data1\"\n"
"\n"
"    with open(\"file2\") as file2:\n"
"        assert file2.read() == \"data2\"\n"
"\n"
"    with open(\"file3\") as file2:\n"
"        assert file2.read() == \"default\""
msgstr ""
"DEFAULT = \"default\"\n"
"data_dict = {\"file1\": \"data1\",\n"
"             \"file2\": \"data2\"}\n"
"\n"
"def open_side_effect(name):\n"
"    return mock_open(read_data=data_dict.get(name, DEFAULT))()\n"
"\n"
"with patch(\"builtins.open\", side_effect=open_side_effect):\n"
"    with open(\"file1\") as file1:\n"
"        assert file1.read() == \"data1\"\n"
"\n"
"    with open(\"file2\") as file2:\n"
"        assert file2.read() == \"data2\"\n"
"\n"
"    with open(\"file3\") as file2:\n"
"        assert file2.read() == \"default\""

#: ../../library/unittest.mock-examples.rst:389
msgid "Patch Decorators"
msgstr "Патч-декораторы"

#: ../../library/unittest.mock-examples.rst:393
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"При использовании :func:`patch` важно исправлять объекты в пространстве "
"имен, в котором они просматриваются. Обычно это просто, но для краткого "
"руководства прочтите :ref:`where to patch <where-to-patch>`."

#: ../../library/unittest.mock-examples.rst:398
msgid ""
"A common need in tests is to patch a class attribute or a module attribute, "
"for example patching a builtin or patching a class in a module to test that "
"it is instantiated. Modules and classes are effectively global, so patching "
"on them has to be undone after the test or the patch will persist into other "
"tests and cause hard to diagnose problems."
msgstr ""
"Обычно в тестах требуется исправить атрибут класса или атрибут модуля, "
"например, исправить встроенную функцию или исправить класс в модуле, чтобы "
"проверить, что он создан. Модули и классы по сути являются глобальными, "
"поэтому исправления для них необходимо отменить после теста, иначе "
"исправление сохранится в других тестах и ​​вызовет трудности для диагностики "
"проблем."

#: ../../library/unittest.mock-examples.rst:404
msgid ""
"mock provides three convenient decorators for this: :func:`patch`, :func:"
"`patch.object` and :func:`patch.dict`. ``patch`` takes a single string, of "
"the form ``package.module.Class.attribute`` to specify the attribute you are "
"patching. It also optionally takes a value that you want the attribute (or "
"class or whatever) to be replaced with. 'patch.object' takes an object and "
"the name of the attribute you would like patched, plus optionally the value "
"to patch it with."
msgstr ""
"макет предоставляет для этого три удобных декоратора: :func:`patch`, :func:"
"`patch.object` и :func:`patch.dict`. ``patch`` принимает одну строку в форме "
"``package.module.Class.attribute`` для указания атрибута, который вы "
"исправляете. Он также необязательно принимает значение, которым вы хотите "
"заменить атрибут (или класс или что-то еще). «patch.object» принимает объект "
"и имя атрибута, который вы хотите исправить, а также, возможно, значение для "
"его исправления."

#: ../../library/unittest.mock-examples.rst:412
msgid "``patch.object``::"
msgstr "``patch.object``::"

#: ../../library/unittest.mock-examples.rst:414
msgid ""
">>> original = SomeClass.attribute\n"
">>> @patch.object(SomeClass, 'attribute', sentinel.attribute)\n"
"... def test():\n"
"...     assert SomeClass.attribute == sentinel.attribute\n"
"...\n"
">>> test()\n"
">>> assert SomeClass.attribute == original\n"
"\n"
">>> @patch('package.module.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import attribute\n"
"...     assert attribute is sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""
">>> original = SomeClass.attribute\n"
">>> @patch.object(SomeClass, 'attribute', sentinel.attribute)\n"
"... def test():\n"
"...     assert SomeClass.attribute == sentinel.attribute\n"
"...\n"
">>> test()\n"
">>> assert SomeClass.attribute == original\n"
"\n"
">>> @patch('package.module.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import attribute\n"
"...     assert attribute is sentinel.attribute\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock-examples.rst:429
msgid ""
"If you are patching a module (including :mod:`builtins`) then use :func:"
"`patch` instead of :func:`patch.object`:"
msgstr ""
"Если вы исправляете модуль (включая :mod:`builtins`), используйте :func:"
"`patch` вместо :func:`patch.object`:"

#: ../../library/unittest.mock-examples.rst:439
msgid ""
"The module name can be 'dotted', in the form ``package.module`` if needed::"
msgstr ""
"При необходимости имя модуля может быть разделено точками в виде package."
"module:"

#: ../../library/unittest.mock-examples.rst:441
msgid ""
">>> @patch('package.module.ClassName.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import ClassName\n"
"...     assert ClassName.attribute == sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""
">>> @patch('package.module.ClassName.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import ClassName\n"
"...     assert ClassName.attribute == sentinel.attribute\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock-examples.rst:448
msgid "A nice pattern is to actually decorate test methods themselves:"
msgstr "Хороший шаблон — украсить сами методы тестирования:"

#: ../../library/unittest.mock-examples.rst:459
msgid ""
"If you want to patch with a Mock, you can use :func:`patch` with only one "
"argument (or :func:`patch.object` with two arguments). The mock will be "
"created for you and passed into the test function / method:"
msgstr ""
"Если вы хотите использовать патч с помощью Mock, вы можете использовать :"
"func:`patch` только с одним аргументом (или :func:`patch.object` с двумя "
"аргументами). Мок будет создан для вас и передан в тестовую функцию/метод:"

#: ../../library/unittest.mock-examples.rst:471
msgid "You can stack up multiple patch decorators using this pattern::"
msgstr ""
"Вы можете объединить несколько декораторов патчей, используя этот шаблон:"

#: ../../library/unittest.mock-examples.rst:473
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     @patch('package.module.ClassName1')\n"
"...     @patch('package.module.ClassName2')\n"
"...     def test_something(self, MockClass2, MockClass1):\n"
"...         self.assertIs(package.module.ClassName1, MockClass1)\n"
"...         self.assertIs(package.module.ClassName2, MockClass2)\n"
"...\n"
">>> MyTest('test_something').test_something()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     @patch('package.module.ClassName1')\n"
"...     @patch('package.module.ClassName2')\n"
"...     def test_something(self, MockClass2, MockClass1):\n"
"...         self.assertIs(package.module.ClassName1, MockClass1)\n"
"...         self.assertIs(package.module.ClassName2, MockClass2)\n"
"...\n"
">>> MyTest('test_something').test_something()"

#: ../../library/unittest.mock-examples.rst:482
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``test_module.ClassName2`` is passed in first."
msgstr ""
"Когда вы вкладываете декораторы патчей, макеты передаются декорируемой "
"функции в том же порядке, в котором они были применены (обычный порядок "
"*Python*, в котором применяются декораторы). Это означает, что снизу вверх, "
"поэтому в приведенном выше примере сначала передается макет для "
"``test_module.ClassName2``."

#: ../../library/unittest.mock-examples.rst:487
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"Существует также :func:`patch.dict` для установки значений в словаре только "
"во время проверки и восстановления словаря в исходное состояние после "
"завершения теста:"

#: ../../library/unittest.mock-examples.rst:498
msgid ""
"``patch``, ``patch.object`` and ``patch.dict`` can all be used as context "
"managers."
msgstr ""
"``patch``, ``patch.object`` и ``patch.dict`` могут использоваться в качестве "
"менеджеров контекста."

#: ../../library/unittest.mock-examples.rst:500
msgid ""
"Where you use :func:`patch` to create a mock for you, you can get a "
"reference to the mock using the \"as\" form of the with statement:"
msgstr ""
"Если вы используете :func:`patch` для создания макета, вы можете получить "
"ссылку на макет, используя форму «as» оператора with:"

#: ../../library/unittest.mock-examples.rst:515
msgid ""
"As an alternative ``patch``, ``patch.object`` and ``patch.dict`` can be used "
"as class decorators. When used in this way it is the same as applying the "
"decorator individually to every method whose name starts with \"test\"."
msgstr ""
"В качестве альтернативы ``patch``, ``patch.object`` и ``patch.dict`` могут "
"использоваться в качестве декораторов классов. При таком использовании это "
"то же самое, что применять декоратор индивидуально к каждому методу, имя "
"которого начинается с «test»."

#: ../../library/unittest.mock-examples.rst:523
msgid "Further Examples"
msgstr "Другие примеры"

#: ../../library/unittest.mock-examples.rst:526
msgid "Here are some more examples for some slightly more advanced scenarios."
msgstr "Вот еще несколько примеров для некоторых более сложных сценариев."

#: ../../library/unittest.mock-examples.rst:530
msgid "Mocking chained calls"
msgstr "Mocking цепочки вызовов"

#: ../../library/unittest.mock-examples.rst:532
msgid ""
"Mocking chained calls is actually straightforward with mock once you "
"understand the :attr:`~Mock.return_value` attribute. When a mock is called "
"for the first time, or you fetch its ``return_value`` before it has been "
"called, a new :class:`Mock` is created."
msgstr ""
"Имитировать связанные вызовы с помощью макета на самом деле просто, если вы "
"понимаете атрибут :attr:`~Mock.return_value`. Когда макет вызывается в "
"первый раз или вы получаете его ``return_value`` до его вызова, создается "
"новый :class:`Mock`."

#: ../../library/unittest.mock-examples.rst:537
msgid ""
"This means that you can see how the object returned from a call to a mocked "
"object has been used by interrogating the ``return_value`` mock:"
msgstr ""
"Это означает, что вы можете увидеть, как объект, возвращенный в результате "
"вызова имитируемого объекта, использовался, опрашивая макет ``return_value``:"

#: ../../library/unittest.mock-examples.rst:545
msgid ""
"From here it is a simple step to configure and then make assertions about "
"chained calls. Of course another alternative is writing your code in a more "
"testable way in the first place..."
msgstr ""
"Отсюда можно легко настроить и затем сделать утверждения о связанных "
"вызовах. Конечно, другой альтернативой является написание кода более "
"тестируемым способом..."

#: ../../library/unittest.mock-examples.rst:549
msgid "So, suppose we have some code that looks a little bit like this:"
msgstr "Итак, предположим, что у нас есть код, который выглядит примерно так:"

#: ../../library/unittest.mock-examples.rst:558
msgid ""
"Assuming that ``BackendProvider`` is already well tested, how do we test "
"``method()``? Specifically, we want to test that the code section ``# more "
"code`` uses the response object in the correct way."
msgstr ""
"Предполагая, что BackendProvider уже хорошо протестирован, как нам "
"протестировать метод()? В частности, мы хотим проверить, что раздел кода ``# "
"more code`` правильно использует объект ответа."

#: ../../library/unittest.mock-examples.rst:562
msgid ""
"As this chain of calls is made from an instance attribute we can monkey "
"patch the ``backend`` attribute on a ``Something`` instance. In this "
"particular case we are only interested in the return value from the final "
"call to ``start_call`` so we don't have much configuration to do. Let's "
"assume the object it returns is 'file-like', so we'll ensure that our "
"response object uses the builtin :func:`open` as its ``spec``."
msgstr ""
"Поскольку эта цепочка вызовов создается из атрибута экземпляра, мы можем "
"обезьяньим образом исправить атрибут ``backend`` в экземпляре ``Something``. "
"В данном конкретном случае нас интересует только возвращаемое значение от "
"последнего вызова start_call, поэтому нам не нужно ничего настраивать. "
"Предположим, что возвращаемый объект похож на файл, поэтому мы обеспечим, "
"чтобы наш объект ответа использовал встроенную функцию :func:`open` в "
"качестве своей ``спецификации``."

#: ../../library/unittest.mock-examples.rst:569
msgid ""
"To do this we create a mock instance as our mock backend and create a mock "
"response object for it. To set the response as the return value for that "
"final ``start_call`` we could do this::"
msgstr ""
"Для этого мы создаем фиктивный экземпляр в качестве нашего фиктивного "
"бэкэнда и создаем для него фиктивный объект ответа. Чтобы установить ответ в "
"качестве возвращаемого значения для финального ``start_call``, мы могли бы "
"сделать следующее:"

#: ../../library/unittest.mock-examples.rst:573
msgid ""
"mock_backend.get_endpoint.return_value.create_call.return_value.start_call."
"return_value = mock_response"
msgstr ""
"ock_backend.get_endpoint.return_value.create_call.return_value.start_call."
"return_value = макет_ответа"

#: ../../library/unittest.mock-examples.rst:575
msgid ""
"We can do that in a slightly nicer way using the :meth:`~Mock."
"configure_mock` method to directly set the return value for us::"
msgstr ""
"Мы можем сделать это немного более удобным способом, используя метод :meth:"
"`~Mock.configure_mock`, чтобы напрямую установить для нас возвращаемое "
"значение:"

#: ../../library/unittest.mock-examples.rst:578
msgid ""
">>> something = Something()\n"
">>> mock_response = Mock(spec=open)\n"
">>> mock_backend = Mock()\n"
">>> config = {'get_endpoint.return_value.create_call.return_value.start_call."
"return_value': mock_response}\n"
">>> mock_backend.configure_mock(**config)"
msgstr ""
">>> something = Something()\n"
">>> mock_response = Mock(spec=open)\n"
">>> mock_backend = Mock()\n"
">>> config = {'get_endpoint.return_value.create_call.return_value.start_call."
"return_value': mock_response}\n"
">>> mock_backend.configure_mock(**config)"

#: ../../library/unittest.mock-examples.rst:584
msgid ""
"With these we monkey patch the \"mock backend\" in place and can make the "
"real call::"
msgstr ""
"С их помощью мы исправим «фиктивный бэкэнд» и сможем сделать настоящий вызов:"

#: ../../library/unittest.mock-examples.rst:587
msgid ""
">>> something.backend = mock_backend\n"
">>> something.method()"
msgstr ""
">>> something.backend = mock_backend\n"
">>> something.method()"

#: ../../library/unittest.mock-examples.rst:590
msgid ""
"Using :attr:`~Mock.mock_calls` we can check the chained call with a single "
"assert. A chained call is several calls in one line of code, so there will "
"be several entries in ``mock_calls``. We can use :meth:`call.call_list` to "
"create this list of calls for us::"
msgstr ""
"Используя :attr:`~Mock.mock_calls`, мы можем проверить цепочку вызовов с "
"помощью одного утверждения. Связанный вызов — это несколько вызовов в одной "
"строке кода, поэтому в ``mock_calls`` будет несколько записей. Мы можем "
"использовать :meth:`call.call_list`, чтобы создать для нас этот список "
"вызовов:"

#: ../../library/unittest.mock-examples.rst:595
msgid ""
">>> chained = call.get_endpoint('foobar').create_call('spam', 'eggs')."
"start_call()\n"
">>> call_list = chained.call_list()\n"
">>> assert mock_backend.mock_calls == call_list"
msgstr ""
">>> chained = call.get_endpoint('foobar').create_call('spam', 'eggs')."
"start_call()\n"
">>> call_list = chained.call_list()\n"
">>> assert mock_backend.mock_calls == call_list"

#: ../../library/unittest.mock-examples.rst:601
msgid "Partial mocking"
msgstr "Частичное издевательство"

#: ../../library/unittest.mock-examples.rst:603
msgid ""
"In some tests I wanted to mock out a call to :meth:`datetime.date.today` to "
"return a known date, but I didn't want to prevent the code under test from "
"creating new date objects. Unfortunately :class:`datetime.date` is written "
"in C, and so I couldn't just monkey-patch out the static :meth:`datetime."
"date.today` method."
msgstr ""
"В некоторых тестах я хотел имитировать вызов :meth:`datetime.date.today` для "
"возврата известной даты, но я не хотел препятствовать тестируемому коду "
"создавать новые объекты даты. К сожалению, :class:`datetime.date` написан на "
"C, и поэтому я не мог просто исправить статический :meth:`datetime.date."
"today` метод."

#: ../../library/unittest.mock-examples.rst:608
msgid ""
"I found a simple way of doing this that involved effectively wrapping the "
"date class with a mock, but passing through calls to the constructor to the "
"real class (and returning real instances)."
msgstr ""
"Я нашел простой способ сделать это, который включал в себя эффективную "
"упаковку класса даты в макет, но передачу вызовов конструктора реальному "
"классу (и возврат реальных экземпляров)."

#: ../../library/unittest.mock-examples.rst:612
msgid ""
"The :func:`patch decorator <patch>` is used here to mock out the ``date`` "
"class in the module under test. The :attr:`~Mock.side_effect` attribute on "
"the mock date class is then set to a lambda function that returns a real "
"date. When the mock date class is called a real date will be constructed and "
"returned by ``side_effect``. ::"
msgstr ""
"Декоратор :func:`patch <patch>` используется здесь для макетирования класса "
"``date`` в тестируемом модуле. Атрибут :attr:`~Mock.side_effect` в классе "
"ложной даты затем устанавливается в лямбда-функцию, которая возвращает "
"реальную дату. Когда вызывается класс ложной даты, реальная дата будет "
"создана и возвращена ``side_effect``. ::"

#: ../../library/unittest.mock-examples.rst:618
msgid ""
">>> from datetime import date\n"
">>> with patch('mymodule.date') as mock_date:\n"
"...     mock_date.today.return_value = date(2010, 10, 8)\n"
"...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)\n"
"...\n"
"...     assert mymodule.date.today() == date(2010, 10, 8)\n"
"...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)"
msgstr ""
">>> from datetime import date\n"
">>> with patch('mymodule.date') as mock_date:\n"
"...     mock_date.today.return_value = date(2010, 10, 8)\n"
"...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)\n"
"...\n"
"...     assert mymodule.date.today() == date(2010, 10, 8)\n"
"...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)"

#: ../../library/unittest.mock-examples.rst:626
msgid ""
"Note that we don't patch :class:`datetime.date` globally, we patch ``date`` "
"in the module that *uses* it. See :ref:`where to patch <where-to-patch>`."
msgstr ""
"Обратите внимание, что мы не обновляем :class:`datetime.date` глобально, мы "
"исправляем ``date`` в модуле, который *использует* его. См. :ref:`где "
"исправлять <где-исправить>`."

#: ../../library/unittest.mock-examples.rst:629
msgid ""
"When ``date.today()`` is called a known date is returned, but calls to the "
"``date(...)`` constructor still return normal dates. Without this you can "
"find yourself having to calculate an expected result using exactly the same "
"algorithm as the code under test, which is a classic testing anti-pattern."
msgstr ""
"Когда вызывается ``date.today()``, возвращается известная дата, но вызовы "
"конструктора ``date(...)`` по-прежнему возвращают обычные даты. Без этого "
"вам придется вычислять ожидаемый результат, используя тот же алгоритм, что и "
"тестируемый код, что является классическим антишаблоном тестирования."

#: ../../library/unittest.mock-examples.rst:634
msgid ""
"Calls to the date constructor are recorded in the ``mock_date`` attributes "
"(``call_count`` and friends) which may also be useful for your tests."
msgstr ""
"Вызовы конструктора даты записываются в атрибуты ``mock_date`` "
"(``call_count`` и его друзья), которые также могут быть полезны для ваших "
"тестов."

#: ../../library/unittest.mock-examples.rst:637
msgid ""
"An alternative way of dealing with mocking dates, or other builtin classes, "
"is discussed in `this blog entry <https://williambert.online/2011/07/how-to-"
"unit-testing-in-django-with-mocking-and-patching/>`_."
msgstr ""
"Альтернативный способ работы с ложными датами или другими встроенными "
"классами обсуждается в этой записи блога <https://williambert.online/2011/07/"
"how-to-unit-testing-in-django-with-mocking- и-исправление/>`_."

#: ../../library/unittest.mock-examples.rst:643
msgid "Mocking a Generator Method"
msgstr "Издевательство над методом генератора"

#: ../../library/unittest.mock-examples.rst:645
msgid ""
"A Python generator is a function or method that uses the :keyword:`yield` "
"statement to return a series of values when iterated over [#]_."
msgstr ""
"Генератор Python — это функция или метод, который использует оператор :"
"keyword:`yield` для возврата серии значений при повторении. [#]_ ."

#: ../../library/unittest.mock-examples.rst:648
msgid ""
"A generator method / function is called to return the generator object. It "
"is the generator object that is then iterated over. The protocol method for "
"iteration is :meth:`~container.__iter__`, so we can mock this using a :class:"
"`MagicMock`."
msgstr ""
"Метод/функция генератора вызывается для возврата объекта генератора. Затем "
"выполняется итерация объекта-генератора. Метод протокола для итерации — :"
"meth:`~container.__iter__`, поэтому мы можем имитировать его, используя :"
"class:`MagicMock`."

#: ../../library/unittest.mock-examples.rst:653
msgid ""
"Here's an example class with an \"iter\" method implemented as a generator:"
msgstr "Вот пример класса с методом «iter», реализованным как генератор:"

#: ../../library/unittest.mock-examples.rst:665
msgid "How would we mock this class, and in particular its \"iter\" method?"
msgstr "Как бы мы высмеивали этот класс и, в частности, его метод «iter»?"

#: ../../library/unittest.mock-examples.rst:667
msgid ""
"To configure the values returned from the iteration (implicit in the call "
"to :class:`list`), we need to configure the object returned by the call to "
"``foo.iter()``."
msgstr ""
"Чтобы настроить значения, возвращаемые в результате итерации (неявно при "
"вызове :class:`list`), нам нужно настроить объект, возвращаемый вызовом "
"``foo.iter()``."

#: ../../library/unittest.mock-examples.rst:675
msgid ""
"There are also generator expressions and more `advanced uses <http://www."
"dabeaz.com/coroutines/index.html>`_ of generators, but we aren't concerned "
"about them here. A very good introduction to generators and how powerful "
"they are is: `Generator Tricks for Systems Programmers <http://www.dabeaz."
"com/generators/>`_."
msgstr ""
"Существуют также выражения-генераторы и более `продвинутые возможности "
"использования <http://www.dabeaz.com/coroutines/index.html>`_ генераторов, "
"но они здесь нас не интересуют. Очень хорошее введение в генераторы и их "
"мощь: «Советы с генераторами для системных программистов <http://www.dabeaz."
"com/generators/>»_."

#: ../../library/unittest.mock-examples.rst:683
msgid "Applying the same patch to every test method"
msgstr "Применение одного и того же патча к каждому методу тестирования"

#: ../../library/unittest.mock-examples.rst:685
msgid ""
"If you want several patches in place for multiple test methods the obvious "
"way is to apply the patch decorators to every method. This can feel like "
"unnecessary repetition. Instead, you can use :func:`patch` (in all its "
"various forms) as a class decorator. This applies the patches to all test "
"methods on the class. A test method is identified by methods whose names "
"start with ``test``::"
msgstr ""
"Если вам нужно несколько патчей для нескольких методов тестирования, "
"очевидный способ — применить декораторы патчей к каждому методу. Это может "
"показаться ненужным повторением. Вместо этого вы можете использовать :func:"
"`patch` (во всех его различных формах) в качестве декоратора класса. При "
"этом исправления применяются ко всем методам тестирования в классе. Метод "
"тестирования идентифицируется методами, имена которых начинаются с ``test``::"

#: ../../library/unittest.mock-examples.rst:692
msgid ""
">>> @patch('mymodule.SomeClass')\n"
"... class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_one(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def test_two(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def not_a_test(self):\n"
"...         return 'something'\n"
"...\n"
">>> MyTest('test_one').test_one()\n"
">>> MyTest('test_two').test_two()\n"
">>> MyTest('test_two').not_a_test()\n"
"'something'"
msgstr ""
">>> @patch('mymodule.SomeClass')\n"
"... class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_one(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def test_two(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def not_a_test(self):\n"
"...         return 'something'\n"
"...\n"
">>> MyTest('test_one').test_one()\n"
">>> MyTest('test_two').test_two()\n"
">>> MyTest('test_two').not_a_test()\n"
"'something'"

#: ../../library/unittest.mock-examples.rst:709
msgid ""
"An alternative way of managing patches is to use the :ref:`start-and-stop`. "
"These allow you to move the patching into your ``setUp`` and ``tearDown`` "
"methods. ::"
msgstr ""
"Альтернативный способ управления патчами — использование :ref:`start-and-"
"stop`. Они позволяют вам переместить исправления в ваши методы ``setUp`` и "
"``tearDown``. ::"

#: ../../library/unittest.mock-examples.rst:713
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher = patch('mymodule.foo')\n"
"...         self.mock_foo = self.patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher.stop()\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher = patch('mymodule.foo')\n"
"...         self.mock_foo = self.patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher.stop()\n"
"...\n"
">>> MyTest('test_foo').run()"

#: ../../library/unittest.mock-examples.rst:726
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the setUp then tearDown is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"Если вы используете этот метод, вы должны убедиться, что исправление "
"«отменено», вызвав ``stop``. Это может быть сложнее, чем вы думаете, потому "
"что если в setUp возникает исключение, то TearDown не вызывается. :meth:"
"`unittest.TestCase.addCleanup` делает это проще::"

#: ../../library/unittest.mock-examples.rst:731
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('mymodule.foo')\n"
"...         self.addCleanup(patcher.stop)\n"
"...         self.mock_foo = patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('mymodule.foo')\n"
"...         self.addCleanup(patcher.stop)\n"
"...         self.mock_foo = patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
">>> MyTest('test_foo').run()"

#: ../../library/unittest.mock-examples.rst:744
msgid "Mocking Unbound Methods"
msgstr "Издевательство над несвязанными методами"

#: ../../library/unittest.mock-examples.rst:746
msgid ""
"Whilst writing tests today I needed to patch an *unbound method* (patching "
"the method on the class rather than on the instance). I needed self to be "
"passed in as the first argument because I want to make asserts about which "
"objects were calling this particular method. The issue is that you can't "
"patch with a mock for this, because if you replace an unbound method with a "
"mock it doesn't become a bound method when fetched from the instance, and so "
"it doesn't get self passed in. The workaround is to patch the unbound method "
"with a real function instead. The :func:`patch` decorator makes it so simple "
"to patch out methods with a mock that having to create a real function "
"becomes a nuisance."
msgstr ""
"Сегодня, когда я писал тесты, мне нужно было исправить *несвязанный метод* "
"(исправив метод в классе, а не в экземпляре). Мне нужно было передать self в "
"качестве первого аргумента, потому что я хочу утверждать, какие объекты "
"вызывали этот конкретный метод. Проблема в том, что вы не можете исправить "
"это с помощью макета, потому что если вы замените несвязанный метод макетом, "
"он не станет связанным методом при извлечении из экземпляра, и поэтому он не "
"будет передан самостоятельно. Обходной путь — заменить несвязанный метод "
"реальной функцией. Декоратор :func:`patch` настолько упрощает исправление "
"методов с помощью макета, что необходимость создания реальной функции "
"становится обременительной."

#: ../../library/unittest.mock-examples.rst:757
msgid ""
"If you pass ``autospec=True`` to patch then it does the patching with a "
"*real* function object. This function object has the same signature as the "
"one it is replacing, but delegates to a mock under the hood. You still get "
"your mock auto-created in exactly the same way as before. What it means "
"though, is that if you use it to patch out an unbound method on a class the "
"mocked function will be turned into a bound method if it is fetched from an "
"instance. It will have ``self`` passed in as the first argument, which is "
"exactly what I wanted:"
msgstr ""
"Если вы передадите ``autospec=True`` для исправления, то исправление будет "
"выполнено с использованием *реального* функционального объекта. Этот объект "
"функции имеет ту же сигнатуру, что и тот, который он заменяет, но под "
"капотом делегирует макет. Вы по-прежнему автоматически создаете макет точно "
"так же, как и раньше. Однако это означает, что если вы используете его для "
"исправления несвязанного метода в классе, имитируемая функция будет "
"превращена в связанный метод, если она будет получена из экземпляра. В "
"качестве первого аргумента будет передано ``self``, и это именно то, что я "
"хотел:"

#: ../../library/unittest.mock-examples.rst:778
msgid ""
"If we don't use ``autospec=True`` then the unbound method is patched out "
"with a Mock instance instead, and isn't called with ``self``."
msgstr ""
"Если мы не используем autospec=True, то несвязанный метод вместо этого "
"исправляется с помощью Mock-экземпляра и не вызывается с ``self``."

#: ../../library/unittest.mock-examples.rst:783
msgid "Checking multiple calls with mock"
msgstr "Проверка нескольких вызовов с помощью макета"

#: ../../library/unittest.mock-examples.rst:785
msgid ""
"mock has a nice API for making assertions about how your mock objects are "
"used."
msgstr ""
"У макета есть хороший API для создания утверждений о том, как используются "
"ваши макетные объекты."

#: ../../library/unittest.mock-examples.rst:792
msgid ""
"If your mock is only being called once you can use the :meth:`~Mock."
"assert_called_once_with` method that also asserts that the :attr:`~Mock."
"call_count` is one."
msgstr ""
"Если ваш макет вызывается только один раз, вы можете использовать метод :"
"meth:`~Mock.assert_known_once_with`, который также утверждает, что :attr:"
"`~Mock.call_count` является таковым."

#: ../../library/unittest.mock-examples.rst:804
msgid ""
"Both ``assert_called_with`` and ``assert_called_once_with`` make assertions "
"about the *most recent* call. If your mock is going to be called several "
"times, and you want to make assertions about *all* those calls you can use :"
"attr:`~Mock.call_args_list`:"
msgstr ""
"И ``assert_called_with``, и ``assert_called_once_with`` делают утверждения о "
"*самом последнем* вызове. Если ваш макет будет вызываться несколько раз, и "
"вы хотите сделать утверждения обо всех * этих вызовах, вы можете "
"использовать :attr:`~Mock.call_args_list`:"

#: ../../library/unittest.mock-examples.rst:816
msgid ""
"The :data:`call` helper makes it easy to make assertions about these calls. "
"You can build up a list of expected calls and compare it to "
"``call_args_list``. This looks remarkably similar to the repr of the "
"``call_args_list``:"
msgstr ""
"Помощник :data:`call` позволяет легко делать утверждения об этих вызовах. Вы "
"можете создать список ожидаемых вызовов и сравнить его с call_args_list. Это "
"очень похоже на воспроизведение ``call_args_list``:"

#: ../../library/unittest.mock-examples.rst:826
msgid "Coping with mutable arguments"
msgstr "Как справиться с изменчивыми аргументами"

#: ../../library/unittest.mock-examples.rst:828
msgid ""
"Another situation is rare, but can bite you, is when your mock is called "
"with mutable arguments. ``call_args`` and ``call_args_list`` store "
"*references* to the arguments. If the arguments are mutated by the code "
"under test then you can no longer make assertions about what the values were "
"when the mock was called."
msgstr ""
"Другая ситуация встречается редко, но может вас укусить — это когда ваш "
"макет вызывается с изменяемыми аргументами. ``call_args`` и "
"``call_args_list`` хранят *ссылки* на аргументы. Если аргументы изменяются "
"тестируемым кодом, вы больше не можете делать утверждения о том, какими были "
"значения при вызове макета."

#: ../../library/unittest.mock-examples.rst:833
msgid ""
"Here's some example code that shows the problem. Imagine the following "
"functions defined in 'mymodule'::"
msgstr ""
"Вот пример кода, который показывает проблему. Представьте себе следующие "
"функции, определенные в mymodule::"

#: ../../library/unittest.mock-examples.rst:836
msgid ""
"def frob(val):\n"
"    pass\n"
"\n"
"def grob(val):\n"
"    \"First frob and then clear val\"\n"
"    frob(val)\n"
"    val.clear()"
msgstr ""
"def frob(val):\n"
"    pass\n"
"\n"
"def grob(val):\n"
"    \"First frob and then clear val\"\n"
"    frob(val)\n"
"    val.clear()"

#: ../../library/unittest.mock-examples.rst:844
msgid ""
"When we try to test that ``grob`` calls ``frob`` with the correct argument "
"look what happens::"
msgstr ""
"Когда мы попытаемся проверить, что ``grob`` вызывает ``frob`` с правильным "
"аргументом, посмотрите, что происходит:"

#: ../../library/unittest.mock-examples.rst:847
msgid ""
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> val\n"
"set()\n"
">>> mock_frob.assert_called_with({6})\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AssertionError: Expected: (({6},), {})\n"
"Called with: ((set(),), {})"
msgstr ""
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> val\n"
"set()\n"
">>> mock_frob.assert_called_with({6})\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AssertionError: Expected: (({6},), {})\n"
"Called with: ((set(),), {})"

#: ../../library/unittest.mock-examples.rst:859
msgid ""
"One possibility would be for mock to copy the arguments you pass in. This "
"could then cause problems if you do assertions that rely on object identity "
"for equality."
msgstr ""
"Одной из возможностей может быть копирование переданных вами аргументов. Это "
"может вызвать проблемы, если вы выполняете утверждения, которые для "
"равенства полагаются на идентичность объекта."

#: ../../library/unittest.mock-examples.rst:863
msgid ""
"Here's one solution that uses the :attr:`~Mock.side_effect` functionality. "
"If you provide a ``side_effect`` function for a mock then ``side_effect`` "
"will be called with the same args as the mock. This gives us an opportunity "
"to copy the arguments and store them for later assertions. In this example "
"I'm using *another* mock to store the arguments so that I can use the mock "
"methods for doing the assertion. Again a helper function sets this up for "
"me. ::"
msgstr ""
"Вот одно решение, использующее функциональность :attr:`~Mock.side_effect`. "
"Если вы предоставите функцию Side_effect для макета, то Side_effect будет "
"вызываться с теми же аргументами, что и макет. Это дает нам возможность "
"скопировать аргументы и сохранить их для последующих утверждений. В этом "
"примере я использую *другой* макет для хранения аргументов, чтобы можно было "
"использовать методы макета для выполнения утверждения. Опять же, "
"вспомогательная функция устанавливает это для меня. ::"

#: ../../library/unittest.mock-examples.rst:871
msgid ""
">>> from copy import deepcopy\n"
">>> from unittest.mock import Mock, patch, DEFAULT\n"
">>> def copy_call_args(mock):\n"
"...     new_mock = Mock()\n"
"...     def side_effect(*args, **kwargs):\n"
"...         args = deepcopy(args)\n"
"...         kwargs = deepcopy(kwargs)\n"
"...         new_mock(*args, **kwargs)\n"
"...         return DEFAULT\n"
"...     mock.side_effect = side_effect\n"
"...     return new_mock\n"
"...\n"
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     new_mock = copy_call_args(mock_frob)\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> new_mock.assert_called_with({6})\n"
">>> new_mock.call_args\n"
"call({6})"
msgstr ""
">>> from copy import deepcopy\n"
">>> from unittest.mock import Mock, patch, DEFAULT\n"
">>> def copy_call_args(mock):\n"
"...     new_mock = Mock()\n"
"...     def side_effect(*args, **kwargs):\n"
"...         args = deepcopy(args)\n"
"...         kwargs = deepcopy(kwargs)\n"
"...         new_mock(*args, **kwargs)\n"
"...         return DEFAULT\n"
"...     mock.side_effect = side_effect\n"
"...     return new_mock\n"
"...\n"
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     new_mock = copy_call_args(mock_frob)\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> new_mock.assert_called_with({6})\n"
">>> new_mock.call_args\n"
"call({6})"

#: ../../library/unittest.mock-examples.rst:892
msgid ""
"``copy_call_args`` is called with the mock that will be called. It returns a "
"new mock that we do the assertion on. The ``side_effect`` function makes a "
"copy of the args and calls our ``new_mock`` with the copy."
msgstr ""
"``copy_call_args`` вызывается с макетом, который будет вызван. Он возвращает "
"новый макет, на котором мы делаем утверждение. Функция Side_effect создает "
"копию аргументов и вызывает наш new_mock с копией."

#: ../../library/unittest.mock-examples.rst:898
msgid ""
"If your mock is only going to be used once there is an easier way of "
"checking arguments at the point they are called. You can simply do the "
"checking inside a ``side_effect`` function."
msgstr ""
"Если ваш макет будет использоваться только один раз, есть более простой "
"способ проверки аргументов в момент их вызова. Вы можете просто выполнить "
"проверку внутри функции Side_effect."

#: ../../library/unittest.mock-examples.rst:912
msgid ""
"An alternative approach is to create a subclass of :class:`Mock` or :class:"
"`MagicMock` that copies (using :func:`copy.deepcopy`) the arguments. Here's "
"an example implementation:"
msgstr ""
"Альтернативный подход — создать подкласс :class:`Mock` или :class:"
"`MagicMock`, который копирует (с использованием :func:`copy.deepcopy`) "
"аргументы. Вот пример реализации:"

#: ../../library/unittest.mock-examples.rst:937
msgid ""
"When you subclass ``Mock`` or ``MagicMock`` all dynamically created "
"attributes, and the ``return_value`` will use your subclass automatically. "
"That means all children of a ``CopyingMock`` will also have the type "
"``CopyingMock``."
msgstr ""
"Когда вы создаете подкласс Mock или MagicMock, все динамически создаваемые "
"атрибуты и return_value будут автоматически использовать ваш подкласс. Это "
"означает, что все дочерние элементы CopyingMock также будут иметь тип "
"CopyingMock."

#: ../../library/unittest.mock-examples.rst:943
msgid "Nesting Patches"
msgstr "Вложение патчей"

#: ../../library/unittest.mock-examples.rst:945
msgid ""
"Using patch as a context manager is nice, but if you do multiple patches you "
"can end up with nested with statements indenting further and further to the "
"right::"
msgstr ""
"Использовать патч в качестве менеджера контекста — это хорошо, но если вы "
"сделаете несколько патчей, вы можете получить вложенные операторы, "
"отступающие все дальше и дальше вправо::"

#: ../../library/unittest.mock-examples.rst:949
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_foo(self):\n"
"...         with patch('mymodule.Foo') as mock_foo:\n"
"...             with patch('mymodule.Bar') as mock_bar:\n"
"...                 with patch('mymodule.Spam') as mock_spam:\n"
"...                     assert mymodule.Foo is mock_foo\n"
"...                     assert mymodule.Bar is mock_bar\n"
"...                     assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').test_foo()\n"
">>> assert mymodule.Foo is original"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_foo(self):\n"
"...         with patch('mymodule.Foo') as mock_foo:\n"
"...             with patch('mymodule.Bar') as mock_bar:\n"
"...                 with patch('mymodule.Spam') as mock_spam:\n"
"...                     assert mymodule.Foo is mock_foo\n"
"...                     assert mymodule.Bar is mock_bar\n"
"...                     assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').test_foo()\n"
">>> assert mymodule.Foo is original"

#: ../../library/unittest.mock-examples.rst:963
msgid ""
"With unittest ``cleanup`` functions and the :ref:`start-and-stop` we can "
"achieve the same effect without the nested indentation. A simple helper "
"method, ``create_patch``, puts the patch in place and returns the created "
"mock for us::"
msgstr ""
"С помощью функций очистки unittest и :ref:`start-and-stop` мы можем добиться "
"того же эффекта без вложенных отступов. Простой вспомогательный метод "
"create_patch устанавливает патч на место и возвращает нам созданный макет:"

#: ../../library/unittest.mock-examples.rst:968
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def create_patch(self, name):\n"
"...         patcher = patch(name)\n"
"...         thing = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...         return thing\n"
"...\n"
"...     def test_foo(self):\n"
"...         mock_foo = self.create_patch('mymodule.Foo')\n"
"...         mock_bar = self.create_patch('mymodule.Bar')\n"
"...         mock_spam = self.create_patch('mymodule.Spam')\n"
"...\n"
"...         assert mymodule.Foo is mock_foo\n"
"...         assert mymodule.Bar is mock_bar\n"
"...         assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').run()\n"
">>> assert mymodule.Foo is original"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def create_patch(self, name):\n"
"...         patcher = patch(name)\n"
"...         thing = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...         return thing\n"
"...\n"
"...     def test_foo(self):\n"
"...         mock_foo = self.create_patch('mymodule.Foo')\n"
"...         mock_bar = self.create_patch('mymodule.Bar')\n"
"...         mock_spam = self.create_patch('mymodule.Spam')\n"
"...\n"
"...         assert mymodule.Foo is mock_foo\n"
"...         assert mymodule.Bar is mock_bar\n"
"...         assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').run()\n"
">>> assert mymodule.Foo is original"

#: ../../library/unittest.mock-examples.rst:991
msgid "Mocking a dictionary with MagicMock"
msgstr "Издевательство над словарем с помощью MagicMock"

#: ../../library/unittest.mock-examples.rst:993
msgid ""
"You may want to mock a dictionary, or other container object, recording all "
"access to it whilst having it still behave like a dictionary."
msgstr ""
"Возможно, вы захотите имитировать словарь или другой объект-контейнер, "
"записывая весь доступ к нему, сохраняя при этом его поведение как словарь."

#: ../../library/unittest.mock-examples.rst:996
msgid ""
"We can do this with :class:`MagicMock`, which will behave like a dictionary, "
"and using :data:`~Mock.side_effect` to delegate dictionary access to a real "
"underlying dictionary that is under our control."
msgstr ""
"Мы можем сделать это с помощью :class:`MagicMock`, который будет вести себя "
"как словарь, и используя :data:`~Mock.side_effect` для делегирования доступа "
"к словарю реальному базовому словарю, который находится под нашим контролем."

#: ../../library/unittest.mock-examples.rst:1000
msgid ""
"When the :meth:`~object.__getitem__` and :meth:`~object.__setitem__` methods "
"of our ``MagicMock`` are called (normal dictionary access) then "
"``side_effect`` is called with the key (and in the case of ``__setitem__`` "
"the value too). We can also control what is returned."
msgstr ""
"Когда вызываются методы :meth:`~object.__getitem__` и :meth:`~object."
"__setitem__` нашего ``MagicMock`` (обычный доступ к словарю), тогда "
"``side_effect`` вызывается с ключом (и в в случае ``__setitem__`` значение "
"тоже). Мы также можем контролировать то, что возвращается."

#: ../../library/unittest.mock-examples.rst:1005
msgid ""
"After the ``MagicMock`` has been used we can use attributes like :data:"
"`~Mock.call_args_list` to assert about how the dictionary was used:"
msgstr ""
"После использования MagicMock мы можем использовать такие атрибуты, как :"
"data:`~Mock.call_args_list`, чтобы утверждать, как использовался словарь:"

#: ../../library/unittest.mock-examples.rst:1021
msgid ""
"An alternative to using ``MagicMock`` is to use ``Mock`` and *only* provide "
"the magic methods you specifically want:"
msgstr ""
"Альтернативой использованию MagicMock является использование Mock и *только* "
"предоставление тех магических методов, которые вам нужны:"

#: ../../library/unittest.mock-examples.rst:1028
msgid ""
"A *third* option is to use ``MagicMock`` but passing in ``dict`` as the "
"*spec* (or *spec_set*) argument so that the ``MagicMock`` created only has "
"dictionary magic methods available:"
msgstr ""
"Третий вариант — использовать MagicMock, но передав dict в качестве "
"аргумента *spec* (или *spec_set*), чтобы созданный MagicMock имел только "
"доступные словарные магические методы:"

#: ../../library/unittest.mock-examples.rst:1036
msgid ""
"With these side effect functions in place, the ``mock`` will behave like a "
"normal dictionary but recording the access. It even raises a :exc:`KeyError` "
"if you try to access a key that doesn't exist."
msgstr ""
"При наличии этих функций побочного эффекта ``mock`` будет вести себя как "
"обычный словарь, но записывает доступ. Он даже выдает ошибку :exc:"
"`KeyError`, если вы пытаетесь получить доступ к несуществующему ключу."

#: ../../library/unittest.mock-examples.rst:1055
msgid ""
"After it has been used you can make assertions about the access using the "
"normal mock methods and attributes:"
msgstr ""
"После его использования вы можете делать утверждения о доступе, используя "
"обычные фиктивные методы и атрибуты:"

#: ../../library/unittest.mock-examples.rst:1067
msgid "Mock subclasses and their attributes"
msgstr "Мокирующие подклассы и их атрибуты"

#: ../../library/unittest.mock-examples.rst:1069
msgid ""
"There are various reasons why you might want to subclass :class:`Mock`. One "
"reason might be to add helper methods. Here's a silly example:"
msgstr ""
"Существуют различные причины, по которым вы можете захотеть создать "
"подкласс :class:`Mock`. Одной из причин может быть добавление "
"вспомогательных методов. Вот глупый пример:"

#: ../../library/unittest.mock-examples.rst:1085
msgid ""
"The standard behaviour for ``Mock`` instances is that attributes and the "
"return value mocks are of the same type as the mock they are accessed on. "
"This ensures that ``Mock`` attributes are ``Mocks`` and ``MagicMock`` "
"attributes are ``MagicMocks`` [#]_. So if you're subclassing to add helper "
"methods then they'll also be available on the attributes and return value "
"mock of instances of your subclass."
msgstr ""
"Стандартное поведение экземпляров ``Mock`` заключается в том, что атрибуты и "
"макеты возвращаемого значения имеют тот же тип, что и макет, к которому они "
"обращаются. Это гарантирует, что атрибуты ``Mock`` будут ``Mocks``, а "
"``MagicMock`` будут ``MagicMocks``. [#]_ . Поэтому, если вы создаете "
"подкласс для добавления вспомогательных методов, они также будут доступны в "
"атрибутах и ​​макете возвращаемого значения экземпляров вашего подкласса."

#: ../../library/unittest.mock-examples.rst:1101
msgid ""
"Sometimes this is inconvenient. For example, `one user <https://code.google."
"com/archive/p/mock/issues/105>`_ is subclassing mock to created a `Twisted "
"adaptor <https://twisted.org/documents/11.0.0/api/twisted.python.components."
"html>`_. Having this applied to attributes too actually causes errors."
msgstr ""
"Иногда это неудобно. Например, `один пользователь <https://code.google.com/"
"archive/p/mock/issues/105>`_ создает подкласс подкласса для создания "
"`Twisted адаптера <https://twisted.org/documents/11.0 .0/api/twisted.python."
"comComponents.html>`_. Применение этого и к атрибутам фактически приводит к "
"ошибкам."

#: ../../library/unittest.mock-examples.rst:1107
msgid ""
"``Mock`` (in all its flavours) uses a method called ``_get_child_mock`` to "
"create these \"sub-mocks\" for attributes and return values. You can prevent "
"your subclass being used for attributes by overriding this method. The "
"signature is that it takes arbitrary keyword arguments (``**kwargs``) which "
"are then passed onto the mock constructor:"
msgstr ""
"``Mock`` (во всех его вариантах) использует метод под названием "
"``_get_child_mock`` для создания этих \"под-макетов\" для атрибутов и "
"возвращаемых значений. Вы можете запретить использование вашего подкласса "
"для атрибутов, переопределив этот метод. Сигнатура заключается в том, что он "
"принимает произвольные аргументы ключевого слова (``**kwargs``), которые "
"затем передаются в макетный конструктор:"

#: ../../library/unittest.mock-examples.rst:1124
msgid ""
"An exception to this rule are the non-callable mocks. Attributes use the "
"callable variant because otherwise non-callable mocks couldn't have callable "
"methods."
msgstr ""
"Исключением из этого правила являются невызываемые макеты. Атрибуты "
"используют вызываемый вариант, потому что в противном случае невызываемые "
"макеты не могли бы иметь вызываемые методы."

#: ../../library/unittest.mock-examples.rst:1130
msgid "Mocking imports with patch.dict"
msgstr "Имитирующий импорт с помощью patch.dict"

#: ../../library/unittest.mock-examples.rst:1132
msgid ""
"One situation where mocking can be hard is where you have a local import "
"inside a function. These are harder to mock because they aren't using an "
"object from the module namespace that we can patch out."
msgstr ""
"Одна из ситуаций, когда издевательство может быть трудным, — это локальный "
"импорт внутри функции. Их сложнее имитировать, поскольку они не используют "
"объект из пространства имен модуля, который мы можем исправить."

#: ../../library/unittest.mock-examples.rst:1136
msgid ""
"Generally local imports are to be avoided. They are sometimes done to "
"prevent circular dependencies, for which there is *usually* a much better "
"way to solve the problem (refactor the code) or to prevent \"up front "
"costs\" by delaying the import. This can also be solved in better ways than "
"an unconditional local import (store the module as a class or module "
"attribute and only do the import on first use)."
msgstr ""
"Обычно следует избегать местного импорта. Иногда это делается для "
"предотвращения циклических зависимостей, для которых *обычно* есть гораздо "
"лучший способ решить проблему (рефакторинг кода) или предотвратить "
"«предварительные затраты» путем задержки импорта. Эту проблему также можно "
"решить лучше, чем безусловный локальный импорт (сохраните модуль как атрибут "
"класса или модуля и выполняйте импорт только при первом использовании)."

#: ../../library/unittest.mock-examples.rst:1143
msgid ""
"That aside there is a way to use ``mock`` to affect the results of an "
"import. Importing fetches an *object* from the :data:`sys.modules` "
"dictionary. Note that it fetches an *object*, which need not be a module. "
"Importing a module for the first time results in a module object being put "
"in ``sys.modules``, so usually when you import something you get a module "
"back. This need not be the case however."
msgstr ""
"Помимо этого, есть способ использовать «mock», чтобы повлиять на результаты "
"импорта. При импорте извлекается *объект* из словаря :data:`sys.modules`. "
"Обратите внимание, что он извлекает *объект*, который не обязательно должен "
"быть модулем. Импорт модуля в первый раз приводит к тому, что объект модуля "
"помещается в ``sys.modules``, поэтому обычно, когда вы что-то импортируете, "
"вы получаете модуль обратно. Однако это не обязательно так."

#: ../../library/unittest.mock-examples.rst:1150
msgid ""
"This means you can use :func:`patch.dict` to *temporarily* put a mock in "
"place in :data:`sys.modules`. Any imports whilst this patch is active will "
"fetch the mock. When the patch is complete (the decorated function exits, "
"the with statement body is complete or ``patcher.stop()`` is called) then "
"whatever was there previously will be restored safely."
msgstr ""
"Это означает, что вы можете использовать :func:`patch.dict`, чтобы "
"*временно* разместить макет в :data:`sys.modules`. Любой импорт, пока этот "
"патч активен, приведет к получению макета. Когда исправление завершено "
"(завершается декорированная функция, тело оператора with завершено или "
"вызывается patcher.stop()), то все, что было ранее, будет безопасно "
"восстановлено."

#: ../../library/unittest.mock-examples.rst:1156
msgid "Here's an example that mocks out the 'fooble' module."
msgstr "Вот пример, который имитирует модуль «fooble»."

#: ../../library/unittest.mock-examples.rst:1168
msgid ""
"As you can see the ``import fooble`` succeeds, but on exit there is no "
"'fooble' left in :data:`sys.modules`."
msgstr ""
"Как вы можете видеть, импорт fooble завершился успешно, но при выходе в :"
"data:`sys.modules` не осталось никакого ``fooble''."

#: ../../library/unittest.mock-examples.rst:1171
msgid "This also works for the ``from module import name`` form:"
msgstr "Это также работает для формы ``from module import name`` form:"

#: ../../library/unittest.mock-examples.rst:1181
msgid "With slightly more work you can also mock package imports:"
msgstr "Немного поработав, вы также можете имитировать импорт пакетов:"

#: ../../library/unittest.mock-examples.rst:1194
msgid "Tracking order of calls and less verbose call assertions"
msgstr "Отслеживание порядка вызовов и менее подробные утверждения вызовов"

#: ../../library/unittest.mock-examples.rst:1196
msgid ""
"The :class:`Mock` class allows you to track the *order* of method calls on "
"your mock objects through the :attr:`~Mock.method_calls` attribute. This "
"doesn't allow you to track the order of calls between separate mock objects, "
"however we can use :attr:`~Mock.mock_calls` to achieve the same effect."
msgstr ""
"Класс :class:`Mock` позволяет вам отслеживать *порядок* вызовов методов "
"ваших макетных объектов через атрибут :attr:`~Mock.method_calls`. Это не "
"позволяет отслеживать порядок вызовов между отдельными макетными объектами, "
"однако мы можем использовать :attr:`~Mock.mock_calls` для достижения того же "
"эффекта."

#: ../../library/unittest.mock-examples.rst:1201
msgid ""
"Because mocks track calls to child mocks in ``mock_calls``, and accessing an "
"arbitrary attribute of a mock creates a child mock, we can create our "
"separate mocks from a parent one. Calls to those child mock will then all be "
"recorded, in order, in the ``mock_calls`` of the parent:"
msgstr ""
"Поскольку макеты отслеживают вызовы дочерних макетов в ``mock_calls``, а "
"доступ к произвольному атрибуту макета создает дочерний макет, мы можем "
"создавать отдельные макеты из родительского. Все вызовы этих дочерних "
"макетов будут по порядку записаны в ``mock_calls`` родительского объекта:"

#: ../../library/unittest.mock-examples.rst:1218
msgid ""
"We can then assert about the calls, including the order, by comparing with "
"the ``mock_calls`` attribute on the manager mock:"
msgstr ""
"Затем мы можем утверждать о вызовах, включая их порядок, путем сравнения с "
"атрибутом ``mock_calls`` в макете менеджера:"

#: ../../library/unittest.mock-examples.rst:1225
msgid ""
"If ``patch`` is creating, and putting in place, your mocks then you can "
"attach them to a manager mock using the :meth:`~Mock.attach_mock` method. "
"After attaching calls will be recorded in ``mock_calls`` of the manager. ::"
msgstr ""
"Если ``patch`` создает и размещает ваши макеты, вы можете прикрепить их к "
"макету менеджера, используя метод :meth:`~Mock.attach_mock`. После "
"прикрепления звонки будут записываться в ``mock_calls`` менеджера. ::"

#: ../../library/unittest.mock-examples.rst:1229
msgid ""
">>> manager = MagicMock()\n"
">>> with patch('mymodule.Class1') as MockClass1:\n"
"...     with patch('mymodule.Class2') as MockClass2:\n"
"...         manager.attach_mock(MockClass1, 'MockClass1')\n"
"...         manager.attach_mock(MockClass2, 'MockClass2')\n"
"...         MockClass1().foo()\n"
"...         MockClass2().bar()\n"
"<MagicMock name='mock.MockClass1().foo()' id='...'>\n"
"<MagicMock name='mock.MockClass2().bar()' id='...'>\n"
">>> manager.mock_calls\n"
"[call.MockClass1(),\n"
"call.MockClass1().foo(),\n"
"call.MockClass2(),\n"
"call.MockClass2().bar()]"
msgstr ""
">>> manager = MagicMock()\n"
">>> with patch('mymodule.Class1') as MockClass1:\n"
"...     with patch('mymodule.Class2') as MockClass2:\n"
"...         manager.attach_mock(MockClass1, 'MockClass1')\n"
"...         manager.attach_mock(MockClass2, 'MockClass2')\n"
"...         MockClass1().foo()\n"
"...         MockClass2().bar()\n"
"<MagicMock name='mock.MockClass1().foo()' id='...'>\n"
"<MagicMock name='mock.MockClass2().bar()' id='...'>\n"
">>> manager.mock_calls\n"
"[call.MockClass1(),\n"
"call.MockClass1().foo(),\n"
"call.MockClass2(),\n"
"call.MockClass2().bar()]"

#: ../../library/unittest.mock-examples.rst:1244
msgid ""
"If many calls have been made, but you're only interested in a particular "
"sequence of them then an alternative is to use the :meth:`~Mock."
"assert_has_calls` method. This takes a list of calls (constructed with the :"
"data:`call` object). If that sequence of calls are in :attr:`~Mock."
"mock_calls` then the assert succeeds."
msgstr ""
"Если было сделано много вызовов, но вас интересует только определенная их "
"последовательность, альтернативой является использование метода :meth:`~Mock."
"assert_has_calls`. Для этого требуется список вызовов (созданный с помощью "
"объекта :data:`call`). Если эта последовательность вызовов находится в :attr:"
"`~Mock.mock_calls`, тогда утверждение будет успешным."

#: ../../library/unittest.mock-examples.rst:1258
msgid ""
"Even though the chained call ``m.one().two().three()`` aren't the only calls "
"that have been made to the mock, the assert still succeeds."
msgstr ""
"Несмотря на то, что связанный вызов m.one().two().three() — не единственные "
"вызовы, которые были сделаны для макета, утверждение все равно завершается "
"успешно."

#: ../../library/unittest.mock-examples.rst:1261
msgid ""
"Sometimes a mock may have several calls made to it, and you are only "
"interested in asserting about *some* of those calls. You may not even care "
"about the order. In this case you can pass ``any_order=True`` to "
"``assert_has_calls``:"
msgstr ""
"Иногда к макету может быть сделано несколько вызовов, и вас интересует "
"только утверждение о *некоторых* из этих вызовов. Возможно, вас даже не "
"волнует порядок. В этом случае вы можете передать ``any_order=True`` в "
"``assert_has_calls``:"

#: ../../library/unittest.mock-examples.rst:1273
msgid "More complex argument matching"
msgstr "Более сложное сопоставление аргументов"

#: ../../library/unittest.mock-examples.rst:1275
msgid ""
"Using the same basic concept as :data:`ANY` we can implement matchers to do "
"more complex assertions on objects used as arguments to mocks."
msgstr ""
"Используя ту же базовую концепцию, что и :data:`ANY`, мы можем реализовать "
"сопоставители для выполнения более сложных утверждений для объектов, "
"используемых в качестве аргументов для макетов."

#: ../../library/unittest.mock-examples.rst:1278
msgid ""
"Suppose we expect some object to be passed to a mock that by default "
"compares equal based on object identity (which is the Python default for "
"user defined classes). To use :meth:`~Mock.assert_called_with` we would need "
"to pass in the exact same object. If we are only interested in some of the "
"attributes of this object then we can create a matcher that will check these "
"attributes for us."
msgstr ""
"Предположим, мы ожидаем, что некоторый объект будет передан в макет, который "
"по умолчанию сравнивает равные на основе идентичности объекта (что является "
"стандартом Python по умолчанию для пользовательских классов). Чтобы "
"использовать :meth:`~Mock.assert_known_with`, нам нужно будет передать тот "
"же самый объект. Если нас интересуют только некоторые атрибуты этого "
"объекта, мы можем создать средство сопоставления, которое будет проверять "
"эти атрибуты за нас."

#: ../../library/unittest.mock-examples.rst:1285
msgid ""
"You can see in this example how a 'standard' call to ``assert_called_with`` "
"isn't sufficient:"
msgstr ""
"В этом примере вы можете видеть, что «стандартного» вызова "
"``assert_called_with`` недостаточно:"

#: ../../library/unittest.mock-examples.rst:1301
msgid ""
"A comparison function for our ``Foo`` class might look something like this:"
msgstr "Функция сравнения для нашего класса Foo может выглядеть примерно так:"

#: ../../library/unittest.mock-examples.rst:1313
msgid ""
"And a matcher object that can use comparison functions like this for its "
"equality operation would look something like this:"
msgstr ""
"И объект сопоставления, который может использовать подобные функции "
"сравнения для операции равенства, будет выглядеть примерно так:"

#: ../../library/unittest.mock-examples.rst:1324
msgid "Putting all this together:"
msgstr "Собираем все это вместе:"

#: ../../library/unittest.mock-examples.rst:1329
msgid ""
"The ``Matcher`` is instantiated with our compare function and the ``Foo`` "
"object we want to compare against. In ``assert_called_with`` the ``Matcher`` "
"equality method will be called, which compares the object the mock was "
"called with against the one we created our matcher with. If they match then "
"``assert_called_with`` passes, and if they don't an :exc:`AssertionError` is "
"raised:"
msgstr ""
"Экземпляр ``Matcher`` создается с помощью нашей функции сравнения и объекта "
"``Foo``, с которым мы хотим сравнить. В ``assert_called_with`` будет вызван "
"метод равенства ``Matcher``, который сравнивает объект, с которым был вызван "
"макет, с тем, с которым мы создали наш сопоставитель. Если они совпадают, то "
"``assert_called_with`` проходит, а если нет, то возникает :exc:"
"`AssertionError`:"

#: ../../library/unittest.mock-examples.rst:1342
msgid ""
"With a bit of tweaking you could have the comparison function raise the :exc:"
"`AssertionError` directly and provide a more useful failure message."
msgstr ""
"После небольшой настройки вы могли бы заставить функцию сравнения напрямую "
"вызывать :exc:`AssertionError` и выдавать более полезное сообщение об ошибке."

#: ../../library/unittest.mock-examples.rst:1345
msgid ""
"As of version 1.5, the Python testing library `PyHamcrest <https://"
"pyhamcrest.readthedocs.io/>`_ provides similar functionality, that may be "
"useful here, in the form of its equality matcher (`hamcrest.library."
"integration.match_equality <https://pyhamcrest.readthedocs.io/en/release-1.8/"
"integration/#module-hamcrest.library.integration.match_equality>`_)."
msgstr ""
"Начиная с версии 1.5, библиотека тестирования Python `PyHamcrest <https://"
"pyhamcrest.readthedocs.io/>`_ предоставляет аналогичную функциональность, "
"которая может быть здесь полезна, в форме средства сопоставления равенства "
"(`hamcrest.library.integration. match_equality <https://pyhamcrest."
"readthedocs.io/en/release-1.8/integration/#module-hamcrest.library."
"integration.match_equality>`_)."
