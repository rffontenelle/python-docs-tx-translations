# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Kristina Mironova, 2021
# decorator_factory <decorator-factory+transifex@yandex.ru>, 2021
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "Транспортировка и протоколы"

#: ../../library/asyncio-protocol.rst:12
msgid "Preface"
msgstr "Введение"

#: ../../library/asyncio-protocol.rst:13
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"Транспорты и протоколы используются API-интерфейсами **низкоуровневого** "
"цикла событий, такими как :meth:`loop.create_connection`. Они используют "
"стиль программирования на основе обратного вызова и обеспечивают "
"высокопроизводительную реализацию сетевых протоколов или протоколов IPC "
"(например, HTTP)."

#: ../../library/asyncio-protocol.rst:18
msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr ""
"По сути, транспорты и протоколы следует использовать только в библиотеках и "
"платформах, а не в асинхронных приложениях высокого уровня."

#: ../../library/asyncio-protocol.rst:22
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr ""
"На этой странице документации описаны как «Транспорты», так и «Протоколы»."

#: ../../library/asyncio-protocol.rst:25
msgid "Introduction"
msgstr "Введение"

#: ../../library/asyncio-protocol.rst:26
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr ""
"На самом высоком уровне транспорт занимается тем, *как* передаются байты, в "
"то время как протокол определяет *какие* байты передавать (и, в некоторой "
"степени, когда)."

#: ../../library/asyncio-protocol.rst:30
msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr ""
"Другой способ сказать то же самое: транспорт — это абстракция для сокета "
"(или аналогичной конечной точки ввода-вывода), тогда как протокол — это "
"абстракция для приложения с точки зрения транспорта."

#: ../../library/asyncio-protocol.rst:35
msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr ""
"Еще одна точка зрения заключается в том, что транспортный и протокольный "
"интерфейсы вместе определяют абстрактный интерфейс для использования "
"сетевого ввода-вывода и межпроцессного ввода-вывода."

#: ../../library/asyncio-protocol.rst:39
msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr ""
"Между объектами транспорта и протокола всегда существует соотношение 1:1: "
"протокол вызывает методы транспорта для отправки данных, а транспорт "
"вызывает методы протокола для передачи полученных данных."

#: ../../library/asyncio-protocol.rst:44
msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"Большинство методов цикла событий, ориентированных на соединение (таких как :"
"meth:`loop.create_connection`), обычно принимают аргумент "
"*protocol_factory*, используемый для создания объекта *Protocol* для "
"принятого соединения, представленного объектом *Transport*. Такие методы "
"обычно возвращают кортеж ``(транспорт, протокол)``."

#: ../../library/asyncio-protocol.rst:51
msgid "Contents"
msgstr " Содержание"

#: ../../library/asyncio-protocol.rst:52
msgid "This documentation page contains the following sections:"
msgstr "Эта страница документации содержит следующие разделы:"

#: ../../library/asyncio-protocol.rst:54
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"В разделе `Transports`_ документируются классы asyncio :class:"
"`BaseTransport`, :class:`ReadTransport`, :class:`WriteTransport`, :class:"
"`Transport`, :class:`DatagramTransport`, и :class:`SubprocessTransport`."

#: ../../library/asyncio-protocol.rst:59
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"В разделе `Protocols`_ документируются классы asyncio :class:"
"`BaseProtocol`, :class:`Protocol`, :class:`BufferedProtocol`, :class:"
"`DatagramProtocol`, и :class:`SubprocessProtocol`."

#: ../../library/asyncio-protocol.rst:63
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr ""
"В разделе `Examples`_ показано, как работать с транспортом, протоколами и "
"низкоуровневыми API цикла обработки событий."

#: ../../library/asyncio-protocol.rst:70
msgid "Transports"
msgstr "Транспорт"

#: ../../library/asyncio-protocol.rst:72
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**Исходный код:** :source:`Lib/asyncio/transports.py`"

#: ../../library/asyncio-protocol.rst:76
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr ""
"Транспорты — это классы, предоставляемые :mod:`asyncio` для абстрагирования "
"различных видов каналов связи."

#: ../../library/asyncio-protocol.rst:79
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"Транспортные объекты всегда создаются с помощью цикла событий asyncio "
"<asyncio-event-loop>`."

#: ../../library/asyncio-protocol.rst:82
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr ""
"asyncio реализует транспорт для TCP, UDP, SSL и каналов подпроцессов. "
"Методы, доступные на транспорте, зависят от типа транспорта."

#: ../../library/asyncio-protocol.rst:85
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr "Транспортные классы :ref:`не потокобезопасны <asyncio-multhreading>`."

#: ../../library/asyncio-protocol.rst:89
msgid "Transports Hierarchy"
msgstr "Иерархия транспорта"

#: ../../library/asyncio-protocol.rst:93
msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr ""
"Базовый класс для всех видов транспорта. Содержит методы, которые "
"используются всеми транспортами asyncio."

#: ../../library/asyncio-protocol.rst:98
msgid "A base transport for write-only connections."
msgstr "Базовый транспорт для соединений только для записи."

#: ../../library/asyncio-protocol.rst:100
msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Экземпляры класса *WriteTransport* возвращаются из метода цикла событий :"
"meth:`loop.connect_write_pipe`, а также используются методами, связанными с "
"подпроцессами, такими как :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:107
msgid "A base transport for read-only connections."
msgstr "Базовый транспорт для соединений только для чтения."

#: ../../library/asyncio-protocol.rst:109
msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Экземпляры класса *ReadTransport* возвращаются из метода цикла событий :meth:"
"`loop.connect_read_pipe`, а также используются методами, связанными с "
"подпроцессами, такими как :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:116
msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr ""
"Интерфейс, представляющий двунаправленный транспорт, например TCP-соединение."

#: ../../library/asyncio-protocol.rst:119
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr ""
"Пользователь не создает экземпляр транспорта напрямую; они вызывают "
"вспомогательную функцию, передавая ей фабрику протоколов и другую "
"информацию, необходимую для создания транспорта и протокола."

#: ../../library/asyncio-protocol.rst:123
msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"Экземпляры класса *Transport* возвращаются или используются методами цикла "
"событий, такими как :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop. sendfile` "
"и т. д."

#: ../../library/asyncio-protocol.rst:131
msgid "A transport for datagram (UDP) connections."
msgstr "Транспорт для дейтаграммных (UDP) соединений."

#: ../../library/asyncio-protocol.rst:133
msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"Экземпляры класса *DatagramTransport* возвращаются из метода цикла событий :"
"meth:`loop.create_datagram_endpoint`."

#: ../../library/asyncio-protocol.rst:139
msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr ""
"Абстракция, представляющая связь между родительским и дочерним процессами ОС."

#: ../../library/asyncio-protocol.rst:142
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"Экземпляры класса *SubprocessTransport* возвращаются из методов цикла "
"событий :meth:`loop.subprocess_shell` и :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:148
msgid "Base Transport"
msgstr "Базовый транспорт"

#: ../../library/asyncio-protocol.rst:152
msgid "Close the transport."
msgstr "Закройте транспорт."

#: ../../library/asyncio-protocol.rst:154
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument. The transport should not be used once it is closed."
msgstr ""
"Если транспорт имеет буфер для исходящих данных, буферизованные данные будут "
"сброшены асинхронно. Больше никаких данных получено не будет. После того, "
"как все буферизованные данные будут очищены, будет вызван метод протокола :"
"meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` с :const:"
"`None` в качестве аргумента. Транспорт не следует использовать, если он "
"закрыт."

#: ../../library/asyncio-protocol.rst:164
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "Верните True, если транспорт закрывается или закрыт."

#: ../../library/asyncio-protocol.rst:168
msgid "Return information about the transport or underlying resources it uses."
msgstr ""
"Возвращает информацию о транспорте или базовых ресурсах, которые он "
"использует."

#: ../../library/asyncio-protocol.rst:171
msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr ""
"*имя* — это строка, представляющая часть информации, относящейся к "
"транспорту, которую необходимо получить."

#: ../../library/asyncio-protocol.rst:174
msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr ""
"*default* — это значение, возвращаемое, если информация недоступна или если "
"транспорт не поддерживает ее запрос с помощью данной сторонней реализации "
"цикла событий или на текущей платформе."

#: ../../library/asyncio-protocol.rst:179
msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr ""
"Например, следующий код пытается получить базовый объект сокета транспорта:"

#: ../../library/asyncio-protocol.rst:182
msgid ""
"sock = transport.get_extra_info('socket')\n"
"if sock is not None:\n"
"    print(sock.getsockopt(...))"
msgstr ""
"sock = transport.get_extra_info('socket')\n"
"if sock is not None:\n"
"    print(sock.getsockopt(...))"

#: ../../library/asyncio-protocol.rst:186
msgid "Categories of information that can be queried on some transports:"
msgstr ""
"Категории информации, которую можно запросить на некоторых транспортах:"

#: ../../library/asyncio-protocol.rst:188
msgid "socket:"
msgstr "сокет:"

#: ../../library/asyncio-protocol.rst:190
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: удаленный адрес, к которому подключен сокет, результат :meth:"
"`socket.socket.getpeername` (``None`` в случае ошибки)"

#: ../../library/asyncio-protocol.rst:194
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: экземпляр :class:`socket.socket`"

#: ../../library/asyncio-protocol.rst:196
msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""
"``'sockname'``: собственный адрес сокета, результат :meth:`socket.socket."
"getsockname`"

#: ../../library/asyncio-protocol.rst:199
msgid "SSL socket:"
msgstr "SSL сокет:"

#: ../../library/asyncio-protocol.rst:201
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'сжатие'``: алгоритм сжатия, используемый как строка, или ``Нет``, если "
"соединение не сжимается; результат :meth:`ssl.SSLSocket.compression`"

#: ../../library/asyncio-protocol.rst:205
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: кортеж из трех значений, содержащий имя используемого шифра, "
"версию протокола SSL, определяющую его использование, и количество "
"используемых секретных битов; результат :meth:`ssl.SSLSocket.cipher`"

#: ../../library/asyncio-protocol.rst:210
msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""
"``'peercert'``: одноранговый сертификат; результат :meth:`ssl.SSLSocket."
"getpeercert`"

#: ../../library/asyncio-protocol.rst:213
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: экземпляр :class:`ssl.SSLContext`"

#: ../../library/asyncio-protocol.rst:215
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'``: :class:`ssl.SSLObject` или экземпляр :class:`ssl.SSLSocket`"

#: ../../library/asyncio-protocol.rst:218
msgid "pipe:"
msgstr "канал:"

#: ../../library/asyncio-protocol.rst:220
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: объект канала"

#: ../../library/asyncio-protocol.rst:222
msgid "subprocess:"
msgstr "подпроцесс"

#: ../../library/asyncio-protocol.rst:224
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: экземпляр :class:`subprocess.Popen`"

#: ../../library/asyncio-protocol.rst:228
msgid "Set a new protocol."
msgstr "Установите новый протокол."

#: ../../library/asyncio-protocol.rst:230
msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr ""
"Переключение протокола следует выполнять только в том случае, если оба "
"протокола документированы для поддержки переключения."

#: ../../library/asyncio-protocol.rst:235
msgid "Return the current protocol."
msgstr "Вернуть текущий протокол."

#: ../../library/asyncio-protocol.rst:239
msgid "Read-only Transports"
msgstr "Транспорты, доступные только для чтения"

#: ../../library/asyncio-protocol.rst:243
msgid "Return ``True`` if the transport is receiving new data."
msgstr "Верните True, если транспорт получает новые данные."

#: ../../library/asyncio-protocol.rst:249
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"Приостановите принимающую сторону транспорта. Никакие данные не будут "
"передаваться в метод протокола :meth:`protocol.data_received() <Protocol."
"data_received>` до тех пор, пока не будет вызван :meth:`resume_reading`."

#: ../../library/asyncio-protocol.rst:253
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""
"Метод идемпотентен, т.е. его можно вызвать, когда транспорт уже "
"приостановлен или закрыт."

#: ../../library/asyncio-protocol.rst:259
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"Возобновите приемную сторону. Метод протокола :meth:`protocol."
"data_received() <Protocol.data_received>` будет вызываться еще раз, если "
"некоторые данные доступны для чтения."

#: ../../library/asyncio-protocol.rst:263
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""
"Метод идемпотентный, т.е. его можно вызвать, когда транспорт уже читает."

#: ../../library/asyncio-protocol.rst:269
msgid "Write-only Transports"
msgstr "Транспорты только для записи"

#: ../../library/asyncio-protocol.rst:273
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Закройте транспорт немедленно, не дожидаясь завершения ожидающих операций. "
"Буферизованные данные будут потеряны. Больше никаких данных получено не "
"будет. Метод протокола :meth:`protocol.connection_lost() <BaseProtocol."
"connection_lost>` в конечном итоге будет вызван с :const:`None` в качестве "
"аргумента."

#: ../../library/asyncio-protocol.rst:281
msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"Верните :const:`True`, если транспорт поддерживает :meth:`~WriteTransport."
"write_eof`, :const:`False` если нет."

#: ../../library/asyncio-protocol.rst:286
msgid "Return the current size of the output buffer used by the transport."
msgstr "Возвращает текущий размер выходного буфера, используемого транспортом."

#: ../../library/asyncio-protocol.rst:290
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"Получите водяные знаки *high* и *low* для управления потоком записи. "
"Возвращает кортеж ``(low, high)``, где *low* и *high* — положительное "
"количество байтов."

#: ../../library/asyncio-protocol.rst:294
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr ""
"Используйте :meth:`set_write_buffer_limits`, чтобы установить ограничения."

#: ../../library/asyncio-protocol.rst:300
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr "Установите водяные знаки *high* и *low* для управления потоком записи."

#: ../../library/asyncio-protocol.rst:302
msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"Эти два значения (измеренные в количестве байтов) управляют моментом вызова "
"методов протокола :meth:`protocol.pause_writing() <BaseProtocol."
"pause_writing>` и :meth:`protocol.resume_writing() <BaseProtocol."
"resume_writing>`. Если указано, нижний водяной знак должен быть меньше или "
"равен верхнему водяному знаку. Ни *высокое*, ни *низкое* не могут быть "
"отрицательными."

#: ../../library/asyncio-protocol.rst:310
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` вызывается, когда размер буфера "
"становится больше или равен значению *high*. Если запись была "
"приостановлена, :meth:`~BaseProtocol.resume_writing` вызывается, когда "
"размер буфера становится меньше или равен значению *low*."

#: ../../library/asyncio-protocol.rst:315
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"Значения по умолчанию зависят от реализации. Если указан только верхний "
"водяной знак, нижний водяной знак по умолчанию принимает значение, зависящее "
"от реализации, меньшее или равное верхнему водяному знаку. Установка *high* "
"в ноль приводит к тому, что *low* также становится равным нулю и вызывает "
"вызов :meth:`~BaseProtocol.pause_writing` всякий раз, когда буфер становится "
"непустым. Установка *low* в ноль приводит к тому, что :meth:`~BaseProtocol."
"resume_writing` будет вызываться только тогда, когда буфер пуст. "
"Использование нуля для любого ограничения обычно неоптимально, поскольку "
"уменьшает возможности одновременного выполнения ввода-вывода и вычислений."

#: ../../library/asyncio-protocol.rst:326
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr ""
"Используйте :meth:`~WriteTransport.get_write_buffer_limits`, чтобы получить "
"ограничения."

#: ../../library/asyncio-protocol.rst:331
msgid "Write some *data* bytes to the transport."
msgstr "Запишите несколько байтов *данных* в транспорт."

#: ../../library/asyncio-protocol.rst:333
#: ../../library/asyncio-protocol.rst:362
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""
"Этот метод не блокирует; он буферизует данные и организует их асинхронную "
"отправку."

#: ../../library/asyncio-protocol.rst:338
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"Запишите список (или любой итерируемый) байтов данных в транспорт. Это "
"функционально эквивалентно вызову :meth:`write` для каждого элемента, "
"полученного в результате итерации, но может быть реализовано более "
"эффективно."

#: ../../library/asyncio-protocol.rst:345
msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr ""
"Закройте конец записи транспорта после очистки всех буферизованных данных. "
"Данные все еще могут быть получены."

#: ../../library/asyncio-protocol.rst:348
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr ""
"Этот метод может вызвать ошибку :exc:`NotImplementedError`, если транспорт "
"(например, SSL) не поддерживает полузакрытые соединения."

#: ../../library/asyncio-protocol.rst:353
msgid "Datagram Transports"
msgstr "Транспортировка датаграмм"

#: ../../library/asyncio-protocol.rst:357
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"Отправьте байты *данных* удаленному узлу, заданному *addr* (целевой адрес, "
"зависящий от транспорта). Если *addr* имеет значение :const:`None`, данные "
"отправляются на целевой адрес, указанный при создании транспорта."

#: ../../library/asyncio-protocol.rst:365
msgid ""
"This method can be called with an empty bytes object to send a zero-length "
"datagram. The buffer size calculation used for flow control is also updated "
"to account for the datagram header."
msgstr ""
"Этот метод можно вызвать с объектом пустых байтов для отправки датаграммы "
"нулевой длины. Расчет размера буфера, используемый для управления потоком, "
"также обновляется с учетом заголовка дейтаграммы."

#: ../../library/asyncio-protocol.rst:372
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Закройте транспорт немедленно, не дожидаясь завершения ожидающих операций. "
"Буферизованные данные будут потеряны. Больше никаких данных получено не "
"будет. Метод протокола :meth:`protocol.connection_lost() <BaseProtocol."
"connection_lost>` в конечном итоге будет вызван с :const:`None` в качестве "
"аргумента."

#: ../../library/asyncio-protocol.rst:382
msgid "Subprocess Transports"
msgstr "Транспорты подпроцессов"

#: ../../library/asyncio-protocol.rst:386
msgid "Return the subprocess process id as an integer."
msgstr "Верните идентификатор процесса подпроцесса в виде целого числа."

#: ../../library/asyncio-protocol.rst:390
msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""
"Возвращает транспорт для канала связи, соответствующий целочисленному "
"файловому дескриптору *fd*:"

#: ../../library/asyncio-protocol.rst:393
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``: читаемый потоковый транспорт стандартного ввода (*stdin*) или :const:"
"`None`, если подпроцесс не был создан с ``stdin=PIPE``"

#: ../../library/asyncio-protocol.rst:395
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``: записываемый потоковый транспорт стандартного вывода (*stdout*) или :"
"const:`None`, если подпроцесс не был создан с ``stdout=PIPE``"

#: ../../library/asyncio-protocol.rst:397
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2``: записываемый потоковый транспорт стандартной ошибки (*stderr*) или :"
"const:`None`, если подпроцесс не был создан с ``stderr=PIPE``"

#: ../../library/asyncio-protocol.rst:399
msgid "other *fd*: :const:`None`"
msgstr "другой *fd*: :const:`None`"

#: ../../library/asyncio-protocol.rst:403
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr ""
"Верните код возврата подпроцесса в виде целого числа или :const:`None`, если "
"он не вернулся, что аналогично атрибуту :attr:`subprocess.Popen.returncode`."

#: ../../library/asyncio-protocol.rst:409
msgid "Kill the subprocess."
msgstr "Убейте подпроцесс."

#: ../../library/asyncio-protocol.rst:411
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"В системах POSIX функция отправляет SIGKILL подпроцессу. В Windows этот "
"метод является псевдонимом :meth:`terminate`."

#: ../../library/asyncio-protocol.rst:414
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "См. также :meth:`subprocess.Popen.kill`."

#: ../../library/asyncio-protocol.rst:418
msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""
"Отправьте номер *сигнала* в подпроцесс, как в :meth:`subprocess.Popen."
"send_signal`."

#: ../../library/asyncio-protocol.rst:423
msgid "Stop the subprocess."
msgstr "Остановите подпроцесс."

#: ../../library/asyncio-protocol.rst:425
msgid ""
"On POSIX systems, this method sends :py:const:`~signal.SIGTERM` to the "
"subprocess. On Windows, the Windows API function :c:func:`!TerminateProcess` "
"is called to stop the subprocess."
msgstr ""
"В системах POSIX этот метод отправляет :py:const:`~signal.SIGTERM` в "
"подпроцесс. В Windows функция Windows API :c:func:`!TerminateProcess` "
"вызывается для остановки подпроцесса."

#: ../../library/asyncio-protocol.rst:429
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "См. также :meth:`subprocess.Popen.terminate`."

#: ../../library/asyncio-protocol.rst:433
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "Завершите подпроцесс, вызвав метод :meth:`kill`."

#: ../../library/asyncio-protocol.rst:435
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr ""
"Если подпроцесс еще не вернулся, закройте транспорты каналов *stdin*, "
"*stdout* и *stderr*."

#: ../../library/asyncio-protocol.rst:442
msgid "Protocols"
msgstr "Протоколы"

#: ../../library/asyncio-protocol.rst:444
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**Исходный код:** :source:`Lib/asyncio/protocols.py`"

#: ../../library/asyncio-protocol.rst:448
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio предоставляет набор абстрактных базовых классов, которые следует "
"использовать для реализации сетевых протоколов. Эти классы предназначены для "
"использования вместе с :ref:`transports <asyncio-transport>`."

#: ../../library/asyncio-protocol.rst:452
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"Подклассы абстрактных классов базового протокола могут реализовывать "
"некоторые или все методы. Все эти методы являются обратными вызовами: они "
"вызываются транспортами при определенных событиях, например при получении "
"каких-то данных. Метод базового протокола должен вызываться соответствующим "
"транспортом."

#: ../../library/asyncio-protocol.rst:459
msgid "Base Protocols"
msgstr "Базовые протоколы"

#: ../../library/asyncio-protocol.rst:463
msgid "Base protocol with methods that all protocols share."
msgstr "Базовый протокол с методами, общими для всех протоколов."

#: ../../library/asyncio-protocol.rst:467
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr ""
"Базовый класс для реализации протоколов потоковой передачи (TCP, сокеты Unix "
"и т. д.)."

#: ../../library/asyncio-protocol.rst:472
msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr ""
"Базовый класс для реализации протоколов потоковой передачи с ручным "
"управлением буфером приема."

#: ../../library/asyncio-protocol.rst:477
msgid "The base class for implementing datagram (UDP) protocols."
msgstr "Базовый класс для реализации протоколов датаграмм (UDP)."

#: ../../library/asyncio-protocol.rst:481
msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr ""
"Базовый класс для реализации протоколов взаимодействия с дочерними "
"процессами (однонаправленные каналы)."

#: ../../library/asyncio-protocol.rst:486
msgid "Base Protocol"
msgstr "Базовый протокол"

#: ../../library/asyncio-protocol.rst:488
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr ""
"Все протоколы asyncio могут реализовывать обратные вызовы базового протокола."

#: ../../library/asyncio-protocol.rst:491
msgid "Connection Callbacks"
msgstr "Обратные вызовы соединения"

#: ../../library/asyncio-protocol.rst:492
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"Обратные вызовы соединения вызываются для всех протоколов ровно один раз за "
"успешное соединение. Все остальные обратные вызовы протокола могут "
"вызываться только между этими двумя методами."

#: ../../library/asyncio-protocol.rst:498
msgid "Called when a connection is made."
msgstr "Вызывается при установлении соединения."

#: ../../library/asyncio-protocol.rst:500
msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr ""
"Аргумент *transport* — это транспорт, представляющий соединение. Протокол "
"отвечает за хранение ссылки на свой транспорт."

#: ../../library/asyncio-protocol.rst:506
msgid "Called when the connection is lost or closed."
msgstr "Вызывается, когда соединение потеряно или закрыто."

#: ../../library/asyncio-protocol.rst:508
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"Аргументом является либо объект исключения, либо :const:`None`. Последнее "
"означает, что получен обычный EOF или соединение было прервано или закрыто "
"на этой стороне соединения."

#: ../../library/asyncio-protocol.rst:514
msgid "Flow Control Callbacks"
msgstr "Обратные вызовы управления потоком"

#: ../../library/asyncio-protocol.rst:515
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr ""
"Обратные вызовы управления потоком могут вызываться транспортами для "
"приостановки или возобновления записи, выполняемой протоколом."

#: ../../library/asyncio-protocol.rst:518
msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr ""
"Дополнительную информацию см. в документации метода :meth:`~WriteTransport."
"set_write_buffer_limits`."

#: ../../library/asyncio-protocol.rst:523
msgid "Called when the transport's buffer goes over the high watermark."
msgstr "Вызывается, когда буфер транспорта превышает верхнюю границу."

#: ../../library/asyncio-protocol.rst:527
msgid "Called when the transport's buffer drains below the low watermark."
msgstr "Вызывается, когда буфер транспорта опустошается ниже нижнего уровня."

#: ../../library/asyncio-protocol.rst:529
msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr ""
"Если размер буфера равен верхнему уровню, :meth:`~BaseProtocol."
"pause_writing` не вызывается: размер буфера должен строго превышаться."

#: ../../library/asyncio-protocol.rst:533
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"И наоборот, :meth:`~BaseProtocol.resume_writing` вызывается, когда размер "
"буфера равен или меньше нижнего водяного знака. Эти конечные условия важны "
"для обеспечения того, чтобы все шло так, как ожидалось, когда любая отметка "
"равна нулю."

#: ../../library/asyncio-protocol.rst:540
msgid "Streaming Protocols"
msgstr "Потоковые протоколы"

#: ../../library/asyncio-protocol.rst:542
msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
"Методы событий, такие как :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe` и :meth:`loop.connect_write_pipe` принимают фабрики, "
"которые возвращают протоколы потоковой передачи."

#: ../../library/asyncio-protocol.rst:550
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""
"Вызывается при получении некоторых данных. *data* — это непустой байтовый "
"объект, содержащий входящие данные."

#: ../../library/asyncio-protocol.rst:553
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr ""
"Будут ли данные буферизованы, фрагментированы или повторно собраны, зависит "
"от транспорта. В общем, вам не следует полагаться на конкретную семантику, а "
"вместо этого сделайте свой синтаксический анализ универсальным и гибким. "
"Однако данные всегда принимаются в правильном порядке."

#: ../../library/asyncio-protocol.rst:558
msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr ""
"Метод можно вызывать произвольное количество раз, пока соединение открыто."

#: ../../library/asyncio-protocol.rst:561
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once ``eof_received()`` is called, ``data_received()`` is not "
"called anymore."
msgstr ""
"Однако :meth:`protocol.eof_received() <Protocol.eof_received>` вызывается не "
"более одного раза. После вызова eof_received() data_received() больше не "
"вызывается."

#: ../../library/asyncio-protocol.rst:567
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"Вызывается, когда другой конец сигнализирует, что он больше не будет "
"отправлять данные (например, путем вызова :meth:`transport.write_eof() "
"<WriteTransport.write_eof>`, если другой конец также использует asyncio)."

#: ../../library/asyncio-protocol.rst:572
msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"Этот метод может возвращать ложное значение (включая None), и в этом случае "
"транспорт закроется сам. И наоборот, если этот метод возвращает истинное "
"значение, используемый протокол определяет, следует ли закрывать транспорт. "
"Поскольку реализация по умолчанию возвращает None, она неявно закрывает "
"соединение."

#: ../../library/asyncio-protocol.rst:578
msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr ""
"Некоторые транспорты, включая SSL, не поддерживают полузакрытые соединения, "
"и в этом случае возврат true из этого метода приведет к закрытию соединения."

#: ../../library/asyncio-protocol.rst:583
#: ../../library/asyncio-protocol.rst:641
msgid "State machine:"
msgstr "Машина состояний"

#: ../../library/asyncio-protocol.rst:585
msgid ""
"start -> connection_made\n"
"    [-> data_received]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"
msgstr ""
"start -> connection_made\n"
"    [-> data_received]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"

#: ../../library/asyncio-protocol.rst:594
msgid "Buffered Streaming Protocols"
msgstr "Протоколы буферизованной потоковой передачи"

#: ../../library/asyncio-protocol.rst:598
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"Буферизованные протоколы можно использовать с любым методом цикла событий, "
"который поддерживает `Streaming Protocols`_."

#: ../../library/asyncio-protocol.rst:601
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"Реализации BufferedProtocol позволяют явно вручную выделять и контролировать "
"буфер приема. Циклы событий могут затем использовать буфер, предоставленный "
"протоколом, чтобы избежать ненужных копий данных. Это может привести к "
"заметному повышению производительности протоколов, которые получают большие "
"объемы данных. Сложные реализации протоколов могут значительно сократить "
"количество выделений буфера."

#: ../../library/asyncio-protocol.rst:608
msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr ""
"Следующие обратные вызовы вызываются в экземплярах :class:`BufferedProtocol`:"

#: ../../library/asyncio-protocol.rst:613
msgid "Called to allocate a new receive buffer."
msgstr "Вызывается для выделения нового буфера приема."

#: ../../library/asyncio-protocol.rst:615
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* — рекомендуемый минимальный размер возвращаемого буфера. "
"Допустимо возвращать буферы меньшего или большего размера, чем предлагает "
"*sizehint*. Если установлено значение -1, размер буфера может быть "
"произвольным. Возврат буфера нулевого размера является ошибкой."

#: ../../library/asyncio-protocol.rst:620
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""
"``get_buffer()`` должен возвращать объект, реализующий :ref:`буферный "
"протокол <bufferobjects>`."

#: ../../library/asyncio-protocol.rst:625
msgid "Called when the buffer was updated with the received data."
msgstr "Вызывается, когда буфер обновляется полученными данными."

#: ../../library/asyncio-protocol.rst:627
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes* — общее количество байтов, записанных в буфер."

#: ../../library/asyncio-protocol.rst:631
msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr ""
"См. документацию по методу :meth:`protocol.eof_received() <Protocol."
"eof_received>`."

#: ../../library/asyncio-protocol.rst:635
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer` может вызываться произвольное "
"количество раз во время соединения. Однако :meth:`protocol.eof_received() "
"<Protocol.eof_received>` вызывается не более одного раза, и, если они "
"вызваны, :meth:`~BufferedProtocol.get_buffer` и :meth:`~BufferedProtocol."
"buffer_updated` не будут позвонил после этого."

#: ../../library/asyncio-protocol.rst:643
msgid ""
"start -> connection_made\n"
"    [-> get_buffer\n"
"        [-> buffer_updated]?\n"
"    ]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"
msgstr ""
"start -> connection_made\n"
"    [-> get_buffer\n"
"        [-> buffer_updated]?\n"
"    ]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"

#: ../../library/asyncio-protocol.rst:654
msgid "Datagram Protocols"
msgstr "Протоколы датаграмм"

#: ../../library/asyncio-protocol.rst:656
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"Экземпляры протокола дейтаграмм должны создаваться фабриками протоколов, "
"передаваемыми в метод :meth:`loop.create_datagram_endpoint`."

#: ../../library/asyncio-protocol.rst:661
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"Вызывается при получении датаграммы. *data* — это байтовый объект, "
"содержащий входящие данные. *addr* — адрес узла, отправляющего данные; "
"точный формат зависит от транспорта."

#: ../../library/asyncio-protocol.rst:667
msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"Вызывается, когда предыдущая операция отправки или получения вызывает "
"ошибку :class:`OSError`. *exc* — это экземпляр :class:`OSError`."

#: ../../library/asyncio-protocol.rst:670
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"Этот метод вызывается в редких случаях, когда транспорт (например, UDP) "
"обнаруживает, что дейтаграмма не может быть доставлена ​​получателю. Однако во "
"многих случаях недоставленные датаграммы будут автоматически отброшены."

#: ../../library/asyncio-protocol.rst:677
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr ""
"В системах BSD (macOS, FreeBSD и т. д.) управление потоком данных не "
"поддерживается для протоколов датаграмм, поскольку не существует надежного "
"способа обнаружения сбоев отправки, вызванных записью слишком большого "
"количества пакетов."

#: ../../library/asyncio-protocol.rst:681
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
"Сокет всегда отображается как «готовый», и лишние пакеты отбрасываются. "
"Ошибка :class:`OSError` с ``errno``, установленным в :const:`errno.ENOBUFS`, "
"может быть вызвана, а может и не возникнуть; если он возникнет, об этом "
"будет сообщено в :meth:`DatagramProtocol.error_received`, но в противном "
"случае оно будет проигнорировано."

#: ../../library/asyncio-protocol.rst:690
msgid "Subprocess Protocols"
msgstr "Протоколы подпроцессов"

#: ../../library/asyncio-protocol.rst:692
msgid ""
"Subprocess Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"Экземпляры протокола подпроцесса должны создаваться фабриками протоколов, "
"передаваемыми методам :meth:`loop.subprocess_exec` и :meth:`loop."
"subprocess_shell`."

#: ../../library/asyncio-protocol.rst:698
msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""
"Вызывается, когда дочерний процесс записывает данные в свой канал stdout или "
"stderr."

#: ../../library/asyncio-protocol.rst:701
msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* — целочисленный файловый дескриптор канала."

#: ../../library/asyncio-protocol.rst:703
msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* — это непустой байтовый объект, содержащий полученные данные."

#: ../../library/asyncio-protocol.rst:707
msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr ""
"Вызывается, когда закрывается один из каналов, взаимодействующих с дочерним "
"процессом."

#: ../../library/asyncio-protocol.rst:710
msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd* — целочисленный дескриптор файла, который был закрыт."

#: ../../library/asyncio-protocol.rst:714
msgid "Called when the child process has exited."
msgstr "Вызывается при выходе дочернего процесса."

#: ../../library/asyncio-protocol.rst:716
msgid ""
"It can be called before :meth:`~SubprocessProtocol.pipe_data_received` and :"
"meth:`~SubprocessProtocol.pipe_connection_lost` methods."
msgstr ""
"Его можно вызвать перед методами :meth:`~SubprocessProtocol."
"pipe_data_received` и :meth:`~SubprocessProtocol.pipe_connection_lost`."

#: ../../library/asyncio-protocol.rst:721
msgid "Examples"
msgstr "Примеры"

#: ../../library/asyncio-protocol.rst:726
msgid "TCP Echo Server"
msgstr "Эхо-сервер TCP"

#: ../../library/asyncio-protocol.rst:728
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""
"Создайте эхо-сервер TCP, используя метод :meth:`loop.create_server`, "
"отправьте обратно полученные данные и закройте соединение::"

#: ../../library/asyncio-protocol.rst:731
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol(asyncio.Protocol):\n"
"    def connection_made(self, transport):\n"
"        peername = transport.get_extra_info('peername')\n"
"        print('Connection from {}'.format(peername))\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        message = data.decode()\n"
"        print('Data received: {!r}'.format(message))\n"
"\n"
"        print('Send: {!r}'.format(message))\n"
"        self.transport.write(data)\n"
"\n"
"        print('Close the client socket')\n"
"        self.transport.close()\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    server = await loop.create_server(\n"
"        EchoServerProtocol,\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    async with server:\n"
"        await server.serve_forever()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol(asyncio.Protocol):\n"
"    def connection_made(self, transport):\n"
"        peername = transport.get_extra_info('peername')\n"
"        print('Connection from {}'.format(peername))\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        message = data.decode()\n"
"        print('Data received: {!r}'.format(message))\n"
"\n"
"        print('Send: {!r}'.format(message))\n"
"        self.transport.write(data)\n"
"\n"
"        print('Close the client socket')\n"
"        self.transport.close()\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    server = await loop.create_server(\n"
"        EchoServerProtocol,\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    async with server:\n"
"        await server.serve_forever()\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:769
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
"В примере эхо-сервера TCP с использованием потоков <asyncio-tcp-echo-server-"
"streams>` используется высокоуровневая функция :func:`asyncio.start_server`."

#: ../../library/asyncio-protocol.rst:775
msgid "TCP Echo Client"
msgstr "Эхо-клиент TCP"

#: ../../library/asyncio-protocol.rst:777
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
"Эхо-клиент TCP, использующий метод :meth:`loop.create_connection`, "
"отправляет данные и ждет, пока соединение не закроется::"

#: ../../library/asyncio-protocol.rst:780
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol(asyncio.Protocol):\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        transport.write(self.message.encode())\n"
"        print('Data sent: {!r}'.format(self.message))\n"
"\n"
"    def data_received(self, data):\n"
"        print('Data received: {!r}'.format(data.decode()))\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print('The server closed the connection')\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = 'Hello World!'\n"
"\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    # Wait until the protocol signals that the connection\n"
"    # is lost and close the transport.\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol(asyncio.Protocol):\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        transport.write(self.message.encode())\n"
"        print('Data sent: {!r}'.format(self.message))\n"
"\n"
"    def data_received(self, data):\n"
"        print('Data received: {!r}'.format(data.decode()))\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print('The server closed the connection')\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = 'Hello World!'\n"
"\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    # Wait until the protocol signals that the connection\n"
"    # is lost and close the transport.\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:825
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
"В примере :ref:`TCP echo client с использованием потоков <asyncio-tcp-echo-"
"client-streams>` используется высокоуровневая функция :func:`asyncio."
"open_connection`."

#: ../../library/asyncio-protocol.rst:832
msgid "UDP Echo Server"
msgstr "Эхо-сервер UDP"

#: ../../library/asyncio-protocol.rst:834
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""
"Эхо-сервер UDP, используя метод :meth:`loop.create_datagram_endpoint`, "
"отправляет обратно полученные данные:"

#: ../../library/asyncio-protocol.rst:837
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol:\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        message = data.decode()\n"
"        print('Received %r from %s' % (message, addr))\n"
"        print('Send %r to %s' % (message, addr))\n"
"        self.transport.sendto(data, addr)\n"
"\n"
"\n"
"async def main():\n"
"    print(\"Starting UDP server\")\n"
"\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # One protocol instance will be created to serve all\n"
"    # client requests.\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        EchoServerProtocol,\n"
"        local_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await asyncio.sleep(3600)  # Serve for 1 hour.\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol:\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        message = data.decode()\n"
"        print('Received %r from %s' % (message, addr))\n"
"        print('Send %r to %s' % (message, addr))\n"
"        self.transport.sendto(data, addr)\n"
"\n"
"\n"
"async def main():\n"
"    print(\"Starting UDP server\")\n"
"\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # One protocol instance will be created to serve all\n"
"    # client requests.\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        EchoServerProtocol,\n"
"        local_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await asyncio.sleep(3600)  # Serve for 1 hour.\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:876
msgid "UDP Echo Client"
msgstr "Эхо-клиент UDP"

#: ../../library/asyncio-protocol.rst:878
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""
"Эхо-клиент UDP, используя метод :meth:`loop.create_datagram_endpoint`, "
"отправляет данные и закрывает транспорт, когда получает ответ:"

#: ../../library/asyncio-protocol.rst:881
msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol:\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"        self.transport = None\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"        print('Send:', self.message)\n"
"        self.transport.sendto(self.message.encode())\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        print(\"Close the socket\")\n"
"        self.transport.close()\n"
"\n"
"    def error_received(self, exc):\n"
"        print('Error received:', exc)\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print(\"Connection closed\")\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = \"Hello World!\"\n"
"\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        remote_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol:\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"        self.transport = None\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"        print('Send:', self.message)\n"
"        self.transport.sendto(self.message.encode())\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        print(\"Close the socket\")\n"
"        self.transport.close()\n"
"\n"
"    def error_received(self, exc):\n"
"        print('Error received:', exc)\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print(\"Connection closed\")\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = \"Hello World!\"\n"
"\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        remote_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:933
msgid "Connecting Existing Sockets"
msgstr "Подключение существующих сокетов"

#: ../../library/asyncio-protocol.rst:935
msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""
"Подождите, пока сокет не получит данные с помощью метода :meth:`loop."
"create_connection` с протоколом::"

#: ../../library/asyncio-protocol.rst:938
msgid ""
"import asyncio\n"
"import socket\n"
"\n"
"\n"
"class MyProtocol(asyncio.Protocol):\n"
"\n"
"    def __init__(self, on_con_lost):\n"
"        self.transport = None\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        # We are done: close the transport;\n"
"        # connection_lost() will be called automatically.\n"
"        self.transport.close()\n"
"\n"
"    def connection_lost(self, exc):\n"
"        # The socket has been closed\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"    on_con_lost = loop.create_future()\n"
"\n"
"    # Create a pair of connected sockets\n"
"    rsock, wsock = socket.socketpair()\n"
"\n"
"    # Register the socket to wait for data.\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: MyProtocol(on_con_lost), sock=rsock)\n"
"\n"
"    # Simulate the reception of data from the network.\n"
"    loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"    try:\n"
"        await protocol.on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"        wsock.close()\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import socket\n"
"\n"
"\n"
"class MyProtocol(asyncio.Protocol):\n"
"\n"
"    def __init__(self, on_con_lost):\n"
"        self.transport = None\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        # We are done: close the transport;\n"
"        # connection_lost() will be called automatically.\n"
"        self.transport.close()\n"
"\n"
"    def connection_lost(self, exc):\n"
"        # The socket has been closed\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"    on_con_lost = loop.create_future()\n"
"\n"
"    # Create a pair of connected sockets\n"
"    rsock, wsock = socket.socketpair()\n"
"\n"
"    # Register the socket to wait for data.\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: MyProtocol(on_con_lost), sock=rsock)\n"
"\n"
"    # Simulate the reception of data from the network.\n"
"    loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"    try:\n"
"        await protocol.on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"        wsock.close()\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-protocol.rst:989
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
"В примере :ref:`наблюдения за файловым дескриптором на предмет событий "
"чтения <asyncio_example_watch_fd>` используется низкоуровневый метод :meth:"
"`loop.add_reader` для регистрации FD."

#: ../../library/asyncio-protocol.rst:993
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
"В примере :ref:`наблюдения за файловым дескриптором на предмет событий "
"чтения <asyncio_example_watch_fd>` используется низкоуровневый метод :meth:"
"`loop.add_reader` для регистрации FD."

#: ../../library/asyncio-protocol.rst:1000
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "loop.subprocess_exec() и SubprocessProtocol"

#: ../../library/asyncio-protocol.rst:1002
msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""
"Пример протокола подпроцесса, используемого для получения выходных данных "
"подпроцесса и ожидания выхода из подпроцесса."

#: ../../library/asyncio-protocol.rst:1005
msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr "Подпроцесс создается методом :meth:`loop.subprocess_exec`::"

#: ../../library/asyncio-protocol.rst:1007
msgid ""
"import asyncio\n"
"import sys\n"
"\n"
"class DateProtocol(asyncio.SubprocessProtocol):\n"
"    def __init__(self, exit_future):\n"
"        self.exit_future = exit_future\n"
"        self.output = bytearray()\n"
"        self.pipe_closed = False\n"
"        self.exited = False\n"
"\n"
"    def pipe_connection_lost(self, fd, exc):\n"
"        self.pipe_closed = True\n"
"        self.check_for_exit()\n"
"\n"
"    def pipe_data_received(self, fd, data):\n"
"        self.output.extend(data)\n"
"\n"
"    def process_exited(self):\n"
"        self.exited = True\n"
"        # process_exited() method can be called before\n"
"        # pipe_connection_lost() method: wait until both methods are\n"
"        # called.\n"
"        self.check_for_exit()\n"
"\n"
"    def check_for_exit(self):\n"
"        if self.pipe_closed and self.exited:\n"
"            self.exit_future.set_result(True)\n"
"\n"
"async def get_date():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    code = 'import datetime; print(datetime.datetime.now())'\n"
"    exit_future = asyncio.Future(loop=loop)\n"
"\n"
"    # Create the subprocess controlled by DateProtocol;\n"
"    # redirect the standard output into a pipe.\n"
"    transport, protocol = await loop.subprocess_exec(\n"
"        lambda: DateProtocol(exit_future),\n"
"        sys.executable, '-c', code,\n"
"        stdin=None, stderr=None)\n"
"\n"
"    # Wait for the subprocess exit using the process_exited()\n"
"    # method of the protocol.\n"
"    await exit_future\n"
"\n"
"    # Close the stdout pipe.\n"
"    transport.close()\n"
"\n"
"    # Read the output which was collected by the\n"
"    # pipe_data_received() method of the protocol.\n"
"    data = bytes(protocol.output)\n"
"    return data.decode('ascii').rstrip()\n"
"\n"
"date = asyncio.run(get_date())\n"
"print(f\"Current date: {date}\")"
msgstr ""
"import asyncio\n"
"import sys\n"
"\n"
"class DateProtocol(asyncio.SubprocessProtocol):\n"
"    def __init__(self, exit_future):\n"
"        self.exit_future = exit_future\n"
"        self.output = bytearray()\n"
"        self.pipe_closed = False\n"
"        self.exited = False\n"
"\n"
"    def pipe_connection_lost(self, fd, exc):\n"
"        self.pipe_closed = True\n"
"        self.check_for_exit()\n"
"\n"
"    def pipe_data_received(self, fd, data):\n"
"        self.output.extend(data)\n"
"\n"
"    def process_exited(self):\n"
"        self.exited = True\n"
"        # process_exited() method can be called before\n"
"        # pipe_connection_lost() method: wait until both methods are\n"
"        # called.\n"
"        self.check_for_exit()\n"
"\n"
"    def check_for_exit(self):\n"
"        if self.pipe_closed and self.exited:\n"
"            self.exit_future.set_result(True)\n"
"\n"
"async def get_date():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    code = 'import datetime; print(datetime.datetime.now())'\n"
"    exit_future = asyncio.Future(loop=loop)\n"
"\n"
"    # Create the subprocess controlled by DateProtocol;\n"
"    # redirect the standard output into a pipe.\n"
"    transport, protocol = await loop.subprocess_exec(\n"
"        lambda: DateProtocol(exit_future),\n"
"        sys.executable, '-c', code,\n"
"        stdin=None, stderr=None)\n"
"\n"
"    # Wait for the subprocess exit using the process_exited()\n"
"    # method of the protocol.\n"
"    await exit_future\n"
"\n"
"    # Close the stdout pipe.\n"
"    transport.close()\n"
"\n"
"    # Read the output which was collected by the\n"
"    # pipe_data_received() method of the protocol.\n"
"    data = bytes(protocol.output)\n"
"    return data.decode('ascii').rstrip()\n"
"\n"
"date = asyncio.run(get_date())\n"
"print(f\"Current date: {date}\")"

#: ../../library/asyncio-protocol.rst:1065
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
"См. также тот же пример <asyncio_example_create_subprocess_exec>, написанный "
"с использованием API высокого уровня."
