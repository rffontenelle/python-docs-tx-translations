# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# alex alev <alex.alev@bk.ru>, 2021
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:05+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/email.message.rst:2
msgid ":mod:`!email.message`: Representing an email message"
msgstr ":mod:`!email.message`: Представление сообщения электронной почты."

#: ../../library/email.message.rst:10
msgid "**Source code:** :source:`Lib/email/message.py`"
msgstr "**Исходный код:** :source:`Lib/email/message.py`"

#: ../../library/email.message.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.message.rst:16
msgid ""
"The central class in the :mod:`email` package is the :class:`EmailMessage` "
"class, imported from the :mod:`email.message` module.  It is the base class "
"for the :mod:`email` object model.  :class:`EmailMessage` provides the core "
"functionality for setting and querying header fields, for accessing message "
"bodies, and for creating or modifying structured messages."
msgstr ""
"Центральным классом пакета :mod:`email` является класс :class:"
"`EmailMessage`, импортированный из модуля :mod:`email.message`. Это базовый "
"класс объектной модели :mod:`email`. :class:`EmailMessage` предоставляет "
"основные функции для настройки и запроса полей заголовков, для доступа к "
"телу сообщения, а также для создания или изменения структурированных "
"сообщений."

#: ../../library/email.message.rst:22
msgid ""
"An email message consists of *headers* and a *payload* (which is also "
"referred to as the *content*).  Headers are :rfc:`5322` or :rfc:`6532` style "
"field names and values, where the field name and value are separated by a "
"colon.  The colon is not part of either the field name or the field value.  "
"The payload may be a simple text message, or a binary object, or a "
"structured sequence of sub-messages each with their own set of headers and "
"their own payload.  The latter type of payload is indicated by the message "
"having a MIME type such as :mimetype:`multipart/\\*` or :mimetype:`message/"
"rfc822`."
msgstr ""
"Сообщение электронной почты состоит из *заголовков* и *полезной нагрузки* "
"(которая также называется *контентом*). Заголовки представляют собой имена и "
"значения полей в стиле :rfc:`5322` или :rfc:`6532`, где имя и значение поля "
"разделяются двоеточием. Двоеточие не является частью ни имени поля, ни "
"значения поля. Полезная нагрузка может представлять собой простое текстовое "
"сообщение, двоичный объект или структурированную последовательность "
"подсообщений, каждое из которых имеет собственный набор заголовков и "
"собственную полезную нагрузку. Последний тип полезных данных обозначается "
"сообщением, имеющим тип MIME, например :mimetype:`multipart/\\*` или :"
"mimetype:`message/rfc822`."

#: ../../library/email.message.rst:31
msgid ""
"The conceptual model provided by an :class:`EmailMessage` object is that of "
"an ordered dictionary of headers coupled with a *payload* that represents "
"the :rfc:`5322` body of the message, which might be a list of sub-"
"``EmailMessage`` objects.  In addition to the normal dictionary methods for "
"accessing the header names and values, there are methods for accessing "
"specialized information from the headers (for example the MIME content "
"type), for operating on the payload, for generating a serialized version of "
"the message, and for recursively walking over the object tree."
msgstr ""
"Концептуальная модель, предоставляемая объектом :class:`EmailMessage`, "
"представляет собой упорядоченный словарь заголовков, соединенный с *полезной "
"нагрузкой*, которая представляет тело :rfc:`5322` сообщения, которое может "
"быть списком вложенных элементов. Объекты `EmailMessage``. В дополнение к "
"обычным словарным методам доступа к именам и значениям заголовков существуют "
"методы для доступа к специализированной информации из заголовков (например, "
"к типу контента MIME), для работы с полезными данными, для создания "
"сериализованной версии сообщения и для рекурсивного обхода дерева объектов."

#: ../../library/email.message.rst:40
msgid ""
"The :class:`EmailMessage` dictionary-like interface is indexed by the header "
"names, which must be ASCII values.  The values of the dictionary are strings "
"with some extra methods.  Headers are stored and returned in case-preserving "
"form, but field names are matched case-insensitively.  The keys are ordered, "
"but unlike a real dict, there can be duplicates.  Additional methods are "
"provided for working with headers that have duplicate keys."
msgstr ""
"Интерфейс, подобный словарю :class:`EmailMessage`, индексируется по именам "
"заголовков, которые должны быть значениями ASCII. Значения словаря "
"представляют собой строки с некоторыми дополнительными методами. Заголовки "
"сохраняются и возвращаются в форме с сохранением регистра, но имена полей "
"сопоставляются без учета регистра. Ключи упорядочены, но в отличие от "
"настоящего дикта могут быть дубликаты. Предусмотрены дополнительные методы "
"для работы с заголовками, имеющими повторяющиеся ключи."

#: ../../library/email.message.rst:47
msgid ""
"The *payload* is either a string or bytes object, in the case of simple "
"message objects, or a list of :class:`EmailMessage` objects, for MIME "
"container documents such as :mimetype:`multipart/\\*` and :mimetype:`message/"
"rfc822` message objects."
msgstr ""
"*Полезная нагрузка* представляет собой либо строку, либо байтовый объект в "
"случае простых объектов сообщения или список объектов :class:`EmailMessage` "
"для документов-контейнеров MIME, таких как :mimetype:`multipart/\\*` и :"
"mimetype. :`message/rfc822` объекты сообщений."

#: ../../library/email.message.rst:55
msgid ""
"If *policy* is specified use the rules it specifies to update and serialize "
"the representation of the message.  If *policy* is not set, use the :class:"
"`~email.policy.default` policy, which follows the rules of the email RFCs "
"except for line endings (instead of the RFC mandated ``\\r\\n``, it uses the "
"Python standard ``\\n`` line endings).  For more information see the :mod:"
"`~email.policy` documentation."
msgstr ""
"Если указана *policy*, используйте указанные ею правила для обновления и "
"сериализации представления сообщения. Если *policy* не установлена, "
"используйте политику :class:`~email.policy.default`, которая соответствует "
"правилам RFC электронной почты, за исключением окончания строк (вместо "
"предписанного RFC ``\\r\\n``, он использует стандартные окончания строк "
"``\\n`` Python). Для получения дополнительной информации см. документацию :"
"mod:`~email.policy`."

#: ../../library/email.message.rst:64
msgid ""
"Return the entire message flattened as a string.  When optional *unixfrom* "
"is true, the envelope header is included in the returned string.  *unixfrom* "
"defaults to ``False``.  For backward compatibility with the base :class:"
"`~email.message.Message` class *maxheaderlen* is accepted, but defaults to "
"``None``, which means that by default the line length is controlled by the :"
"attr:`~email.policy.Policy.max_line_length` of the policy.  The *policy* "
"argument may be used to override the default policy obtained from the "
"message instance.  This can be used to control some of the formatting "
"produced by the method, since the specified *policy* will be passed to the :"
"class:`~email.generator.Generator`."
msgstr ""
"Вернуть все сообщение в виде строки. Если необязательный параметр *unixfrom* "
"имеет значение true, заголовок конверта включается в возвращаемую строку. "
"*unixfrom* по умолчанию имеет значение «False». Для обратной совместимости с "
"базовым :class:`~email.message.Message` класс *maxheaderlen* принимается, но "
"по умолчанию установлено значение ``None``, что означает, что по умолчанию "
"длина строки контролируется :attr:`~ email.policy.Policy.max_line_length` "
"политики. Аргумент *policy* можно использовать для переопределения политики "
"по умолчанию, полученной из экземпляра сообщения. Это можно использовать для "
"управления некоторыми элементами форматирования, создаваемыми методом, "
"поскольку указанная *policy* будет передана в :class:`~email.generator."
"Generator`."

#: ../../library/email.message.rst:76 ../../library/email.message.rst:114
msgid ""
"Flattening the message may trigger changes to the :class:`EmailMessage` if "
"defaults need to be filled in to complete the transformation to a string "
"(for example, MIME boundaries may be generated or modified)."
msgstr ""
"Сглаживание сообщения может вызвать изменения в :class:`EmailMessage`, если "
"для завершения преобразования в строку необходимо заполнить значения по "
"умолчанию (например, могут быть созданы или изменены границы MIME)."

#: ../../library/email.message.rst:80
msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.Generator` for "
"a more flexible API for serializing messages.  Note also that this method is "
"restricted to producing messages serialized as \"7 bit clean\" when :attr:"
"`~email.policy.EmailPolicy.utf8` is ``False``, which is the default."
msgstr ""
"Обратите внимание, что этот метод предоставляется для удобства и может быть "
"не самым полезным способом сериализации сообщений в вашем приложении, "
"особенно если вы имеете дело с несколькими сообщениями. См. :class:`email."
"generator.Generator` для получения более гибкого API для сериализации "
"сообщений. Также обратите внимание, что этот метод ограничен созданием "
"сообщений, сериализованных как «7-битные чистые», когда :attr:`~email.policy."
"EmailPolicy.utf8` имеет значение ``False``, что является значением по "
"умолчанию."

#: ../../library/email.message.rst:88
msgid ""
"the default behavior when *maxheaderlen* is not specified was changed from "
"defaulting to 0 to defaulting to the value of *max_line_length* from the "
"policy."
msgstr ""
"поведение по умолчанию, когда *maxheaderlen* не указано, было изменено со "
"значения по умолчанию на 0 на значение по умолчанию *max_line_length* из "
"политики."

#: ../../library/email.message.rst:95
msgid ""
"Equivalent to ``as_string(policy=self.policy.clone(utf8=True))``.  Allows "
"``str(msg)`` to produce a string containing the serialized message in a "
"readable format."
msgstr ""
"Эквивалентно ``as_string(policy=self.policy.clone(utf8=True))``. Позволяет "
"``str(msg)`` создавать строку, содержащую сериализованное сообщение в "
"читаемом формате."

#: ../../library/email.message.rst:99
msgid ""
"the method was changed to use ``utf8=True``, thus producing an :rfc:`6531`-"
"like message representation, instead of being a direct alias for :meth:"
"`as_string`."
msgstr ""
"метод был изменен на использование ``utf8=True``, создавая таким образом "
"представление сообщения, подобное :rfc:`6531`, вместо прямого псевдонима "
"для :meth:`as_string`."

#: ../../library/email.message.rst:106
msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned string.  "
"*unixfrom* defaults to ``False``.  The *policy* argument may be used to "
"override the default policy obtained from the message instance. This can be "
"used to control some of the formatting produced by the method, since the "
"specified *policy* will be passed to the :class:`~email.generator."
"BytesGenerator`."
msgstr ""
"Верните все сообщение в виде байтового объекта. Если необязательный параметр "
"*unixfrom* имеет значение true, заголовок конверта включается в возвращаемую "
"строку. *unixfrom* по умолчанию имеет значение «False». Аргумент *policy* "
"можно использовать для переопределения политики по умолчанию, полученной из "
"экземпляра сообщения. Это можно использовать для управления некоторыми "
"элементами форматирования, производимыми методом, поскольку указанная "
"*policy* будет передана в :class:`~email.generator.BytesGenerator`."

#: ../../library/email.message.rst:118
msgid ""
"Note that this method is provided as a convenience and may not be the most "
"useful way to serialize messages in your application, especially if you are "
"dealing with multiple messages.  See :class:`email.generator.BytesGenerator` "
"for a more flexible API for serializing messages."
msgstr ""
"Обратите внимание, что этот метод предоставляется для удобства и может быть "
"не самым полезным способом сериализации сообщений в вашем приложении, "
"особенно если вы имеете дело с несколькими сообщениями. См. :class:`email."
"generator.BytesGenerator` для получения более гибкого API для сериализации "
"сообщений."

#: ../../library/email.message.rst:127
msgid ""
"Equivalent to :meth:`.as_bytes`.  Allows ``bytes(msg)`` to produce a bytes "
"object containing the serialized message."
msgstr ""
"Эквивалент :meth:`.as_bytes`. Позволяет ``bytes(msg)`` создавать объект "
"bytes, содержащий сериализованное сообщение."

#: ../../library/email.message.rst:133
msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ :class:"
"`EmailMessage` objects, otherwise return ``False``.  When :meth:"
"`is_multipart` returns ``False``, the payload should be a string object "
"(which might be a CTE encoded binary payload).  Note that :meth:"
"`is_multipart` returning ``True`` does not necessarily mean that \"msg."
"get_content_maintype() == 'multipart'\" will return the ``True``. For "
"example, ``is_multipart`` will return ``True`` when the :class:"
"`EmailMessage` is of type ``message/rfc822``."
msgstr ""
"Возвращайте ``True``, если полезная нагрузка сообщения представляет собой "
"список объектов подкласса \\ :class:`EmailMessage`, в противном случае "
"возвращайте ``False``. Когда :meth:`is_multipart` возвращает ``False``, "
"полезная нагрузка должна быть строковым объектом (который может быть "
"двоичной полезной нагрузкой в ​​кодировке CTE). Обратите внимание, что :meth:"
"`is_multipart`, возвращающий ``True``, не обязательно означает, что \"msg."
"get_content_maintype() == 'multipart'\" вернет ``True``. Например, "
"``is_multipart`` вернет ``True``, если :class:`EmailMessage` имеет тип "
"``message/rfc822``."

#: ../../library/email.message.rst:145
msgid ""
"Set the message's envelope header to *unixfrom*, which should be a string.  "
"(See :class:`~mailbox.mboxMessage` for a brief description of this header.)"
msgstr ""
"Установите для заголовка конверта сообщения значение *unixfrom*, которое "
"должно быть строкой. (Краткое описание этого заголовка см. в :class:"
"`~mailbox.mboxMessage`.)"

#: ../../library/email.message.rst:152
msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the envelope "
"header was never set."
msgstr ""
"Верните заголовок конверта сообщения. По умолчанию установлено значение "
"«Нет», если заголовок конверта никогда не устанавливался."

#: ../../library/email.message.rst:156
msgid ""
"The following methods implement the mapping-like interface for accessing the "
"message's headers.  Note that there are some semantic differences between "
"these methods and a normal mapping (i.e. dictionary) interface.  For "
"example, in a dictionary there are no duplicate keys, but here there may be "
"duplicate message headers.  Also, in dictionaries there is no guaranteed "
"order to the keys returned by :meth:`keys`, but in an :class:`EmailMessage` "
"object, headers are always returned in the order they appeared in the "
"original message, or in which they were added to the message later.  Any "
"header deleted and then re-added is always appended to the end of the header "
"list."
msgstr ""
"Следующие методы реализуют интерфейс, похожий на сопоставление, для доступа "
"к заголовкам сообщений. Обратите внимание, что между этими методами и "
"интерфейсом обычного сопоставления (то есть словаря) существуют некоторые "
"семантические различия. Например, в словаре нет повторяющихся ключей, а "
"здесь могут быть повторяющиеся заголовки сообщений. Кроме того, в словарях "
"нет гарантированного порядка ключей, возвращаемых :meth:`keys`, но в "
"объекте :class:`EmailMessage` заголовки всегда возвращаются в том порядке, в "
"котором они появились в исходном сообщении, или в том порядке, в котором они "
"появились в исходном сообщении. были добавлены в сообщение позже. Любой "
"заголовок, удаленный, а затем повторно добавленный, всегда добавляется в "
"конец списка заголовков."

#: ../../library/email.message.rst:167
msgid ""
"These semantic differences are intentional and are biased toward convenience "
"in the most common use cases."
msgstr ""
"Эти семантические различия являются преднамеренными и ориентированы на "
"удобство в наиболее распространенных случаях использования."

#: ../../library/email.message.rst:170
msgid ""
"Note that in all cases, any envelope header present in the message is not "
"included in the mapping interface."
msgstr ""
"Обратите внимание, что во всех случаях любой заголовок конверта, "
"присутствующий в сообщении, не включается в интерфейс сопоставления."

#: ../../library/email.message.rst:176
msgid "Return the total number of headers, including duplicates."
msgstr "Возвращает общее количество заголовков, включая дубликаты."

#: ../../library/email.message.rst:181
msgid ""
"Return ``True`` if the message object has a field named *name*. Matching is "
"done without regard to case and *name* does not include the trailing colon.  "
"Used for the ``in`` operator.  For example::"
msgstr ""
"Верните ``True``, если объект сообщения имеет поле с именем *name*. "
"Сопоставление выполняется без учета регистра, а *имя* не содержит "
"завершающего двоеточия. Используется для оператора ``in``. Например::"

#: ../../library/email.message.rst:185
msgid ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"
msgstr ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"

#: ../../library/email.message.rst:191
msgid ""
"Return the value of the named header field.  *name* does not include the "
"colon field separator.  If the header is missing, ``None`` is returned; a :"
"exc:`KeyError` is never raised."
msgstr ""
"Верните значение именованного поля заголовка. *имя* не включает разделитель "
"полей двоеточие. Если заголовок отсутствует, возвращается None; :exc:"
"`KeyError` никогда не возникает."

#: ../../library/email.message.rst:195
msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is undefined.  "
"Use the :meth:`get_all` method to get the values of all the extant headers "
"named *name*."
msgstr ""
"Обратите внимание: если именованное поле появляется в заголовках сообщения "
"более одного раза, то, какое именно из значений этого поля будет возвращено, "
"не определено. Используйте метод :meth:`get_all`, чтобы получить значения "
"всех существующих заголовков с именем *name*."

#: ../../library/email.message.rst:200
msgid ""
"Using the standard (non-``compat32``) policies, the returned value is an "
"instance of a subclass of :class:`email.headerregistry.BaseHeader`."
msgstr ""
"При использовании стандартных политик (не-``compat32``) возвращаемое "
"значение является экземпляром подкласса :class:`email.headerregistry."
"BaseHeader`."

#: ../../library/email.message.rst:206
msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing headers."
msgstr ""
"Добавьте заголовок к сообщению с именем поля *name* и значением *val*. Поле "
"добавляется в конец существующих заголовков сообщения."

#: ../../library/email.message.rst:209
msgid ""
"Note that this does *not* overwrite or delete any existing header with the "
"same name.  If you want to ensure that the new header is the only one "
"present in the message with field name *name*, delete the field first, e.g.::"
msgstr ""
"Обратите внимание, что это *не* перезаписывает и не удаляет любой "
"существующий заголовок с тем же именем. Если вы хотите, чтобы новый "
"заголовок был единственным в сообщении с именем поля *имя*, сначала удалите "
"это поле, например::"

#: ../../library/email.message.rst:213
msgid ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"
msgstr ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"

#: ../../library/email.message.rst:216
msgid ""
"If the :mod:`policy <email.policy>` defines certain headers to be unique (as "
"the standard policies do), this method may raise a :exc:`ValueError` when an "
"attempt is made to assign a value to such a header when one already exists.  "
"This behavior is intentional for consistency's sake, but do not depend on it "
"as we may choose to make such assignments do an automatic deletion of the "
"existing header in the future."
msgstr ""
"Если :mod:`policy <email.policy>` определяет определенные заголовки как "
"уникальные (как это делают стандартные политики), этот метод может вызвать :"
"exc:`ValueError` при попытке присвоить значение такому заголовок, если он "
"уже существует. Такое поведение сделано намеренно ради согласованности, но "
"не зависит от него, поскольку мы можем заставить такие назначения "
"автоматически удалять существующий заголовок в будущем."

#: ../../library/email.message.rst:226
msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr ""
"Удалите все вхождения поля с именем *name* из заголовков сообщений. "
"Исключение не возникает, если именованное поле отсутствует в заголовках."

#: ../../library/email.message.rst:233
msgid "Return a list of all the message's header field names."
msgstr "Возвращает список всех имен полей заголовка сообщения."

#: ../../library/email.message.rst:238
msgid "Return a list of all the message's field values."
msgstr "Возвращает список всех значений полей сообщения."

#: ../../library/email.message.rst:243
msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr ""
"Возвращает список из двух кортежей, содержащий все заголовки и значения "
"полей сообщения."

#: ../../library/email.message.rst:249
msgid ""
"Return the value of the named header field.  This is identical to :meth:"
"`~object.__getitem__` except that optional *failobj* is returned if the "
"named header is missing (*failobj* defaults to ``None``)."
msgstr ""
"Верните значение именованного поля заголовка. Это идентично :meth:`~object."
"__getitem__`, за исключением того, что необязательный *failobj* "
"возвращается, если именованный заголовок отсутствует (*failobj* по умолчанию "
"имеет значение ``None``)."

#: ../../library/email.message.rst:254
msgid "Here are some additional useful header related methods:"
msgstr ""
"Вот несколько дополнительных полезных методов, связанных с заголовками:"

#: ../../library/email.message.rst:259
msgid ""
"Return a list of all the values for the field named *name*. If there are no "
"such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr ""
"Возвращает список всех значений поля с именем *name*. Если в сообщении нет "
"таких именованных заголовков, возвращается *failobj* (по умолчанию — None)."

#: ../../library/email.message.rst:266
msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the *primary* "
"value for the header."
msgstr ""
"Расширенная настройка заголовка. Этот метод похож на :meth:`__setitem__`, за "
"исключением того, что дополнительные параметры заголовка могут быть "
"предоставлены в качестве аргументов ключевого слова. *_name* — это "
"добавляемое поле заголовка, а *_value* — это *основное* значение заголовка."

#: ../../library/email.message.rst:271
msgid ""
"For each item in the keyword argument dictionary *_params*, the key is taken "
"as the parameter name, with underscores converted to dashes (since dashes "
"are illegal in Python identifiers).  Normally, the parameter will be added "
"as ``key=\"value\"`` unless the value is ``None``, in which case only the "
"key will be added."
msgstr ""
"Для каждого элемента в словаре аргументов ключевых слов *_params* ключ "
"принимается в качестве имени параметра, а символы подчеркивания "
"преобразуются в тире (поскольку тире недопустимы в идентификаторах Python). "
"Обычно параметр добавляется как ``key=\"value\"``, если только значение не "
"равно ``None``, в этом случае будет добавлен только ключ."

#: ../../library/email.message.rst:277
msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly controlled by specifying the value as a three tuple in the format "
"``(CHARSET, LANGUAGE, VALUE)``, where ``CHARSET`` is a string naming the "
"charset to be used to encode the value, ``LANGUAGE`` can usually be set to "
"``None`` or the empty string (see :rfc:`2231` for other possibilities), and "
"``VALUE`` is the string value containing non-ASCII code points.  If a three "
"tuple is not passed and the value contains non-ASCII characters, it is "
"automatically encoded in :rfc:`2231` format using a ``CHARSET`` of ``utf-8`` "
"and a ``LANGUAGE`` of ``None``."
msgstr ""
"Если значение содержит символы, отличные от ASCII, кодировкой и языком можно "
"явно управлять, указав значение в виде трехкортежа в формате ``(CHARSET, "
"LANGUAGE, VALUE)``, где ``CHARSET`` — это строковое имя. кодировку, которая "
"будет использоваться для кодирования значения, для ``LANGUAGE`` обычно можно "
"установить значение ``None`` или пустую строку (другие возможности см. в :"
"rfc:`2231`), а ``VALUE`` — это строковое значение, содержащее кодовые точки, "
"отличные от ASCII. Если трехкортеж не передается и значение содержит "
"символы, отличные от ASCII, оно автоматически кодируется в формате :rfc:"
"`2231` с использованием ``CHARSET`` из ``utf-8`` и ``LANGUAGE``. из ``Нет``."

#: ../../library/email.message.rst:287
msgid "Here is an example::"
msgstr "Вот пример::"

#: ../../library/email.message.rst:289
msgid "msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"
msgstr ""
"msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"

#: ../../library/email.message.rst:291
msgid "This will add a header that looks like ::"
msgstr "Это добавит заголовок, который будет выглядеть так::"

#: ../../library/email.message.rst:293
msgid "Content-Disposition: attachment; filename=\"bud.gif\""
msgstr "Content-Disposition: attachment; filename=\"bud.gif\""

#: ../../library/email.message.rst:295
msgid "An example of the extended interface with non-ASCII characters::"
msgstr "Пример расширенного интерфейса с символами, отличными от ASCII:"

#: ../../library/email.message.rst:297
msgid ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"
msgstr ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"

#: ../../library/email.message.rst:303
msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case of the original "
"header.  If no matching header is found, raise a :exc:`KeyError`."
msgstr ""
"Замените заголовок. Замените первый заголовок, найденный в сообщении, "
"который соответствует *_name*, сохранив порядок заголовка и регистр имени "
"поля исходного заголовка. Если соответствующий заголовок не найден, "
"вызовите :exc:`KeyError`."

#: ../../library/email.message.rst:311
msgid ""
"Return the message's content type, coerced to lower case of the form :"
"mimetype:`maintype/subtype`.  If there is no :mailheader:`Content-Type` "
"header in the message return the value returned by :meth:"
"`get_default_type`.  If the :mailheader:`Content-Type` header is invalid, "
"return ``text/plain``."
msgstr ""
"Возвращает тип содержимого сообщения, приведенный к нижнему регистру, в "
"форме :mimetype:`maintype/subtype`. Если в сообщении нет заголовка :"
"mailheader:`Content-Type`, верните значение, возвращаемое :meth:"
"`get_default_type`. Если заголовок :mailheader:`Content-Type` "
"недействителен, верните ``text/plain``."

#: ../../library/email.message.rst:317
msgid ""
"(According to :rfc:`2045`, messages always have a default type, :meth:"
"`get_content_type` will always return a value.  :rfc:`2045` defines a "
"message's default type to be :mimetype:`text/plain` unless it appears inside "
"a :mimetype:`multipart/digest` container, in which case it would be :"
"mimetype:`message/rfc822`.  If the :mailheader:`Content-Type` header has an "
"invalid type specification, :rfc:`2045` mandates that the default type be :"
"mimetype:`text/plain`.)"
msgstr ""
"(Согласно :rfc:`2045`, сообщения всегда имеют тип по умолчанию, :meth:"
"`get_content_type` всегда будет возвращать значение. :rfc:`2045` определяет "
"тип сообщения по умолчанию: :mimetype:`text/plain` если только он не "
"появляется внутри контейнера :mimetype:`multipart/digest`, и в этом случае "
"это будет :mimetype:`message/rfc822`. Если заголовок :mailheader:`Content-"
"Type` имеет недопустимую спецификацию типа, :rfc: `2045` требует, чтобы тип "
"по умолчанию был :mimetype:`text/plain`.)"

#: ../../library/email.message.rst:328
msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype` "
"part of the string returned by :meth:`get_content_type`."
msgstr ""
"Возвращает основной тип контента сообщения. Это часть :mimetype:`maintype` "
"строки, возвращаемой :meth:`get_content_type`."

#: ../../library/email.message.rst:334
msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` part "
"of the string returned by :meth:`get_content_type`."
msgstr ""
"Возвращает тип подконтента сообщения. Это часть :mimetype:`subtype` строки, "
"возвращаемой :meth:`get_content_type`."

#: ../../library/email.message.rst:340
msgid ""
"Return the default content type.  Most messages have a default content type "
"of :mimetype:`text/plain`, except for messages that are subparts of :"
"mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"Верните тип контента по умолчанию. Большинство сообщений имеют тип "
"содержимого по умолчанию :mimetype:`text/plain`, за исключением сообщений, "
"которые являются подчастями контейнеров :mimetype:`multipart/digest`. Такие "
"подразделы имеют тип контента по умолчанию :mimetype:`message/rfc822`."

#: ../../library/email.message.rst:348
msgid ""
"Set the default content type.  *ctype* should either be :mimetype:`text/"
"plain` or :mimetype:`message/rfc822`, although this is not enforced.  The "
"default content type is not stored in the :mailheader:`Content-Type` header, "
"so it only affects the return value of the ``get_content_type`` methods when "
"no :mailheader:`Content-Type` header is present in the message."
msgstr ""
"Установите тип контента по умолчанию. *ctype* должен быть либо :mimetype:"
"`text/plain`, либо :mimetype:`message/rfc822`, хотя это не является "
"обязательным. Тип контента по умолчанию не хранится в заголовке :mailheader:"
"`Content-Type`, поэтому он влияет на возвращаемое значение методов "
"``get_content_type`` только тогда, когда в сообщении отсутствует заголовок :"
"mailheader:`Content-Type`. ."

#: ../../library/email.message.rst:359
msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the parameter "
"already exists in the header, replace its value with *value*. When *header* "
"is ``Content-Type`` (the default) and the header does not yet exist in the "
"message, add it, set its value to :mimetype:`text/plain`, and append the new "
"parameter value.  Optional *header* specifies an alternative header to :"
"mailheader:`Content-Type`."
msgstr ""
"Установите параметр в заголовке :mailheader:`Content-Type`. Если параметр "
"уже существует в заголовке, замените его значение на *value*. Если *header* "
"имеет значение ``Content-Type`` (по умолчанию), а заголовок еще не "
"существует в сообщении, добавьте его, установите для него значение :mimetype:"
"`text/plain` и добавьте новое значение параметра. Необязательный *header* "
"указывает альтернативный заголовок :mailheader:`Content-Type`."

#: ../../library/email.message.rst:366
msgid ""
"If the value contains non-ASCII characters, the charset and language may be "
"explicitly specified using the optional *charset* and *language* "
"parameters.  Optional *language* specifies the :rfc:`2231` language, "
"defaulting to the empty string.  Both *charset* and *language* should be "
"strings.  The default is to use the ``utf8`` *charset* and ``None`` for the "
"*language*."
msgstr ""
"Если значение содержит символы, отличные от ASCII, кодировку и язык можно "
"явно указать с помощью необязательных параметров *charset* и *language*. "
"Необязательный *language* указывает язык :rfc:`2231`, по умолчанию "
"используется пустая строка. И *charset*, и *language* должны быть строками. "
"По умолчанию для *языка* используется кодировка ``utf8`` *charset* и "
"``None``."

#: ../../library/email.message.rst:373
msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of "
"the list of headers.  If *replace* is ``True``, the header will be updated "
"in place."
msgstr ""
"Если *replace* имеет значение «False» (по умолчанию), заголовок перемещается "
"в конец списка заголовков. Если *replace* имеет значение True, заголовок "
"будет обновлен на месте."

#: ../../library/email.message.rst:377 ../../library/email.message.rst:394
msgid ""
"Use of the *requote* parameter with :class:`EmailMessage` objects is "
"deprecated."
msgstr ""
"Использование параметра *requote* с объектами :class:`EmailMessage` устарело."

#: ../../library/email.message.rst:380
msgid ""
"Note that existing parameter values of headers may be accessed through the :"
"attr:`~email.headerregistry.ParameterizedMIMEHeader.params` attribute of the "
"header value (for example, ``msg['Content-Type'].params['charset']``)."
msgstr ""
"Обратите внимание, что к существующим значениям параметров заголовков можно "
"получить доступ через атрибут :attr:`~email.headerregistry."
"ParameterizedMIMEHeader.params` значения заголовка (например, ``msg['Content-"
"Type'].params['charset' ]``)."

#: ../../library/email.message.rst:384
msgid "``replace`` keyword was added."
msgstr "Добавлено ключевое слово replace."

#: ../../library/email.message.rst:389
msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type` "
"header.  The header will be re-written in place without the parameter or its "
"value.  Optional *header* specifies an alternative to :mailheader:`Content-"
"Type`."
msgstr ""
"Полностью удалите данный параметр из заголовка :mailheader:`Content-Type`. "
"Заголовок будет перезаписан без параметра или его значения. Необязательный "
"*header* указывает альтернативу :mailheader:`Content-Type`."

#: ../../library/email.message.rst:400
msgid ""
"Return the value of the ``filename`` parameter of the :mailheader:`Content-"
"Disposition` header of the message.  If the header does not have a "
"``filename`` parameter, this method falls back to looking for the ``name`` "
"parameter on the :mailheader:`Content-Type` header.  If neither is found, or "
"the header is missing, then *failobj* is returned. The returned string will "
"always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Возвращает значение параметра ``filename`` заголовка :mailheader:`Content-"
"Disposition` сообщения. Если в заголовке нет параметра ``filename``, этот "
"метод возвращается к поиску параметра ``name`` в заголовке :mailheader:"
"`Content-Type`. Если ни один из них не найден или заголовок отсутствует, "
"возвращается *failobj*. Возвращенная строка всегда будет без кавычек "
"согласно :func:`email.utils.unquote`."

#: ../../library/email.message.rst:411
msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader:`Content-"
"Type` header of the message, or *failobj* if either the header is missing, "
"or has no ``boundary`` parameter.  The returned string will always be "
"unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Возвращает значение параметра ``boundary`` заголовка :mailheader:`Content-"
"Type` сообщения или *failobj*, если заголовок отсутствует или не имеет "
"параметра ``boundary``. Возвращенная строка всегда будет без кавычек "
"согласно :func:`email.utils.unquote`."

#: ../../library/email.message.rst:419
msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to "
"*boundary*.  :meth:`set_boundary` will always quote *boundary* if "
"necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the message "
"object has no :mailheader:`Content-Type` header."
msgstr ""
"Установите для параметра border заголовка :mailheader:`Content-Type` "
"значение *boundary*. :meth:`set_boundary` всегда будет заключать в кавычки "
"*boundary*, если это необходимо. Ошибка :exc:`~email.errors."
"HeaderParseError` возникает, если объект сообщения не имеет заголовка :"
"mailheader:`Content-Type`."

#: ../../library/email.message.rst:424
msgid ""
"Note that using this method is subtly different from deleting the old :"
"mailheader:`Content-Type` header and adding a new one with the new boundary "
"via :meth:`add_header`, because :meth:`set_boundary` preserves the order of "
"the :mailheader:`Content-Type` header in the list of headers."
msgstr ""
"Обратите внимание, что использование этого метода немного отличается от "
"удаления старого заголовка :mailheader:`Content-Type` и добавления нового с "
"новой границей через :meth:`add_header`, поскольку :meth:`set_boundary` "
"сохраняет порядок :mailheader:`Content-Type` заголовок в списке заголовков."

#: ../../library/email.message.rst:433
msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` header, "
"coerced to lower case.  If there is no :mailheader:`Content-Type` header, or "
"if that header has no ``charset`` parameter, *failobj* is returned."
msgstr ""
"Возвращает параметр ``charset`` заголовка :mailheader:`Content-Type`, "
"переведенный в нижний регистр. Если заголовок :mailheader:`Content-Type` "
"отсутствует или этот заголовок не имеет параметра ``charset``, возвращается "
"*failobj*."

#: ../../library/email.message.rst:440
msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one element "
"for each subpart in the payload, otherwise, it will be a list of length 1."
msgstr ""
"Возвращает список, содержащий имена наборов символов в сообщении. Если "
"сообщение имеет тип :mimetype:`multipart`, то список будет содержать по "
"одному элементу для каждой части полезных данных, в противном случае это "
"будет список длиной 1."

#: ../../library/email.message.rst:444
msgid ""
"Each item in the list will be a string which is the value of the ``charset`` "
"parameter in the :mailheader:`Content-Type` header for the represented "
"subpart.  If the subpart has no :mailheader:`Content-Type` header, no "
"``charset`` parameter, or is not of the :mimetype:`text` main MIME type, "
"then that item in the returned list will be *failobj*."
msgstr ""
"Каждый элемент в списке будет строкой, которая является значением параметра "
"charset в заголовке :mailheader:`Content-Type` для представленной части. "
"Если подраздел не имеет заголовка :mailheader:`Content-Type`, параметра "
"``charset`` или не относится к основному типу MIME :mimetype:`text`, то этот "
"элемент в возвращаемом списке будет *failobj* ."

#: ../../library/email.message.rst:453
msgid ""
"Return ``True`` if there is a :mailheader:`Content-Disposition` header and "
"its (case insensitive) value is ``attachment``, ``False`` otherwise."
msgstr ""
"Возвращает ``True``, если существует заголовок :mailheader:`Content-"
"Disposition` и его (регистронезависимое) значение равно ``attachment``, "
"``False`` в противном случае."

#: ../../library/email.message.rst:456
msgid ""
"is_attachment is now a method instead of a property, for consistency with :"
"meth:`~email.message.Message.is_multipart`."
msgstr ""
"is_attachment теперь является методом, а не свойством, для согласованности "
"с :meth:`~email.message.Message.is_multipart`."

#: ../../library/email.message.rst:463
msgid ""
"Return the lowercased value (without parameters) of the message's :"
"mailheader:`Content-Disposition` header if it has one, or ``None``.  The "
"possible values for this method are *inline*, *attachment* or ``None`` if "
"the message follows :rfc:`2183`."
msgstr ""
"Возвращает значение в нижнем регистре (без параметров) заголовка сообщения :"
"mailheader:`Content-Disposition`, если он есть, или ``None``. Возможные "
"значения для этого метода: *inline*, *attachment* или ``None``, если за "
"сообщением следует :rfc:`2183`."

#: ../../library/email.message.rst:471
msgid ""
"The following methods relate to interrogating and manipulating the content "
"(payload) of the message."
msgstr ""
"Следующие методы относятся к опросу и манипулированию содержимым (полезной "
"нагрузкой) сообщения."

#: ../../library/email.message.rst:477
msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in depth-"
"first traversal order.  You will typically use :meth:`walk` as the iterator "
"in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
"Метод :meth:`walk` — это универсальный генератор, который можно использовать "
"для перебора всех частей и подчастей дерева объектов сообщений в порядке "
"обхода в глубину. Обычно вы будете использовать :meth:`walk` в качестве "
"итератора в цикле ``for``; каждая итерация возвращает следующую подчасть."

#: ../../library/email.message.rst:482
msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr ""
"Вот пример, который печатает MIME-тип каждой части составной структуры "
"сообщения:"

#: ../../library/email.message.rst:491
msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"
msgstr ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"

#: ../../library/email.message.rst:503
msgid ""
"``walk`` iterates over the subparts of any part where :meth:`is_multipart` "
"returns ``True``, even though ``msg.get_content_maintype() == 'multipart'`` "
"may return ``False``.  We can see this in our example by making use of the "
"``_structure`` debug helper function:"
msgstr ""
"``walk`` перебирает подчасти любой части, где :meth:`is_multipart` "
"возвращает ``True``, хотя ``msg.get_content_maintype() == 'multipart'`` "
"может возвращать ``False``. Мы можем увидеть это в нашем примере, "
"воспользовавшись вспомогательной функцией отладки ``_structure``:"

#: ../../library/email.message.rst:509
msgid ""
">>> from email.iterators import _structure\n"
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"
msgstr ""
">>> from email.iterators import _structure\n"
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"

#: ../../library/email.message.rst:531
msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into the "
"subparts."
msgstr ""
"Здесь части «сообщения» не являются «составными частями», но они содержат "
"подчасти. ``is_multipart()`` возвращает ``True`` и ``walk`` спускается в "
"подчасти."

#: ../../library/email.message.rst:538
msgid ""
"Return the MIME part that is the best candidate to be the \"body\" of the "
"message."
msgstr ""
"Возвращает часть MIME, которая является лучшим кандидатом на роль «тела» "
"сообщения."

#: ../../library/email.message.rst:541
msgid ""
"*preferencelist* must be a sequence of strings from the set ``related``, "
"``html``, and ``plain``, and indicates the order of preference for the "
"content type of the part returned."
msgstr ""
"*preferencelist* должен быть последовательностью строк из набора `` "
"linked``, ``html`` и ``plain`` и указывает порядок предпочтения типа "
"контента возвращаемой части."

#: ../../library/email.message.rst:545
msgid ""
"Start looking for candidate matches with the object on which the "
"``get_body`` method is called."
msgstr ""
"Начните поиск совпадений кандидатов с объекта, для которого вызывается метод "
"get_body."

#: ../../library/email.message.rst:548
msgid ""
"If ``related`` is not included in *preferencelist*, consider the root part "
"(or subpart of the root part) of any related encountered as a candidate if "
"the (sub-)part matches a preference."
msgstr ""
"Если ``связанный`` не включен в *список предпочтений*, рассматривайте "
"корневую часть (или подчасть корневой части) любого встреченного связанного "
"объекта как кандидата, если (под)часть соответствует предпочтению."

#: ../../library/email.message.rst:552
msgid ""
"When encountering a ``multipart/related``, check the ``start`` parameter and "
"if a part with a matching :mailheader:`Content-ID` is found, consider only "
"it when looking for candidate matches.  Otherwise consider only the first "
"(default root) part of the ``multipart/related``."
msgstr ""
"При обнаружении ``multipart/related`` проверьте параметр ``start`` и, если "
"найдена часть с совпадающим :mailheader:`Content-ID`, учитывайте только ее "
"при поиске совпадений-кандидатов. В противном случае учитывайте только "
"первую (корневую) часть ``multipart/related``."

#: ../../library/email.message.rst:557
msgid ""
"If a part has a :mailheader:`Content-Disposition` header, only consider the "
"part a candidate match if the value of the header is ``inline``."
msgstr ""
"Если часть имеет заголовок :mailheader:`Content-Disposition`, считайте часть "
"кандидатом на соответствие только в том случае, если значение заголовка "
"является ``inline``."

#: ../../library/email.message.rst:560
msgid ""
"If none of the candidates matches any of the preferences in "
"*preferencelist*, return ``None``."
msgstr ""
"Если ни один из кандидатов не соответствует ни одному из предпочтений в "
"*preferencelist*, верните ``None``."

#: ../../library/email.message.rst:563
msgid ""
"Notes: (1) For most applications the only *preferencelist* combinations that "
"really make sense are ``('plain',)``, ``('html', 'plain')``, and the default "
"``('related', 'html', 'plain')``.  (2) Because matching starts with the "
"object on which ``get_body`` is called, calling ``get_body`` on a "
"``multipart/related`` will return the object itself unless *preferencelist* "
"has a non-default value. (3) Messages (or message parts) that do not specify "
"a :mailheader:`Content-Type` or whose :mailheader:`Content-Type` header is "
"invalid will be treated as if they are of type ``text/plain``, which may "
"occasionally cause ``get_body`` to return unexpected results."
msgstr ""
"Примечания: (1) Для большинства приложений единственными комбинациями "
"*списков предпочтений*, которые действительно имеют смысл, являются "
"``('plain',)``, ``('html', 'plain')`` и значение по умолчанию "
"``( 'связанный', 'html', 'обычный')``. (2) Поскольку сопоставление "
"начинается с объекта, для которого вызывается ``get_body``, вызов "
"``get_body`` для ``multipart/related`` вернет сам объект, если только "
"*preferencelist* не имеет значения, отличного от значения по умолчанию. (3) "
"Сообщения (или части сообщения), в которых не указан :mailheader:`Content-"
"Type` или чей :mailheader:`Content-Type` заголовок недействителен, будут "
"обрабатываться так, как если бы они имели тип ``text/plain` `, что иногда "
"может привести к тому, что ``get_body`` будет возвращать неожиданные "
"результаты."

#: ../../library/email.message.rst:577
msgid ""
"Return an iterator over all of the immediate sub-parts of the message that "
"are not candidate \"body\" parts.  That is, skip the first occurrence of "
"each of ``text/plain``, ``text/html``, ``multipart/related``, or ``multipart/"
"alternative`` (unless they are explicitly marked as attachments via :"
"mailheader:`Content-Disposition: attachment`), and return all remaining "
"parts.  When applied directly to a ``multipart/related``, return an iterator "
"over the all the related parts except the root part (ie: the part pointed to "
"by the ``start`` parameter, or the first part if there is no ``start`` "
"parameter or the ``start`` parameter doesn't match the :mailheader:`Content-"
"ID` of any of the parts).  When applied directly to a ``multipart/"
"alternative`` or a non-``multipart``, return an empty iterator."
msgstr ""
"Возвращает итератор для всех непосредственных подчастей сообщения, которые "
"не являются кандидатами на части тела. То есть пропустить первое вхождение "
"каждого из ``text/plain``, ``text/html``, ``multipart/related`` или "
"``multipart/alternative`` (если они явно не помечены как вложения). через :"
"mailheader:`Content-Disposition: Attachment`) и верните все оставшиеся "
"части. При применении непосредственно к ``multipart/related`` возвращает "
"итератор для всех связанных частей, кроме корневой части (т. е. части, на "
"которую указывает параметр ``start``, или первой части, если нет Параметр "
"``start`` или параметр ``start`` не соответствует :mailheader:`Content-ID` "
"ни одной из частей). При прямом применении к ``multipart/alternative`` или "
"не``multipart`` возвращается пустой итератор."

#: ../../library/email.message.rst:593
msgid ""
"Return an iterator over all of the immediate sub-parts of the message, which "
"will be empty for a non-``multipart``.  (See also :meth:`~email.message."
"EmailMessage.walk`.)"
msgstr ""
"Возвращает итератор для всех непосредственных подчастей сообщения, который "
"будет пустым для не-``multipart``. (См. также :meth:`~email.message."
"EmailMessage.walk`.)"

#: ../../library/email.message.rst:600
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.get_content` method of "
"the *content_manager*, passing self as the message object, and passing along "
"any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`."
msgstr ""
"Вызовите метод :meth:`~email.contentmanager.ContentManager.get_content` "
"*content_manager*, передав self в качестве объекта сообщения и передав любые "
"другие аргументы или ключевые слова в качестве дополнительных аргументов. "
"Если *content_manager* не указан, используйте ``content_manager``, указанный "
"в текущем :mod:`~email.policy`."

#: ../../library/email.message.rst:609
msgid ""
"Call the :meth:`~email.contentmanager.ContentManager.set_content` method of "
"the *content_manager*, passing self as the message object, and passing along "
"any other arguments or keywords as additional arguments.  If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`."
msgstr ""
"Вызовите метод :meth:`~email.contentmanager.ContentManager.set_content` "
"*content_manager*, передав self в качестве объекта сообщения и передав любые "
"другие аргументы или ключевые слова в качестве дополнительных аргументов. "
"Если *content_manager* не указан, используйте ``content_manager``, указанный "
"в текущем :mod:`~email.policy`."

#: ../../library/email.message.rst:618
msgid ""
"Convert a non-``multipart`` message into a ``multipart/related`` message, "
"moving any existing :mailheader:`Content-` headers and payload into a (new) "
"first part of the ``multipart``.  If *boundary* is specified, use it as the "
"boundary string in the multipart, otherwise leave the boundary to be "
"automatically created when it is needed (for example, when the message is "
"serialized)."
msgstr ""
"Преобразуйте не-``multipart`` сообщение в ``multipart/related``, переместив "
"все существующие заголовки :mailheader:`Content-` и полезную нагрузку в "
"(новую) первую часть ``multipart``. Если указано *boundary*, используйте его "
"в качестве граничной строки в составной части, в противном случае оставьте "
"границу автоматически создаваться при необходимости (например, при "
"сериализации сообщения)."

#: ../../library/email.message.rst:628
msgid ""
"Convert a non-``multipart`` or a ``multipart/related`` into a ``multipart/"
"alternative``, moving any existing :mailheader:`Content-` headers and "
"payload into a (new) first part of the ``multipart``.  If *boundary* is "
"specified, use it as the boundary string in the multipart, otherwise leave "
"the boundary to be automatically created when it is needed (for example, "
"when the message is serialized)."
msgstr ""
"Преобразуйте не-``multipart`` или ``multipart/relative`` в ``multipart/"
"alternative``, переместив любые существующие заголовки :mailheader:`Content-"
"` и полезную нагрузку в (новую) первую часть ``многочастный``. Если указано "
"*boundary*, используйте его в качестве граничной строки в составной части, в "
"противном случае оставьте границу автоматически создаваться при "
"необходимости (например, при сериализации сообщения)."

#: ../../library/email.message.rst:638
msgid ""
"Convert a non-``multipart``, a ``multipart/related``, or a ``multipart-"
"alternative`` into a ``multipart/mixed``, moving any existing :mailheader:"
"`Content-` headers and payload into a (new) first part of the "
"``multipart``.  If *boundary* is specified, use it as the boundary string in "
"the multipart, otherwise leave the boundary to be automatically created when "
"it is needed (for example, when the message is serialized)."
msgstr ""
"Преобразуйте не-``multipart``, ``multipart/related`` или ``multipart-"
"alternative`` в ``multipart/mixed``, переместив все существующие заголовки :"
"mailheader:`Content-` и полезная нагрузка в (новую) первую часть "
"``multipart``. Если указано *boundary*, используйте его в качестве граничной "
"строки в составной части, в противном случае оставьте границу автоматически "
"создаваться при необходимости (например, при сериализации сообщения)."

#: ../../library/email.message.rst:648
msgid ""
"If the message is a ``multipart/related``, create a new message object, pass "
"all of the arguments to its :meth:`set_content` method, and :meth:`~email."
"message.Message.attach` it to the ``multipart``.  If the message is a non-"
"``multipart``, call :meth:`make_related` and then proceed as above.  If the "
"message is any other type of ``multipart``, raise a :exc:`TypeError`. If "
"*content_manager* is not specified, use the ``content_manager`` specified by "
"the current :mod:`~email.policy`. If the added part has no :mailheader:"
"`Content-Disposition` header, add one with the value ``inline``."
msgstr ""
"Если сообщение является ``многочастным/связанным``, создайте новый объект "
"сообщения, передайте все аргументы его методу :meth:`set_content` и :meth:"
"`~email.message.Message.attach` в ``многочастный``. Если сообщение не "
"является составным, вызовите :meth:`make_related` и затем действуйте, как "
"указано выше. Если сообщение представляет собой любой другой тип "
"``multipart``, вызовите :exc:`TypeError`. Если *content_manager* не указан, "
"используйте ``content_manager``, указанный в текущем :mod:`~email.policy`. "
"Если добавленная часть не имеет заголовка :mailheader:`Content-Disposition`, "
"добавьте его со значением ``inline``."

#: ../../library/email.message.rst:661
msgid ""
"If the message is a ``multipart/alternative``, create a new message object, "
"pass all of the arguments to its :meth:`set_content` method, and :meth:"
"`~email.message.Message.attach` it to the ``multipart``.  If the message is "
"a non-``multipart`` or ``multipart/related``, call :meth:`make_alternative` "
"and then proceed as above.  If the message is any other type of "
"``multipart``, raise a :exc:`TypeError`. If *content_manager* is not "
"specified, use the ``content_manager`` specified by the current :mod:`~email."
"policy`."
msgstr ""
"Если сообщение является ``многочастным/альтернативным``, создайте новый "
"объект сообщения, передайте все аргументы его методу :meth:`set_content` и :"
"meth:`~email.message.Message.attach` в него. ``многочастный``. Если "
"сообщение не является «многочастным» или «многочастным/связанным», вызовите :"
"meth:`make_alternative` и затем действуйте, как указано выше. Если сообщение "
"представляет собой любой другой тип ``multipart``, вызовите :exc:"
"`TypeError`. Если *content_manager* не указан, используйте "
"``content_manager``, указанный в текущем :mod:`~email.policy`."

#: ../../library/email.message.rst:673
msgid ""
"If the message is a ``multipart/mixed``, create a new message object, pass "
"all of the arguments to its :meth:`set_content` method, and :meth:`~email."
"message.Message.attach` it to the ``multipart``.  If the message is a non-"
"``multipart``, ``multipart/related``, or ``multipart/alternative``, call :"
"meth:`make_mixed` and then proceed as above. If *content_manager* is not "
"specified, use the ``content_manager`` specified by the current :mod:`~email."
"policy`.  If the added part has no :mailheader:`Content-Disposition` header, "
"add one with the value ``attachment``.  This method can be used both for "
"explicit attachments (:mailheader:`Content-Disposition: attachment`) and "
"``inline`` attachments (:mailheader:`Content-Disposition: inline`), by "
"passing appropriate options to the ``content_manager``."
msgstr ""
"Если сообщение является ``многочастным/смешанным``, создайте новый объект "
"сообщения, передайте все аргументы его методу :meth:`set_content` и :meth:"
"`~email.message.Message.attach` в него. ``многочастный``. Если сообщение не "
"является «многочастным», «многочастным/связанным» или «многочастным/"
"альтернативным», вызовите :meth:`make_mixed` и затем действуйте, как указано "
"выше. Если *content_manager* не указан, используйте ``content_manager``, "
"указанный в текущем :mod:`~email.policy`. Если добавленная часть не имеет "
"заголовка :mailheader:`Content-Disposition`, добавьте его со значением "
"``attachment``. Этот метод можно использовать как для явных вложений (:"
"mailheader:`Content-Disposition: Attachment`), так и для ``inline`` вложений "
"(:mailheader:`Content-Disposition: inline`), передав соответствующие "
"параметры в ``content_manager' ``."

#: ../../library/email.message.rst:689
msgid "Remove the payload and all of the headers."
msgstr "Удалите полезную нагрузку и все заголовки."

#: ../../library/email.message.rst:694
msgid ""
"Remove the payload and all of the :mailheader:`!Content-` headers, leaving "
"all other headers intact and in their original order."
msgstr ""
"Удалите полезную нагрузку и все заголовки :mailheader:`!Content-`, оставив "
"все остальные заголовки нетронутыми и в исходном порядке."

#: ../../library/email.message.rst:698
msgid ":class:`EmailMessage` objects have the following instance attributes:"
msgstr "Объекты :class:`EmailMessage` имеют следующие атрибуты экземпляра:"

#: ../../library/email.message.rst:703
msgid ""
"The format of a MIME document allows for some text between the blank line "
"following the headers, and the first multipart boundary string. Normally, "
"this text is never visible in a MIME-aware mail reader because it falls "
"outside the standard MIME armor.  However, when viewing the raw text of the "
"message, or when viewing the message in a non-MIME aware reader, this text "
"can become visible."
msgstr ""
"Формат документа MIME допускает наличие некоторого текста между пустой "
"строкой, следующей за заголовками, и первой составной граничной строкой. "
"Обычно этот текст никогда не отображается в программе чтения почты с "
"поддержкой MIME, поскольку он выходит за рамки стандартной защиты MIME. "
"Однако при просмотре необработанного текста сообщения или при просмотре "
"сообщения в программе чтения, не поддерживающей MIME, этот текст может стать "
"видимым."

#: ../../library/email.message.rst:710
msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text after "
"the headers but before the first boundary string, it assigns this text to "
"the message's *preamble* attribute.  When the :class:`~email.generator."
"Generator` is writing out the plain text representation of a MIME message, "
"and it finds the message has a *preamble* attribute, it will write this text "
"in the area between the headers and the first boundary.  See :mod:`email."
"parser` and :mod:`email.generator` for details."
msgstr ""
"Атрибут *preamble* содержит начальный дополнительный текст для документов "
"MIME. Когда :class:`~email.parser.Parser` обнаруживает некоторый текст после "
"заголовков, но перед первой граничной строкой, он присваивает этот текст "
"атрибуту *preamble* сообщения. Когда :class:`~email.generator.Generator` "
"записывает простое текстовое представление сообщения MIME и обнаруживает, "
"что сообщение имеет атрибут *preamble*, он записывает этот текст в область "
"между заголовками и первая граница. Подробности смотрите в :mod:`email."
"parser` и :mod:`email.generator`."

#: ../../library/email.message.rst:720
msgid ""
"Note that if the message object has no preamble, the *preamble* attribute "
"will be ``None``."
msgstr ""
"Обратите внимание: если объект сообщения не имеет преамбулы, атрибут "
"*preamble* будет иметь значение «Нет»."

#: ../../library/email.message.rst:726
msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and the "
"end of the message.  As with the :attr:`~EmailMessage.preamble`, if there is "
"no epilog text this attribute will be ``None``."
msgstr ""
"Атрибут *epilogue* действует так же, как атрибут *preamble*, за исключением "
"того, что он содержит текст, который появляется между последней границей и "
"концом сообщения. Как и в случае с :attr:`~EmailMessage.preamble`, если "
"текст эпилога отсутствует, этот атрибут будет ``None``."

#: ../../library/email.message.rst:734
msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description of "
"the possible parsing defects."
msgstr ""
"Атрибут *defects* содержит список всех проблем, обнаруженных при разборе "
"этого сообщения. См. :mod:`email.errors` для подробного описания возможных "
"дефектов синтаксического анализа."

#: ../../library/email.message.rst:741
msgid ""
"This class represents a subpart of a MIME message.  It is identical to :"
"class:`EmailMessage`, except that no :mailheader:`MIME-Version` headers are "
"added when :meth:`~EmailMessage.set_content` is called, since sub-parts do "
"not need their own :mailheader:`MIME-Version` headers."
msgstr ""
"Этот класс представляет собой часть сообщения MIME. Он идентичен :class:"
"`EmailMessage`, за исключением того, что при вызове :meth:`~EmailMessage."
"set_content` не добавляются заголовки :mailheader:`MIME-Version`, поскольку "
"подчастям не нужны собственные :mailheader: Заголовки `MIME-версия`."

#: ../../library/email.message.rst:748
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/email.message.rst:749
msgid ""
"Originally added in 3.4 as a :term:`provisional module <provisional "
"package>`.  Docs for legacy message class moved to :ref:`compat32_message`."
msgstr ""
"Первоначально добавлен в версии 3.4 как :term:`предварительный модуль "
"<предварительный пакет>`. Документация по устаревшему классу сообщений "
"перемещена в :ref:`compat32_message`."
