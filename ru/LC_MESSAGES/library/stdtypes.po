# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# alex alev <alex.alev@bk.ru>, 2020
# 9ea32e92423425918dce7ed595a4af87_42fb29b <b683cc4a07330fb1ca73f09953de9b8b_753633>, 2020
# Kristina Mironova, 2020
# decorator_factory <decorator-factory+transifex@yandex.ru>, 2020
# Daniil Kolesnikov, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-13 17:28+0000\n"
"PO-Revision-Date: 2020-05-30 12:10+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Встроенные типы"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"В следующих разделах описаны стандартные типы, встроенные в интерпретатор."

#: ../../library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"Основными встроенными типами являются числа, последовательности, "
"сопоставления, классы, экземпляры и исключения."

#: ../../library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Некоторые классы коллекций изменяемы. Методы, которые добавляют, вычитают "
"или переставляют свои члены на месте и не возвращают конкретный элемент, "
"никогда не возвращают сам экземпляр коллекции, а ``None``."

#: ../../library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"Некоторые операции поддерживаются несколькими типами объектов; в частности, "
"практически все объекты можно сравнить на равенство, проверить на истинность "
"и преобразовать в строку (с помощью :func:`repr` функция или немного другая :"
"func:`str` функция). Последняя функция неявно используется, когда объект "
"записывается с помощью :func:`печать` функция."

#: ../../library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Проверка логического значения"

#: ../../library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Любой объект может быть проверен на истинность для использования в :keyword:"
"`если` или :keyword:`пока` условие или в качестве операнда приведенных ниже "
"логических операций."

#: ../../library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`__bool__` method that returns ``False`` or a :meth:`__len__` method "
"that returns zero, when called with the object. [1]_  Here are most of the "
"built-in objects considered false:"
msgstr ""

#: ../../library/stdtypes.rst:55
msgid "constants defined to be false: ``None`` and ``False``."
msgstr ""

#: ../../library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"ноль любого числового типа: ``0`` , ``0.0`` , ``0j`` , ``Десятичный(0)`` , "
"``Дробь(0, 1)``"

#: ../../library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"пустые последовательности и коллекции: ``''`` , ``()`` , ``[]`` , ``{}`` , "
"``set()`` , ``диапазон(0)``"

#: ../../library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Операции и встроенные функции, имеющие логический результат, всегда "
"возвращают значение. ``0`` или ``Ложь`` за ложь и ``1`` или ``Правда`` "
"верно, если не указано иное. (Важное исключение: логические операции ``или`` "
"и ``и`` всегда возвращают один из своих операндов.)"

#: ../../library/stdtypes.rst:78
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr "Булевы операции --- :keyword:`!и` , :keyword:`!or` , :keyword:`!нет`"

#: ../../library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "Это логические операции, упорядоченные по возрастанию приоритета:"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:143
#: ../../library/stdtypes.rst:274 ../../library/stdtypes.rst:363
#: ../../library/stdtypes.rst:413 ../../library/stdtypes.rst:861
#: ../../library/stdtypes.rst:1056
msgid "Operation"
msgstr "Операция"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:274
#: ../../library/stdtypes.rst:363 ../../library/stdtypes.rst:413
#: ../../library/stdtypes.rst:861 ../../library/stdtypes.rst:1056
msgid "Result"
msgstr "Результат"

#: ../../library/stdtypes.rst:85 ../../library/stdtypes.rst:274
#: ../../library/stdtypes.rst:413 ../../library/stdtypes.rst:861
#: ../../library/stdtypes.rst:1056 ../../library/stdtypes.rst:2226
#: ../../library/stdtypes.rst:3381
msgid "Notes"
msgstr "Примечания"

#: ../../library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: ../../library/stdtypes.rst:87
msgid "if *x* is false, then *y*, else *x*"
msgstr ""

#: ../../library/stdtypes.rst:87 ../../library/stdtypes.rst:284
#: ../../library/stdtypes.rst:863 ../../library/stdtypes.rst:866
#: ../../library/stdtypes.rst:1067 ../../library/stdtypes.rst:2232
#: ../../library/stdtypes.rst:3387
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: ../../library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "если *x* ложно, то *x*, иначе *y*"

#: ../../library/stdtypes.rst:90 ../../library/stdtypes.rst:287
#: ../../library/stdtypes.rst:307 ../../library/stdtypes.rst:1095
#: ../../library/stdtypes.rst:2236 ../../library/stdtypes.rst:2238
#: ../../library/stdtypes.rst:3391 ../../library/stdtypes.rst:3393
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: ../../library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "если *x* ложно, то ``Правда`` , еще ``Ложь``"

#: ../../library/stdtypes.rst:93 ../../library/stdtypes.rst:875
#: ../../library/stdtypes.rst:1098 ../../library/stdtypes.rst:2240
#: ../../library/stdtypes.rst:2242 ../../library/stdtypes.rst:2244
#: ../../library/stdtypes.rst:2246 ../../library/stdtypes.rst:3395
#: ../../library/stdtypes.rst:3397 ../../library/stdtypes.rst:3399
#: ../../library/stdtypes.rst:3401
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:102 ../../library/stdtypes.rst:318
#: ../../library/stdtypes.rst:431 ../../library/stdtypes.rst:902
#: ../../library/stdtypes.rst:1106 ../../library/stdtypes.rst:2272
#: ../../library/stdtypes.rst:3431
msgid "Notes:"
msgstr "Примечания:"

#: ../../library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Это сокращенный оператор, поэтому он оценивает второй аргумент только в том "
"случае, если первый имеет значение false."

#: ../../library/stdtypes.rst:109
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Это сокращенный оператор, поэтому он оценивает второй аргумент только в том "
"случае, если первый аргумент истинен."

#: ../../library/stdtypes.rst:113
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``не`` имеет более низкий приоритет, чем нелогические операторы, поэтому "
"``не а == б`` интерпретируется как ``не (a == b)`` , и ``а == не б`` "
"является синтаксической ошибкой."

#: ../../library/stdtypes.rst:120
msgid "Comparisons"
msgstr "Сравнения"

#: ../../library/stdtypes.rst:134
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"В Python имеется восемь операций сравнения. Все они имеют одинаковый "
"приоритет (который выше, чем у логических операций). Сравнения могут быть "
"связаны произвольно; например, ``x < y <= z`` эквивалентно ``x < y и y <= "
"z`` , за исключением того, что *y* вычисляется только один раз (но в обоих "
"случаях *z* вообще не вычисляется, когда ``х < у`` оказывается ложным)."

#: ../../library/stdtypes.rst:140
msgid "This table summarizes the comparison operations:"
msgstr "В этой таблице суммированы операции сравнения:"

#: ../../library/stdtypes.rst:143 ../../library/stdtypes.rst:2203
#: ../../library/stdtypes.rst:2226 ../../library/stdtypes.rst:3358
#: ../../library/stdtypes.rst:3381
msgid "Meaning"
msgstr "Значение"

#: ../../library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:145
msgid "strictly less than"
msgstr "строго меньше, чем"

#: ../../library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:147
msgid "less than or equal"
msgstr "меньше или равно"

#: ../../library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "строго больше, чем"

#: ../../library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "больше или равно"

#: ../../library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:153
msgid "equal"
msgstr "равный"

#: ../../library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:155
msgid "not equal"
msgstr "не равно"

#: ../../library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: ../../library/stdtypes.rst:157
msgid "object identity"
msgstr "идентичность объекта"

#: ../../library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: ../../library/stdtypes.rst:159
msgid "negated object identity"
msgstr "отрицаемая идентичность объекта"

#: ../../library/stdtypes.rst:166
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"Объекты разных типов, за исключением разных числовых типов, никогда не "
"сравниваются равными. ``==`` оператор всегда определен, но для некоторых "
"типов объектов (например, объектов класса) эквивалентен :keyword:`есть` . "
"``<`` , ``<=`` , ``>`` и ``>=`` операторы определяются только там, где они "
"имеют смысл; например, они поднимают :exc:`TypeError` исключение, когда один "
"из аргументов является комплексным числом."

#: ../../library/stdtypes.rst:180
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`__eq__` method."
msgstr ""

#: ../../library/stdtypes.rst:183
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, and :meth:"
"`__ge__` (in general, :meth:`__lt__` and :meth:`__eq__` are sufficient, if "
"you want the conventional meanings of the comparison operators)."
msgstr ""

#: ../../library/stdtypes.rst:189
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"Поведение :keyword:`есть` и :keyword:`is not` операторы нельзя настроить; "
"также их можно применять к любым двум объектам и никогда не вызывать "
"исключения."

#: ../../library/stdtypes.rst:197
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`__contains__` method."
msgstr ""

#: ../../library/stdtypes.rst:204
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Числовые типы --- :класс:`int` , :class:`плавать` , :class:`сложный`"

#: ../../library/stdtypes.rst:214
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:type:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""

#: ../../library/stdtypes.rst:236
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""

#: ../../library/stdtypes.rst:261
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex. A comparison between numbers "
"of different types behaves as though the exact values of those numbers were "
"being compared. [2]_"
msgstr ""
"Python полностью поддерживает смешанную арифметику: когда оператор двоичной "
"арифметики имеет операнды разных числовых типов, операнд с «более узким» "
"типом расширяется до операнда другого, где целое число уже, чем с плавающей "
"запятой, которое уже, чем комплексное. Сравнение чисел разных типов "
"происходит так, как если бы сравнивались точные значения этих чисел. [2]_"

#: ../../library/stdtypes.rst:267
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
"Конструкторы :func:`int` , :func:`плавающий` , и :func:`сложный` может "
"использоваться для создания чисел определенного типа."

#: ../../library/stdtypes.rst:270
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"Все числовые типы (кроме комплексных) поддерживают следующие операции "
"(приоритеты операций см. :ref:`operator-summary` ):"

#: ../../library/stdtypes.rst:274
msgid "Full documentation"
msgstr "Полная документация"

#: ../../library/stdtypes.rst:276
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:276
msgid "sum of *x* and *y*"
msgstr "сумма *x* и *y*"

#: ../../library/stdtypes.rst:278
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:278
msgid "difference of *x* and *y*"
msgstr "разница *x* и *y*"

#: ../../library/stdtypes.rst:280
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:280
msgid "product of *x* and *y*"
msgstr "произведение *x* и *y*"

#: ../../library/stdtypes.rst:282
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:282
msgid "quotient of *x* and *y*"
msgstr "частное от *x* и *y*"

#: ../../library/stdtypes.rst:284
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:284
msgid "floored quotient of *x* and *y*"
msgstr "частное от *x* и *y*"

#: ../../library/stdtypes.rst:287
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:287
msgid "remainder of ``x / y``"
msgstr "остаток ``х/у``"

#: ../../library/stdtypes.rst:289
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:289
msgid "*x* negated"
msgstr "*x* отрицается"

#: ../../library/stdtypes.rst:291
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:291
msgid "*x* unchanged"
msgstr "*x* без изменений"

#: ../../library/stdtypes.rst:293
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:293
msgid "absolute value or magnitude of *x*"
msgstr "абсолютное значение или величина *x*"

#: ../../library/stdtypes.rst:293
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/stdtypes.rst:296
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:296
msgid "*x* converted to integer"
msgstr "*x* преобразовано в целое число"

#: ../../library/stdtypes.rst:296
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../../library/stdtypes.rst:296
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/stdtypes.rst:298
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:298
msgid "*x* converted to floating point"
msgstr "*x* преобразовано в формат с плавающей запятой"

#: ../../library/stdtypes.rst:298
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../../library/stdtypes.rst:298
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/stdtypes.rst:300
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../../library/stdtypes.rst:300
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"комплексное число с действительной частью *re* и мнимой частью *im*. *im* по "
"умолчанию равно нулю."

#: ../../library/stdtypes.rst:300 ../../library/stdtypes.rst:1088
#: ../../library/stdtypes.rst:2234 ../../library/stdtypes.rst:3418
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:300
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/stdtypes.rst:304
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:304
msgid "conjugate of the complex number *c*"
msgstr "сопряженное комплексному числу *c*"

#: ../../library/stdtypes.rst:307
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:307
msgid "the pair ``(x // y, x % y)``"
msgstr "пара ``(x // y, x % y)``"

#: ../../library/stdtypes.rst:307
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/stdtypes.rst:309
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:309 ../../library/stdtypes.rst:311
msgid "*x* to the power *y*"
msgstr "*x* в степени *y*"

#: ../../library/stdtypes.rst:309 ../../library/stdtypes.rst:311
#: ../../library/stdtypes.rst:1077 ../../library/stdtypes.rst:1080
#: ../../library/stdtypes.rst:2259 ../../library/stdtypes.rst:2262
#: ../../library/stdtypes.rst:2265 ../../library/stdtypes.rst:3414
#: ../../library/stdtypes.rst:3421
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:309
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/stdtypes.rst:311
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:321
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""

#: ../../library/stdtypes.rst:327
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Не для комплексных чисел. Вместо этого преобразуйте в числа с плавающей "
"запятой, используя :func:`abs` если это уместно."

#: ../../library/stdtypes.rst:339
msgid ""
"Conversion from floating point to integer may round or truncate as in C; see "
"functions :func:`math.floor` and :func:`math.ceil` for well-defined "
"conversions."
msgstr ""

#: ../../library/stdtypes.rst:344
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"float также принимает строки «nan» и «inf» с необязательным префиксом «+» "
"или «-» для обозначения «не число» (NaN) и положительную или отрицательную "
"бесконечность."

#: ../../library/stdtypes.rst:348
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python определяет ``pow(0, 0)`` и ``0 ** 0`` быть ``1`` , как это обычно "
"бывает с языками программирования."

#: ../../library/stdtypes.rst:352
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"Принимаемые числовые литералы включают цифры ``0`` к ``9`` или любой "
"эквивалент Unicode (кодовые точки с ``Нд`` свойство)."

#: ../../library/stdtypes.rst:355
msgid ""
"See http://www.unicode.org/Public/12.1.0/ucd/extracted/DerivedNumericType."
"txt for a complete list of code points with the ``Nd`` property."
msgstr ""

#: ../../library/stdtypes.rst:359
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Все :class:`numbers.Real` типы ( :класс:`int` и :class:`плавать` ) также "
"включают в себя следующие операции:"

#: ../../library/stdtypes.rst:365
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:365
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* сокращено до :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:368
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:368
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* округляется до *n* цифр, округляя половину до четного. Если *n* опущено, "
"по умолчанию оно равно 0."

#: ../../library/stdtypes.rst:372
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:372
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "величайший :class:`~numbers.Integral` <= *х*"

#: ../../library/stdtypes.rst:375
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:375
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "наименьший :class:`~numbers.Integral` >= *х*"

#: ../../library/stdtypes.rst:379
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"Дополнительные числовые операции см. :mod:`математика` и :mod:`cmath` модули."

#: ../../library/stdtypes.rst:388
msgid "Bitwise Operations on Integer Types"
msgstr "Побитовые операции с целочисленными типами"

#: ../../library/stdtypes.rst:402
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"Побитовые операции имеют смысл только для целых чисел. Результат побитовых "
"операций вычисляется так, как если бы они выполнялись в дополнении до двух с "
"бесконечным числом знаковых битов."

#: ../../library/stdtypes.rst:406
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"Приоритеты двоичных поразрядных операций ниже, чем у числовых операций, и "
"выше, чем у сравнений; унарная операция ``~`` имеет тот же приоритет, что и "
"другие унарные числовые операции ( ``+`` и ``-`` )."

#: ../../library/stdtypes.rst:410
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"В этой таблице перечислены побитовые операции, отсортированные по "
"возрастанию приоритета:"

#: ../../library/stdtypes.rst:415
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:415
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "побитовое :dfn:`или` из *x* и *y*"

#: ../../library/stdtypes.rst:415 ../../library/stdtypes.rst:418
#: ../../library/stdtypes.rst:421 ../../library/stdtypes.rst:1101
#: ../../library/stdtypes.rst:2248 ../../library/stdtypes.rst:2252
#: ../../library/stdtypes.rst:3403 ../../library/stdtypes.rst:3407
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:418
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:418
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "побитовое :dfn:`исключающее или` из *x* и *y*"

#: ../../library/stdtypes.rst:421
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:421
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "побитовое :dfn:`and` из *x* и *y*"

#: ../../library/stdtypes.rst:424
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:424
msgid "*x* shifted left by *n* bits"
msgstr "*x* сдвинуто влево на *n* бит"

#: ../../library/stdtypes.rst:424
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:426
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:426
msgid "*x* shifted right by *n* bits"
msgstr "*x* сдвинуто вправо на *n* бит"

#: ../../library/stdtypes.rst:426
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:428
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:428
msgid "the bits of *x* inverted"
msgstr "биты *x* инвертированы"

#: ../../library/stdtypes.rst:434
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""
"Отрицательное количество смен является незаконным и приводит к :exc:"
"`ValueError` быть поднятым."

#: ../../library/stdtypes.rst:437
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr "Сдвиг влево на *n* бит эквивалентен умножению на ``pow(2, n)`` ."

#: ../../library/stdtypes.rst:440
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr ""
"Сдвиг вправо на *n* бит эквивалентен делению нижнего уровня на ``pow(2, "
"n)`` ."

#: ../../library/stdtypes.rst:443
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"Выполнение этих вычислений по крайней мере с одним дополнительным битом "
"расширения знака в конечном представлении с дополнением до двух (рабочая "
"разрядность ``1 + max(x.bit_length(), y.bit_length())`` или более) "
"достаточно для получения того же результата, как если бы число знаковых "
"битов было бесконечным."

#: ../../library/stdtypes.rst:450
msgid "Additional Methods on Integer Types"
msgstr "Дополнительные методы для целочисленных типов"

#: ../../library/stdtypes.rst:452
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"Тип int реализует :class:`numbers.Integral` :term:`абстрактный базовый "
"класс`. Кроме того, он предоставляет еще несколько методов:"

#: ../../library/stdtypes.rst:457
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Возвращает количество бит, необходимое для представления целого числа в "
"двоичном формате, исключая знак и ведущие нули::"

#: ../../library/stdtypes.rst:466
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"Точнее, если ``х`` не равно нулю, то ``x.bit_length()`` уникальное "
"положительное целое число ``к`` такой, что ``2**(k-1) <= abs(x) < 2**k`` . "
"Эквивалентно, когда ``абс(х)`` достаточно мал, чтобы иметь правильно "
"округленный логарифм, тогда ``k = 1 + int(log(abs(x), 2))`` . Если ``х`` "
"равно нулю, то ``x.bit_length()`` возвращает ``0`` ."

#: ../../library/stdtypes.rst:472
msgid "Equivalent to::"
msgstr "Эквивалентно::"

#: ../../library/stdtypes.rst:483
msgid "Return an array of bytes representing an integer."
msgstr "Возвращает массив байтов, представляющий целое число."

#: ../../library/stdtypes.rst:495
msgid ""
"The integer is represented using *length* bytes.  An :exc:`OverflowError` is "
"raised if the integer is not representable with the given number of bytes."
msgstr ""

#: ../../library/stdtypes.rst:499 ../../library/stdtypes.rst:531
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer.  If *byteorder* is ``\"big\"``, the most significant byte is at the "
"beginning of the byte array.  If *byteorder* is ``\"little\"``, the most "
"significant byte is at the end of the byte array.  To request the native "
"byte order of the host system, use :data:`sys.byteorder` as the byte order "
"value."
msgstr ""

#: ../../library/stdtypes.rst:506
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"Аргумент *signed* определяет, используется ли дополнение до двух для "
"представления целого числа. Если *подписано* ``Ложь`` и задано отрицательное "
"целое число, :exc:`OverflowError` поднят. Значение по умолчанию для "
"*подписанного*: ``Ложь`` ."

#: ../../library/stdtypes.rst:515
msgid "Return the integer represented by the given array of bytes."
msgstr "Возвращает целое число, представленное заданным массивом байтов."

#: ../../library/stdtypes.rst:528
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"Аргумент *bytes* должен быть либо :term:`байтоподобным объектом`, либо "
"итерируемым объектом, производящим байты."

#: ../../library/stdtypes.rst:538
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"Аргумент *signed* указывает, используется ли дополнение до двух для "
"представления целого числа."

#: ../../library/stdtypes.rst:545
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"integer and with a positive denominator. The integer ratio of integers "
"(whole numbers) is always the integer as the numerator and ``1`` as the "
"denominator."
msgstr ""

#: ../../library/stdtypes.rst:553
msgid "Additional Methods on Float"
msgstr "Дополнительные методы с плавающей запятой"

#: ../../library/stdtypes.rst:555
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"Тип float реализует :class:`numbers.Real` :term:`абстрактный базовый класс`. "
"float также имеет следующие дополнительные методы."

#: ../../library/stdtypes.rst:560
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""

#: ../../library/stdtypes.rst:567
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Возвращаться ``Правда`` если экземпляр числа с плавающей запятой конечен с "
"целочисленным значением и ``Ложь`` в противном случае::"

#: ../../library/stdtypes.rst:575
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Два метода поддерживают преобразование в шестнадцатеричные строки и обратно. "
"Поскольку числа с плавающей запятой в Python хранятся внутри как двоичные "
"числа, преобразование числа с плавающей запятой в *десятичную* строку или из "
"нее обычно приводит к небольшой ошибке округления. Напротив, "
"шестнадцатеричные строки допускают точное представление и спецификацию чисел "
"с плавающей запятой. Это может быть полезно при отладке и числовой работе."

#: ../../library/stdtypes.rst:586
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Возвращает представление числа с плавающей запятой в виде шестнадцатеричной "
"строки. Для конечных чисел с плавающей запятой это представление всегда "
"будет включать ведущий ``0x`` и конечный ``п`` и показатель."

#: ../../library/stdtypes.rst:594
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Метод класса, возвращающий число с плавающей запятой, представленное "
"шестнадцатеричной строкой *s*. Строка *s* может иметь начальные и конечные "
"пробелы."

#: ../../library/stdtypes.rst:599
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"Обратите внимание, что :meth:`float.hex` является методом экземпляра, а :"
"meth:`float.fromhex` это метод класса."

#: ../../library/stdtypes.rst:602
msgid "A hexadecimal string takes the form::"
msgstr "Шестнадцатеричная строка имеет вид::"

#: ../../library/stdtypes.rst:606
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"где необязательно ``подписать`` может либо ``+`` или ``-`` , ``целое`` и "
"``фракция`` представляют собой строки шестнадцатеричных цифр, а "
"``экспонента`` — десятичное целое число с необязательным ведущим знаком. "
"Регистр не имеет значения, и в целом или дробном числе должна быть хотя бы "
"одна шестнадцатеричная цифра. Этот синтаксис аналогичен синтаксису, "
"указанному в разделе 6.4.4.2 стандарта C99, а также синтаксису, "
"используемому в Java 1.5 и более поздних версиях. В частности, вывод :meth:"
"`float.hex` можно использовать как шестнадцатеричный литерал с плавающей "
"запятой в коде C или Java, а также шестнадцатеричные строки, созданные с "
"помощью C. ``%a`` символ формата или Java ``Double.toHexString`` "
"принимаются :meth:`float.fromhex` ."

#: ../../library/stdtypes.rst:619
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Обратите внимание, что показатель степени записывается в десятичной, а не "
"шестнадцатеричной форме, и что он дает степень 2, на которую можно умножить "
"коэффициент. Например, шестнадцатеричная строка ``0x3.a7p10'' представляет "
"число с плавающей запятой ``(3 + 10./16 + 7./16**2) * 2.0**10`` , или "
"``3740.0`` ::"

#: ../../library/stdtypes.rst:629
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"Применяя обратное преобразование к ``3740.0`` дает другую шестнадцатеричную "
"строку, представляющую то же число::"

#: ../../library/stdtypes.rst:639
msgid "Hashing of numeric types"
msgstr "Хеширование числовых типов"

#: ../../library/stdtypes.rst:641
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`__hash__` "
"method documentation for more details).  For ease of implementation and "
"efficiency across a variety of numeric types (including :class:`int`, :class:"
"`float`, :class:`decimal.Decimal` and :class:`fractions.Fraction`) Python's "
"hash for numeric types is based on a single mathematical function that's "
"defined for any rational number, and hence applies to all instances of :"
"class:`int` and :class:`fractions.Fraction`, and all finite instances of :"
"class:`float` and :class:`decimal.Decimal`.  Essentially, this function is "
"given by reduction modulo ``P`` for a fixed prime ``P``.  The value of ``P`` "
"is made available to Python as the :attr:`modulus` attribute of :data:`sys."
"hash_info`."
msgstr ""

#: ../../library/stdtypes.rst:656
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"В настоящее время используется простое число ``P = 2**31 - 1`` на машинах с "
"32-битными лонгами C и ``P = 2**61 - 1`` на машинах с 64-битными лонгами C."

#: ../../library/stdtypes.rst:659
msgid "Here are the rules in detail:"
msgstr "Вот правила подробно:"

#: ../../library/stdtypes.rst:661
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"Если ``x = m/n`` является неотрицательным рациональным числом и ``н`` не "
"делится на ``П`` , определять ``хэш(x)`` как ``m * invmod(n, P) % P`` , где "
"``invmod(n, P)`` дает обратное значение ``н`` модуль ``П`` ."

#: ../../library/stdtypes.rst:665
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"Если ``x = m/n`` является неотрицательным рациональным числом и ``н`` "
"делится на ``П`` (но ``м`` нет) тогда ``н`` не имеет обратного модуля ``П`` "
"и приведенное выше правило не применяется; в этом случае определить "
"``хэш(x)`` быть постоянным значением ``sys.hash_info.inf`` ."

#: ../../library/stdtypes.rst:670
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"Если ``x = m/n`` является отрицательным рациональным числом, определяют "
"``хэш(x)`` как ``-хэш(-x)`` . Если полученный хэш ``-1`` , замените его на "
"``-2`` ."

#: ../../library/stdtypes.rst:674
msgid ""
"The particular values ``sys.hash_info.inf``, ``-sys.hash_info.inf`` and "
"``sys.hash_info.nan`` are used as hash values for positive infinity, "
"negative infinity, or nans (respectively).  (All hashable nans have the same "
"hash value.)"
msgstr ""

#: ../../library/stdtypes.rst:679
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Для :class:`сложный` число ``с`` хеш-значения действительной и мнимой частей "
"объединяются путем вычисления ``hash(z.real) + sys.hash_info.imag * hash(z."
"imag)`` , уменьшено по модулю ``2**sys.hash_info.width`` так что оно лежит в "
"``диапазон(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))`` . "
"Опять же, если результат ``-1`` , он заменяется на ``-2`` ."

#: ../../library/stdtypes.rst:687
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"Чтобы прояснить вышеизложенные правила, приведем пример кода Python, "
"эквивалентного встроенному хешу, для вычисления хеша рационального числа: :"
"class:`плавать` , или :class:`сложный` ::"

#: ../../library/stdtypes.rst:742
msgid "Iterator Types"
msgstr "Типы итераторов"

#: ../../library/stdtypes.rst:750
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python поддерживает концепцию итерации по контейнерам. Это реализуется с "
"использованием двух разных методов; они используются для того, чтобы "
"пользовательские классы могли поддерживать итерацию. Последовательности, "
"более подробно описанные ниже, всегда поддерживают итерационные методы."

#: ../../library/stdtypes.rst:755
msgid ""
"One method needs to be defined for container objects to provide iteration "
"support:"
msgstr ""

#: ../../library/stdtypes.rst:762
msgid ""
"Return an iterator object.  The object is required to support the iterator "
"protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""

#: ../../library/stdtypes.rst:771
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Сами объекты итератора должны поддерживать следующие два метода, которые "
"вместе образуют :dfn:`протокол итератора`:"

#: ../../library/stdtypes.rst:777
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements. This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""

#: ../../library/stdtypes.rst:785
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iternext` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""

#: ../../library/stdtypes.rst:790
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python определяет несколько объектов-итераторов для поддержки итерации по "
"общим и конкретным типам последовательностей, словарям и другим более "
"специализированным формам. Конкретные типы не важны, кроме реализации "
"протокола итератора."

#: ../../library/stdtypes.rst:795
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"Как только итератор :meth:`~iterator.__next__` метод вызывает :exc:"
"`СтопИтерация` , он должен продолжать делать это при последующих вызовах. "
"Реализации, не подчиняющиеся этому свойству, считаются сломанными."

#: ../../library/stdtypes.rst:803
msgid "Generator Types"
msgstr "Типы генераторов"

#: ../../library/stdtypes.rst:805
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`~generator.__next__` methods. More information about generators can be "
"found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""

#: ../../library/stdtypes.rst:817
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr ""
"Типы последовательностей --- :class:`список` , :class:`кортеж` , :class:"
"`диапазон`"

#: ../../library/stdtypes.rst:819
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Существует три основных типа последовательностей: списки, кортежи и объекты "
"диапазона. Дополнительные типы последовательностей, предназначенные для "
"обработки двоичных данных.\n"
"` и :ref:`текстовые строки` описаны в специальных разделах."

#: ../../library/stdtypes.rst:828
msgid "Common Sequence Operations"
msgstr "Общие операции с последовательностью"

#: ../../library/stdtypes.rst:832
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"Операции в следующей таблице поддерживаются большинством типов "
"последовательностей, как изменяемых, так и неизменяемых. :class:`collections."
"abc.Sequence` ABC предусмотрен для упрощения правильной реализации этих "
"операций над пользовательскими типами последовательностей."

#: ../../library/stdtypes.rst:837
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"В этой таблице перечислены операции последовательности, отсортированные по "
"возрастанию приоритета. В таблице *s* и *t* — однотипные последовательности, "
"*n*, *i*, *j* и *k* — целые числа, а *x* — произвольный объект, "
"удовлетворяющий любым ограничениям типа и значения. навязано *s*."

#: ../../library/stdtypes.rst:842
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"The ``в`` и ``не в`` операции имеют те же приоритеты, что и операции "
"сравнения. ``+`` (конкатенация) и ``*`` Операции (повторения) имеют тот же "
"приоритет, что и соответствующие числовые операции. [3]_"

#: ../../library/stdtypes.rst:863
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/stdtypes.rst:863
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``Правда`` если элемент *s* равен *x*, иначе ``Ложь``"

#: ../../library/stdtypes.rst:866
msgid "``x not in s``"
msgstr "``x не в s``"

#: ../../library/stdtypes.rst:866
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False`` если элемент из *s* равно *x*, иначе ``True``"

#: ../../library/stdtypes.rst:869
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:869
msgid "the concatenation of *s* and *t*"
msgstr "объединение *s* и *t*"

#: ../../library/stdtypes.rst:869
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../library/stdtypes.rst:872
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` или ``n * s``"

#: ../../library/stdtypes.rst:872
msgid "equivalent to adding *s* to itself *n* times"
msgstr "эквивалентно добавлению *s* к самому себе *n* раз"

#: ../../library/stdtypes.rst:872
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../../library/stdtypes.rst:875
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:875
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*i*\\-й элемент *s*, происхождение 0"

#: ../../library/stdtypes.rst:877
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:877
msgid "slice of *s* from *i* to *j*"
msgstr "кусочек *s* от *i* до *j*"

#: ../../library/stdtypes.rst:877
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:879
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../../library/stdtypes.rst:879
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "кусочек *s* от *i* до *j* с шагом *k*"

#: ../../library/stdtypes.rst:879
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:882
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/stdtypes.rst:882
msgid "length of *s*"
msgstr "длина *s*"

#: ../../library/stdtypes.rst:884
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../library/stdtypes.rst:884
msgid "smallest item of *s*"
msgstr "самый маленький предмет из *s*"

#: ../../library/stdtypes.rst:886
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../library/stdtypes.rst:886
msgid "largest item of *s*"
msgstr "самый большой предмет из *s*"

#: ../../library/stdtypes.rst:888
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../../library/stdtypes.rst:888
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"индекс первого вхождения *x* в *s* (после или после индекса *i* и перед "
"индексом *j*)"

#: ../../library/stdtypes.rst:888 ../../library/stdtypes.rst:3389
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/stdtypes.rst:892
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../library/stdtypes.rst:892
msgid "total number of occurrences of *x* in *s*"
msgstr "общее количество вхождений *x* в *s*"

#: ../../library/stdtypes.rst:896
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"Последовательности одного типа также поддерживают сравнения. В частности, "
"кортежи и списки сравниваются лексикографически путем сравнения "
"соответствующих элементов. Это означает, что для сравнения на равенство "
"каждый элемент должен сравниваться равным, а две последовательности должны "
"быть одного типа и иметь одинаковую длину. (Подробнее см. :ref:`сравнения` в "
"справочнике по языку.)"

#: ../../library/stdtypes.rst:905
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"В то время как ``в`` и ``не в`` операции используются только для простого "
"тестирования сдерживания, в общем случае некоторые специализированные "
"последовательности (например, :class:`str` , :class:`байты` и :class:"
"`bytearray` ) также используйте их для тестирования подпоследовательностей::"

#: ../../library/stdtypes.rst:914
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"Значения *n* менее ``0`` рассматриваются как ``0`` (что дает пустую "
"последовательность того же типа, что и *s*). Обратите внимание, что элементы "
"последовательности *s* не копируются; на них ссылаются несколько раз. Это "
"часто преследует новых программистов Python; учитывать::"

#: ../../library/stdtypes.rst:926
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"Произошло то, что ``[[]]`` представляет собой одноэлементный список, "
"содержащий пустой список, поэтому все три элемента ``[[]] * 3`` являются "
"ссылками на этот единственный пустой список. Изменение любого из элементов "
"``списки`` изменяет этот единственный список. Вы можете создать список "
"различных списков таким образом:"

#: ../../library/stdtypes.rst:938
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"Дальнейшее объяснение доступно в разделе часто задаваемых вопросов. :ref:"
"`faq-многомерный-список` ."

#: ../../library/stdtypes.rst:942
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Если *i* или *j* отрицательны, индекс относится к концу последовательности "
"*s*: ``лен(ы) + я`` или ``только(ы) + j'' заменяется. Но обратите внимание, "
"что ``-0`` все еще ``0`` ."

#: ../../library/stdtypes.rst:947
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"Срез *s* от *i* до *j* определяется как последовательность элементов с "
"индексом *k* такая, что ``i <= k < j`` . Если *i* или *j* больше, чем "
"``лен(ы)`` , использовать ``лен(ы)`` . Если *i* опущено или ``Нет`` , "
"использовать ``0`` . Если *j* опущено или ``Нет`` , использовать "
"``лен(ы)`` . Если *i* больше или равно *j*, срез пуст."

#: ../../library/stdtypes.rst:954
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"Срез *s* от *i* до *j* с шагом *k* определяется как последовательность "
"элементов с индексом ``x = я + n*k`` такой, что ``0 <= n < (ji)/k`` . "
"Другими словами, индексы ``я`` , ``я+к`` , ``я+2*к`` , ``я+3*к`` и так "
"далее, останавливаясь при достижении *j* (но никогда не включая *j*). Когда "
"*k* положительное значение, *i* и *j* уменьшаются до ``лен(ы)`` если они "
"больше. Когда *k* отрицательное значение, *i* и *j* уменьшаются до ``лен(ы) "
"- 1`` если они больше. Если *i* или *j* опущены или ``Нет`` , они становятся "
"«конечными» значениями (какой конец зависит от знака *k*). Обратите "
"внимание: *k* не может быть нулевым. Если *k* есть ``Нет`` , это "
"рассматривается как ``1`` ."

#: ../../library/stdtypes.rst:965
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"Объединение неизменяемых последовательностей всегда приводит к созданию "
"нового объекта. Это означает, что построение последовательности путем "
"повторной конкатенации будет иметь квадратичные затраты времени выполнения "
"по отношению к общей длине последовательности. Чтобы получить линейную "
"стоимость времени выполнения, необходимо переключиться на одну из "
"альтернатив ниже:"

#: ../../library/stdtypes.rst:970
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"если объединить :class:`str` объекты, вы можете создать список и "
"использовать :meth:`str.join` в конце или напишите :class:`io.StringIO` "
"экземпляр и получить его значение после завершения"

#: ../../library/stdtypes.rst:974
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"если объединить :class:`байты` объекты, вы можете аналогичным образом "
"использовать :meth:`bytes.join` или :class:`io.BytesIO` или вы можете "
"выполнить объединение на месте с помощью :class:`bytearray` объект. :class:"
"`bytearray` объекты изменяемы и имеют эффективный механизм перераспределения"

#: ../../library/stdtypes.rst:979
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
"если объединить :class:`кортеж` объекты, расширить :class:`список` вместо"

#: ../../library/stdtypes.rst:981
msgid "for other types, investigate the relevant class documentation"
msgstr "для других типов изучите соответствующую документацию по классу"

#: ../../library/stdtypes.rst:985
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Некоторые типы последовательностей (например, :class:`диапазон` ) "
"поддерживают только последовательности элементов, соответствующие "
"определенным шаблонам, и, следовательно, не поддерживают конкатенацию или "
"повторение последовательностей."

#: ../../library/stdtypes.rst:990
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"``индекс`` поднимает :exc:`ValueError` когда *x* не найден в *s*. Не все "
"реализации поддерживают передачу дополнительных аргументов *i* и *j*. Эти "
"аргументы позволяют эффективно искать подразделы последовательности. "
"Передача дополнительных аргументов примерно эквивалентна использованию ``s[i:"
"j].index(x)`` , только без копирования каких-либо данных и с возвращаемым "
"индексом, относящимся к началу последовательности, а не к началу среза."

#: ../../library/stdtypes.rst:1001
msgid "Immutable Sequence Types"
msgstr "Неизменяемые типы последовательностей"

#: ../../library/stdtypes.rst:1008
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"Единственная операция, которую обычно реализуют неизменяемые типы "
"последовательностей и которая не реализуется также изменяемыми типами "
"последовательностей, — это поддержка :func:`хэш` встроенный."

#: ../../library/stdtypes.rst:1012
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Эта поддержка позволяет использовать неизменяемые последовательности, такие "
"как :class:`кортеж` экземпляры, которые будут использоваться в качестве :"
"class:`dict` ключи и храниться в :класс:`набор` и :class:`frozenset` "
"экземпляры."

#: ../../library/stdtypes.rst:1016
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Попытка хешировать неизменяемую последовательность, содержащую нехешируемые "
"значения, приведет к :exc:`TypeError` ."

#: ../../library/stdtypes.rst:1023
msgid "Mutable Sequence Types"
msgstr "Изменяемые типы последовательностей"

#: ../../library/stdtypes.rst:1030
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"Операции в следующей таблице определены для изменяемых типов "
"последовательностей. :class:`collections.abc.MutableSequence` ABC "
"предусмотрен для упрощения правильной реализации этих операций над "
"пользовательскими типами последовательностей."

#: ../../library/stdtypes.rst:1034
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"В таблице *s* — это экземпляр изменяемого типа последовательности, *t* — "
"любой итерируемый объект, а *x* — произвольный объект, который соответствует "
"любым ограничениям типа и значения, налагаемым *s* (например, :class:"
"`bytearray` принимает только целые числа, соответствующие ограничению "
"значения ``0 <= x <= 255`` )."

#: ../../library/stdtypes.rst:1058
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1058
msgid "item *i* of *s* is replaced by *x*"
msgstr "элемент *i* из *s* заменяется на *x*"

#: ../../library/stdtypes.rst:1061
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1061
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr "фрагмент *s* от *i* до *j* заменяется содержимым итерируемого *t*"

#: ../../library/stdtypes.rst:1065
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1065
msgid "same as ``s[i:j] = []``"
msgstr "то же, что ``s[i:j] = []``"

#: ../../library/stdtypes.rst:1067
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1067
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "элементы ``s[i:j:k]`` заменяются на *t*"

#: ../../library/stdtypes.rst:1070
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1070
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "удаляет элементы ``s[i:j:k]`` из списка"

#: ../../library/stdtypes.rst:1073
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../library/stdtypes.rst:1073
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""
"добавляет *x* в конец последовательности (так же, как ``s[len(s):len(s)] = "
"[x]`` )"

#: ../../library/stdtypes.rst:1077
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../library/stdtypes.rst:1077
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "удаляет все элементы из *s* (так же, как ``дель s[:]`` )"

#: ../../library/stdtypes.rst:1080
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../library/stdtypes.rst:1080
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "создает неглубокую копию *s* (так же, как ``s[:]`` )"

#: ../../library/stdtypes.rst:1083
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` или ``s += t``"

#: ../../library/stdtypes.rst:1083
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""
"расширяет *s* содержимым *t* (по большей части то же самое, что и ``s[len(s):"
"len(s)] = t`` )"

#: ../../library/stdtypes.rst:1088
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../../library/stdtypes.rst:1088
msgid "updates *s* with its contents repeated *n* times"
msgstr "обновляет *s*, его содержимое повторяется *n* раз"

#: ../../library/stdtypes.rst:1091
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../library/stdtypes.rst:1091
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""
"вставляет *x* в *s* по индексу, заданному *i* (так же, как ``s[i:i] = [x]`` )"

#: ../../library/stdtypes.rst:1095
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` или ``s.pop(i)``"

#: ../../library/stdtypes.rst:1095
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "извлекает элемент по адресу *i*, а также удаляет его из *s*"

#: ../../library/stdtypes.rst:1098
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1098
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr ""

#: ../../library/stdtypes.rst:1101
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1101
msgid "reverses the items of *s* in place"
msgstr "меняет местами элементы *s* на месте"

#: ../../library/stdtypes.rst:1109
msgid "*t* must have the same length as the slice it is replacing."
msgstr ""

#: ../../library/stdtypes.rst:1112
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"Необязательный аргумент *i* по умолчанию имеет значение ``-1`` , так что по "
"умолчанию последний элемент удаляется и возвращается."

#: ../../library/stdtypes.rst:1116
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ":meth:`удалить` поднимает :exc:`ValueError` когда *x* не найден в *s*."

#: ../../library/stdtypes.rst:1119
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
"The :meth:`обратный` Метод изменяет последовательность на месте для экономии "
"места при реверсировании большой последовательности. Чтобы напомнить "
"пользователям, что он действует побочным эффектом, он не возвращает обратную "
"последовательность."

#: ../../library/stdtypes.rst:1124
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""
":meth:`чисто` и :meth:`!копировать` включены для согласованности с "
"интерфейсами изменяемых контейнеров, которые не поддерживают операции "
"нарезки (например, :class:`dict` и :класс:`набор` ). :meth:`!копировать` не "
"является частью :class:`collections.abc.MutableSequence` ABC, но его "
"предоставляют большинство конкретных классов изменяемых последовательностей."

#: ../../library/stdtypes.rst:1130
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr ":meth:`clear` и :meth:`!copy` методы ."

#: ../../library/stdtypes.rst:1134
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"Значение *n* является целым числом или объектом, реализующим :meth:`~object."
"__index__` . Нулевые и отрицательные значения *n* очищают "
"последовательность. Элементы последовательности не копируются; на них "
"ссылаются несколько раз, как объяснено для ``с*н`` под :ref:`typesseq-"
"common` ."

#: ../../library/stdtypes.rst:1143
msgid "Lists"
msgstr "Списки"

#: ../../library/stdtypes.rst:1147
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"Списки представляют собой изменяемые последовательности, обычно используемые "
"для хранения коллекций однородных элементов (где точная степень сходства "
"зависит от приложения)."

#: ../../library/stdtypes.rst:1153
msgid "Lists may be constructed in several ways:"
msgstr "Списки могут быть составлены несколькими способами:"

#: ../../library/stdtypes.rst:1155
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""
"Использование пары квадратных скобок для обозначения пустого списка: ``[]``"

#: ../../library/stdtypes.rst:1156
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Используя квадратные скобки, разделяя элементы запятыми: ``[а]`` , ``[а, б, "
"в]``"

#: ../../library/stdtypes.rst:1157
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "Использование понимания списка:: ``[x for x in iterable]``"

#: ../../library/stdtypes.rst:1158
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr ""
"Использование конструктора типа: ``список()`` или ``список(итеративный)``"

#: ../../library/stdtypes.rst:1160
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"Конструктор создает список, элементы которого такие же и в том же порядке, "
"что и элементы *iterable*. *iterable* может быть последовательностью, "
"контейнером, поддерживающим итерацию, или объектом-итератором. Если "
"*iterable* уже является списком, создается и возвращается копия, аналогично "
"``итерируемый[:]`` . Например, ``список('abc')`` возвращает ``['a', 'b', "
"'c']`` и ``список( (1, 2, 3))`` возвращает ``[1, 2, 3]`` . Если аргумент не "
"указан, конструктор создает новый пустой список. ``[]`` ."

#: ../../library/stdtypes.rst:1169
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"Многие другие операции также создают списки, включая `:func:`отсортировано` "
"отсортировано` встроенный."

#: ../../library/stdtypes.rst:1172
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Списки реализуют все :ref:`common\n"
"` и :ref:`изменяемый`последовательность операций. Списки также предоставляют "
"следующий дополнительный метод:"

#: ../../library/stdtypes.rst:1178
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Этот метод сортирует список на месте, используя только ``<`` сравнения между "
"предметами. Исключения не подавляются: если какие-либо операции сравнения "
"завершатся неудачно, вся операция сортировки завершится неудачно (и список, "
"скорее всего, останется в частично измененном состоянии)."

#: ../../library/stdtypes.rst:1183
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`сортировка` принимает два аргумента, которые могут быть переданы "
"только по ключевому слову (:ref:`keyword-only аргументы\n"
"`):"

#: ../../library/stdtypes.rst:1186
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* определяет функцию одного аргумента, которая используется для "
"извлечения ключа сравнения из каждого элемента списка (например, ``key=str."
"lower`` ). Ключ, соответствующий каждому элементу списка, вычисляется один "
"раз и затем используется для всего процесса сортировки. Значение по "
"умолчанию ``Нет`` означает, что элементы списка сортируются напрямую, без "
"вычисления отдельного значения ключа."

#: ../../library/stdtypes.rst:1193
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"The :func:`functools.cmp_to_key` доступна утилита для преобразования функции "
"*cmp* в стиле версии 2.x в функцию *key*."

#: ../../library/stdtypes.rst:1196
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* - логическое значение. Если установлено значение ``True``, то "
"элементы списка сортируются так, как если бы каждое сравнение было обратным."

#: ../../library/stdtypes.rst:1199
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Этот метод изменяет последовательность на месте для экономии места при "
"сортировке большой последовательности. Чтобы напомнить пользователям, что он "
"работает побочным эффектом, он не возвращает отсортированную "
"последовательность (используйте :func:`отсортировано` для явного запроса "
"нового экземпляра отсортированного списка)."

#: ../../library/stdtypes.rst:1204
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
"The :meth:`сортировка` метод гарантированно стабилен. Сортировка является "
"стабильной, если она гарантирует отсутствие изменения относительного порядка "
"элементов, которые сравниваются равными. Это полезно при сортировке за "
"несколько проходов (например, сортировка по отделу, а затем по уровню "
"заработной платы)."

#: ../../library/stdtypes.rst:1209
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Для примеров сортировки и краткого руководства по сортировке см. :ref:"
"`sortinghowto`."

#: ../../library/stdtypes.rst:1213
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"Пока список сортируется, эффект от попытки изменения или даже проверки "
"списка не определен. Реализация Python на C делает список пустым на время и "
"вызывает :exc:`ValueError` если он может обнаружить, что список был изменен "
"во время сортировки."

#: ../../library/stdtypes.rst:1222
msgid "Tuples"
msgstr "Кортежи"

#: ../../library/stdtypes.rst:1226
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Кортежи — это неизменяемые последовательности, обычно используемые для "
"хранения коллекций гетерогенных данных (например, двухкортежей, созданных :"
"func:`перечислить` встроенный). Кортежи также используются в случаях, когда "
"необходима неизменяемая последовательность однородных данных (например, для "
"хранения в :класс:`набор` или :class:`dict` пример)."

#: ../../library/stdtypes.rst:1234
msgid "Tuples may be constructed in a number of ways:"
msgstr "Кортежи могут быть созданы несколькими способами:"

#: ../../library/stdtypes.rst:1236
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""
"Использование пары круглых скобок для обозначения пустого кортежа: ``()``"

#: ../../library/stdtypes.rst:1237
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""
"Использование завершающей запятой для одноэлементного кортежа: ``а,`` или "
"``(а,)``"

#: ../../library/stdtypes.rst:1238
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "Разделение элементов запятыми: ``а, б, в`` или ``(а, б, в)``"

#: ../../library/stdtypes.rst:1239
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""
"Используя :func:`кортеж` встроенный: ``кортеж()`` или ``кортеж(итерируемый)''"

#: ../../library/stdtypes.rst:1241
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"Конструктор создает кортеж, элементы которого такие же и в том же порядке, "
"что и элементы *iterable*. *iterable* может быть последовательностью, "
"контейнером, поддерживающим итерацию, или объектом-итератором. Если "
"*iterable* уже является кортежем, он возвращается без изменений. Например, "
"``кортеж('abc')`` возвращает ``('a', 'b', 'c')`` и ``кортеж( [1, 2, 3] )`` "
"возвращает ``(1, 2, 3)`` . Если аргумент не указан, конструктор создает "
"новый пустой кортеж. ``()`` ."

#: ../../library/stdtypes.rst:1249
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Обратите внимание, что на самом деле кортеж образует запятая, а не круглые "
"скобки. Круглые скобки необязательны, за исключением случая пустого кортежа "
"или случаев, когда они необходимы во избежание синтаксической "
"двусмысленности. Например, ``f(a, b, c)`` — это вызов функции с тремя "
"аргументами, а ``f((a, b, c))`` — это вызов функции с тройкой в ​​качестве "
"единственного аргумента."

#: ../../library/stdtypes.rst:1255
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Кортежи реализуют все :ref:`common\n"
"`последовательность операций."

#: ../../library/stdtypes.rst:1258
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"Для разнородных коллекций данных, где доступ по имени более понятен, чем "
"доступ по индексу, :func:`collections.namedtuple` может быть более "
"подходящим выбором, чем простой объект-кортеж."

#: ../../library/stdtypes.rst:1266
msgid "Ranges"
msgstr "Диапазоны"

#: ../../library/stdtypes.rst:1270
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
"The :class:`диапазон` Тип представляет неизменяемую последовательность чисел "
"и обычно используется для повторения определенного количества раз в :keyword:"
"`для` петли."

#: ../../library/stdtypes.rst:1277
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the ``__index__`` special "
"method).  If the *step* argument is omitted, it defaults to ``1``. If the "
"*start* argument is omitted, it defaults to ``0``. If *step* is zero, :exc:"
"`ValueError` is raised."
msgstr ""

#: ../../library/stdtypes.rst:1283
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Для положительного *шага* содержимое диапазона ``р`` определяются по формуле "
"``r[i] = начало + шаг*i`` где ``я >= 0`` и ``r[i] <стоп`` ."

#: ../../library/stdtypes.rst:1287
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"При отрицательном *шаге* содержимое диапазона по-прежнему определяется по "
"формуле ``r[i] = начало + шаг*i`` , но ограничения ``я >= 0`` и ``r[i] > "
"стоп`` ."

#: ../../library/stdtypes.rst:1291
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Объект диапазона будет пустым, если ``r[0]`` не соответствует ценностному "
"ограничению. Диапазоны поддерживают отрицательные индексы, но они "
"интерпретируются как индексация с конца последовательности, определяемой "
"положительными индексами."

#: ../../library/stdtypes.rst:1296
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"Диапазоны, содержащие абсолютные значения, превышающие :data:`sys.maxsize` "
"разрешены, но некоторые функции (например, :func:`лен` ) может поднять :exc:"
"`OverflowError` ."

#: ../../library/stdtypes.rst:1300
msgid "Range examples::"
msgstr "Примеры диапазонов::"

#: ../../library/stdtypes.rst:1317
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"Диапазоны реализуют все :ref:`common\n"
"` операции с последовательностями, за исключением конкатенации и повторения "
"(поскольку объекты диапазона могут представлять только последовательности, "
"которые следуют строгому шаблону, а повторение и конкатенация обычно "
"нарушают этот шаблон)."

#: ../../library/stdtypes.rst:1324
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr "Значение параметра *start* (или ``0`` если параметр не был указан)"

#: ../../library/stdtypes.rst:1329
msgid "The value of the *stop* parameter"
msgstr "Значение параметра *stop*"

#: ../../library/stdtypes.rst:1333
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr "Значение параметра *step* (или ``1`` если параметр не был указан)"

#: ../../library/stdtypes.rst:1336
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
"Преимущество :class:`диапазон` печатать поверх обычного :class:`список` или :"
"class:`кортеж` это :class:`диапазон` объект всегда будет занимать один и тот "
"же (небольшой) объем памяти, независимо от размера представляемого им "
"диапазона (поскольку он хранит только ``старт`` , ``стоп`` и ``шаг`` "
"значений, вычисляя отдельные позиции и поддиапазоны по мере необходимости)."

#: ../../library/stdtypes.rst:1342
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Объекты диапазона реализуют :class:`collections.abc.Sequence` ABC и "
"предоставляют такие функции, как тесты на сдерживание, поиск по индексу "
"элементов, нарезку и поддержку отрицательных индексов (см. :ref:`typesseq` ):"

#: ../../library/stdtypes.rst:1362
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"Проверка объектов диапазона на равенство с ``==`` и ``!=`` сравнивает их как "
"последовательности. То есть два объекта диапазона считаются равными, если "
"они представляют одну и ту же последовательность значений. (Обратите "
"внимание, что два объекта диапазона, которые сравниваются равными, могут "
"иметь разные :attr:`~range.start` , :attr:`~range.stop` и :attr:`~range."
"step` атрибуты, например ``диапазон(0) == диапазон(2, 1, 3)`` или "
"``диапазон(0, 3, 2) == диапазон(0, 4, 2)`` .)"

#: ../../library/stdtypes.rst:1369
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Реализуйте последовательность ABC. Поддержка нарезки и отрицательных "
"индексов. Тест :класс:`int` объекты для членства в постоянное время вместо "
"перебора всех элементов."

#: ../../library/stdtypes.rst:1375
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"Определите '==' и '!=' для сравнения объектов диапазона на основе "
"последовательности значений, которые они определяют (вместо сравнения на "
"основе идентичности объекта)."

#: ../../library/stdtypes.rst:1380
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""

#: ../../library/stdtypes.rst:1386
msgid ""
"The `linspace recipe <http://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range suitable for floating point "
"applications."
msgstr ""

#: ../../library/stdtypes.rst:1398
msgid "Text Sequence Type --- :class:`str`"
msgstr "Тип текстовой последовательности --- :class:`str`"

#: ../../library/stdtypes.rst:1400
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"Текстовые данные в Python обрабатываются с помощью :class:`str` объекты или :"
"dfn:`strings`. Строки неизменяемы :ref:`sequences\n"
"` кодовых точек Юникода. Строковые литералы записываются разными способами:"

#: ../../library/stdtypes.rst:1405
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Одиночные кавычки: ``'allows embedded \"double\" quotes'``"

#: ../../library/stdtypes.rst:1406
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``."
msgstr ""

#: ../../library/stdtypes.rst:1407
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr ""
"Тройное цитирование: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"

#: ../../library/stdtypes.rst:1409
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"Строки в тройных кавычках могут занимать несколько строк — все связанные "
"пробелы будут включены в строковый литерал."

#: ../../library/stdtypes.rst:1412
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Строковые литералы, являющиеся частью одного выражения и между которыми есть "
"только пробелы, будут неявно преобразованы в один строковый литерал. То "
"есть, ``(\"спам\" \"яйца\") == \"спам яйца\"`` ."

#: ../../library/stdtypes.rst:1416
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""

#: ../../library/stdtypes.rst:1420
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Строки также могут быть созданы из других объектов с помощью :class:`str` "
"конструктор."

#: ../../library/stdtypes.rst:1423
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Поскольку отдельного типа «символ» не существует, индексация строки создает "
"строки длины 1. То есть для непустой строки *s*, ``s[0] == s[0:1]`` ."

#: ../../library/stdtypes.rst:1429
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Также нет изменяемого типа строки, но :meth:`str.join` или :class:`io."
"StringIO` может использоваться для эффективного создания строк из нескольких "
"фрагментов."

#: ../../library/stdtypes.rst:1433
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Для обратной совместимости с серией Python 2 ``в'' префикс снова разрешен "
"для строковых литералов. Он не влияет на значение строковых литералов и не "
"может комбинироваться с ``р`` префикс."

#: ../../library/stdtypes.rst:1445
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"Вернуть :ref:`строку\n"
"`версия *объекта*. Если *object* не указан, возвращается пустая строка. В "
"противном случае поведение ``стр()`` зависит от того, задано ли "
"*кодирование* или *ошибки*, следующим образом."

#: ../../library/stdtypes.rst:1449
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`object.__str__() <object.__str__>`, which is the \"informal\" or nicely "
"printable string representation of *object*.  For string objects, this is "
"the string itself.  If *object* does not have a :meth:`~object.__str__` "
"method, then :func:`str` falls back to returning :meth:`repr(object) <repr>`."
msgstr ""

#: ../../library/stdtypes.rst:1460
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"Если указан хотя бы один из *кодирования* или *ошибок*, *объект* должен "
"быть :term:`байтоподобным объектом` (например, :class:`байты` или :class:"
"`bytearray` ). В этом случае, если *объект* является :class:`байты` (или :"
"class:`bytearray` ) объект, то ``str(байты, кодировка, ошибки)`` "
"эквивалентно :meth:`bytes.decode(кодировка, ошибки) <bytes.decode>` . В "
"противном случае объект байтов, лежащий в основе объекта буфера, получается "
"перед вызовом. :meth:`bytes.decode` . Видеть :ref:`binaryseq` и :ref:"
"`bufferobjects` для получения информации о буферных объектах."

#: ../../library/stdtypes.rst:1469
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Прохождение :class:`байты` возражать против :func:`str` без аргументов "
"*encoding* или *errors* подпадает под первый случай возврата неформального "
"строкового представления (см. также :option:`-b` опция командной строки для "
"Python). Например::"

#: ../../library/stdtypes.rst:1477
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"Для получения дополнительной информации о ``ул`` класс и его методы, см. :"
"ref:`textseq` и :ref:`строковые методы` раздел ниже. Чтобы вывести "
"форматированные строки, см. :ref:`Ф-струны` и :ref:`formatstrings` разделы. "
"Кроме того, см. :ref:`stringservices` раздел."

#: ../../library/stdtypes.rst:1489
msgid "String Methods"
msgstr "Методы строк"

#: ../../library/stdtypes.rst:1494
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Строки реализуют все :ref:`common\n"
"` операции последовательности, а также дополнительные методы, описанные ниже."

#: ../../library/stdtypes.rst:1497
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Строки также поддерживают два стиля форматирования строк, один из которых "
"обеспечивает большую степень гибкости и настройки (см. :meth:`str.format` , :"
"ref:`formatstrings` и :ref:`форматирование строк` ) и другой на основе C "
"``printf`` форматирование стиля, которое обрабатывает более узкий диапазон "
"типов и его немного сложнее правильно использовать, но часто быстрее в тех "
"случаях, когда оно может обрабатываться ( :ref:`старое форматирование "
"строк` )."

#: ../../library/stdtypes.rst:1504
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"The :ref:`текстовые сервисы` раздел стандартной библиотеки охватывает ряд "
"других модулей, которые предоставляют различные утилиты, связанные с текстом "
"(включая поддержку регулярных выражений в :mod:`re` модуль)."

#: ../../library/stdtypes.rst:1510
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""
"Верните копию строки, в которой первый символ записан с заглавной буквы, а "
"остальные — строчными."

#: ../../library/stdtypes.rst:1513
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""
"Первый символ теперь отображается в заглавном, а не в верхнем регистре. Это "
"означает, что в таких символах, как орграфы, заглавной будет только первая "
"буква, а не полный символ."

#: ../../library/stdtypes.rst:1520
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Верните копию строки в свёрнутом регистре. Строки в регистре можно "
"использовать для сопоставления без регистра."

#: ../../library/stdtypes.rst:1523
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"Свертывание регистра похоже на преобразование нижнего регистра, но более "
"агрессивно, поскольку оно предназначено для удаления всех различий в "
"регистре в строке. Например, немецкая строчная буква ``'ß'`` эквивалентно "
"``\"сс\"`` . Поскольку оно уже в нижнем регистре, :meth:`нижний` ничего бы "
"не сделал, чтобы ``'ß'`` ; :meth:`casefold` преобразует его в ``\"сс\"`` ."

#: ../../library/stdtypes.rst:1529
msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr ""

#: ../../library/stdtypes.rst:1537
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Возврат по центру строки длиной *ширина*. Заполнение выполняется с "
"использованием указанного *fillchar* (по умолчанию используется пробел "
"ASCII). Исходная строка возвращается, если *ширина* меньше или равна "
"``лен(ы)`` ."

#: ../../library/stdtypes.rst:1545
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Возвращает количество непересекающихся вхождений подстроки *sub* в диапазоне "
"[*start*, *end*]. Необязательные аргументы *start* и *end* интерпретируются "
"как в нотации среза."

#: ../../library/stdtypes.rst:1552
msgid ""
"Return an encoded version of the string as a bytes object. Default encoding "
"is ``'utf-8'``. *errors* may be given to set a different error handling "
"scheme. The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`. Other possible values are ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` and any other "
"name registered via :func:`codecs.register_error`, see section :ref:`error-"
"handlers`. For a list of possible encodings, see section :ref:`standard-"
"encodings`."
msgstr ""

#: ../../library/stdtypes.rst:1561
msgid "Support for keyword arguments added."
msgstr ""

#: ../../library/stdtypes.rst:1567
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"Возвращаться ``Правда`` если строка заканчивается указанным *суффиксом*, в "
"противном случае верните ``Ложь`` . *suffix* также может представлять собой "
"кортеж суффиксов, которые нужно искать. Если используется необязательный "
"*start*, тест начинается с этой позиции. Если используется необязательный "
"*end*, остановите сравнение в этой позиции."

#: ../../library/stdtypes.rst:1575
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"Возвращает копию строки, в которой все символы табуляции заменены одним или "
"несколькими пробелами, в зависимости от текущего столбца и заданного размера "
"табуляции. Позиции табуляции встречаются через каждые символы *tabsize* (по "
"умолчанию — 8, что соответствует позициям табуляции в столбцах 0, 8, 16 и т. "
"д.). Чтобы расширить строку, текущий столбец устанавливается на ноль, и "
"строка проверяется посимвольно. Если символ представляет собой табуляцию "
"( ``\\t`` ), в результат вставляются один или несколько символов пробела, "
"пока текущий столбец не сравняется со следующей позицией табуляции. (Сам "
"символ табуляции не копируется.) Если символ представляет собой новую строку "
"( ``\\n`` ) или вернуть ( ``\\r`` ), он копируется, и текущий столбец "
"сбрасывается в ноль. Любой другой символ копируется без изменений, а текущий "
"столбец увеличивается на единицу независимо от того, как символ представлен "
"при печати."

#: ../../library/stdtypes.rst:1596
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"Возвращает самый низкий индекс в строке, где в срезе находится подстрока "
"*sub*. ``s[начало:конец]`` . Необязательные аргументы *start* и *end* "
"интерпретируются как в нотации среза. Возвращаться ``-1`` если *sub* не "
"найден."

#: ../../library/stdtypes.rst:1602
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"The :meth:`~str.find` метод следует использовать только в том случае, если "
"вам нужно знать положение *sub*. Чтобы проверить, является ли *sub* "
"подстрокой или нет, используйте команду :keyword:`в` оператор::"

#: ../../library/stdtypes.rst:1612
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"Выполните операцию форматирования строки. Строка, для которой вызывается "
"этот метод, может содержать литеральный текст или поля замены, разделенные "
"фигурными скобками. ``{}`` . Каждое поле замены содержит либо числовой "
"индекс позиционного аргумента, либо имя аргумента ключевого слова. "
"Возвращает копию строки, в которой каждое поле замены заменяется строковым "
"значением соответствующего аргумента."

#: ../../library/stdtypes.rst:1622
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Видеть :ref:`formatstrings` для описания различных параметров "
"форматирования, которые можно указать в строках формата."

#: ../../library/stdtypes.rst:1626
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"При форматировании числа ( :класс:`int` , :class:`плавать` , :class:"
"`сложный` , :class:`decimal.Decimal` и подклассы) с ``н`` тип (например: "
"``'{:n}'.format(1234)`` ), функция временно устанавливает ``LC_CTYPE`` "
"локаль для ``LC_NUMERIC`` локаль для декодирования ``десятичная_точка`` и "
"``тысячи_сентября`` поля :c:func:`localeconv` если они не ASCII или длиннее "
"1 байта, и ``LC_NUMERIC`` локаль отличается от ``LC_CTYPE`` локаль. Это "
"временное изменение влияет на другие потоки."

#: ../../library/stdtypes.rst:1635
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"При форматировании числа с помощью ``н`` тип, функция временно устанавливает "
"``LC_CTYPE`` локаль для ``LC_NUMERIC`` локаль в некоторых случаях."

#: ../../library/stdtypes.rst:1643
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"Похоже на: ``str.format(**отображение)`` , за исключением того, что "
"``картографирование`` используется напрямую, а не копируется в :class:"
"`dict` . Это полезно, если, например, ``картографирование`` это подкласс "
"dict:"

#: ../../library/stdtypes.rst:1659
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
"Нравиться :meth:`~str.find` , но поднять :exc:`ValueError` когда подстрока "
"не найдена."

#: ../../library/stdtypes.rst:1665
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Возвращаться ``Правда`` если все символы в строке буквенно-цифровые и есть "
"хотя бы один символ, ``Ложь`` в противном случае. Персонаж ``с`` является "
"буквенно-цифровым, если возвращается одно из следующих значений ``Правда`` : "
"``c.isalpha()`` , ``c.isdecimal()`` , ``c.isdigit()`` , или ``c."
"isnumeric()`` ."

#: ../../library/stdtypes.rst:1673
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the "
"\"Alphabetic\" property defined in the Unicode Standard."
msgstr ""

#: ../../library/stdtypes.rst:1682
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""
"Возвращаться ``Правда`` если строка пуста или все символы в ней являются "
"ASCII, ``Ложь`` в противном случае. Символы ASCII имеют кодовые точки в "
"диапазоне от U+0000 до U+007F."

#: ../../library/stdtypes.rst:1691
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""
"Возвращаться ``Правда`` если все символы в строке являются десятичными "
"символами и существует хотя бы один символ, ``Ложь`` в противном случае. "
"Десятичные символы — это те символы, которые можно использовать для "
"формирования чисел по основанию 10, например U+0660, АРАБСКАЯ-ИНДИЙСКАЯ "
"ЦИФРА НОЛЬ. Формально десятичный символ — это символ общей категории Юникода "
"«Nd»."

#: ../../library/stdtypes.rst:1701
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Возвращаться ``Правда`` если все символы в строке являются цифрами и имеется "
"хотя бы один символ, ``Ложь`` в противном случае. Цифры включают десятичные "
"символы и цифры, требующие специальной обработки, например цифры верхнего "
"индекса совместимости. Сюда входят цифры, которые нельзя использовать для "
"образования чисел по основанию 10, например числа Харости. Формально цифра — "
"это символ, имеющий значение свойства Numeric_Type=Digit или "
"Numeric_Type=Decimal."

#: ../../library/stdtypes.rst:1711
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""
"Возвращаться ``Правда`` если строка является допустимым идентификатором в "
"соответствии с определением языка, раздел :ref:`идентификаторы` ."

#: ../../library/stdtypes.rst:1714
msgid ""
"Call :func:`keyword.iskeyword` to test whether string ``s`` is a reserved "
"identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""

#: ../../library/stdtypes.rst:1717
msgid "Example: ::"
msgstr "Пример: ::"

#: ../../library/stdtypes.rst:1730
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Возвращаться ``Правда`` если все символы в регистре [4]_ в строке написаны "
"строчными буквами и есть хотя бы один регистровый символ, ``Ложь`` в "
"противном случае."

#: ../../library/stdtypes.rst:1736
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"Возвращаться ``Правда`` если все символы в строке являются цифрами и имеется "
"хотя бы один символ, ``Ложь`` в противном случае. К числовым символам "
"относятся цифры и все символы, имеющие свойство числового значения Юникода, "
"например U+2155, ОБЫЧНАЯ ДРОБЬ ОДНА ПЯТАЯ. Формально числовыми символами "
"являются символы со значением свойства Numeric_Type=Digit, "
"Numeric_Type=Decimal или Numeric_Type=Numeric."

#: ../../library/stdtypes.rst:1746
msgid ""
"Return ``True`` if all characters in the string are printable or the string "
"is empty, ``False`` otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Возвращаться ``Правда`` если все символы в строке доступны для печати или "
"строка пуста, ``Ложь`` в противном случае. Непечатаемые символы — это "
"символы, определенные в базе данных символов Юникода как «Другие» или "
"«Разделители», за исключением пробела ASCII (0x20), который считается "
"печатаемым. (Обратите внимание, что печатные символы в этом контексте — это "
"те символы, которые не следует экранировать при :func:`repr` вызывается для "
"строки. Это не имеет никакого отношения к обработке строк, записанных в :"
"data:`sys.stdout` или :data:`sys.stderr` .)"

#: ../../library/stdtypes.rst:1757
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""
"Возвращаться ``Правда`` если в строке есть только пробельные символы и есть "
"хотя бы один символ, ``Ложь`` в противном случае."

#: ../../library/stdtypes.rst:1760
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"Символ является *пробелом*, если он находится в базе данных символов Юникода "
"(см. :mod:`unicodedata` ), либо его общая категория ``Зс`` («Разделитель, "
"пробел»), или его двунаправленный класс является одним из ``WS`` , ``Б`` , "
"или ``С`` ."

#: ../../library/stdtypes.rst:1768
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"Возвращаться ``Правда`` если строка представляет собой строку с заголовком и "
"содержит хотя бы один символ, например, символы верхнего регистра могут "
"следовать только за символами без регистра, а символы нижнего регистра - "
"только за символами с регистром. Возвращаться ``Ложь`` в противном случае."

#: ../../library/stdtypes.rst:1775
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Возвращаться ``Правда`` если все символы в регистре [4]_ в строке указаны "
"прописные буквы и есть хотя бы один регистровый символ, ``Ложь`` в противном "
"случае."

#: ../../library/stdtypes.rst:1781
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"Возвращает строку, которая представляет собой объединение строк в "
"*iterable*. А :exc:`TypeError` будет поднято, если в *iterable* есть какие-"
"либо нестроковые значения, включая :class:`байты` объекты. Разделителем "
"между элементами является строка, предоставляющая этот метод."

#: ../../library/stdtypes.rst:1789
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Возвращает строку длиной *ширина*, выровненную по левому краю. Заполнение "
"выполняется с использованием указанного *fillchar* (по умолчанию "
"используется пробел ASCII). Исходная строка возвращается, если *ширина* "
"меньше или равна ``лен(ы)`` ."

#: ../../library/stdtypes.rst:1796
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Вернуть копию строки со всеми регистровыми символами [4]_ преобразован в "
"нижний регистр."

#: ../../library/stdtypes.rst:1799
msgid ""
"The lowercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""

#: ../../library/stdtypes.rst:1805
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Верните копию строки с удаленными ведущими символами. Аргумент *chars* "
"представляет собой строку, определяющую набор символов, которые необходимо "
"удалить. Если опущено или ``Нет`` , аргумент *chars* по умолчанию удаляет "
"пробелы. Аргумент *chars* не является префиксом; скорее, все комбинации его "
"значений удаляются::"

#: ../../library/stdtypes.rst:1818
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Этот статический метод возвращает таблицу перевода, пригодную для :meth:`str."
"translate` ."

#: ../../library/stdtypes.rst:1820
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Если имеется только один аргумент, это должен быть словарь, отображающий "
"порядковые номера Юникода (целые числа) или символы (строки длины 1) в "
"порядковые номера Юникода, строки (произвольной длины) или ``Нет`` . Ключи "
"символов будут преобразованы в порядковые номера."

#: ../../library/stdtypes.rst:1825
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"Если есть два аргумента, они должны быть строками одинаковой длины, и в "
"результирующем словаре каждый символ x будет сопоставлен с символом в той же "
"позиции в y. Если есть третий аргумент, это должна быть строка, символы "
"которой будут сопоставлены с ``Нет`` в результате."

#: ../../library/stdtypes.rst:1833
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Разделите строку при первом появлении *sep* и верните кортеж из трех частей, "
"содержащий часть перед разделителем, сам разделитель и часть после "
"разделителя. Если разделитель не найден, верните тройной кортеж, содержащий "
"саму строку, за которой следуют две пустые строки."

#: ../../library/stdtypes.rst:1841
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""

#: ../../library/stdtypes.rst:1848
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Возвращает наибольший индекс в строке, где найдена подстрока *sub*, такая, "
"что *sub* содержится внутри ``s[начало:конец]`` . Необязательные аргументы "
"*start* и *end* интерпретируются как в нотации среза. Возвращаться ``-1`` "
"при неудаче."

#: ../../library/stdtypes.rst:1855
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Нравиться :meth:`rfind` но поднимает :exc:`ValueError` когда подстрока *sub* "
"не найдена."

#: ../../library/stdtypes.rst:1861
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Возвращает строку длиной *ширина*, выровненную по правому краю. Заполнение "
"выполняется с использованием указанного *fillchar* (по умолчанию "
"используется пробел ASCII). Исходная строка возвращается, если *ширина* "
"меньше или равна ``лен(ы)`` ."

#: ../../library/stdtypes.rst:1868
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Разделите строку по последнему вхождению *sep* и верните тройной кортеж, "
"содержащий часть перед разделителем, сам разделитель и часть после "
"разделителя. Если разделитель не найден, верните тройной кортеж, содержащий "
"две пустые строки, за которыми следует сама строка."

#: ../../library/stdtypes.rst:1876
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Возвращает список слов в строке, используя *sep* в качестве строки-"
"разделителя. Если указано *maxsplit*, выполняется не более *maxsplit* "
"разбиений, *самых правых*. Если *sep* не указано или ``Нет`` , любая строка "
"пробелов является разделителем. За исключением раскола справа, :meth:"
"`rsplit` ведет себя как :meth:`сплит` что подробно описано ниже."

#: ../../library/stdtypes.rst:1885
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Верните копию строки с удаленными конечными символами. Аргумент *chars* "
"представляет собой строку, определяющую набор символов, которые необходимо "
"удалить. Если опущено или ``Нет`` , аргумент *chars* по умолчанию удаляет "
"пробелы. Аргумент *chars* не является суффиксом; скорее, все комбинации его "
"значений удаляются::"

#: ../../library/stdtypes.rst:1898
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Возвращает список слов в строке, используя *sep* в качестве строки-"
"разделителя. Если указано *maxsplit*, будет выполнено не более *maxsplit* "
"разбиений (таким образом, в списке будет не более ``макссплит+1`` элементы). "
"Если *maxsplit* не указано или ``-1`` , то количество разбиений не "
"ограничено (сделаны все возможные разбиения)."

#: ../../library/stdtypes.rst:1904
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""

#: ../../library/stdtypes.rst:1910 ../../library/stdtypes.rst:1926
#: ../../library/stdtypes.rst:1978 ../../library/stdtypes.rst:2046
#: ../../library/stdtypes.rst:2109 ../../library/stdtypes.rst:2893
#: ../../library/stdtypes.rst:2909 ../../library/stdtypes.rst:3000
#: ../../library/stdtypes.rst:3016 ../../library/stdtypes.rst:3041
#: ../../library/stdtypes.rst:3055 ../../library/stdtypes.rst:3083
#: ../../library/stdtypes.rst:3097 ../../library/stdtypes.rst:3115
#: ../../library/stdtypes.rst:3142 ../../library/stdtypes.rst:3165
#: ../../library/stdtypes.rst:3192 ../../library/stdtypes.rst:3234
#: ../../library/stdtypes.rst:3258
msgid "For example::"
msgstr "Например::"

#: ../../library/stdtypes.rst:1919
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Если *sep* не указано или ``Нет`` , применяется другой алгоритм разделения: "
"серии последовательных пробелов рассматриваются как один разделитель, и "
"результат не будет содержать пустых строк в начале или конце, если строка "
"имеет начальные или конечные пробелы. Следовательно, разделение пустой "
"строки или строки, состоящей только из пробелов, с помощью ``Нет`` "
"разделитель возвращает ``[]`` ."

#: ../../library/stdtypes.rst:1941
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Возвращает список строк в строке, разрывающихся на границах строк. Разрывы "
"строк не включаются в результирующий список, если не указано значение "
"*keepends* и истинное значение."

#: ../../library/stdtypes.rst:1945
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Этот метод разбивается на следующих границах строк. В частности, границы "
"представляют собой расширенный набор :term:`универсальных символов новой "
"строки`."

#: ../../library/stdtypes.rst:1949
msgid "Representation"
msgstr "Представление"

#: ../../library/stdtypes.rst:1949
msgid "Description"
msgstr "Описание"

#: ../../library/stdtypes.rst:1951
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:1951
msgid "Line Feed"
msgstr "Перевод строки"

#: ../../library/stdtypes.rst:1953
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:1953
msgid "Carriage Return"
msgstr "Возврат каретки"

#: ../../library/stdtypes.rst:1955
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../../library/stdtypes.rst:1955
msgid "Carriage Return + Line Feed"
msgstr "Возврат каретки + перевод строки"

#: ../../library/stdtypes.rst:1957
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` или ``\\x0b``"

#: ../../library/stdtypes.rst:1957
msgid "Line Tabulation"
msgstr "Табуляция строк"

#: ../../library/stdtypes.rst:1959
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` или ``\\x0c``"

#: ../../library/stdtypes.rst:1959
msgid "Form Feed"
msgstr "Перевод каретки"

#: ../../library/stdtypes.rst:1961
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../../library/stdtypes.rst:1961
msgid "File Separator"
msgstr "Разделитель файлов"

#: ../../library/stdtypes.rst:1963
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../../library/stdtypes.rst:1963
msgid "Group Separator"
msgstr "Разделитель групп"

#: ../../library/stdtypes.rst:1965
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../../library/stdtypes.rst:1965
msgid "Record Separator"
msgstr "Разделитель записей"

#: ../../library/stdtypes.rst:1967
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:1967
msgid "Next Line (C1 Control Code)"
msgstr "Следующая строка (код управления C1)"

#: ../../library/stdtypes.rst:1969
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:1969
msgid "Line Separator"
msgstr "Разделитель строк"

#: ../../library/stdtypes.rst:1971
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:1971
msgid "Paragraph Separator"
msgstr "Разделитель абзацев"

#: ../../library/stdtypes.rst:1976
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` и ``\\f`` добавлен в список границ линий."

#: ../../library/stdtypes.rst:1985
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"В отличие от :meth:`~str.split` если указана строка-разделитель *sep*, этот "
"метод возвращает пустой список для пустой строки, а разрыв конечной строки "
"не приводит к появлению дополнительной строки::"

#: ../../library/stdtypes.rst:1994
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Для сравнения: ``split('\\n')`` дает::"

#: ../../library/stdtypes.rst:2004
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Возвращаться ``Правда`` если строка начинается с *префикса*, в противном "
"случае возврат ``Ложь`` . *prefix* также может представлять собой кортеж "
"префиксов для поиска. Если используется необязательный *start*, тестовая "
"строка начинается с этой позиции. Если используется необязательный *end*, "
"прекратите сравнение строки в этой позиции."

#: ../../library/stdtypes.rst:2012
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Верните копию строки с удаленными ведущими и конечными символами. Аргумент "
"*chars* представляет собой строку, определяющую набор символов, которые "
"необходимо удалить. Если опущено или ``Нет`` , аргумент *chars* по умолчанию "
"удаляет пробелы. Аргумент *chars* не является префиксом или суффиксом; "
"скорее, все комбинации его значений удаляются::"

#: ../../library/stdtypes.rst:2023
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"Крайние начальные и конечные значения аргументов *chars* удаляются из "
"строки. Символы удаляются с начального конца до тех пор, пока не будет "
"достигнут строковый символ, не содержащийся в наборе символов в *chars*. "
"Аналогичное действие происходит и на заднем конце. Например::"

#: ../../library/stdtypes.rst:2036
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Возвращает копию строки с символами верхнего регистра, преобразованными в "
"нижний регистр, и наоборот. Обратите внимание, что это не обязательно верно, "
"что ``s.swapcase().swapcase() == s`` ."

#: ../../library/stdtypes.rst:2043
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Возвращает версию строки с заголовком, где слова начинаются с символа "
"верхнего регистра, а остальные символы — строчные."

#: ../../library/stdtypes.rst:2051 ../../library/stdtypes.rst:3202
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"Алгоритм использует простое независимое от языка определение слова как "
"группы последовательных букв. Определение работает во многих контекстах, но "
"это означает, что апострофы в сокращениях и притяжательных падежах образуют "
"границы слов, что может быть нежелательным результатом:"

#: ../../library/stdtypes.rst:2059 ../../library/stdtypes.rst:3210
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Обходной путь для апострофов можно создать с помощью регулярных выражений::"

#: ../../library/stdtypes.rst:2073
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`__getitem__`, typically a :term:`mapping` or :term:"
"`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""

#: ../../library/stdtypes.rst:2082
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"Вы можете использовать :meth:`str.maketrans` для создания карты перевода из "
"посимвольных сопоставлений в разных форматах."

#: ../../library/stdtypes.rst:2085
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"См. также :mod:`кодеки` модуль для более гибкого подхода к пользовательским "
"сопоставлениям символов."

#: ../../library/stdtypes.rst:2091
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Вернуть копию строки со всеми регистровыми символами [4]_ преобразован в "
"верхний регистр. Обратите внимание, что ``s.upper().isupper()`` может быть "
"``Ложь`` если ``с`` содержит символы без регистра или если категория Юникода "
"результирующих символов не «Lu» (буква, верхний регистр), а, например, "
"«Lt» (буква, заглавный регистр)."

#: ../../library/stdtypes.rst:2097
msgid ""
"The uppercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""

#: ../../library/stdtypes.rst:2103
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Вернуть копию строки, заполненной ASCII. ``'0'`` цифры, чтобы получилась "
"строка длиной *ширины*. Ведущий префикс знака ( ``'+'`` / ``'-'`` ) "
"обрабатывается путем вставки дополнения *после* символа знака, а не перед "
"ним. Исходная строка возвращается, если *ширина* меньше или равна "
"``лен(ы)`` ."

#: ../../library/stdtypes.rst:2121
msgid "``printf``-style String Formatting"
msgstr "``printf`` -стиль форматирования строк"

#: ../../library/stdtypes.rst:2134
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""
"Описанные здесь операции форматирования имеют ряд особенностей, которые "
"приводят к ряду распространенных ошибок (например, к неправильному "
"отображению кортежей и словарей). Использование новых форматированных "
"строковых литералов\n"
"`, :meth:`str.format` интерфейс или строки шаблона` может помочь избежать "
"этих ошибок. Каждая из этих альтернатив предлагает свои собственные "
"компромиссы и преимущества простоты, гибкости и/или расширяемости."

#: ../../library/stdtypes.rst:2142
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""

#: ../../library/stdtypes.rst:2148
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Если для *format* требуется один аргумент, *values* может быть одним "
"объектом, не являющимся кортежем. [5]_ В противном случае *значения* должны "
"быть кортежем с количеством элементов, указанным в строке формата, или одним "
"объектом сопоставления (например, словарем)."

#: ../../library/stdtypes.rst:2158 ../../library/stdtypes.rst:3313
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Спецификатор преобразования содержит два или более символов и включает "
"следующие компоненты, которые должны встречаться в следующем порядке:"

#: ../../library/stdtypes.rst:2161 ../../library/stdtypes.rst:3316
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "The ``'%'`` символ, который отмечает начало спецификатора."

#: ../../library/stdtypes.rst:2163 ../../library/stdtypes.rst:3318
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"Ключ сопоставления (необязательно), состоящий из последовательности символов "
"в скобках (например, ``(какое-то имя)`` )."

#: ../../library/stdtypes.rst:2166 ../../library/stdtypes.rst:3321
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Флаги преобразования (необязательно), которые влияют на результат некоторых "
"типов преобразования."

#: ../../library/stdtypes.rst:2169 ../../library/stdtypes.rst:3324
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Минимальная ширина поля (необязательно). Если указано как ``'*'`` "
"(звездочка), фактическая ширина считывается из следующего элемента кортежа в "
"*values*, а преобразуемый объект идет после минимальной ширины поля и "
"дополнительной точности."

#: ../../library/stdtypes.rst:2173 ../../library/stdtypes.rst:3328
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"Точность (необязательно), заданная как ``'.'`` (точка), за которой следует "
"точность. Если указано как ``'*'`` (звездочка), фактическая точность "
"считывается из следующего элемента кортежа в *values*, а преобразуемое "
"значение идет после точности."

#: ../../library/stdtypes.rst:2178 ../../library/stdtypes.rst:3333
msgid "Length modifier (optional)."
msgstr "Модификатор длины (необязательно)."

#: ../../library/stdtypes.rst:2180 ../../library/stdtypes.rst:3335
msgid "Conversion type."
msgstr "Тип приведения."

#: ../../library/stdtypes.rst:2182
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Если правым аргументом является словарь (или другой тип сопоставления), "
"тогда форматы в строке *должны* включать заключенный в круглые скобки ключ "
"сопоставления в этот словарь, вставленный сразу после ``'%'`` характер. Ключ "
"сопоставления выбирает значение для форматирования из сопоставления. "
"Например:"

#: ../../library/stdtypes.rst:2191 ../../library/stdtypes.rst:3346
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"В данном случае нет ``*`` спецификаторы могут встречаться в формате "
"(поскольку они требуют последовательного списка параметров)."

#: ../../library/stdtypes.rst:2194 ../../library/stdtypes.rst:3349
msgid "The conversion flag characters are:"
msgstr "Символы флага преобразования:"

#: ../../library/stdtypes.rst:2203 ../../library/stdtypes.rst:3358
msgid "Flag"
msgstr "Флаг"

#: ../../library/stdtypes.rst:2205 ../../library/stdtypes.rst:3360
msgid "``'#'``"
msgstr "``'#'``"

#: ../../library/stdtypes.rst:2205 ../../library/stdtypes.rst:3360
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""
"Преобразование значений будет использовать «альтернативную форму» (если это "
"определено ниже)."

#: ../../library/stdtypes.rst:2208 ../../library/stdtypes.rst:3363
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:2208 ../../library/stdtypes.rst:3363
msgid "The conversion will be zero padded for numeric values."
msgstr "Преобразование будет дополнено нулями для числовых значений."

#: ../../library/stdtypes.rst:2210 ../../library/stdtypes.rst:3365
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:2210 ../../library/stdtypes.rst:3365
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"Преобразованное значение остается скорректированным (переопределяет ``'0'`` "
"преобразование, если даны оба)."

#: ../../library/stdtypes.rst:2213 ../../library/stdtypes.rst:3368
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:2213 ../../library/stdtypes.rst:3368
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(пробел) Перед положительным числом (или пустой строкой), полученным в "
"результате знакового преобразования, следует оставить пробел."

#: ../../library/stdtypes.rst:2216 ../../library/stdtypes.rst:3371
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:2216 ../../library/stdtypes.rst:3371
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"Знаковый персонаж ( ``'+'`` или ``'-'`` ) будет предшествовать "
"преобразованию (переопределяет флаг «пробел»)."

#: ../../library/stdtypes.rst:2220 ../../library/stdtypes.rst:3375
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Модификатор длины ( ``ч`` , ``л`` , или ``Л`` ) может присутствовать, но "
"игнорируется, поскольку в нем нет необходимости для Python, например ``%ld`` "
"идентичен ``%d`` ."

#: ../../library/stdtypes.rst:2223 ../../library/stdtypes.rst:3378
msgid "The conversion types are:"
msgstr "Типы конверсий:"

#: ../../library/stdtypes.rst:2226 ../../library/stdtypes.rst:3381
msgid "Conversion"
msgstr "Конверсия"

#: ../../library/stdtypes.rst:2228 ../../library/stdtypes.rst:3383
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/stdtypes.rst:2228 ../../library/stdtypes.rst:2230
#: ../../library/stdtypes.rst:3383 ../../library/stdtypes.rst:3385
msgid "Signed integer decimal."
msgstr "Целое десятичное число со знаком."

#: ../../library/stdtypes.rst:2230 ../../library/stdtypes.rst:3385
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/stdtypes.rst:2232 ../../library/stdtypes.rst:3387
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:2232 ../../library/stdtypes.rst:3387
msgid "Signed octal value."
msgstr "Восьмеричное значение со знаком."

#: ../../library/stdtypes.rst:2234 ../../library/stdtypes.rst:3389
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/stdtypes.rst:2234 ../../library/stdtypes.rst:3389
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Устаревший тип -- он идентичен ``'d'`` ."

#: ../../library/stdtypes.rst:2236 ../../library/stdtypes.rst:3391
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:2236 ../../library/stdtypes.rst:3391
msgid "Signed hexadecimal (lowercase)."
msgstr "Шестнадцатеричное число со знаком (строчная буква)."

#: ../../library/stdtypes.rst:2238 ../../library/stdtypes.rst:3393
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/stdtypes.rst:2238 ../../library/stdtypes.rst:3393
msgid "Signed hexadecimal (uppercase)."
msgstr "Шестнадцатеричное число со знаком (заглавные буквы)."

#: ../../library/stdtypes.rst:2240 ../../library/stdtypes.rst:3395
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/stdtypes.rst:2240 ../../library/stdtypes.rst:3395
msgid "Floating point exponential format (lowercase)."
msgstr ""

#: ../../library/stdtypes.rst:2242 ../../library/stdtypes.rst:3397
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:2242 ../../library/stdtypes.rst:3397
msgid "Floating point exponential format (uppercase)."
msgstr ""

#: ../../library/stdtypes.rst:2244 ../../library/stdtypes.rst:3399
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/stdtypes.rst:2244 ../../library/stdtypes.rst:2246
#: ../../library/stdtypes.rst:3399 ../../library/stdtypes.rst:3401
msgid "Floating point decimal format."
msgstr ""

#: ../../library/stdtypes.rst:2246 ../../library/stdtypes.rst:3401
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/stdtypes.rst:2248 ../../library/stdtypes.rst:3403
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/stdtypes.rst:2248 ../../library/stdtypes.rst:3403
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../library/stdtypes.rst:2252 ../../library/stdtypes.rst:3407
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/stdtypes.rst:2252 ../../library/stdtypes.rst:3407
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../library/stdtypes.rst:2256 ../../library/stdtypes.rst:3411
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/stdtypes.rst:2256
msgid "Single character (accepts integer or single character string)."
msgstr "Одиночный символ (принимает целое число или строку из одного символа)."

#: ../../library/stdtypes.rst:2259 ../../library/stdtypes.rst:3424
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:2259
msgid "String (converts any Python object using :func:`repr`)."
msgstr "String (преобразует любой объект Python, используя :func:`repr` )."

#: ../../library/stdtypes.rst:2262 ../../library/stdtypes.rst:3418
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/stdtypes.rst:2262
msgid "String (converts any Python object using :func:`str`)."
msgstr "String (преобразует любой объект Python, используя :func:`str` )."

#: ../../library/stdtypes.rst:2265 ../../library/stdtypes.rst:3421
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/stdtypes.rst:2265
msgid "String (converts any Python object using :func:`ascii`)."
msgstr "String (преобразует любой объект Python, используя :func:`ascii` )."

#: ../../library/stdtypes.rst:2268 ../../library/stdtypes.rst:3427
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:2268 ../../library/stdtypes.rst:3427
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"Никакой аргумент не преобразуется, в результате ``'%'`` характер результата."

#: ../../library/stdtypes.rst:2275 ../../library/stdtypes.rst:3434
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"Альтернативная форма приводит к использованию ведущего восьмеричного "
"спецификатора ( ``'0о'`` ), который нужно вставить перед первой цифрой."

#: ../../library/stdtypes.rst:2279 ../../library/stdtypes.rst:3438
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"Альтернативная форма вызывает ведущее ``'0x'`` или ``'0X'`` (в зависимости "
"от того, ``'х'`` или ``'Х'`` использовался формат) для вставки перед первой "
"цифрой."

#: ../../library/stdtypes.rst:2283 ../../library/stdtypes.rst:3442
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"Альтернативная форма приводит к тому, что результат всегда содержит "
"десятичную точку, даже если за ней не следуют никакие цифры."

#: ../../library/stdtypes.rst:2286 ../../library/stdtypes.rst:3445
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"Точность определяет количество цифр после десятичной точки и по умолчанию "
"равна 6."

#: ../../library/stdtypes.rst:2290 ../../library/stdtypes.rst:3449
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"Альтернативная форма приводит к тому, что результат всегда содержит "
"десятичную точку, а конечные нули не удаляются, как это было бы в противном "
"случае."

#: ../../library/stdtypes.rst:2293 ../../library/stdtypes.rst:3452
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"Точность определяет количество значащих цифр до и после десятичной точки и "
"по умолчанию равна 6."

#: ../../library/stdtypes.rst:2297 ../../library/stdtypes.rst:3456
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "Если точность ``Н`` , вывод усекается до ``Н`` персонажи."

#: ../../library/stdtypes.rst:2300 ../../library/stdtypes.rst:3465
msgid "See :pep:`237`."
msgstr "См. :pep:`237`."

#: ../../library/stdtypes.rst:2302
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Поскольку строки Python имеют явную длину, ``%s`` преобразования не "
"предполагают, что ``'\\0'`` это конец строки."

#: ../../library/stdtypes.rst:2307
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"``%f`` преобразования для чисел, абсолютное значение которых превышает 1e50, "
"больше не заменяются на ``%g`` конверсии."

#: ../../library/stdtypes.rst:2318
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"Типы двоичных последовательностей --- :class:`байты` , :class:`bytearray` , :"
"class:`memoryview`"

#: ../../library/stdtypes.rst:2326
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"Основные встроенные типы для управления двоичными данными: :class:`байты` и :"
"class:`bytearray` . Их поддерживают :class:`memoryview` который использует "
"протокол :ref:`buffer\n"
"` для доступа к памяти других двоичных объектов без необходимости создания "
"копии."

#: ../../library/stdtypes.rst:2331
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
"The :mod:`массив` Модуль поддерживает эффективное хранение базовых типов "
"данных, таких как 32-битные целые числа и плавающие значения двойной "
"точности IEEE754."

#: ../../library/stdtypes.rst:2337
msgid "Bytes Objects"
msgstr "Байтовые объекты"

#: ../../library/stdtypes.rst:2341
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"Объекты Bytes представляют собой неизменяемые последовательности отдельных "
"байтов. Поскольку многие основные двоичные протоколы основаны на текстовой "
"кодировке ASCII, объекты bytes предлагают несколько методов, которые "
"действительны только при работе с данными, совместимыми с ASCII, и тесно "
"связаны со строковыми объектами множеством других способов."

#: ../../library/stdtypes.rst:2348
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"Во-первых, синтаксис байтовых литералов во многом такой же, как и для "
"строковых литералов, за исключением того, что ``б`` добавлен префикс:"

#: ../../library/stdtypes.rst:2351
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "Одиночные кавычки: ``b'still allows embedded \"double\" quotes'``"

#: ../../library/stdtypes.rst:2352
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``."
msgstr ""

#: ../../library/stdtypes.rst:2353
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"Тройное цитирование: ``b'''3 single quotes'''``, ``b\"\"\"3 double "
"quotes\"\"\"``"

#: ../../library/stdtypes.rst:2355
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"В байтовых литералах разрешены только символы ASCII (независимо от "
"заявленной кодировки исходного кода). Любые двоичные значения больше 127 "
"необходимо вводить в байтовые литералы, используя соответствующую escape-"
"последовательность."

#: ../../library/stdtypes.rst:2359
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"Как и строковые литералы, байтовые литералы также могут использовать ``р`` "
"префикс для отключения обработки escape-последовательностей. Видеть :ref:"
"`строки` подробнее о различных формах байтовых литералов, включая "
"поддерживаемые escape-последовательности."

#: ../../library/stdtypes.rst:2363
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"В то время как литералы и представления байтов основаны на тексте ASCII, "
"объекты байтов фактически ведут себя как неизменяемые последовательности "
"целых чисел, при этом каждое значение в последовательности ограничено таким "
"образом, что ``0 <= x < 256`` (попытки нарушить это ограничение вызовут :exc:"
"`ValueError` ). Это сделано намеренно, чтобы подчеркнуть, что, хотя многие "
"двоичные форматы включают элементы на основе ASCII и ими можно с пользой "
"манипулировать с помощью некоторых тексто-ориентированных алгоритмов, обычно "
"это не относится к произвольным двоичным данным (слепое применение "
"алгоритмов обработки текста к форматам двоичных данных, которые не являются "
"Совместимость с ASCII обычно приводит к повреждению данных)."

#: ../../library/stdtypes.rst:2373
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""
"Помимо литеральных форм, объекты bytes можно создавать и другими способами:"

#: ../../library/stdtypes.rst:2376
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr "Объект указанной длины с нулевым заполнением байтов: ``байты(10)``"

#: ../../library/stdtypes.rst:2377
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "Объект указанной длины с нулевым заполнением байтов: ``байты(10)``"

#: ../../library/stdtypes.rst:2378
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Копирование существующих двоичных данных через протокол буфера: "
"``байты(obj)``"

#: ../../library/stdtypes.rst:2380
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr ""
"Также см. :ref:`bytes\n"
"` встроенный."

#: ../../library/stdtypes.rst:2382
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"Поскольку две шестнадцатеричные цифры точно соответствуют одному байту, "
"шестнадцатеричные числа являются широко используемым форматом для описания "
"двоичных данных. Соответственно, тип bytes имеет дополнительный метод класса "
"для чтения данных в этом формате:"

#: ../../library/stdtypes.rst:2388
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Этот :class:`байты` Метод класса возвращает объект байтов, декодируя "
"заданный строковый объект. Строка должна содержать две шестнадцатеричные "
"цифры на байт, при этом пробелы ASCII игнорируются."

#: ../../library/stdtypes.rst:2395
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
":meth:`bytes.fromhex` теперь пропускает все пробелы ASCII в строке, а не "
"только пробелы."

#: ../../library/stdtypes.rst:2399
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"Существует функция обратного преобразования для преобразования байтового "
"объекта в его шестнадцатеричное представление."

#: ../../library/stdtypes.rst:2404 ../../library/stdtypes.rst:2498
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"Возвращает строковый объект, содержащий две шестнадцатеричные цифры для "
"каждого байта экземпляра."

#: ../../library/stdtypes.rst:2410
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default "
"between each byte.  A second optional *bytes_per_sep* parameter controls the "
"spacing.  Positive values calculate the separator position from the right, "
"negative values from the left."
msgstr ""

#: ../../library/stdtypes.rst:2426
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""
":meth:`bytes.hex` теперь поддерживает дополнительные параметры *sep* и "
"*bytes_per_sep* для вставки разделителей между байтами в шестнадцатеричном "
"выводе."

#: ../../library/stdtypes.rst:2430
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"Поскольку объекты bytes представляют собой последовательности целых чисел "
"(сродни кортежу), для объекта bytes *b*, ``b[0]`` будет целым числом, а "
"``б[0:1]`` будет байтовым объектом длиной 1. (Это контрастирует с текстовыми "
"строками, где индексация и нарезка создают строку длины 1)"

#: ../../library/stdtypes.rst:2435
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"Представление объектов байтов использует литеральный формат ( ``б'...'`` ), "
"так как это часто более полезно, чем, например, ``байты([46, 46, 46])`` . Вы "
"всегда можете преобразовать объект байтов в список целых чисел, используя "
"``список(б)`` ."

#: ../../library/stdtypes.rst:2440
msgid ""
"For Python 2.x users: In the Python 2.x series, a variety of implicit "
"conversions between 8-bit strings (the closest thing 2.x offers to a built-"
"in binary data type) and Unicode strings were permitted. This was a "
"backwards compatibility workaround to account for the fact that Python "
"originally only supported 8-bit text, and Unicode text was a later addition. "
"In Python 3.x, those implicit conversions are gone - conversions between 8-"
"bit binary data and Unicode text must be explicit, and bytes and string "
"objects will always compare unequal."
msgstr ""

#: ../../library/stdtypes.rst:2453
msgid "Bytearray Objects"
msgstr "Объекты байтовых массивов"

#: ../../library/stdtypes.rst:2457
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
":class:`bytearray` объекты являются изменяемым аналогом :class:`байты` "
"объекты."

#: ../../library/stdtypes.rst:2462
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"Для объектов bytearray не существует специального синтаксиса литералов, "
"вместо этого они всегда создаются путем вызова конструктора:"

#: ../../library/stdtypes.rst:2465
msgid "Creating an empty instance: ``bytearray()``"
msgstr "Создание пустого экземпляра: ``bytearray()``"

#: ../../library/stdtypes.rst:2466
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""
"Создание заполненного нулями экземпляра заданной длины: ``bytearray(10)``"

#: ../../library/stdtypes.rst:2467
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "Из итерации целых чисел: ``bytearray(диапазон(20))``"

#: ../../library/stdtypes.rst:2468
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Копирование существующих двоичных данных через протокол буфера: "
"``bytearray(b'Привет!')``"

#: ../../library/stdtypes.rst:2470
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Поскольку объекты bytearray являются изменяемыми, они поддерживают :ref:"
"`mutable\n"
"` операции с последовательностями в дополнение к обычным операциям с байтами "
"и байтовыми массивами, описанным в :ref:`байтовые-методы` ."

#: ../../library/stdtypes.rst:2474
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr ""
"Также см. :ref:`bytearray\n"
"` встроенный."

#: ../../library/stdtypes.rst:2476
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"Поскольку две шестнадцатеричные цифры точно соответствуют одному байту, "
"шестнадцатеричные числа являются широко используемым форматом для описания "
"двоичных данных. Соответственно, тип bytearray имеет дополнительный метод "
"класса для чтения данных в этом формате:"

#: ../../library/stdtypes.rst:2482
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"Этот :class:`bytearray` Метод класса возвращает объект bytearray, декодируя "
"заданный строковый объект. Строка должна содержать две шестнадцатеричные "
"цифры на байт, при этом пробелы ASCII игнорируются."

#: ../../library/stdtypes.rst:2489
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""
":meth:`bytearray.fromhex` теперь пропускает все пробелы ASCII в строке, а не "
"только пробелы."

#: ../../library/stdtypes.rst:2493
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"Существует функция обратного преобразования для преобразования объекта "
"байтового массива в его шестнадцатеричное представление."

#: ../../library/stdtypes.rst:2506
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"Похоже на: :meth:`bytes.hex` , :meth:`bytearray.hex` теперь поддерживает "
"дополнительные параметры *sep* и *bytes_per_sep* для вставки разделителей "
"между байтами в шестнадцатеричном выводе."

#: ../../library/stdtypes.rst:2511
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"Поскольку объекты байтового массива представляют собой последовательности "
"целых чисел (сродни списку), для объекта байтового массива *b*, ``b[0]`` "
"будет целым числом, а ``б[0:1]`` будет объектом байтового массива длины 1. "
"(Это контрастирует с текстовыми строками, где индексация и нарезка создают "
"строку длины 1)"

#: ../../library/stdtypes.rst:2516
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"Для представления объектов bytearray используется литеральный формат байтов "
"( ``bytearray(b'...')`` ), так как это часто более полезно, чем, например, "
"``bytearray([46, 46, 46])`` . Вы всегда можете преобразовать объект "
"bytearray в список целых чисел, используя ``список(б)`` ."

#: ../../library/stdtypes.rst:2525
msgid "Bytes and Bytearray Operations"
msgstr "Байты и операции с байтовыми массивами"

#: ../../library/stdtypes.rst:2530
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"Объекты bytes и bytearray поддерживают :ref:`common\n"
"`последовательность операций. Они взаимодействуют не только с операндами "
"одного и того же типа, но и с любым :term:`байтоподобным объектом`. "
"Благодаря такой гибкости их можно свободно смешивать в операциях, не вызывая "
"ошибок. Однако тип возвращаемого результата может зависеть от порядка "
"операндов."

#: ../../library/stdtypes.rst:2538
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"Методы объектов bytes и bytearray не принимают строки в качестве аргументов, "
"так же как методы строк не принимают в качестве аргументов байты. Например, "
"вам нужно написать::"

#: ../../library/stdtypes.rst:2545
msgid "and::"
msgstr "и::"

#: ../../library/stdtypes.rst:2550
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"Некоторые операции с байтами и массивами байтов предполагают использование "
"двоичных форматов, совместимых с ASCII, и, следовательно, их следует "
"избегать при работе с произвольными двоичными данными. Эти ограничения "
"описаны ниже."

#: ../../library/stdtypes.rst:2555
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"Использование этих операций на основе ASCII для управления двоичными "
"данными, которые не хранятся в формате на основе ASCII, может привести к "
"повреждению данных."

#: ../../library/stdtypes.rst:2558
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"Следующие методы для байтов и объектов bytearray можно использовать с "
"произвольными двоичными данными."

#: ../../library/stdtypes.rst:2564
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Возвращает количество непересекающихся вхождений подпоследовательности *sub* "
"в диапазоне [*start*, *end*]. Необязательные аргументы *start* и *end* "
"интерпретируются как в нотации среза."

#: ../../library/stdtypes.rst:2568 ../../library/stdtypes.rst:2615
#: ../../library/stdtypes.rst:2637 ../../library/stdtypes.rst:2703
#: ../../library/stdtypes.rst:2716
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"Подпоследовательностью для поиска может быть любой :term:`байтовый объект` "
"или целое число в диапазоне от 0 до 255."

#: ../../library/stdtypes.rst:2571 ../../library/stdtypes.rst:2627
#: ../../library/stdtypes.rst:2640 ../../library/stdtypes.rst:2706
#: ../../library/stdtypes.rst:2719
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr ""
"Также примите целое число в диапазоне от 0 до 255 в качестве "
"подпоследовательности."

#: ../../library/stdtypes.rst:2578
msgid ""
"Return a string decoded from the given bytes.  Default encoding is "
"``'utf-8'``. *errors* may be given to set a different error handling "
"scheme.  The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`.  Other possible values are ``'ignore'``, "
"``'replace'`` and any other name registered via :func:`codecs."
"register_error`, see section :ref:`error-handlers`. For a list of possible "
"encodings, see section :ref:`standard-encodings`."
msgstr ""

#: ../../library/stdtypes.rst:2588
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary bytes or "
"bytearray object."
msgstr ""

#: ../../library/stdtypes.rst:2592
msgid "Added support for keyword arguments."
msgstr "Добавлена ​​поддержка аргументов ключевых слов."

#: ../../library/stdtypes.rst:2599
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Возвращаться ``Правда`` если двоичные данные заканчиваются указанным "
"*суффиксом*, в противном случае верните ``Ложь`` . *suffix* также может "
"представлять собой кортеж суффиксов, которые нужно искать. Если используется "
"необязательный *start*, тест начинается с этой позиции. Если используется "
"необязательный *end*, остановите сравнение в этой позиции."

#: ../../library/stdtypes.rst:2604
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr "Суффиксом(ами) для поиска может быть любой :term:`байтовый объект`."

#: ../../library/stdtypes.rst:2610
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"Возвращает самый низкий индекс в данных, где найдена подпоследовательность "
"*sub*, так что *sub* содержится в срезе. ``s[начало:конец]`` . "
"Необязательные аргументы *start* и *end* интерпретируются как в нотации "
"среза. Возвращаться ``-1`` если *sub* не найден."

#: ../../library/stdtypes.rst:2620
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"The :meth:`~bytes.find` метод следует использовать только в том случае, если "
"вам нужно знать положение *sub*. Чтобы проверить, является ли *sub* "
"подстрокой или нет, используйте команду :keyword:`в` оператор::"

#: ../../library/stdtypes.rst:2634
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
"Нравиться :meth:`~bytes.find` , но поднять :exc:`ValueError` когда "
"подпоследовательность не найдена."

#: ../../library/stdtypes.rst:2647
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"Возвращает объект bytes или bytearray, который представляет собой "
"объединение последовательностей двоичных данных в *iterable*. А :exc:"
"`TypeError` будет поднято, если в *iterable* есть какие-либо значения, "
"которые не являются :term:`байтоподобными объектами\n"
"`, в том числе :class:`str` объекты. Разделителем между элементами является "
"содержимое объекта bytes или bytearray, предоставляющего этот метод."

#: ../../library/stdtypes.rst:2658
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"Этот статический метод возвращает таблицу перевода, пригодную для :meth:"
"`bytes.translate` это сопоставит каждый символ в *from* с символом в той же "
"позиции в *to*; *from* и *to* должны быть :term:`байтоподобными объектами\n"
"` и иметь одинаковую длину."

#: ../../library/stdtypes.rst:2669
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"Разделите последовательность при первом появлении *sep* и верните кортеж из "
"трех частей, содержащий часть перед разделителем, сам разделитель или его "
"копию в виде массива байтов и часть после разделителя. Если разделитель не "
"найден, верните тройной кортеж, содержащий копию исходной "
"последовательности, за которой следуют два пустых байта или объекты "
"байтового массива."

#: ../../library/stdtypes.rst:2676 ../../library/stdtypes.rst:2733
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr "Разделителем для поиска может быть любой :term:`байтовый объект`."

#: ../../library/stdtypes.rst:2682
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"Верните копию последовательности, в которой все вхождения "
"подпоследовательности *old* заменены на *new*. Если указан необязательный "
"аргумент *count*, заменяются только первые вхождения *count*."

#: ../../library/stdtypes.rst:2686
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"Подпоследовательность для поиска и ее замены может быть любым :term:"
"`байтоподобным объектом`."

#: ../../library/stdtypes.rst:2691 ../../library/stdtypes.rst:2784
#: ../../library/stdtypes.rst:2798 ../../library/stdtypes.rst:2822
#: ../../library/stdtypes.rst:2836 ../../library/stdtypes.rst:2871
#: ../../library/stdtypes.rst:2941 ../../library/stdtypes.rst:2959
#: ../../library/stdtypes.rst:2987 ../../library/stdtypes.rst:3126
#: ../../library/stdtypes.rst:3181 ../../library/stdtypes.rst:3224
#: ../../library/stdtypes.rst:3245 ../../library/stdtypes.rst:3267
#: ../../library/stdtypes.rst:3469
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"Версия этого метода *не* работает на месте — она всегда создает новый "
"объект, даже если не было внесено никаких изменений."

#: ../../library/stdtypes.rst:2698
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"Возвращает наивысший индекс в последовательности, где найдена "
"подпоследовательность *sub*, такая, что *sub* содержится внутри ``s[начало:"
"конец]`` . Необязательные аргументы *start* и *end* интерпретируются как в "
"нотации среза. Возвращаться ``-1`` при неудаче."

#: ../../library/stdtypes.rst:2713
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
"Нравиться :meth:`~bytes.rfind` но поднимает :exc:`ValueError` когда "
"подпоследовательность *sub* не найдена."

#: ../../library/stdtypes.rst:2726
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"Разделите последовательность при последнем вхождении *sep* и верните кортеж "
"из трех частей, содержащий часть перед разделителем, сам разделитель или его "
"копию в виде массива байтов и часть после разделителя. Если разделитель не "
"найден, верните тройной кортеж, содержащий два пустых байта или объекта "
"байтового массива, за которыми следует копия исходной последовательности."

#: ../../library/stdtypes.rst:2739
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Возвращаться ``Правда`` если двоичные данные начинаются с указанного "
"*префикса*, в противном случае верните ``Ложь`` . *prefix* также может "
"представлять собой кортеж префиксов для поиска. Если используется "
"необязательный *start*, тест начинается с этой позиции. Если используется "
"необязательный *end*, остановите сравнение в этой позиции."

#: ../../library/stdtypes.rst:2744
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr "Префикс(ы) для поиска может быть любым :term:`байтоподобным объектом`."

#: ../../library/stdtypes.rst:2750
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"Возвращает копию объекта bytes или bytearray, где все байты, встречающиеся в "
"необязательном аргументе *delete*, удалены, а оставшиеся байты сопоставлены "
"с помощью данной таблицы перевода, которая должна быть объектом bytes длиной "
"256."

#: ../../library/stdtypes.rst:2755
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"Вы можете использовать :func:`bytes.maketrans` метод создания таблицы "
"перевода."

#: ../../library/stdtypes.rst:2758
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"Установите для аргумента *table* значение ``Нет`` для переводов, которые "
"удаляют только символы::"

#: ../../library/stdtypes.rst:2764
msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* теперь поддерживается в качестве аргумента ключевого слова."

#: ../../library/stdtypes.rst:2768
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"Следующие методы для объектов bytes и bytearray имеют поведение по "
"умолчанию, предполагающее использование двоичных форматов, совместимых с "
"ASCII, но их по-прежнему можно использовать с произвольными двоичными "
"данными, передавая соответствующие аргументы. Обратите внимание, что все "
"методы bytearray в этом разделе *не* работают на месте, а вместо этого "
"создают новые объекты."

#: ../../library/stdtypes.rst:2777
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Возвращает копию объекта с центром в последовательности длины *ширины*. "
"Заполнение выполняется с использованием указанного *fillbyte* (по умолчанию "
"используется пробел ASCII). Для :class:`байты` объекты, исходная "
"последовательность возвращается, если *width* меньше или равна ``лен(ы)`` ."

#: ../../library/stdtypes.rst:2791
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Возвращает копию объекта, выровненную по левому краю, в последовательности "
"длиной *ширины*. Заполнение выполняется с использованием указанного "
"*fillbyte* (по умолчанию используется пробел ASCII). Для :class:`байты` "
"объекты, исходная последовательность возвращается, если *width* меньше или "
"равна ``лен(ы)`` ."

#: ../../library/stdtypes.rst:2805
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Вернуть копию последовательности с удаленными указанными ведущими байтами. "
"Аргумент *chars* представляет собой двоичную последовательность, "
"определяющую набор удаляемых байтовых значений. Название указывает на тот "
"факт, что этот метод обычно используется с символами ASCII. Если опущено или "
"``Нет`` , аргумент *chars* по умолчанию удаляет пробелы ASCII. Аргумент "
"*chars* не является префиксом; скорее, все комбинации его значений "
"удаляются::"

#: ../../library/stdtypes.rst:2817 ../../library/stdtypes.rst:2866
#: ../../library/stdtypes.rst:2936
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"Двоичная последовательность удаляемых байтовых значений может быть любым :"
"term:`байтоподобным объектом`."

#: ../../library/stdtypes.rst:2829
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Возвращает копию объекта, выровненную по правому краю в последовательности "
"длины *ширины*. Заполнение выполняется с использованием указанного "
"*fillbyte* (по умолчанию используется пробел ASCII). Для :class:`байты` "
"объекты, исходная последовательность возвращается, если *width* меньше или "
"равна ``лен(ы)`` ."

#: ../../library/stdtypes.rst:2843
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"Разделите двоичную последовательность на подпоследовательности одного и того "
"же типа, используя *sep* в качестве строки-разделителя. Если указано "
"*maxsplit*, выполняется не более *maxsplit* разбиений, *самых правых*. Если "
"*sep* не указано или ``Нет`` , любая подпоследовательность, состоящая "
"исключительно из пробелов ASCII, является разделителем. За исключением "
"раскола справа, :meth:`rsplit` ведет себя как :meth:`сплит` что подробно "
"описано ниже."

#: ../../library/stdtypes.rst:2854
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Вернуть копию последовательности с удаленными указанными конечными байтами. "
"Аргумент *chars* представляет собой двоичную последовательность, "
"определяющую набор удаляемых байтовых значений. Название указывает на тот "
"факт, что этот метод обычно используется с символами ASCII. Если опущено или "
"``Нет`` , аргумент *chars* по умолчанию удаляет пробелы ASCII. Аргумент "
"*chars* не является суффиксом; скорее, все комбинации его значений "
"удаляются::"

#: ../../library/stdtypes.rst:2878
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"Разделите двоичную последовательность на подпоследовательности одного и того "
"же типа, используя *sep* в качестве строки-разделителя. Если задано "
"*maxsplit* и оно неотрицательно, выполняется не более *maxsplit* разбиений "
"(таким образом, в списке будет не более ``макссплит+1`` элементы). Если "
"*maxsplit* не указан или ``-1`` , то количество разбиений не ограничено "
"(сделаны все возможные разбиения)."

#: ../../library/stdtypes.rst:2884
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of "
"object being split.  The *sep* argument may be any :term:`bytes-like object`."
msgstr ""

#: ../../library/stdtypes.rst:2902
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"Если *sep* не указано или ``Нет`` , применяется другой алгоритм разделения: "
"серии последовательных пробелов ASCII рассматриваются как один разделитель, "
"и результат не будет содержать пустых строк в начале или конце, если "
"последовательность имеет начальные или конечные пробелы. Следовательно, "
"разделение пустой последовательности или последовательности, состоящей "
"исключительно из пробелов ASCII без указанного разделителя, возвращает "
"результат. ``[]`` ."

#: ../../library/stdtypes.rst:2923
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Вернуть копию последовательности с удаленными указанными ведущими и "
"конечными байтами. Аргумент *chars* представляет собой двоичную "
"последовательность, определяющую набор удаляемых байтовых значений. Название "
"указывает на тот факт, что этот метод обычно используется с символами ASCII. "
"Если опущено или ``Нет`` , аргумент *chars* по умолчанию удаляет пробелы "
"ASCII. Аргумент *chars* не является префиксом или суффиксом; скорее, все "
"комбинации его значений удаляются::"

#: ../../library/stdtypes.rst:2945
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"Следующие методы для объектов байтов и байтовых массивов предполагают "
"использование двоичных форматов, совместимых с ASCII, и их не следует "
"применять к произвольным двоичным данным. Обратите внимание, что все методы "
"bytearray в этом разделе *не* работают на месте, а вместо этого создают "
"новые объекты."

#: ../../library/stdtypes.rst:2953
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"Возвращает копию последовательности, в которой каждый байт интерпретируется "
"как символ ASCII, причем первый байт пишется с заглавной буквы, а остальные "
"— со строчной. Значения байтов, отличные от ASCII, передаются без изменений."

#: ../../library/stdtypes.rst:2966
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"Возвращает копию последовательности, в которой все символы табуляции ASCII "
"заменяются одним или несколькими пробелами ASCII, в зависимости от текущего "
"столбца и заданного размера табуляции. Позиции табуляции встречаются через "
"каждые *tabsize* байты (по умолчанию — 8, что дает позиции табуляции в "
"столбцах 0, 8, 16 и т. д.). Чтобы расширить последовательность, текущий "
"столбец устанавливается на ноль, и последовательность проверяется побайтно. "
"Если байт представляет собой символ табуляции ASCII ( ``б'\\т'`` ), в "
"результат вставляются один или несколько символов пробела, пока текущий "
"столбец не сравняется со следующей позицией табуляции. (Сам символ табуляции "
"не копируется.) Если текущий байт является символом новой строки ASCII "
"( ``б'\\n'`` ) или возврат каретки ( ``б'\\р'`` ), он копируется, и текущий "
"столбец сбрасывается в ноль. Любое другое значение байта копируется без "
"изменений, а текущий столбец увеличивается на единицу независимо от того, "
"как значение байта представляется при печати:"

#: ../../library/stdtypes.rst:2994
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Возвращаться ``Правда`` если все байты в последовательности являются "
"буквенными символами ASCII или десятичными цифрами ASCII и "
"последовательность не пуста, ``Ложь`` в противном случае. Алфавитные символы "
"ASCII — это значения байтов в последовательности. "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` . Десятичные "
"цифры ASCII — это значения байтов в последовательности ``b'0123456789'`` ."

#: ../../library/stdtypes.rst:3011
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Возвращаться ``Правда`` если все байты в последовательности являются "
"буквенными символами ASCII и последовательность не пуста, ``Ложь`` в "
"противном случае. Алфавитные символы ASCII — это значения байтов в "
"последовательности. "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` ."

#: ../../library/stdtypes.rst:3027
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"Возвращаться ``Правда`` если последовательность пуста или все байты в "
"последовательности являются ASCII, ``Ложь`` в противном случае. Байты ASCII "
"находятся в диапазоне 0–0x7F."

#: ../../library/stdtypes.rst:3037
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Возвращаться ``Правда`` если все байты в последовательности представляют "
"собой десятичные цифры ASCII и последовательность не пуста, ``Ложь`` в "
"противном случае. Десятичные цифры ASCII — это значения байтов в "
"последовательности ``b'0123456789'`` ."

#: ../../library/stdtypes.rst:3052
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""
"Возвращаться ``Правда`` если в последовательности есть хотя бы один символ "
"ASCII нижнего регистра и нет символов ASCII верхнего регистра, ``Ложь`` в "
"противном случае."

#: ../../library/stdtypes.rst:3062 ../../library/stdtypes.rst:3104
#: ../../library/stdtypes.rst:3120 ../../library/stdtypes.rst:3170
#: ../../library/stdtypes.rst:3239
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Символы ASCII нижнего регистра — это значения байтов в последовательности. "
"``b'abcdefghijklmnopqrstuvwxyz'`` . Символы ASCII верхнего регистра — это "
"значения байтов в последовательности. ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`` ."

#: ../../library/stdtypes.rst:3070
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Возвращаться ``Правда`` если все байты в последовательности представляют "
"собой пробелы ASCII и последовательность не пуста, ``Ложь`` в противном "
"случае. Пробелы ASCII — это значения байтов в последовательности. ``b' "
"\\t\\n\\r\\x0b\\f'`` (пробел, табуляция, новая строка, возврат каретки, "
"вертикальная табуляция, перевод страницы)."

#: ../../library/stdtypes.rst:3079
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Возвращаться ``Правда`` если последовательность является регистром "
"заголовков ASCII и не пуста, ``Ложь`` в противном случае. Видеть :meth:"
"`bytes.title` для получения более подробной информации об определении "
"«заглавного регистра»."

#: ../../library/stdtypes.rst:3094
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""
"Возвращаться ``Правда`` если в последовательности есть хотя бы один "
"буквенный символ ASCII в верхнем регистре и нет символов ASCII в нижнем "
"регистре, ``Ложь`` в противном случае."

#: ../../library/stdtypes.rst:3112
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"Возвращает копию последовательности, в которой все символы ASCII верхнего "
"регистра преобразованы в соответствующие символы нижнего регистра."

#: ../../library/stdtypes.rst:3137
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"Возвращает список строк двоичной последовательности, разрывающихся на "
"границах строк ASCII. Этот метод использует :term:`универсальный подход "
"новой строки` для разделения строк. Разрывы строк не включаются в "
"результирующий список, если не указано значение *keepends* и истинное "
"значение."

#: ../../library/stdtypes.rst:3149
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"В отличие от :meth:`~bytes.split` если указана строка-разделитель *sep*, "
"этот метод возвращает пустой список для пустой строки, а разрыв конечной "
"строки не приводит к появлению дополнительной строки::"

#: ../../library/stdtypes.rst:3162
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Возвращает копию последовательности, в которой все символы ASCII нижнего "
"регистра преобразованы в соответствующие символы верхнего регистра и "
"наоборот."

#: ../../library/stdtypes.rst:3174
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""

#: ../../library/stdtypes.rst:3188
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"Возвращает версию двоичной последовательности с заголовком, где слова "
"начинаются с символа ASCII в верхнем регистре, а остальные символы — в "
"нижнем регистре. Значения байтов без регистра остаются неизмененными."

#: ../../library/stdtypes.rst:3197
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"Символы ASCII нижнего регистра — это значения байтов в последовательности. "
"``b'abcdefghijklmnopqrstuvwxyz'`` . Символы ASCII верхнего регистра — это "
"значения байтов в последовательности. ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`` . "
"Все остальные байтовые значения не имеют регистра."

#: ../../library/stdtypes.rst:3231
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"Возвращает копию последовательности, в которой все символы ASCII нижнего "
"регистра преобразованы в соответствующие символы верхнего регистра."

#: ../../library/stdtypes.rst:3252
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"Вернуть копию последовательности, заполненную ASCII. ``b'0'`` цифры, чтобы "
"составить последовательность длиной *шириной*. Ведущий префикс знака "
"( ``б'+'`` / ``б'-'`` ) обрабатывается путем вставки дополнения *после* "
"символа знака, а не перед ним. Для :class:`байты` объекты, исходная "
"последовательность возвращается, если *width* меньше или равна ``len(seq)`` ."

#: ../../library/stdtypes.rst:3274
msgid "``printf``-style Bytes Formatting"
msgstr "``printf`` -стиль форматирования байтов"

#: ../../library/stdtypes.rst:3291
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"Описанные здесь операции форматирования имеют ряд особенностей, которые "
"приводят к ряду распространенных ошибок (например, к неправильному "
"отображению кортежей и словарей). Если печатаемое значение может быть "
"кортежем или словарем, оберните его в кортеж."

#: ../../library/stdtypes.rst:3296
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"Байтовые объекты ( ``байты`` / ``bytearray`` ) имеют одну уникальную "
"встроенную операцию: ``%`` оператор (по модулю). Это также известно как "
"оператор *форматирования* байтов или *интерполяции*. Данный ``формат % "
"значений`` (где *format* — байтовый объект), ``%`` спецификации "
"преобразования в *формате* заменяются нулем или более элементами *значений*. "
"Эффект аналогичен использованию :c:func:`sprintf` на языке Си."

#: ../../library/stdtypes.rst:3303
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Если для *format* требуется один аргумент, *values* может быть одним "
"объектом, не являющимся кортежем. [5]_ В противном случае *значения* должны "
"быть кортежем с количеством элементов, указанным в объекте байтов формата, "
"или одним объектом сопоставления (например, словарем)."

#: ../../library/stdtypes.rst:3337
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Если правым аргументом является словарь (или другой тип сопоставления), "
"тогда форматы в объекте bytes *должны* включать заключенный в круглые скобки "
"ключ сопоставления в этот словарь, вставленный сразу после ``'%'`` характер. "
"Ключ сопоставления выбирает значение для форматирования из сопоставления. "
"Например:"

#: ../../library/stdtypes.rst:3411
msgid "Single byte (accepts integer or single byte objects)."
msgstr "Однобайтовый (принимает целочисленные или однобайтовые объекты)."

#: ../../library/stdtypes.rst:3414
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/stdtypes.rst:3414
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`__bytes__`)."
msgstr ""

#: ../../library/stdtypes.rst:3418
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'`` это псевдоним для ``'б'`` и должен использоваться только для баз кода "
"Python2/3."

#: ../../library/stdtypes.rst:3421
msgid ""
"Bytes (converts any Python object using ``repr(obj)."
"encode('ascii','backslashreplace)``)."
msgstr ""

#: ../../library/stdtypes.rst:3424
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'р'`` это псевдоним для ``'а'`` и должен использоваться только для баз "
"кода Python2/3."

#: ../../library/stdtypes.rst:3424
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/stdtypes.rst:3459
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` устарел, но не будет удален в серии 3.x."

#: ../../library/stdtypes.rst:3462
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` устарел, но не будет удален в серии 3.x."

#: ../../library/stdtypes.rst:3474
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - Добавление % форматирования к байтам и байтовым массивам."

#: ../../library/stdtypes.rst:3481
msgid "Memory Views"
msgstr "Виды памяти"

#: ../../library/stdtypes.rst:3483
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
":class:`memoryview` объекты позволяют коду Python получать доступ к "
"внутренним данным объекта, который поддерживает протокол :ref:`buffer\n"
"`без копирования."

#: ../../library/stdtypes.rst:3489
msgid ""
"Create a :class:`memoryview` that references *obj*.  *obj* must support the "
"buffer protocol.  Built-in objects that support the buffer protocol include :"
"class:`bytes` and :class:`bytearray`."
msgstr ""

#: ../../library/stdtypes.rst:3493
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating object *obj*.  For many simple types "
"such as :class:`bytes` and :class:`bytearray`, an element is a single byte, "
"but other types such as :class:`array.array` may have bigger elements."
msgstr ""

#: ../../library/stdtypes.rst:3499
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the view. "
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""

#: ../../library/stdtypes.rst:3506
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
"А :class:`memoryview` поддерживает нарезку и индексирование для "
"предоставления данных. Одномерная нарезка приведет к созданию "
"подпредставления::"

#: ../../library/stdtypes.rst:3519
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"Если :class:`~memoryview.format` является одним из спецификаторов "
"собственного формата из :mod:`структура` модуль также поддерживается "
"индексирование целыми числами или кортежами целых чисел и возвращает один "
"*элемент* правильного типа. Одномерные представления памяти можно "
"индексировать с помощью целого числа или одноцелого кортежа. Многомерные "
"представления памяти можно индексировать с помощью кортежей, состоящих ровно "
"из *ndim* целых чисел, где *ndim* — количество измерений. Нульмерные "
"представления памяти можно индексировать с помощью пустого кортежа."

#: ../../library/stdtypes.rst:3528
msgid "Here is an example with a non-byte format::"
msgstr "Вот пример с небайтовым форматом:"

#: ../../library/stdtypes.rst:3540
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"Если базовый объект доступен для записи, представление памяти поддерживает "
"одномерное назначение среза. Изменение размера не допускается::"

#: ../../library/stdtypes.rst:3561
msgid ""
"One-dimensional memoryviews of hashable (read-only) types with formats 'B', "
"'b' or 'c' are also hashable. The hash is defined as ``hash(m) == hash(m."
"tobytes())``::"
msgstr ""

#: ../../library/stdtypes.rst:3573
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now hashable."
msgstr ""

#: ../../library/stdtypes.rst:3577
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"MemoryView теперь автоматически регистрируется с помощью :class:`collections."
"abc.Sequence`"

#: ../../library/stdtypes.rst:3581
msgid "memoryviews can now be indexed with tuple of integers."
msgstr ""
"Просмотры памяти теперь можно индексировать с помощью кортежа целых чисел."

#: ../../library/stdtypes.rst:3584
msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` имеет несколько методов:"

#: ../../library/stdtypes.rst:3588
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"Просмотр памяти и :pep:`3118` экспортера равны, если их формы эквивалентны и "
"если все соответствующие значения равны, когда соответствующие коды формата "
"операндов интерпретируются с использованием :mod:`структура` синтаксис."

#: ../../library/stdtypes.rst:3592
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"Для подмножества :mod:`структура` строки формата, поддерживаемые в настоящее "
"время :meth:`толист` , ``v`` и ``ч`` равны, если ``v.tolist() == w."
"tolist()`` ::"

#: ../../library/stdtypes.rst:3611
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"Если какая-либо строка формата не поддерживается :mod:`структура` модуль, то "
"объекты всегда будут сравниваться как неравные (даже если строки формата и "
"содержимое буфера идентичны)::"

#: ../../library/stdtypes.rst:3627
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""

#: ../../library/stdtypes.rst:3630
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"Предыдущие версии сравнивали необработанную память без учета формата "
"элемента и структуры логического массива."

#: ../../library/stdtypes.rst:3636
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Верните данные в буфер в виде байтовой строки. Это эквивалентно вызову :"
"class:`байты` конструктор в MemoryView. ::"

#: ../../library/stdtypes.rst:3645
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"Для несмежных массивов результат равен представлению плоского списка, в "
"котором все элементы преобразованы в байты. :meth:`тобайты` поддерживает все "
"строки формата, включая те, которых нет в :mod:`структура` синтаксис модуля."

#: ../../library/stdtypes.rst:3650
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""
"*порядок* может быть {'C', 'F', 'A'}. Когда *order* имеет значение «C» или "
"«F», данные исходного массива преобразуются в порядок C или Fortran. Для "
"смежных представлений «A» возвращает точную копию физической памяти. В "
"частности, сохраняется порядок Фортрана в памяти. Для несмежных "
"представлений данные сначала преобразуются в C. *order=None* — то же самое, "
"что *order='C'*."

#: ../../library/stdtypes.rst:3659
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""
"Возвращает строковый объект, содержащий две шестнадцатеричные цифры для "
"каждого байта в буфере. ::"

#: ../../library/stdtypes.rst:3668
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"Похоже на: :meth:`bytes.hex` , :meth:`memoryview.hex` теперь поддерживает "
"дополнительные параметры *sep* и *bytes_per_sep* для вставки разделителей "
"между байтами в шестнадцатеричном выводе."

#: ../../library/stdtypes.rst:3675
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "Верните данные в буфер в виде списка элементов. ::"

#: ../../library/stdtypes.rst:3685
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""
":meth:`толист` теперь поддерживает все односимвольные форматы в :mod:"
"`структура` синтаксис модуля, а также многомерные представления."

#: ../../library/stdtypes.rst:3692
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""
"Верните версию объекта MemoryView, доступную только для чтения. Исходный "
"объект MemoryView не изменяется. ::"

#: ../../library/stdtypes.rst:3711
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"Освободите базовый буфер, предоставленный объектом MemoryView. Многие "
"объекты выполняют специальные действия, когда на них удерживается взгляд "
"(например, :class:`bytearray` временно запретит изменение размера); поэтому "
"вызов Release() удобен для того, чтобы как можно скорее снять эти "
"ограничения (и освободить все висящие ресурсы)."

#: ../../library/stdtypes.rst:3717
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""

#: ../../library/stdtypes.rst:3728
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"Для аналогичного эффекта можно использовать протокол управления контекстом, "
"используя ``с`` заявление::"

#: ../../library/stdtypes.rst:3744
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"Приведите представление памяти к новому формату или форме. *форма* по "
"умолчанию ``[byte_length//new_itemsize]`` , что означает, что представление "
"результатов будет одномерным. Возвращаемое значение — это новое "
"представление памяти, но сам буфер не копируется. Поддерживаемые приведения: "
"1D -> C-:term:`contigious` и C-contigious -> 1D."

#: ../../library/stdtypes.rst:3750
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length."
msgstr ""

#: ../../library/stdtypes.rst:3755
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "Привести 1D/длинные байты к 1D/беззнаковым байтам::"

#: ../../library/stdtypes.rst:3778
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "Преобразование 1D/беззнаковых байтов в 1D/char::"

#: ../../library/stdtypes.rst:3791
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "Привести 1D/байты к 3D/целые числа к 1D/знаковому символу::"

#: ../../library/stdtypes.rst:3817
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "Преобразование 1D/unsigned long в 2D/unsigned long::"

#: ../../library/stdtypes.rst:3831
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"Исходный формат больше не ограничен при приведении к байтовому представлению."

#: ../../library/stdtypes.rst:3834
msgid "There are also several readonly attributes available:"
msgstr "Также доступно несколько атрибутов только для чтения:"

#: ../../library/stdtypes.rst:3838
msgid "The underlying object of the memoryview::"
msgstr "Базовый объект MemoryView::"

#: ../../library/stdtypes.rst:3849
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())`` . Это объем "
"пространства в байтах, который массив будет использовать в непрерывном "
"представлении. Оно не обязательно равно ``только(м)'' ::"

#: ../../library/stdtypes.rst:3868
msgid "Multi-dimensional arrays::"
msgstr "Многомерные массивы::"

#: ../../library/stdtypes.rst:3885
msgid "A bool indicating whether the memory is read only."
msgstr ""
"Логическое значение, указывающее, доступна ли память только для чтения."

#: ../../library/stdtypes.rst:3889
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"Строка, содержащая формат (в :mod:`структура` стиль модуля) для каждого "
"элемента в представлении. Представление памяти может быть создано из "
"экспортеров с произвольными строками формата, но некоторые методы "
"(например, :meth:`толист` ) ограничены собственными форматами отдельных "
"элементов."

#: ../../library/stdtypes.rst:3894
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"формат ``'Б'`` теперь обрабатывается в соответствии с синтаксисом модуля "
"структуры. Это означает, что ``memoryview(b'abc')[0] == b'abc'[0] == 97`` ."

#: ../../library/stdtypes.rst:3900
msgid "The size in bytes of each element of the memoryview::"
msgstr "Размер в байтах каждого элемента MemoryView::"

#: ../../library/stdtypes.rst:3913
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Целое число, указывающее, сколько измерений многомерного массива "
"представляет память."

#: ../../library/stdtypes.rst:3918
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"Кортеж целых чисел длиной :attr:`я` придание памяти формы N-мерного массива."

#: ../../library/stdtypes.rst:3921 ../../library/stdtypes.rst:3929
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "Пустой кортеж вместо ``Нет`` когда ндим = 0."

#: ../../library/stdtypes.rst:3926
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"Кортеж целых чисел длиной :attr:`я` указание размера в байтах для доступа к "
"каждому элементу для каждого измерения массива."

#: ../../library/stdtypes.rst:3934
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr "Used internally for PIL-style arrays. The value is informational only."

#: ../../library/stdtypes.rst:3938
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr ""
"Логическое значение, указывающее, является ли память C-:term:`непрерывной`."

#: ../../library/stdtypes.rst:3944
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr ""
"Логическое значение, указывающее, является ли память :term:`непрерывной` в "
"формате Фортрана."

#: ../../library/stdtypes.rst:3950
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr ""
"Логическое значение, указывающее, является ли память :term:`непрерывной`."

#: ../../library/stdtypes.rst:3958
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Типы наборов --- :class:`set`, :class:`frozenset`"

#: ../../library/stdtypes.rst:3962
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Объект :dfn:`set` представляет собой неупорядоченную коллекцию различных :"
"term:`hashable` объектов. Обычное использование включает проверку членства, "
"удаление дубликатов из последовательности и вычисление математических "
"операций, таких как пересечение, объединение, разность и симметричная "
"разность. (Для других контейнеров см. встроенный :class:`dict` , :class:"
"`список` , и :class:`кортеж` занятия и :mod:`коллекции` модуль.)"

#: ../../library/stdtypes.rst:3969
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Как и другие коллекции, наборы поддерживают ``x в наборе`` , "
"``лен(набор)`` , и ``для x в наборе`` . Будучи неупорядоченной коллекцией, "
"наборы не записывают положение элемента или порядок вставки. Соответственно, "
"наборы не поддерживают индексирование, нарезку или другое поведение, "
"подобное последовательностям."

#: ../../library/stdtypes.rst:3974
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"В настоящее время существует два встроенных типа наборов: :класс:`набор` и :"
"class:`frozenset` . :класс:`набор` тип является изменяемым --- содержимое "
"можно изменить с помощью таких методов, как :meth:`~set.add` и :meth:`~set."
"remove` . Поскольку он изменчив, он не имеет хэш-значения и не может "
"использоваться ни как ключ словаря, ни как элемент другого набора. :class:"
"`frozenset` type является неизменяемым и :term:`hashable` --- его содержимое "
"не может быть изменено после его создания; поэтому его можно использовать "
"как ключ словаря или как элемент другого набора."

#: ../../library/stdtypes.rst:3982
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"Непустые наборы (не замороженные наборы) можно создавать, помещая список "
"элементов, разделенных запятыми, в фигурные скобки, например: ``{'джек', "
"'сйорд'}`` , в дополнение к :класс:`набор` конструктор."

#: ../../library/stdtypes.rst:3986
msgid "The constructors for both classes work the same:"
msgstr "Конструкторы для обоих классов работают одинаково:"

#: ../../library/stdtypes.rst:3991
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Возвращает новый объект set или Frozenset, элементы которого взяты из "
"*iterable*. Элементы набора должны быть :term:`hashable`. Чтобы представлять "
"наборы наборов, внутренние наборы должны быть :class:`frozenset` объекты. "
"Если *iterable* не указано, возвращается новый пустой набор."

#: ../../library/stdtypes.rst:3997
msgid "Sets can be created by several means:"
msgstr "Наборы можно создавать несколькими способами:"

#: ../../library/stdtypes.rst:3999
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr ""
"Используйте список элементов, разделенных запятыми, в фигурных скобках: "
"``{'джек', 'сйорд'}``"

#: ../../library/stdtypes.rst:4000
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr ""
"Используйте понимание множества: ``{c вместо c в 'abracadabra', если c не в "
"'abc'}``"

#: ../../library/stdtypes.rst:4001
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""
"Используйте конструктор типа: ``set()`` , ``set('foobar')`` , ``set(['a', "
"'b', 'foo'])``"

#: ../../library/stdtypes.rst:4003
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"Экземпляры :класс:`набор` и :class:`frozenset` обеспечить следующие операции:"

#: ../../library/stdtypes.rst:4008
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "Возвращает количество элементов в наборе *s* (мощность *s*)."

#: ../../library/stdtypes.rst:4012
msgid "Test *x* for membership in *s*."
msgstr "Проверьте *x* на членство в *s*."

#: ../../library/stdtypes.rst:4016
msgid "Test *x* for non-membership in *s*."
msgstr "Проверьте *x* на отсутствие членства в *s*."

#: ../../library/stdtypes.rst:4020
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Возвращаться ``Правда`` если в наборе нет общих элементов с *other*. "
"Множества непересекающиеся тогда и только тогда, когда их пересечение "
"является пустым множеством."

#: ../../library/stdtypes.rst:4026
msgid "Test whether every element in the set is in *other*."
msgstr "Проверьте, находится ли каждый элемент в наборе в *other*."

#: ../../library/stdtypes.rst:4030
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Проверьте, является ли набор правильным подмножеством *other*, то есть ``set "
"<= другое и set != другое`` ."

#: ../../library/stdtypes.rst:4036
msgid "Test whether every element in *other* is in the set."
msgstr "Проверьте, находится ли каждый элемент в *other* в наборе."

#: ../../library/stdtypes.rst:4040
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Проверьте, является ли этот набор надмножеством *other*, то есть "
"``установить >= другое и установить != другое`` ."

#: ../../library/stdtypes.rst:4046
msgid "Return a new set with elements from the set and all others."
msgstr "Вернуть новый набор с элементами из этого набора и всеми остальными."

#: ../../library/stdtypes.rst:4051
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Вернуть новый набор с элементами, общими для этого набора и всех остальных."

#: ../../library/stdtypes.rst:4056
msgid "Return a new set with elements in the set that are not in the others."
msgstr "Вернуть новый набор с элементами в наборе, которых нет в других."

#: ../../library/stdtypes.rst:4061
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Вернуть новый набор с элементами либо из набора, либо из *other*, но не из "
"обоих."

#: ../../library/stdtypes.rst:4065
msgid "Return a shallow copy of the set."
msgstr "Верните неглубокую копию набора."

#: ../../library/stdtypes.rst:4068
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and :"
"meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""

#: ../../library/stdtypes.rst:4075
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"Оба :класс:`набор` и :class:`frozenset` набор поддержки для установки "
"сравнений. Два множества равны тогда и только тогда, когда каждый элемент "
"каждого множества содержится в другом (каждое является подмножеством "
"другого). Набор меньше другого набора тогда и только тогда, когда первый "
"набор является собственным подмножеством второго набора (является "
"подмножеством, но не равен). Набор больше другого набора тогда и только "
"тогда, когда первый набор является собственным надмножеством второго набора "
"(является надмножеством, но не равен)."

#: ../../library/stdtypes.rst:4082
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Экземпляры :класс:`набор` сравниваются с примерами :class:`frozenset` на "
"основе их членов. Например, ``set('abc') == замороженный набор('abc')`` "
"возвращает ``Правда`` и так же ``set('abc') в set([frozenset('abc')])`` ."

#: ../../library/stdtypes.rst:4086
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"Сравнения подмножества и равенства не обобщаются до полной функции "
"упорядочения. Например, любые два непустых непересекающихся множества не "
"равны и не являются подмножествами друг друга, поэтому *все* из следующих "
"значений возвращают ``Ложь`` : ``a<b`` , ``a==b`` , или ``a>b`` ."

#: ../../library/stdtypes.rst:4091
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Поскольку множества определяют только частичный порядок (отношения "
"подмножества), выходные данные :meth:`list.sort` метод не определен для "
"списков наборов."

#: ../../library/stdtypes.rst:4094
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"Элементы набора, такие как ключи словаря, должны быть :term:`hashable`."

#: ../../library/stdtypes.rst:4096
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Бинарные операции, которые смешивают :класс:`набор` случаи с :class:"
"`frozenset` вернуть тип первого операнда. Например: ``frozenset('ab') | "
"set('BC')`` возвращает экземпляр :class:`frozenset` ."

#: ../../library/stdtypes.rst:4100
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"В следующей таблице перечислены операции, доступные для :класс:`набор` "
"которые не применяются к неизменяемым экземплярам :class:`frozenset` :"

#: ../../library/stdtypes.rst:4106
msgid "Update the set, adding elements from all others."
msgstr "Обновите набор, добавив элементы из всех остальных."

#: ../../library/stdtypes.rst:4111
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""
"Обновите набор, сохранив только найденные в нем элементы и все остальные."

#: ../../library/stdtypes.rst:4116
msgid "Update the set, removing elements found in others."
msgstr "Обновите набор, удалив элементы, найденные в других."

#: ../../library/stdtypes.rst:4121
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Обновите набор, сохраняя только элементы, найденные в любом наборе, но не в "
"обоих."

#: ../../library/stdtypes.rst:4125
msgid "Add element *elem* to the set."
msgstr "Добавьте в набор элемент *elem*."

#: ../../library/stdtypes.rst:4129
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Удалить элемент *elem* из набора. Поднимает :exc:`KeyError` если *elem* не "
"содержится в наборе."

#: ../../library/stdtypes.rst:4134
msgid "Remove element *elem* from the set if it is present."
msgstr "Удалите элемент *elem* из набора, если он присутствует."

#: ../../library/stdtypes.rst:4138
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Удалить и вернуть произвольный элемент из набора. Поднимает :exc:`KeyError` "
"если набор пуст."

#: ../../library/stdtypes.rst:4143
msgid "Remove all elements from the set."
msgstr "Удалите все элементы из набора."

#: ../../library/stdtypes.rst:4146
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Обратите внимание, что версии без оператора :meth:`обновить` , :meth:"
"`intersection_update` , :meth:`difference_update` , и :meth:"
"`symmetric_difference_update` методы будут принимать любую итерацию в "
"качестве аргумента."

#: ../../library/stdtypes.rst:4151
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""

#: ../../library/stdtypes.rst:4159
msgid "Mapping Types --- :class:`dict`"
msgstr "Типы сопоставления --- :class:`dict`"

#: ../../library/stdtypes.rst:4169
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Объект :term:`mapping` отображает :term:`hashable` значения на произвольные "
"объекты. Отображения — это изменяемые объекты. В настоящее время существует "
"только один стандартный тип сопоставления — :dfn:`dictionary`. (Для других "
"контейнеров см. встроенный :class:`список` , :класс:`набор` , и :class:"
"`кортеж` занятия и :mod:`коллекции` модуль.)"

#: ../../library/stdtypes.rst:4175
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""

#: ../../library/stdtypes.rst:4184
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}`` "
"or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr ""

#: ../../library/stdtypes.rst:4192
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"Возвращает новый словарь, инициализированный необязательным позиционным "
"аргументом и, возможно, пустым набором аргументов ключевого слова."

#: ../../library/stdtypes.rst:4195
msgid "Dictionaries can be created by several means:"
msgstr "Словари можно создавать несколькими способами:"

#: ../../library/stdtypes.rst:4197
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"Используйте список разделенных запятыми ``ключ: значение`` пары в фигурных "
"скобках: ``{'джек': 4098, 'сйорд': 4127}`` или ``{4098: 'домкрат', 4127: "
"'пила'}``"

#: ../../library/stdtypes.rst:4199
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr ""
"Используйте понимание dict: ``{}`` , ``{x: x ** 2 для x в диапазоне (10)}``"

#: ../../library/stdtypes.rst:4200
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""
"Используйте конструктор типа: ``дикт()`` , ``dict([('foo', 100), ('bar', "
"200)])`` , ``dict(foo=100, bar=200)``"

#: ../../library/stdtypes.rst:4203
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"Если позиционный аргумент не указан, создается пустой словарь. Если задан "
"позиционный аргумент и это объект сопоставления, словарь создается с теми же "
"парами ключ-значение, что и объект сопоставления. В противном случае "
"позиционный аргумент должен быть :term:`iterable` объектом. Каждый элемент в "
"итерации сам по себе должен быть итерацией ровно с двумя объектами. Первый "
"объект каждого элемента становится ключом в новом словаре, а второй объект — "
"соответствующим значением. Если ключ встречается более одного раза, "
"последнее значение этого ключа становится соответствующим значением в новом "
"словаре."

#: ../../library/stdtypes.rst:4213
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"Если заданы аргументы ключевого слова, аргументы ключевого слова и их "
"значения добавляются в словарь, созданный на основе позиционного аргумента. "
"Если добавляемый ключ уже присутствует, значение аргумента ключевого слова "
"заменяет значение позиционного аргумента."

#: ../../library/stdtypes.rst:4218
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Для иллюстрации: все следующие примеры возвращают словарь, равный "
"``{\"один\": 1, \"два\": 2, \"три\": 3}`` ::"

#: ../../library/stdtypes.rst:4229
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Предоставление аргументов ключевого слова, как в первом примере, работает "
"только для ключей, которые являются допустимыми идентификаторами Python. В "
"противном случае можно использовать любые действительные ключи."

#: ../../library/stdtypes.rst:4233
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Это операции, которые поддерживают словари (и, следовательно, "
"пользовательские типы сопоставлений также должны поддерживать):"

#: ../../library/stdtypes.rst:4238
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "Возвращает список всех ключей, используемых в словаре *d*."

#: ../../library/stdtypes.rst:4242
msgid "Return the number of items in the dictionary *d*."
msgstr "Возвращает количество элементов в словаре *d*."

#: ../../library/stdtypes.rst:4246
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"Верните элемент *d* с помощью ключа *key*. поднимает вопрос :exc:`KeyError` "
"если *ключ* отсутствует на карте."

#: ../../library/stdtypes.rst:4251
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"Если подкласс dict определяет метод :meth:`__missing__` и *ключ* "
"отсутствует, ``d[ключ]`` операция вызывает этот метод с ключом *key* в "
"качестве аргумента. ``d[ключ]`` затем операция возвращает или вызывает все, "
"что возвращается или создается функцией ``__missing__(ключ)`` вызов. Никакие "
"другие операции или методы не вызывают :meth:`__missing__` . Если :meth:"
"`__missing__` не определено, :exc:`KeyError` поднят. :meth:`__missing__` "
"должен быть методом; это не может быть переменная экземпляра::"

#: ../../library/stdtypes.rst:4269
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"В приведенном выше примере показана часть реализации :class:`collections."
"Counter` . Другой ``__missing__`` метод используется :class:`collections."
"defaultdict` ."

#: ../../library/stdtypes.rst:4275
msgid "Set ``d[key]`` to *value*."
msgstr "Набор ``d[ключ]`` чтобы *ценить*."

#: ../../library/stdtypes.rst:4279
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"Удалять ``d[ключ]`` от *д*. поднимает вопрос :exc:`KeyError` если *ключ* "
"отсутствует на карте."

#: ../../library/stdtypes.rst:4284
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "Возвращаться ``Правда`` если у *d* есть ключ *key*, иначе ``Ложь`` ."

#: ../../library/stdtypes.rst:4288
msgid "Equivalent to ``not key in d``."
msgstr "Эквивалентно ``не вводить d`` ."

#: ../../library/stdtypes.rst:4292
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Возвращает итератор по ключам словаря. Это ярлык для ``iter(d.keys())`` ."

#: ../../library/stdtypes.rst:4297
msgid "Remove all items from the dictionary."
msgstr "Удалить все элементы из словаря."

#: ../../library/stdtypes.rst:4301
msgid "Return a shallow copy of the dictionary."
msgstr "Верните неполную копию словаря."

#: ../../library/stdtypes.rst:4305
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"Создайте новый словарь с ключами из *iterable* и значениями, установленными "
"в *value*."

#: ../../library/stdtypes.rst:4307
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""
":meth:`fromkeys` — это метод класса, который возвращает новый словарь. "
"*значение* по умолчанию равно ``Нет`` . Все значения относятся только к "
"одному экземпляру, поэтому, как правило, не имеет смысла, чтобы *value* было "
"изменяемым объектом, например пустым списком. Чтобы получить различные "
"значения, используйте понимание :ref:`dict\n"
"` вместо этого."

#: ../../library/stdtypes.rst:4315
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Возвращает значение *key*, если *key* находится в словаре, иначе *default*. "
"Если *default* не указано, по умолчанию используется значение ``Нет`` , так "
"что этот метод никогда не вызывает :exc:`KeyError` ."

#: ../../library/stdtypes.rst:4321
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"Вернуть новое представление элементов словаря ( ``(ключ, значение)`` пары). "
"См. :ref:`документацию по объектам просмотра.\n"
"`."

#: ../../library/stdtypes.rst:4326
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Вернуть новое представление ключей словаря. См. :ref:`документацию по "
"объектам просмотра.\n"
"`."

#: ../../library/stdtypes.rst:4331
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"Если *key* есть в словаре, удалите его и верните его значение, иначе верните "
"*default*. Если *default* не задано и *key* отсутствует в словаре, :exc:"
"`KeyError` поднят."

#: ../../library/stdtypes.rst:4337
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"Удалить и вернуть ``(ключ, значение)`` пара из словаря. Пары возвращаются в "
"порядке :abbr:`LIFO (последний пришел, первый ушел)`."

#: ../../library/stdtypes.rst:4340
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`Я пью` полезен для деструктивного перебора словаря, что часто "
"используется в алгоритмах множеств. Если словарь пуст, вызов :meth:`Я пью` "
"поднимает вопрос :exc:`KeyError` ."

#: ../../library/stdtypes.rst:4344
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""
"Заказ LIFO теперь гарантирован. В предыдущих версиях :meth:`Я пью` вернет "
"произвольную пару ключ/значение."

#: ../../library/stdtypes.rst:4350
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""
"Верните обратный итератор по ключам словаря. Это ярлык для ``обратный(d."
"keys())`` ."

#: ../../library/stdtypes.rst:4357
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Если *key* есть в словаре, верните его значение. Если нет, вставьте *key* со "
"значением *default* и верните *default*. *по умолчанию* по умолчанию "
"``Нет`` ."

#: ../../library/stdtypes.rst:4363
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Обновите словарь парами ключ/значение из *other*, перезаписав существующие "
"ключи. Возвращаться ``Нет`` ."

#: ../../library/stdtypes.rst:4366
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`обновить` принимает либо другой объект словаря, либо итерацию пар "
"ключ/значение (в виде кортежей или других итераций длины два). Если указаны "
"аргументы ключевого слова, словарь затем обновляется этими парами ключ/"
"значение: ``d.update(красный=1, синий=2)`` ."

#: ../../library/stdtypes.rst:4373
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"Верните новое представление значений словаря. См. :ref:`документацию по "
"объектам просмотра.\n"
"`."

#: ../../library/stdtypes.rst:4376
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""
"Сравнение равенства между одним ``dict.values()`` просмотр и другой всегда "
"вернется ``Ложь`` . Это также применимо при сравнении ``dict.values()`` "
"себе::"

#: ../../library/stdtypes.rst:4384
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`."
msgstr ""
"Словари сравнивают равные тогда и только тогда, когда они имеют одинаковые "
"значения. ``(ключ, значение)`` пары (независимо от заказа). Сравнение "
"порядков ('<', '<=', '>=', '>') повышает :exc:`TypeError` ."

#: ../../library/stdtypes.rst:4388
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"Словари сохраняют порядок вставки. Обратите внимание, что обновление ключа "
"не влияет на порядок. Ключи, добавленные после удаления, вставляются в "
"конце. ::"

#: ../../library/stdtypes.rst:4406
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"Порядок словаря гарантированно является порядком вставки. Такое поведение "
"было частью реализации CPython начиная с версии 3.6."

#: ../../library/stdtypes.rst:4410
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr "Словари и представления словарей обратимы. ::"

#: ../../library/stdtypes.rst:4422
msgid "Dictionaries are now reversible."
msgstr "Словари теперь обратимы."

#: ../../library/stdtypes.rst:4427
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
":class:`types.MappingProxyType` может использоваться для создания "
"представления только для чтения :class:`dict` ."

#: ../../library/stdtypes.rst:4434
msgid "Dictionary view objects"
msgstr "Объекты представления словаря"

#: ../../library/stdtypes.rst:4436
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
"Объекты, возвращенные :meth:`dict.keys` , :meth:`dict.values` и :meth:`dict."
"items` являются *объектами просмотра*. Они обеспечивают динамическое "
"представление записей словаря, а это означает, что при изменении словаря "
"представление отражает эти изменения."

#: ../../library/stdtypes.rst:4441
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Представления словаря можно перебирать для получения соответствующих данных "
"и поддерживать тесты членства:"

#: ../../library/stdtypes.rst:4446
msgid "Return the number of entries in the dictionary."
msgstr "Возвращает количество записей в словаре."

#: ../../library/stdtypes.rst:4450
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Возвращает итератор по ключам, значениям или элементам (представленным в "
"виде кортежей ``(ключ, значение)`` ) в словаре."

#: ../../library/stdtypes.rst:4453
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"Ключи и значения перебираются в порядке вставки. Это позволяет создавать "
"``(значение, ключ)`` пары, используя :func:`zip` : ``pairs = zip(d.values(), "
"d.keys())`` . Другой способ создать тот же список: ``pairs = [(v, k) для (k, "
"v) в d.items()]`` ."

#: ../../library/stdtypes.rst:4458
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Повторение представлений при добавлении или удалении записей в словаре может "
"привести к возникновению проблемы. :exc:`RuntimeError` или не удастся "
"перебрать все записи."

#: ../../library/stdtypes.rst:4461
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "Порядок словаря гарантированно является порядком вставки."

#: ../../library/stdtypes.rst:4466
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Возвращаться ``Правда`` если *x* находится в ключах, значениях или элементах "
"базового словаря (в последнем случае *x* должно быть ``(ключ, значение)`` "
"кортеж)."

#: ../../library/stdtypes.rst:4471
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""
"Верните обратный итератор по ключам, значениям или элементам словаря. "
"Представление будет повторяться в порядке, обратном вставке."

#: ../../library/stdtypes.rst:4474
msgid "Dictionary views are now reversible."
msgstr "Представления словаря теперь обратимы."

#: ../../library/stdtypes.rst:4478
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all "
"values are hashable, so that ``(key, value)`` pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-"
"like since the entries are generally not unique.)  For set-like views, all "
"of the operations defined for the abstract base class :class:`collections."
"abc.Set` are available (for example, ``==``, ``<``, or ``^``)."
msgstr ""

#: ../../library/stdtypes.rst:4485
msgid "An example of dictionary view usage::"
msgstr "Пример использования представления словаря::"

#: ../../library/stdtypes.rst:4520
msgid "Context Manager Types"
msgstr "Типы контекстных менеджеров"

#: ../../library/stdtypes.rst:4527
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"Python :keyword:`с` Оператор поддерживает концепцию контекста времени "
"выполнения, определенного менеджером контекста. Это реализовано с помощью "
"пары методов, которые позволяют определяемым пользователем классам "
"определять контекст времени выполнения, который вводится до выполнения тела "
"инструкции и завершается по завершении инструкции:"

#: ../../library/stdtypes.rst:4535
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"Введите контекст времени выполнения и верните либо этот объект, либо другой "
"объект, связанный с контекстом времени выполнения. Значение, возвращаемое "
"этим методом, привязано к идентификатору в :keyword:`!as` пункт :keyword:`с` "
"операторы, использующие этот менеджер контекста."

#: ../../library/stdtypes.rst:4540
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"Примером контекстного менеджера, который возвращает сам себя, является :term:"
"`файловый объект`. Файловые объекты возвращают себя из __enter__(), чтобы "
"разрешить :func:`открыть` использоваться в качестве контекстного выражения "
"в :keyword:`с` заявление."

#: ../../library/stdtypes.rst:4544
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"Примером менеджера контекста, который возвращает связанный объект, является "
"тот, который возвращается :func:`decimal.localcontext` . Эти менеджеры "
"устанавливают активный десятичный контекст в копию исходного десятичного "
"контекста, а затем возвращают копию. Это позволяет вносить изменения в "
"текущий десятичный контекст в теле :keyword:`с` оператор, не затрагивая код "
"вне :keyword:`!с` заявление."

#: ../../library/stdtypes.rst:4554
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Выйдите из контекста времени выполнения и верните логический флаг, "
"указывающий, следует ли подавлять возникшее исключение. Если исключение "
"произошло во время выполнения тела :keyword:`с` аргументы содержат тип "
"исключения, значение и информацию трассировки. В противном случае все три "
"аргумента ``Нет`` ."

#: ../../library/stdtypes.rst:4559
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"Возврат истинного значения из этого метода приведет к :keyword:`с` оператор, "
"чтобы подавить исключение и продолжить выполнение с оператора, следующего "
"сразу за :keyword:`!с` заявление. В противном случае исключение продолжает "
"распространяться после завершения выполнения этого метода. Исключения, "
"возникающие во время выполнения этого метода, заменят любое исключение, "
"возникшее в теле метода. :keyword:`!с` заявление."

#: ../../library/stdtypes.rst:4566
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`__exit__` "
"method has actually failed."
msgstr ""

#: ../../library/stdtypes.rst:4572
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python определяет несколько менеджеров контекста для поддержки простой "
"синхронизации потоков, быстрого закрытия файлов или других объектов и более "
"простого манипулирования активным контекстом десятичной арифметики. "
"Конкретные типы не рассматриваются специально, за исключением их реализации "
"протокола управления контекстом. См. :mod:`contextlib` модуль для некоторых "
"примеров."

#: ../../library/stdtypes.rst:4578
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`__enter__` and :meth:`__exit__` methods, rather than the iterator produced "
"by an undecorated generator function."
msgstr ""

#: ../../library/stdtypes.rst:4585
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"Обратите внимание, что в структуре типов объектов Python в API Python/C нет "
"специального слота для любого из этих методов. Типы расширений, желающие "
"определить эти методы, должны предоставить их как обычный доступный метод "
"Python. По сравнению с накладными расходами на настройку контекста времени "
"выполнения, накладные расходы на поиск в словаре одного класса незначительны."

#: ../../library/stdtypes.rst:4595
msgid "Other Built-in Types"
msgstr "Другие встроенные типы"

#: ../../library/stdtypes.rst:4597
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"Интерпретатор поддерживает несколько других типов объектов. Большинство из "
"них поддерживают только одну или две операции."

#: ../../library/stdtypes.rst:4604
msgid "Modules"
msgstr "Модули"

#: ../../library/stdtypes.rst:4606
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"Единственная специальная операция над модулем — это доступ к атрибутам: ``m."
"name`` , где *m* — модуль, а *name* обращается к имени, определенному в "
"таблице символов *m*. Атрибуты модуля могут быть назначены. (Обратите "
"внимание, что :keyword:`импорт` Строго говоря, оператор не является "
"операцией над объектом модуля; ``импортировать foo`` не требует "
"существования объекта модуля с именем *foo*, скорее требуется (внешнее) "
"*определение* для модуля с именем *foo* где-то.)"

#: ../../library/stdtypes.rst:4613
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Особым атрибутом каждого модуля является :attr:`~object.__dict__` . Это "
"словарь, содержащий таблицу символов модуля. Изменение этого словаря "
"фактически изменит таблицу символов модуля, но прямое присвоение :attr:"
"`~object.__dict__` атрибут невозможен (вы можете написать ``m.__dict__['a'] "
"= 1`` , который определяет ``ма`` быть ``1`` , но ты не можешь написать ``m."
"__dict__ = {}`` ). Модификация :attr:`~object.__dict__` напрямую не "
"рекомендуется."

#: ../../library/stdtypes.rst:4621
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Модули, встроенные в интерпретатор, пишутся так: ``<модуль "
"'sys' (встроенный)>`` . Если они загружены из файла, они записываются как "
"``<модуль 'os' из '/usr/local/lib/pythonX.Y/os.pyc'>`` ."

#: ../../library/stdtypes.rst:4629
msgid "Classes and Class Instances"
msgstr "Классы и экземпляры классов"

#: ../../library/stdtypes.rst:4631
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Видеть :ref:`объекты` и :ref:`класс` для этих."

#: ../../library/stdtypes.rst:4637
msgid "Functions"
msgstr "Функции"

#: ../../library/stdtypes.rst:4639
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Объекты функций создаются определениями функций. Единственная операция над "
"функциональным объектом — это его вызов: ``func(список-аргументов)`` ."

#: ../../library/stdtypes.rst:4642
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"На самом деле существует два типа функциональных объектов: встроенные "
"функции и пользовательские функции. Оба поддерживают одну и ту же операцию "
"(вызов функции), но реализация разная, отсюда и разные типы объектов."

#: ../../library/stdtypes.rst:4646
msgid "See :ref:`function` for more information."
msgstr "Видеть :ref:`функция` для получения дополнительной информации."

#: ../../library/stdtypes.rst:4652
msgid "Methods"
msgstr "Методы"

#: ../../library/stdtypes.rst:4656
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""

#: ../../library/stdtypes.rst:4661
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to "
"the argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is "
"the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-"
"n)`` is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""

#: ../../library/stdtypes.rst:4670
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""

#: ../../library/stdtypes.rst:4690 ../../library/stdtypes.rst:4721
msgid "See :ref:`types` for more information."
msgstr "Видеть :ref:`типы` для получения дополнительной информации."

#: ../../library/stdtypes.rst:4698
msgid "Code Objects"
msgstr "Объекты кода"

#: ../../library/stdtypes.rst:4704
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`__code__` attribute. See also the :mod:`code` module."
msgstr ""

#: ../../library/stdtypes.rst:4711
msgid ""
"Accessing ``__code__`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"__code__\"``."
msgstr ""

#: ../../library/stdtypes.rst:4718
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Объект кода можно выполнить или оценить, передав его (вместо исходной "
"строки) в :func:`exec` или :func:`eval` встроенные функции."

#: ../../library/stdtypes.rst:4727
msgid "Type Objects"
msgstr "Объекты типа"

#: ../../library/stdtypes.rst:4733
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Объекты типов представляют различные типы объектов. Доступ к типу объекта "
"осуществляется встроенной функцией :func:`тип` . Специальных операций над "
"типами нет. Стандартный модуль :mod:`типы` определяет имена для всех "
"стандартных встроенных типов."

#: ../../library/stdtypes.rst:4738
msgid "Types are written like this: ``<class 'int'>``."
msgstr "Типы записываются так: ``<класс 'int'>`` ."

#: ../../library/stdtypes.rst:4744
msgid "The Null Object"
msgstr "Нулевой объект"

#: ../../library/stdtypes.rst:4746
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Этот объект возвращается функциями, которые не возвращают значение явно. Он "
"не поддерживает никаких специальных операций. Существует ровно один нулевой "
"объект с именем ``Нет`` (встроенное имя). ``тип(Нет)()`` производит тот же "
"синглтон."

#: ../../library/stdtypes.rst:4750
msgid "It is written as ``None``."
msgstr "Это написано как ``Нет`` ."

#: ../../library/stdtypes.rst:4757
msgid "The Ellipsis Object"
msgstr "Объект «Эллипсис»"

#: ../../library/stdtypes.rst:4759
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Этот объект обычно используется при нарезке (см. :ref:`нарезки` ). Он не "
"поддерживает никаких специальных операций. Существует ровно один объект с "
"многоточием с именем :const:`Многоточие` (встроенное имя). ``тип(многоточие)"
"()`` производит :const:`Многоточие` синглтон."

#: ../../library/stdtypes.rst:4764
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "Это написано как ``Многоточие`` или ``...`` ."

#: ../../library/stdtypes.rst:4770
msgid "The NotImplemented Object"
msgstr "Нереализованный объект"

#: ../../library/stdtypes.rst:4772
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""

#: ../../library/stdtypes.rst:4777
msgid "It is written as ``NotImplemented``."
msgstr ""

#: ../../library/stdtypes.rst:4783
msgid "Boolean Values"
msgstr "Логические значения"

#: ../../library/stdtypes.rst:4785
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""

#: ../../library/stdtypes.rst:4798
msgid "They are written as ``False`` and ``True``, respectively."
msgstr ""

#: ../../library/stdtypes.rst:4804
msgid "Internal Objects"
msgstr "Внутренние объекты"

#: ../../library/stdtypes.rst:4806
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""

#: ../../library/stdtypes.rst:4813
msgid "Special Attributes"
msgstr "Специальные атрибуты"

#: ../../library/stdtypes.rst:4815
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"Реализация добавляет несколько специальных атрибутов, доступных только для "
"чтения, к нескольким типам объектов, где они уместны. О некоторых из них не "
"сообщается :func:`скажи` встроенная функция."

#: ../../library/stdtypes.rst:4822
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"Словарь или другой объект сопоставления, используемый для хранения атрибутов "
"объекта (доступных для записи)."

#: ../../library/stdtypes.rst:4828
msgid "The class to which a class instance belongs."
msgstr "Класс, которому принадлежит экземпляр класса."

#: ../../library/stdtypes.rst:4833
msgid "The tuple of base classes of a class object."
msgstr "Кортеж базовых классов объекта класса."

#: ../../library/stdtypes.rst:4838
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr "Имя класса, функции, метода, дескриптора или экземпляра генератора."

#: ../../library/stdtypes.rst:4844
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
":term:`полное имя` класса, функции, метода, дескриптора или экземпляра "
"генератора."

#: ../../library/stdtypes.rst:4852
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"Этот атрибут представляет собой кортеж классов, которые учитываются при "
"поиске базовых классов во время разрешения метода."

#: ../../library/stdtypes.rst:4858
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"Этот метод может быть переопределен метаклассом, чтобы настроить порядок "
"разрешения методов для его экземпляров. Он вызывается при создании "
"экземпляра класса, а его результат сохраняется в :attr:`~class.__mro__` ."

#: ../../library/stdtypes.rst:4865
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive. Example::"
msgstr ""

#: ../../library/stdtypes.rst:4876
msgid "Integer string conversion length limitation"
msgstr "Ограничение длины преобразования целочисленной строки"

#: ../../library/stdtypes.rst:4878
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:"
"`str` to mitigate denial of service attacks. This limit *only* applies to "
"decimal or other non-power-of-two number bases. Hexadecimal, octal, and "
"binary conversions are unlimited. The limit can be configured."
msgstr ""
"CPython имеет глобальное ограничение на преобразование между :класс:`int` и :"
"class:`str` для смягчения атак типа «отказ в обслуживании». Это ограничение "
"*только* применяется к десятичным или другим системам счисления, отличным от "
"степени двойки. Шестнадцатеричные, восьмеричные и двоичные преобразования не "
"ограничены. Лимит можно настроить."

#: ../../library/stdtypes.rst:4883
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that "
"can convert a string to a binary integer or a binary integer to a string in "
"linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""
"The :класс:`int` тип в CPython — это число произвольной длины, хранящееся в "
"двоичной форме (широко известное как «bignum»). Не существует алгоритма, "
"который мог бы преобразовать строку в двоичное целое число или двоичное "
"целое число в строку за линейное время, *если только* основание не является "
"степенью 2. Даже самые известные алгоритмы для основания 10 имеют "
"субквадратическую сложность. Преобразование большого значения, например "
"``int('1' * 500_000)`` может занять больше секунды на быстром процессоре."

#: ../../library/stdtypes.rst:4890
msgid ""
"Limiting conversion size offers a practical way to avoid `CVE-2020-10735 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735>`_."
msgstr ""

#: ../../library/stdtypes.rst:4893
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr ""
"Ограничение применяется к количеству цифровых символов во входной или "
"выходной строке, когда используется алгоритм нелинейного преобразования. "
"Символы подчеркивания и знак не учитываются при расчете лимита."

#: ../../library/stdtypes.rst:4897
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr "Если операция превысит лимит, :exc:`ValueError` поднят:"

#: ../../library/stdtypes.rst:4919
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be "
"configured is 640 digits as provided in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."
msgstr ""
"Ограничение по умолчанию составляет 4300 цифр, как указано в :data:`sys."
"int_info.default_max_str_digits. <sys.int_info>` . Самый низкий предел, "
"который можно настроить, составляет 640 цифр, как указано в :data:`sys."
"int_info.str_digits_check_threshold. <sys.int_info>` ."

#: ../../library/stdtypes.rst:4924
msgid "Verification:"
msgstr "Верификация:"

#: ../../library/stdtypes.rst:4939
msgid "Affected APIs"
msgstr "Затронутые API"

#: ../../library/stdtypes.rst:4941
msgid ""
"The limitation only applies to potentially slow conversions between :class:"
"`int` and :class:`str` or :class:`bytes`:"
msgstr ""
"Ограничение применяется только к потенциально медленным преобразованиям "
"между :класс:`int` и :class:`str` или :class:`байты` :"

#: ../../library/stdtypes.rst:4944
msgid "``int(string)`` with default base 10."
msgstr "``int(строка)`` с базой по умолчанию 10."

#: ../../library/stdtypes.rst:4945
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr "``int(строка, база)`` для всех оснований, не являющихся степенью 2."

#: ../../library/stdtypes.rst:4946
msgid "``str(integer)``."
msgstr "``str(integer)``."

#: ../../library/stdtypes.rst:4947
msgid "``repr(integer)``."
msgstr "``repr(integer)``."

#: ../../library/stdtypes.rst:4948
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""
"любое другое преобразование строк в базу 10, например ``f\"{integer}\"`` , "
"``\"{}\".format(целое число)`` , или ``b\"%d\" % целое число`` ."

#: ../../library/stdtypes.rst:4951
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr "Ограничения не распространяются на функции с линейным алгоритмом:"

#: ../../library/stdtypes.rst:4953
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr "``int(строка, база)`` с основанием 2, 4, 8, 16 или 32."

#: ../../library/stdtypes.rst:4954
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ":func:`int.from_bytes` и :func:`int.to_bytes`."

#: ../../library/stdtypes.rst:4955
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ":func:`hex`, :func:`oct`, :func:`bin`."

#: ../../library/stdtypes.rst:4956
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ""
":ref:`formatspec` для шестнадцатеричных, восьмеричных и двоичных чисел."

#: ../../library/stdtypes.rst:4957
msgid ":class:`str` to :class:`float`."
msgstr ":class:`str` на :class:`float`."

#: ../../library/stdtypes.rst:4958
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ":class:`str` на :class:`decimal.Decimal`."

#: ../../library/stdtypes.rst:4961
msgid "Configuring the limit"
msgstr "Настройка лимита"

#: ../../library/stdtypes.rst:4963
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr ""
"Перед запуском Python вы можете использовать переменную среды или флаг "
"командной строки интерпретатора, чтобы настроить ограничение:"

#: ../../library/stdtypes.rst:4966
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""
":envvar:`PYTHONINTMAXSTRDIGITS` , например ``PYTHONINTMAXSTRDIGITS=640 "
"python3`` чтобы установить ограничение на 640 или ``PYTHONINTMAXSTRDIGITS=0 "
"python3`` чтобы отключить ограничение."

#: ../../library/stdtypes.rst:4969
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""
":option:`-X int_max_str_digits\n"
"`, например ``python3 -X int_max_str_digits=640``"

#: ../../library/stdtypes.rst:4971
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the "
"env var and the ``-X`` option are set, the ``-X`` option takes precedence. A "
"value of *-1* indicates that both were unset, thus a value of :data:`sys."
"int_info.default_max_str_digits` was used during initialization."
msgstr ""
":data:`sys.flags.int_max_str_digits` содержит значение :envvar:"
"`PYTHONINTMAXSTRDIGITS` или :option:`-X int_max_str_digits\n"
"`. Если и env var, и ``-X`` опция установлена, ``-X`` вариант имеет "
"приоритет. Значение *-1* указывает, что оба были отключены, поэтому "
"значение :data:`sys.int_info.default_max_str_digits` использовался во время "
"инициализации."

#: ../../library/stdtypes.rst:4977
msgid ""
"From code, you can inspect the current limit and set a new one using these :"
"mod:`sys` APIs:"
msgstr ""
"Из кода вы можете проверить текущий предел и установить новый, используя "
"эти :mod:`sys` API:"

#: ../../library/stdtypes.rst:4980
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have "
"their own limit."
msgstr ""
":func:`sys.get_int_max_str_digits` и :func:`sys.set_int_max_str_digits` "
"являются геттером и установщиком ограничения для всего интерпретатора. У "
"субинтерпретаторов есть свой предел."

#: ../../library/stdtypes.rst:4984
msgid ""
"Information about the default and minimum can be found in :attr:`sys."
"int_info`:"
msgstr ""

#: ../../library/stdtypes.rst:4986
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` — это "
"скомпилированный предел по умолчанию."

#: ../../library/stdtypes.rst:4988
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` — наименьшее "
"допустимое значение предела (кроме 0, которое отключает его)."

#: ../../library/stdtypes.rst:4995
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or "
"even at installation time - anytime an up to date ``.pyc`` does not already "
"exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""
"Установка нижнего предела *может* привести к проблемам. Хотя и редко, но "
"существует код, который содержит в исходном виде целочисленные константы в "
"десятичном формате, превышающие минимальный порог. Последствием установки "
"ограничения является то, что исходный код Python, содержащий десятичные "
"целые литералы, длина которых превышает предел, столкнется с ошибкой во "
"время анализа, обычно во время запуска или во время импорта или даже во "
"время установки - в любое время и в обновленном виде. ``.pyc`` для кода еще "
"не существует. Обходной путь для источника, содержащего такие большие "
"константы, — преобразовать их в ``0x`` шестнадцатеричной форме, поскольку "
"она не имеет предела."

#: ../../library/stdtypes.rst:5004
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""
"Тщательно протестируйте свое приложение, если вы используете нижний предел. "
"Убедитесь, что ваши тесты выполняются с ограничением, установленным заранее "
"через среду или флаг, чтобы оно применялось во время запуска и даже на любом "
"этапе установки, который может вызвать Python для предварительной "
"компиляции. ``.py`` источники для ``.pyc`` файлы."

#: ../../library/stdtypes.rst:5010
msgid "Recommended configuration"
msgstr "Рекомендуемая конфигурация"

#: ../../library/stdtypes.rst:5012
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.11."
msgstr ""

#: ../../library/stdtypes.rst:5017
msgid "Example::"
msgstr "Пример::"

#: ../../library/stdtypes.rst:5029
msgid "If you need to disable it entirely, set it to ``0``."
msgstr ""
"Если вам нужно полностью отключить его, установите для него значение ``0`` ."

#: ../../library/stdtypes.rst:5033
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/stdtypes.rst:5034
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Дополнительную информацию об этих специальных методах можно найти в "
"Справочном руководстве Python ( :ref:`кастомизация` )."

#: ../../library/stdtypes.rst:5037
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"Как следствие, список ``[1, 2]`` считается равным ``[1.0, 2.0]`` и "
"аналогично для кортежей."

#: ../../library/stdtypes.rst:5040
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"Должно быть, так как синтаксический анализатор не может определить тип "
"операндов."

#: ../../library/stdtypes.rst:5042
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Символы в регистре — это символы, общее свойство категории которых равно "
"«Lu» (буква, верхний регистр), «Ll» (буква, нижний регистр) или «Lt» (буква, "
"заголовок)."

#: ../../library/stdtypes.rst:5045
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Поэтому, чтобы форматировать только кортеж, вам следует предоставить "
"одноэлементный кортеж, единственным элементом которого является "
"форматируемый кортеж."
