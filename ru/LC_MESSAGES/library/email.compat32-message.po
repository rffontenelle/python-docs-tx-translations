# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:04+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/email.compat32-message.rst:4
msgid ""
":mod:`email.message.Message`: Representing an email message using the :data:"
"`~email.policy.compat32` API"
msgstr ""
":mod:`email.message.Message`: Представление сообщения электронной почты с "
"помощью API :data:`~email.policy.compat32`"

#: ../../library/email.compat32-message.rst:13
msgid ""
"The :class:`Message` class is very similar to the :class:`~email.message."
"EmailMessage` class, without the methods added by that class, and with the "
"default behavior of certain other methods being slightly different.  We also "
"document here some methods that, while supported by the :class:`~email."
"message.EmailMessage` class, are not recommended unless you are dealing with "
"legacy code."
msgstr ""
"Класс :class:`Message` очень похож на класс :class:`~email.message."
"EmailMessage`, за исключением методов, добавленных этим классом, а поведение "
"некоторых других методов по умолчанию немного отличается. Мы также "
"документируем здесь некоторые методы, которые, хотя и поддерживаются "
"классом :class:`~email.message.EmailMessage`, не рекомендуются к "
"использованию, если вы не имеете дело с устаревшим кодом."

#: ../../library/email.compat32-message.rst:20
msgid "The philosophy and structure of the two classes is otherwise the same."
msgstr "В остальном философия и структура этих двух классов одинаковы."

#: ../../library/email.compat32-message.rst:22
msgid ""
"This document describes the behavior under the default (for :class:"
"`Message`) policy :attr:`~email.policy.Compat32`.  If you are going to use "
"another policy, you should be using the :class:`~email.message.EmailMessage` "
"class instead."
msgstr ""
"В этом документе описывается поведение политики по умолчанию (для :class:"
"`Message`) :attr:`~email.policy.Compat32`. Если вы собираетесь использовать "
"другую политику, вам следует использовать вместо нее класс :class:`~email."
"message.EmailMessage`."

#: ../../library/email.compat32-message.rst:26
msgid ""
"An email message consists of *headers* and a *payload*.  Headers must be :"
"rfc:`5322` style names and values, where the field name and value are "
"separated by a colon.  The colon is not part of either the field name or the "
"field value.  The payload may be a simple text message, or a binary object, "
"or a structured sequence of sub-messages each with their own set of headers "
"and their own payload.  The latter type of payload is indicated by the "
"message having a MIME type such as :mimetype:`multipart/\\*` or :mimetype:"
"`message/rfc822`."
msgstr ""
"Сообщение электронной почты состоит из *заголовков* и *полезной нагрузки*. "
"Заголовки должны иметь имена и значения в стиле :rfc:`5322`, где имя и "
"значение поля разделяются двоеточием. Двоеточие не является частью ни имени "
"поля, ни значения поля. Полезная нагрузка может представлять собой простое "
"текстовое сообщение, двоичный объект или структурированную "
"последовательность подсообщений, каждое из которых имеет собственный набор "
"заголовков и собственную полезную нагрузку. Последний тип полезных данных "
"обозначается сообщением, имеющим тип MIME, например :mimetype:`multipart/"
"\\*` или :mimetype:`message/rfc822`."

#: ../../library/email.compat32-message.rst:35
msgid ""
"The conceptual model provided by a :class:`Message` object is that of an "
"ordered dictionary of headers with additional methods for accessing both "
"specialized information from the headers, for accessing the payload, for "
"generating a serialized version of the message, and for recursively walking "
"over the object tree.  Note that duplicate headers are supported but special "
"methods must be used to access them."
msgstr ""
"Концептуальная модель, предоставляемая объектом :class:`Message`, "
"представляет собой упорядоченный словарь заголовков с дополнительными "
"методами для доступа как к специализированной информации из заголовков, так "
"и для доступа к полезной нагрузке, для генерации сериализованной версии "
"сообщения и для рекурсивного проходя по дереву объектов. Обратите внимание, "
"что дублирующиеся заголовки поддерживаются, но для доступа к ним необходимо "
"использовать специальные методы."

#: ../../library/email.compat32-message.rst:42
msgid ""
"The :class:`Message` pseudo-dictionary is indexed by the header names, which "
"must be ASCII values.  The values of the dictionary are strings that are "
"supposed to contain only ASCII characters; there is some special handling "
"for non-ASCII input, but it doesn't always produce the correct results.  "
"Headers are stored and returned in case-preserving form, but field names are "
"matched case-insensitively.  There may also be a single envelope header, "
"also known as the *Unix-From* header or the ``From_`` header.  The *payload* "
"is either a string or bytes, in the case of simple message objects, or a "
"list of :class:`Message` objects, for MIME container documents (e.g. :"
"mimetype:`multipart/\\*` and :mimetype:`message/rfc822`)."
msgstr ""
"Псевдословарь :class:`Message` индексируется по именам заголовков, которые "
"должны быть значениями ASCII. Значения словаря — это строки, которые должны "
"содержать только символы ASCII; существует специальная обработка ввода, "
"отличного от ASCII, но она не всегда дает правильные результаты. Заголовки "
"сохраняются и возвращаются в форме с сохранением регистра, но имена полей "
"сопоставляются без учета регистра. Также может быть один заголовок конверта, "
"также известный как заголовок *Unix-From* или заголовок «From_». *Полезная "
"нагрузка* — это строка или байты в случае простых объектов сообщений или "
"список объектов :class:`Message` для документов-контейнеров MIME (например, :"
"mimetype:`multipart/\\*` и :mimetype: `сообщение/rfc822`)."

#: ../../library/email.compat32-message.rst:53
msgid "Here are the methods of the :class:`Message` class:"
msgstr "Вот методы класса :class:`Message`:"

#: ../../library/email.compat32-message.rst:58
msgid ""
"If *policy* is specified (it must be an instance of a :mod:`~email.policy` "
"class) use the rules it specifies to update and serialize the representation "
"of the message.  If *policy* is not set, use the :class:`compat32 <email."
"policy.Compat32>` policy, which maintains backward compatibility with the "
"Python 3.2 version of the email package.  For more information see the :mod:"
"`~email.policy` documentation."
msgstr ""
"Если указана *policy* (она должна быть экземпляром класса :mod:`~email."
"policy`), используйте указанные ею правила для обновления и сериализации "
"представления сообщения. Если *policy* не задано, используйте политику :"
"class:`compat32 <email.policy.Compat32>`, которая обеспечивает обратную "
"совместимость с версией пакета электронной почты Python 3.2. Для получения "
"дополнительной информации см. документацию :mod:`~email.policy`."

#: ../../library/email.compat32-message.rst:65
msgid "The *policy* keyword argument was added."
msgstr "Был добавлен аргумент ключевого слова *policy*."

#: ../../library/email.compat32-message.rst:70
msgid ""
"Return the entire message flattened as a string.  When optional *unixfrom* "
"is true, the envelope header is included in the returned string. *unixfrom* "
"defaults to ``False``.  For backward compatibility reasons, *maxheaderlen* "
"defaults to ``0``, so if you want a different value you must override it "
"explicitly (the value specified for *max_line_length* in the policy will be "
"ignored by this method).  The *policy* argument may be used to override the "
"default policy obtained from the message instance. This can be used to "
"control some of the formatting produced by the method, since the specified "
"*policy* will be passed to the ``Generator``."
msgstr ""
"Вернуть все сообщение в виде строки. Если необязательный параметр *unixfrom* "
"имеет значение true, заголовок конверта включается в возвращаемую строку. "
"*unixfrom* по умолчанию имеет значение «False». По соображениям обратной "
"совместимости *maxheaderlen* по умолчанию имеет значение ``0``, поэтому, "
"если вам нужно другое значение, вы должны явно переопределить его (значение, "
"указанное для *max_line_length* в политике, будет игнорироваться этим "
"методом). Аргумент *policy* можно использовать для переопределения политики "
"по умолчанию, полученной из экземпляра сообщения. Это можно использовать для "
"управления некоторым форматированием, создаваемым методом, поскольку "
"указанная *политика* будет передана в ``Генератор``."

#: ../../library/email.compat32-message.rst:80
#: ../../library/email.compat32-message.rst:122
msgid ""
"Flattening the message may trigger changes to the :class:`Message` if "
"defaults need to be filled in to complete the transformation to a string "
"(for example, MIME boundaries may be generated or modified)."
msgstr ""
"Сглаживание сообщения может вызвать изменения в :class:`Message`, если для "
"завершения преобразования в строку необходимо заполнить значения по "
"умолчанию (например, могут быть созданы или изменены границы MIME)."

#: ../../library/email.compat32-message.rst:84
msgid ""
"Note that this method is provided as a convenience and may not always format "
"the message the way you want.  For example, by default it does not do the "
"mangling of lines that begin with ``From`` that is required by the Unix mbox "
"format.  For more flexibility, instantiate a :class:`~email.generator."
"Generator` instance and use its :meth:`~email.generator.Generator.flatten` "
"method directly.  For example::"
msgstr ""
"Обратите внимание, что этот метод предоставляется для удобства и не всегда "
"может форматировать сообщение так, как вы хотите. Например, по умолчанию он "
"не выполняет искажение строк, начинающихся с ``From``, как того требует "
"формат Unix mbox. Для большей гибкости создайте экземпляр :class:`~email."
"generator.Generator` и используйте его метод :meth:`~email.generator."
"Generator.flatten` напрямую. Например::"

#: ../../library/email.compat32-message.rst:91
msgid ""
"from io import StringIO\n"
"from email.generator import Generator\n"
"fp = StringIO()\n"
"g = Generator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"
msgstr ""
"from io import StringIO\n"
"from email.generator import Generator\n"
"fp = StringIO()\n"
"g = Generator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"

#: ../../library/email.compat32-message.rst:98
msgid ""
"If the message object contains binary data that is not encoded according to "
"RFC standards, the non-compliant data will be replaced by unicode \"unknown "
"character\" code points.  (See also :meth:`.as_bytes` and :class:`~email."
"generator.BytesGenerator`.)"
msgstr ""
"Если объект сообщения содержит двоичные данные, которые не закодированы в "
"соответствии со стандартами RFC, несовместимые данные будут заменены "
"кодовыми точками Юникода «неизвестный символ». (См. также :meth:`.as_bytes` "
"и :class:`~email.generator.BytesGenerator`.)"

#: ../../library/email.compat32-message.rst:103
msgid "the *policy* keyword argument was added."
msgstr "был добавлен аргумент ключевого слова *policy*."

#: ../../library/email.compat32-message.rst:108
msgid ""
"Equivalent to :meth:`.as_string`.  Allows ``str(msg)`` to produce a string "
"containing the formatted message."
msgstr ""
"Эквивалент :meth:`.as_string`. Позволяет ``str(msg)`` создавать строку, "
"содержащую форматированное сообщение."

#: ../../library/email.compat32-message.rst:114
msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned string.  "
"*unixfrom* defaults to ``False``.  The *policy* argument may be used to "
"override the default policy obtained from the message instance. This can be "
"used to control some of the formatting produced by the method, since the "
"specified *policy* will be passed to the ``BytesGenerator``."
msgstr ""
"Верните все сообщение в виде байтового объекта. Если необязательный параметр "
"*unixfrom* имеет значение true, заголовок конверта включается в возвращаемую "
"строку. *unixfrom* по умолчанию имеет значение «False». Аргумент *policy* "
"можно использовать для переопределения политики по умолчанию, полученной из "
"экземпляра сообщения. Это можно использовать для управления некоторыми "
"аспектами форматирования, производимыми методом, поскольку указанная "
"*политика* будет передана в ``BytesGenerator``."

#: ../../library/email.compat32-message.rst:126
msgid ""
"Note that this method is provided as a convenience and may not always format "
"the message the way you want.  For example, by default it does not do the "
"mangling of lines that begin with ``From`` that is required by the Unix mbox "
"format.  For more flexibility, instantiate a :class:`~email.generator."
"BytesGenerator` instance and use its :meth:`~email.generator.BytesGenerator."
"flatten` method directly. For example::"
msgstr ""
"Обратите внимание, что этот метод предоставляется для удобства и не всегда "
"может форматировать сообщение так, как вы хотите. Например, по умолчанию он "
"не выполняет искажение строк, начинающихся с ``From``, как того требует "
"формат Unix mbox. Для большей гибкости создайте экземпляр :class:`~email."
"generator.BytesGenerator` и используйте его метод :meth:`~email.generator."
"BytesGenerator.flatten` напрямую. Например::"

#: ../../library/email.compat32-message.rst:134
msgid ""
"from io import BytesIO\n"
"from email.generator import BytesGenerator\n"
"fp = BytesIO()\n"
"g = BytesGenerator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"
msgstr ""
"from io import BytesIO\n"
"from email.generator import BytesGenerator\n"
"fp = BytesIO()\n"
"g = BytesGenerator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"

#: ../../library/email.compat32-message.rst:146
msgid ""
"Equivalent to :meth:`.as_bytes`.  Allows ``bytes(msg)`` to produce a bytes "
"object containing the formatted message."
msgstr ""
"Эквивалент :meth:`.as_bytes`. Позволяет ``bytes(msg)`` создавать объект "
"bytes, содержащий форматированное сообщение."

#: ../../library/email.compat32-message.rst:154
msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ :class:"
"`Message` objects, otherwise return ``False``.  When :meth:`is_multipart` "
"returns ``False``, the payload should be a string object (which might be a "
"CTE encoded binary payload).  (Note that :meth:`is_multipart` returning "
"``True`` does not necessarily mean that \"msg.get_content_maintype() == "
"'multipart'\" will return the ``True``. For example, ``is_multipart`` will "
"return ``True`` when the :class:`Message` is of type ``message/rfc822``.)"
msgstr ""
"Возвращайте ``True``, если полезные данные сообщения представляют собой "
"список объектов подкласса \\ :class:`Message`, в противном случае "
"возвращайте ``False``. Когда :meth:`is_multipart` возвращает ``False``, "
"полезная нагрузка должна быть строковым объектом (который может быть "
"двоичной полезной нагрузкой в ​​кодировке CTE). (Обратите внимание, что :meth:"
"`is_multipart`, возвращающий ``True``, не обязательно означает, что \"msg."
"get_content_maintype() == 'multipart'\" вернет ``True``. Например, "
"``is_multipart`` будет возвращайте ``True``, когда :class:`Message` имеет "
"тип ``message/rfc822``.)"

#: ../../library/email.compat32-message.rst:166
msgid ""
"Set the message's envelope header to *unixfrom*, which should be a string."
msgstr ""
"Установите для заголовка конверта сообщения значение *unixfrom*, которое "
"должно быть строкой."

#: ../../library/email.compat32-message.rst:171
msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the envelope "
"header was never set."
msgstr ""
"Верните заголовок конверта сообщения. По умолчанию установлено значение "
"«Нет», если заголовок конверта никогда не устанавливался."

#: ../../library/email.compat32-message.rst:177
msgid ""
"Add the given *payload* to the current payload, which must be ``None`` or a "
"list of :class:`Message` objects before the call. After the call, the "
"payload will always be a list of :class:`Message` objects.  If you want to "
"set the payload to a scalar object (e.g. a string), use :meth:`set_payload` "
"instead."
msgstr ""
"Добавьте заданную *полезную нагрузку* к текущей полезной нагрузке, которая "
"должна быть ``None`` или списком объектов :class:`Message` перед вызовом. "
"После вызова полезная нагрузка всегда будет списком объектов :class:"
"`Message`. Если вы хотите установить полезную нагрузку в скалярный объект "
"(например, строку), используйте вместо этого :meth:`set_payload`."

#: ../../library/email.compat32-message.rst:183
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by :meth:`~email.message.EmailMessage."
"set_content` and the related ``make`` and ``add`` methods."
msgstr ""
"Это устаревший метод. В классе :class:`~email.emailmessage.EmailMessage` его "
"функциональность заменяется :meth:`~email.message.EmailMessage.set_content` "
"и соответствующими методами ``make`` и ``add``."

#: ../../library/email.compat32-message.rst:191
msgid ""
"Return the current payload, which will be a list of :class:`Message` objects "
"when :meth:`is_multipart` is ``True``, or a string when :meth:`is_multipart` "
"is ``False``.  If the payload is a list and you mutate the list object, you "
"modify the message's payload in place."
msgstr ""
"Возвращает текущую полезную нагрузку, которая будет списком объектов :class:"
"`Message`, если :meth:`is_multipart` имеет значение ``True``, или строкой, "
"если :meth:`is_multipart` имеет значение ``False``. Если полезные данные "
"представляют собой список и вы изменяете объект списка, вы изменяете "
"полезные данные сообщения на месте."

#: ../../library/email.compat32-message.rst:196
msgid ""
"With optional argument *i*, :meth:`get_payload` will return the *i*-th "
"element of the payload, counting from zero, if :meth:`is_multipart` is "
"``True``.  An :exc:`IndexError` will be raised if *i* is less than 0 or "
"greater than or equal to the number of items in the payload.  If the payload "
"is a string (i.e.  :meth:`is_multipart` is ``False``) and *i* is given, a :"
"exc:`TypeError` is raised."
msgstr ""
"С необязательным аргументом *i*, :meth:`get_payload` вернет *i*-й элемент "
"полезных данных, считая с нуля, если :meth:`is_multipart` имеет значение "
"``True``. :exc:`IndexError` будет возникать, если *i* меньше 0 или больше "
"или равно количеству элементов в полезных данных. Если полезная нагрузка "
"представляет собой строку (т. е. :meth:`is_multipart` имеет значение "
"``False``) и задано *i*, возникает ошибка :exc:`TypeError`."

#: ../../library/email.compat32-message.rst:203
msgid ""
"Optional *decode* is a flag indicating whether the payload should be decoded "
"or not, according to the :mailheader:`Content-Transfer-Encoding` header. "
"When ``True`` and the message is not a multipart, the payload will be "
"decoded if this header's value is ``quoted-printable`` or ``base64``. If "
"some other encoding is used, or :mailheader:`Content-Transfer-Encoding` "
"header is missing, the payload is returned as-is (undecoded).  In all cases "
"the returned value is binary data.  If the message is a multipart and the "
"*decode* flag is ``True``, then ``None`` is returned.  If the payload is "
"base64 and it was not perfectly formed (missing padding, characters outside "
"the base64 alphabet), then an appropriate defect will be added to the "
"message's defect property (:class:`~email.errors.InvalidBase64PaddingDefect` "
"or :class:`~email.errors.InvalidBase64CharactersDefect`, respectively)."
msgstr ""
"Необязательный *decode* — это флаг, указывающий, следует ли декодировать "
"полезную нагрузку или нет, в соответствии с заголовком :mailheader:`Content-"
"Transfer-Encoding`. Когда ``True`` и сообщение не является составным, "
"полезные данные будут декодированы, если значение этого заголовка равно "
"``quoted-printable`` или ``base64``. Если используется другая кодировка или "
"заголовок :mailheader:`Content-Transfer-Encoding` отсутствует, полезные "
"данные возвращаются как есть (некодированные). Во всех случаях возвращаемое "
"значение представляет собой двоичные данные. Если сообщение состоит из "
"нескольких частей и флаг *decode* имеет значение True, то возвращается None. "
"Если полезная нагрузка имеет формат Base64 и сформирована неправильно "
"(отсутствуют отступы, символы вне алфавита Base64), то соответствующий "
"дефект будет добавлен к свойству дефекта сообщения (:class:`~email.errors."
"InvalidBase64PaddingDefect` или :class: `~email.errors."
"InvalidBase64CharactersDefect` соответственно)."

#: ../../library/email.compat32-message.rst:217
msgid ""
"When *decode* is ``False`` (the default) the body is returned as a string "
"without decoding the :mailheader:`Content-Transfer-Encoding`.  However, for "
"a :mailheader:`Content-Transfer-Encoding` of 8bit, an attempt is made to "
"decode the original bytes using the ``charset`` specified by the :mailheader:"
"`Content-Type` header, using the ``replace`` error handler. If no "
"``charset`` is specified, or if the ``charset`` given is not recognized by "
"the email package, the body is decoded using the default ASCII charset."
msgstr ""
"Когда *decode* имеет значение «False» (по умолчанию), тело возвращается в "
"виде строки без декодирования :mailheader:`Content-Transfer-Encoding`. "
"Однако для :mailheader:`Content-Transfer-Encoding` размером 8 бит делается "
"попытка декодировать исходные байты с использованием ``кодировки``, "
"указанной в заголовке :mailheader:`Content-Type`, с использованием `` "
"replace`` обработчик ошибок. Если кодировка не указана или указанная "
"кодировка не распознается пакетом электронной почты, тело декодируется с "
"использованием кодировки ASCII по умолчанию."

#: ../../library/email.compat32-message.rst:226
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by :meth:`~email.message.EmailMessage."
"get_content` and :meth:`~email.message.EmailMessage.iter_parts`."
msgstr ""
"Это устаревший метод. В классе :class:`~email.emailmessage.EmailMessage` его "
"функциональность заменяется :meth:`~email.message.EmailMessage.get_content` "
"и :meth:`~email.message.EmailMessage.iter_parts`."

#: ../../library/email.compat32-message.rst:234
msgid ""
"Set the entire message object's payload to *payload*.  It is the client's "
"responsibility to ensure the payload invariants.  Optional *charset* sets "
"the message's default character set; see :meth:`set_charset` for details."
msgstr ""
"Установите для всей полезной нагрузки объекта сообщения значение *payload*. "
"Ответственность за обеспечение инвариантов полезной нагрузки лежит на "
"клиенте. Необязательный *charset* устанавливает набор символов сообщения по "
"умолчанию; подробности см. в :meth:`set_charset`."

#: ../../library/email.compat32-message.rst:238
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by :meth:`~email.message.EmailMessage."
"set_content`."
msgstr ""
"Это устаревший метод. В классе :class:`~email.emailmessage.EmailMessage` его "
"функциональность заменяется на :meth:`~email.message.EmailMessage."
"set_content`."

#: ../../library/email.compat32-message.rst:245
msgid ""
"Set the character set of the payload to *charset*, which can either be a :"
"class:`~email.charset.Charset` instance (see :mod:`email.charset`), a string "
"naming a character set, or ``None``.  If it is a string, it will be "
"converted to a :class:`~email.charset.Charset` instance.  If *charset* is "
"``None``, the ``charset`` parameter will be removed from the :mailheader:"
"`Content-Type` header (the message will not be otherwise modified).  "
"Anything else will generate a :exc:`TypeError`."
msgstr ""
"Установите для набора символов полезной нагрузки значение *charset*, которое "
"может быть экземпляром :class:`~email.charset.Charset` (см. :mod:`email."
"charset`), строкой, определяющей набор символов, или ` ``Нет``. Если это "
"строка, она будет преобразована в экземпляр :class:`~email.charset.Charset`. "
"Если *charset* имеет значение None, параметр charset будет удален из "
"заголовка :mailheader:Content-Type (сообщение не будет изменено иначе). Все "
"остальное вызовет ошибку :exc:`TypeError`."

#: ../../library/email.compat32-message.rst:253
msgid ""
"If there is no existing :mailheader:`MIME-Version` header one will be "
"added.  If there is no existing :mailheader:`Content-Type` header, one will "
"be added with a value of :mimetype:`text/plain`.  Whether the :mailheader:"
"`Content-Type` header already exists or not, its ``charset`` parameter will "
"be set to *charset.output_charset*.   If *charset.input_charset* and "
"*charset.output_charset* differ, the payload will be re-encoded to the "
"*output_charset*.  If there is no existing :mailheader:`Content-Transfer-"
"Encoding` header, then the payload will be transfer-encoded, if needed, "
"using the specified :class:`~email.charset.Charset`, and a header with the "
"appropriate value will be added.  If a :mailheader:`Content-Transfer-"
"Encoding` header already exists, the payload is assumed to already be "
"correctly encoded using that :mailheader:`Content-Transfer-Encoding` and is "
"not modified."
msgstr ""
"Если существующего заголовка :mailheader:`MIME-Version` нет, он будет "
"добавлен. Если существующего заголовка :mailheader:`Content-Type` нет, он "
"будет добавлен со значением :mimetype:`text/plain`. Независимо от того, "
"существует ли заголовок :mailheader:`Content-Type` или нет, его параметр "
"``charset`` будет установлен в *charset.output_charset*. Если *charset."
"input_charset* и *charset.output_charset* различаются, полезные данные будут "
"перекодированы в *output_charset*. Если существующего заголовка :mailheader:"
"`Content-Transfer-Encoding` нет, то полезные данные будут при необходимости "
"закодированы при передаче с использованием указанного :class:`~email.charset."
"Charset` и заголовка с соответствующим стоимость будет добавлена. Если "
"заголовок :mailheader:`Content-Transfer-Encoding` уже существует, "
"предполагается, что полезные данные уже правильно закодированы с "
"использованием этого :mailheader:`Content-Transfer-Encoding` и не изменяются."

#: ../../library/email.compat32-message.rst:267
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by the *charset* parameter of the :meth:"
"`email.emailmessage.EmailMessage.set_content` method."
msgstr ""
"Это устаревший метод. В классе :class:`~email.emailmessage.EmailMessage` его "
"функциональность заменяется параметром *charset* метода :meth:`email."
"emailmessage.EmailMessage.set_content`."

#: ../../library/email.compat32-message.rst:275
msgid ""
"Return the :class:`~email.charset.Charset` instance associated with the "
"message's payload."
msgstr ""
"Верните экземпляр :class:`~email.charset.Charset`, связанный с полезной "
"нагрузкой сообщения."

#: ../../library/email.compat32-message.rst:278
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class it always returns ``None``."
msgstr ""
"Это устаревший метод. В классе :class:`~email.emailmessage.EmailMessage` он "
"всегда возвращает ``None``."

#: ../../library/email.compat32-message.rst:283
msgid ""
"The following methods implement a mapping-like interface for accessing the "
"message's :rfc:`2822` headers.  Note that there are some semantic "
"differences between these methods and a normal mapping (i.e. dictionary) "
"interface.  For example, in a dictionary there are no duplicate keys, but "
"here there may be duplicate message headers.  Also, in dictionaries there is "
"no guaranteed order to the keys returned by :meth:`keys`, but in a :class:"
"`Message` object, headers are always returned in the order they appeared in "
"the original message, or were added to the message later.  Any header "
"deleted and then re-added are always appended to the end of the header list."
msgstr ""
"Следующие методы реализуют интерфейс, похожий на сопоставление, для доступа "
"к заголовкам :rfc:`2822` сообщения. Обратите внимание, что между этими "
"методами и интерфейсом обычного сопоставления (то есть словаря) существуют "
"некоторые семантические различия. Например, в словаре нет повторяющихся "
"ключей, а здесь могут быть повторяющиеся заголовки сообщений. Кроме того, в "
"словарях нет гарантированного порядка ключей, возвращаемых :meth:`keys`, но "
"в объекте :class:`Message` заголовки всегда возвращаются в том порядке, в "
"котором они появились в исходном сообщении или были добавлены в него. "
"сообщение позже. Любой удаленный, а затем повторно добавленный заголовок "
"всегда добавляется в конец списка заголовков."

#: ../../library/email.compat32-message.rst:293
msgid ""
"These semantic differences are intentional and are biased toward maximal "
"convenience."
msgstr ""
"Эти семантические различия являются преднамеренными и направлены на "
"максимальное удобство."

#: ../../library/email.compat32-message.rst:296
msgid ""
"Note that in all cases, any envelope header present in the message is not "
"included in the mapping interface."
msgstr ""
"Обратите внимание, что во всех случаях любой заголовок конверта, "
"присутствующий в сообщении, не включается в интерфейс сопоставления."

#: ../../library/email.compat32-message.rst:299
msgid ""
"In a model generated from bytes, any header values that (in contravention of "
"the RFCs) contain non-ASCII bytes will, when retrieved through this "
"interface, be represented as :class:`~email.header.Header` objects with a "
"charset of ``unknown-8bit``."
msgstr ""
"В модели, сгенерированной из байтов, любые значения заголовков, которые (в "
"нарушение RFC) содержат байты, отличные от ASCII, при получении через этот "
"интерфейс будут представлены как объекты :class:`~email.header.Header` с "
"кодировкой ``неизвестный-8бит``."

#: ../../library/email.compat32-message.rst:307
msgid "Return the total number of headers, including duplicates."
msgstr "Возвращает общее количество заголовков, включая дубликаты."

#: ../../library/email.compat32-message.rst:312
msgid ""
"Return ``True`` if the message object has a field named *name*. Matching is "
"done case-insensitively and *name* should not include the trailing colon. "
"Used for the ``in`` operator, e.g.::"
msgstr ""
"Верните ``True``, если объект сообщения имеет поле с именем *name*. "
"Сопоставление выполняется без учета регистра, и *имя* не должно включать в "
"себя завершающее двоеточие. Используется для оператора ``in``, например::"

#: ../../library/email.compat32-message.rst:316
msgid ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"
msgstr ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"

#: ../../library/email.compat32-message.rst:322
msgid ""
"Return the value of the named header field.  *name* should not include the "
"colon field separator.  If the header is missing, ``None`` is returned; a :"
"exc:`KeyError` is never raised."
msgstr ""
"Верните значение именованного поля заголовка. *имя* не должно включать "
"разделитель полей двоеточие. Если заголовок отсутствует, возвращается None; :"
"exc:`KeyError` никогда не возникает."

#: ../../library/email.compat32-message.rst:326
msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is undefined.  "
"Use the :meth:`get_all` method to get the values of all the extant named "
"headers."
msgstr ""
"Обратите внимание: если именованное поле появляется в заголовках сообщения "
"более одного раза, то, какое именно из значений этого поля будет возвращено, "
"не определено. Используйте метод :meth:`get_all`, чтобы получить значения "
"всех существующих именованных заголовков."

#: ../../library/email.compat32-message.rst:334
msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing fields."
msgstr ""
"Добавьте заголовок к сообщению с именем поля *name* и значением *val*. Поле "
"добавляется в конец существующих полей сообщения."

#: ../../library/email.compat32-message.rst:337
msgid ""
"Note that this does *not* overwrite or delete any existing header with the "
"same name.  If you want to ensure that the new header is the only one "
"present in the message with field name *name*, delete the field first, e.g.::"
msgstr ""
"Обратите внимание, что это *не* перезаписывает и не удаляет любой "
"существующий заголовок с тем же именем. Если вы хотите, чтобы новый "
"заголовок был единственным в сообщении с именем поля *имя*, сначала удалите "
"это поле, например::"

#: ../../library/email.compat32-message.rst:341
msgid ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"
msgstr ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"

#: ../../library/email.compat32-message.rst:347
msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr ""
"Удалите все вхождения поля с именем *name* из заголовков сообщений. "
"Исключение не возникает, если именованное поле отсутствует в заголовках."

#: ../../library/email.compat32-message.rst:354
msgid "Return a list of all the message's header field names."
msgstr "Возвращает список всех имен полей заголовка сообщения."

#: ../../library/email.compat32-message.rst:359
msgid "Return a list of all the message's field values."
msgstr "Возвращает список всех значений полей сообщения."

#: ../../library/email.compat32-message.rst:364
msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr ""
"Возвращает список из двух кортежей, содержащий все заголовки и значения "
"полей сообщения."

#: ../../library/email.compat32-message.rst:370
msgid ""
"Return the value of the named header field.  This is identical to :meth:"
"`~object.__getitem__` except that optional *failobj* is returned if the "
"named header is missing (defaults to ``None``)."
msgstr ""
"Верните значение именованного поля заголовка. Это идентично :meth:`~object."
"__getitem__`, за исключением того, что необязательный *failobj* "
"возвращается, если именованный заголовок отсутствует (по умолчанию ``None``)."

#: ../../library/email.compat32-message.rst:374
msgid "Here are some additional useful methods:"
msgstr "Вот еще несколько полезных методов:"

#: ../../library/email.compat32-message.rst:379
msgid ""
"Return a list of all the values for the field named *name*. If there are no "
"such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr ""
"Возвращает список всех значений поля с именем *name*. Если в сообщении нет "
"таких именованных заголовков, возвращается *failobj* (по умолчанию — None)."

#: ../../library/email.compat32-message.rst:386
msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the *primary* "
"value for the header."
msgstr ""
"Расширенная настройка заголовка. Этот метод похож на :meth:`__setitem__`, за "
"исключением того, что дополнительные параметры заголовка могут быть "
"предоставлены в качестве аргументов ключевого слова. *_name* — это "
"добавляемое поле заголовка, а *_value* — это *основное* значение заголовка."

#: ../../library/email.compat32-message.rst:391
msgid ""
"For each item in the keyword argument dictionary *_params*, the key is taken "
"as the parameter name, with underscores converted to dashes (since dashes "
"are illegal in Python identifiers).  Normally, the parameter will be added "
"as ``key=\"value\"`` unless the value is ``None``, in which case only the "
"key will be added.  If the value contains non-ASCII characters, it can be "
"specified as a three tuple in the format ``(CHARSET, LANGUAGE, VALUE)``, "
"where ``CHARSET`` is a string naming the charset to be used to encode the "
"value, ``LANGUAGE`` can usually be set to ``None`` or the empty string (see :"
"rfc:`2231` for other possibilities), and ``VALUE`` is the string value "
"containing non-ASCII code points.  If a three tuple is not passed and the "
"value contains non-ASCII characters, it is automatically encoded in :rfc:"
"`2231` format using a ``CHARSET`` of ``utf-8`` and a ``LANGUAGE`` of "
"``None``."
msgstr ""
"Для каждого элемента в словаре аргументов ключевого слова *_params* ключ "
"принимается в качестве имени параметра, а символы подчеркивания "
"преобразуются в тире (поскольку тире недопустимы в идентификаторах Python). "
"Обычно параметр добавляется как ``key=\"value\"``, если только значение не "
"равно ``None``, в этом случае будет добавлен только ключ. Если значение "
"содержит символы, отличные от ASCII, его можно указать в виде трехкортежа в "
"формате ``(CHARSET, LANGUAGE, VALUE)``, где ``CHARSET`` — это строка, "
"определяющая кодировку, которая будет использоваться для кодирования. "
"значение, ``LANGUAGE`` обычно может быть установлено в ``None`` или пустую "
"строку (см. :rfc:`2231` для других возможностей), а ``VALUE`` — это "
"строковое значение, содержащее кодовые точки, отличные от ASCII. . Если "
"трехкортеж не передается и значение содержит символы, отличные от ASCII, оно "
"автоматически кодируется в формате :rfc:`2231` с использованием ``CHARSET`` "
"из ``utf-8`` и ``LANGUAGE``. из ``Нет``."

#: ../../library/email.compat32-message.rst:405
msgid "Here's an example::"
msgstr "Вот пример::"

#: ../../library/email.compat32-message.rst:407
msgid "msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"
msgstr ""
"msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"

#: ../../library/email.compat32-message.rst:409
msgid "This will add a header that looks like ::"
msgstr "Это добавит заголовок, который будет выглядеть так::"

#: ../../library/email.compat32-message.rst:411
msgid "Content-Disposition: attachment; filename=\"bud.gif\""
msgstr "Content-Disposition: attachment; filename=\"bud.gif\""

#: ../../library/email.compat32-message.rst:413
msgid "An example with non-ASCII characters::"
msgstr "Пример с символами, отличными от ASCII::"

#: ../../library/email.compat32-message.rst:415
msgid ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"
msgstr ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"

#: ../../library/email.compat32-message.rst:418
msgid "Which produces ::"
msgstr "Который производит ::"

#: ../../library/email.compat32-message.rst:420
msgid ""
"Content-Disposition: attachment; filename*=\"iso-8859-1''Fu%DFballer.ppt\""
msgstr ""
"Content-Disposition: attachment; filename*=\"iso-8859-1''Fu%DFballer.ppt\""

#: ../../library/email.compat32-message.rst:425
msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case.  If no matching "
"header was found, a :exc:`KeyError` is raised."
msgstr ""
"Замените заголовок. Замените первый заголовок, найденный в сообщении, "
"который соответствует *_name*, сохраняя порядок заголовков и регистр имени "
"поля. Если соответствующий заголовок не найден, возникает ошибка :exc:"
"`KeyError`."

#: ../../library/email.compat32-message.rst:432
msgid ""
"Return the message's content type.  The returned string is coerced to lower "
"case of the form :mimetype:`maintype/subtype`.  If there was no :mailheader:"
"`Content-Type` header in the message the default type as given by :meth:"
"`get_default_type` will be returned.  Since according to :rfc:`2045`, "
"messages always have a default type, :meth:`get_content_type` will always "
"return a value."
msgstr ""
"Возвращает тип содержимого сообщения. Возвращаемая строка преобразуется в "
"нижний регистр и имеет вид :mimetype:`maintype/subtype`. Если в сообщении не "
"было заголовка :mailheader:`Content-Type`, будет возвращен тип по умолчанию, "
"заданный :meth:`get_default_type`. Поскольку согласно :rfc:`2045`, сообщения "
"всегда имеют тип по умолчанию, :meth:`get_content_type` всегда будет "
"возвращать значение."

#: ../../library/email.compat32-message.rst:439
msgid ""
":rfc:`2045` defines a message's default type to be :mimetype:`text/plain` "
"unless it appears inside a :mimetype:`multipart/digest` container, in which "
"case it would be :mimetype:`message/rfc822`.  If the :mailheader:`Content-"
"Type` header has an invalid type specification, :rfc:`2045` mandates that "
"the default type be :mimetype:`text/plain`."
msgstr ""
":rfc:`2045` определяет тип сообщения по умолчанию как :mimetype:`text/"
"plain`, если только оно не появляется внутри контейнера :mimetype:`multipart/"
"digest`, и в этом случае это будет :mimetype:`message/rfc822` . Если "
"заголовок :mailheader:`Content-Type` имеет недопустимую спецификацию типа, :"
"rfc:`2045` требует, чтобы типом по умолчанию был :mimetype:`text/plain`."

#: ../../library/email.compat32-message.rst:448
msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype` "
"part of the string returned by :meth:`get_content_type`."
msgstr ""
"Возвращает основной тип контента сообщения. Это часть :mimetype:`maintype` "
"строки, возвращаемой :meth:`get_content_type`."

#: ../../library/email.compat32-message.rst:454
msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` part "
"of the string returned by :meth:`get_content_type`."
msgstr ""
"Возвращает тип подконтента сообщения. Это часть :mimetype:`subtype` строки, "
"возвращаемой :meth:`get_content_type`."

#: ../../library/email.compat32-message.rst:460
msgid ""
"Return the default content type.  Most messages have a default content type "
"of :mimetype:`text/plain`, except for messages that are subparts of :"
"mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"Верните тип контента по умолчанию. Большинство сообщений имеют тип "
"содержимого по умолчанию :mimetype:`text/plain`, за исключением сообщений, "
"которые являются подчастями контейнеров :mimetype:`multipart/digest`. Такие "
"подразделы имеют тип контента по умолчанию :mimetype:`message/rfc822`."

#: ../../library/email.compat32-message.rst:468
msgid ""
"Set the default content type.  *ctype* should either be :mimetype:`text/"
"plain` or :mimetype:`message/rfc822`, although this is not enforced.  The "
"default content type is not stored in the :mailheader:`Content-Type` header."
msgstr ""
"Установите тип контента по умолчанию. *ctype* должен быть либо :mimetype:"
"`text/plain`, либо :mimetype:`message/rfc822`, хотя это не является "
"обязательным. Тип контента по умолчанию не хранится в заголовке :mailheader:"
"`Content-Type`."

#: ../../library/email.compat32-message.rst:476
msgid ""
"Return the message's :mailheader:`Content-Type` parameters, as a list. The "
"elements of the returned list are 2-tuples of key/value pairs, as split on "
"the ``'='`` sign.  The left hand side of the ``'='`` is the key, while the "
"right hand side is the value.  If there is no ``'='`` sign in the parameter "
"the value is the empty string, otherwise the value is as described in :meth:"
"`get_param` and is unquoted if optional *unquote* is ``True`` (the default)."
msgstr ""
"Верните параметры :mailheader:`Content-Type` сообщения в виде списка. "
"Элементы возвращаемого списка представляют собой два кортежа пар ключ/"
"значение, разделенные знаком ``'='``. Левая часть ``'='`` — это ключ, а "
"правая часть — значение. Если в параметре нет знака ``'='``, значением "
"является пустая строка, в противном случае значение соответствует описанию "
"в :meth:`get_param` и не помещается в кавычки, если необязательный *unquote* "
"равен ``True`` ( значение по умолчанию)."

#: ../../library/email.compat32-message.rst:484
msgid ""
"Optional *failobj* is the object to return if there is no :mailheader:"
"`Content-Type` header.  Optional *header* is the header to search instead "
"of :mailheader:`Content-Type`."
msgstr ""
"Необязательный *failobj* — это объект, возвращаемый в случае отсутствия "
"заголовка :mailheader:`Content-Type`. Необязательный *header* — это "
"заголовок для поиска вместо :mailheader:`Content-Type`."

#: ../../library/email.compat32-message.rst:488
#: ../../library/email.compat32-message.rst:526
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by the *params* property of the "
"individual header objects returned by the header access methods."
msgstr ""
"Это устаревший метод. В классе :class:`~email.emailmessage.EmailMessage` его "
"функциональность заменяется свойством *params* отдельных объектов заголовка, "
"возвращаемых методами доступа к заголовку."

#: ../../library/email.compat32-message.rst:496
msgid ""
"Return the value of the :mailheader:`Content-Type` header's parameter "
"*param* as a string.  If the message has no :mailheader:`Content-Type` "
"header or if there is no such parameter, then *failobj* is returned "
"(defaults to ``None``)."
msgstr ""
"Возвращает значение параметра *param* заголовка :mailheader:`Content-Type` в "
"виде строки. Если сообщение не имеет заголовка :mailheader:`Content-Type` "
"или такой параметр отсутствует, то возвращается *failobj* (по умолчанию "
"значение ``None``)."

#: ../../library/email.compat32-message.rst:501
msgid ""
"Optional *header* if given, specifies the message header to use instead of :"
"mailheader:`Content-Type`."
msgstr ""
"Необязательный *header*, если задан, указывает заголовок сообщения, который "
"будет использоваться вместо :mailheader:`Content-Type`."

#: ../../library/email.compat32-message.rst:504
msgid ""
"Parameter keys are always compared case insensitively.  The return value can "
"either be a string, or a 3-tuple if the parameter was :rfc:`2231` encoded.  "
"When it's a 3-tuple, the elements of the value are of the form ``(CHARSET, "
"LANGUAGE, VALUE)``.  Note that both ``CHARSET`` and ``LANGUAGE`` can be "
"``None``, in which case you should consider ``VALUE`` to be encoded in the "
"``us-ascii`` charset.  You can usually ignore ``LANGUAGE``."
msgstr ""
"Ключи параметров всегда сравниваются без учета регистра. Возвращаемое "
"значение может быть либо строкой, либо кортежем из трех элементов, если "
"параметр был закодирован в формате :rfc:`2231`. Когда это кортеж из трех "
"элементов, элементы значения имеют форму ``(CHARSET, LANGUAGE, VALUE)``. "
"Обратите внимание, что и CHARSET, и LANGUAGE могут иметь значение None, и в "
"этом случае вам следует учитывать, что VALUE закодировано в кодировке us-"
"ascii. Обычно вы можете игнорировать ``LANGUAGE``."

#: ../../library/email.compat32-message.rst:512
msgid ""
"If your application doesn't care whether the parameter was encoded as in :"
"rfc:`2231`, you can collapse the parameter value by calling :func:`email."
"utils.collapse_rfc2231_value`, passing in the return value from :meth:"
"`get_param`.  This will return a suitably decoded Unicode string when the "
"value is a tuple, or the original string unquoted if it isn't.  For example::"
msgstr ""
"Если вашему приложению не важно, был ли параметр закодирован как :rfc:"
"`2231`, вы можете свернуть значение параметра, вызвав :func:`email.utils."
"collapse_rfc2231_value`, передав возвращаемое значение из :meth:` "
"get_param`. Это вернет правильно декодированную строку Unicode, если "
"значение является кортежем, или исходную строку без кавычек, если это не "
"так. Например::"

#: ../../library/email.compat32-message.rst:519
msgid ""
"rawparam = msg.get_param('foo')\n"
"param = email.utils.collapse_rfc2231_value(rawparam)"
msgstr ""
"rawparam = msg.get_param('foo')\n"
"param = email.utils.collapse_rfc2231_value(rawparam)"

#: ../../library/email.compat32-message.rst:522
msgid ""
"In any case, the parameter value (either the returned string, or the "
"``VALUE`` item in the 3-tuple) is always unquoted, unless *unquote* is set "
"to ``False``."
msgstr ""
"В любом случае значение параметра (либо возвращаемая строка, либо элемент "
"``VALUE`` в тройке) всегда не заключено в кавычки, если только для параметра "
"*unquote* не установлено значение ``False``."

#: ../../library/email.compat32-message.rst:535
msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the parameter "
"already exists in the header, its value will be replaced with *value*.  If "
"the :mailheader:`Content-Type` header as not yet been defined for this "
"message, it will be set to :mimetype:`text/plain` and the new parameter "
"value will be appended as per :rfc:`2045`."
msgstr ""
"Установите параметр в заголовке :mailheader:`Content-Type`. Если параметр "
"уже существует в заголовке, его значение будет заменено на *значение*. Если "
"заголовок :mailheader:`Content-Type` еще не определен для этого сообщения, "
"ему будет присвоено значение :mimetype:`text/plain`, а новое значение "
"параметра будет добавлено в соответствии с :rfc:`2045`."

#: ../../library/email.compat32-message.rst:541
msgid ""
"Optional *header* specifies an alternative header to :mailheader:`Content-"
"Type`, and all parameters will be quoted as necessary unless optional "
"*requote* is ``False`` (the default is ``True``)."
msgstr ""
"Необязательный *header* указывает альтернативный заголовок :mailheader:"
"`Content-Type`, и все параметры будут заключены в кавычки по мере "
"необходимости, если необязательный *requote* не имеет значения ``False`` (по "
"умолчанию установлено ``True``)."

#: ../../library/email.compat32-message.rst:545
msgid ""
"If optional *charset* is specified, the parameter will be encoded according "
"to :rfc:`2231`. Optional *language* specifies the RFC 2231 language, "
"defaulting to the empty string.  Both *charset* and *language* should be "
"strings."
msgstr ""
"Если указан необязательный *charset*, параметр будет закодирован в "
"соответствии с :rfc:`2231`. Необязательный *language* указывает язык RFC "
"2231, по умолчанию используется пустая строка. И *charset*, и *language* "
"должны быть строками."

#: ../../library/email.compat32-message.rst:550
msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of "
"the list of headers.  If *replace* is ``True``, the header will be updated "
"in place."
msgstr ""
"Если *replace* имеет значение «False» (по умолчанию), заголовок перемещается "
"в конец списка заголовков. Если *replace* имеет значение True, заголовок "
"будет обновлен на месте."

#: ../../library/email.compat32-message.rst:554
msgid "``replace`` keyword was added."
msgstr "Добавлено ключевое слово replace."

#: ../../library/email.compat32-message.rst:559
msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type` "
"header.  The header will be re-written in place without the parameter or its "
"value.  All values will be quoted as necessary unless *requote* is ``False`` "
"(the default is ``True``).  Optional *header* specifies an alternative to :"
"mailheader:`Content-Type`."
msgstr ""
"Полностью удалите данный параметр из заголовка :mailheader:`Content-Type`. "
"Заголовок будет перезаписан без параметра или его значения. Все значения "
"будут заключены в кавычки по мере необходимости, если *requote* не равно "
"``False`` (по умолчанию установлено ``True``). Необязательный *header* "
"указывает альтернативу :mailheader:`Content-Type`."

#: ../../library/email.compat32-message.rst:568
msgid ""
"Set the main type and subtype for the :mailheader:`Content-Type` header. "
"*type* must be a string in the form :mimetype:`maintype/subtype`, otherwise "
"a :exc:`ValueError` is raised."
msgstr ""
"Установите основной тип и подтип для заголовка :mailheader:`Content-Type`. "
"*type* должен быть строкой в ​​форме :mimetype:`maintype/subtype`, в противном "
"случае выдается :exc:`ValueError`."

#: ../../library/email.compat32-message.rst:572
msgid ""
"This method replaces the :mailheader:`Content-Type` header, keeping all the "
"parameters in place.  If *requote* is ``False``, this leaves the existing "
"header's quoting as is, otherwise the parameters will be quoted (the "
"default)."
msgstr ""
"Этот метод заменяет заголовок :mailheader:`Content-Type`, сохраняя все "
"параметры на месте. Если *requote* имеет значение «False», это оставляет "
"кавычки существующего заголовка как есть, в противном случае параметры будут "
"заключены в кавычки (по умолчанию)."

#: ../../library/email.compat32-message.rst:577
msgid ""
"An alternative header can be specified in the *header* argument. When the :"
"mailheader:`Content-Type` header is set a :mailheader:`MIME-Version` header "
"is also added."
msgstr ""
"Альтернативный заголовок можно указать в аргументе *header*. Когда "
"установлен заголовок :mailheader:`Content-Type`, также добавляется "
"заголовок :mailheader:`MIME-Version`."

#: ../../library/email.compat32-message.rst:581
msgid ""
"This is a legacy method.  On the :class:`~email.emailmessage.EmailMessage` "
"class its functionality is replaced by the ``make_`` and ``add_`` methods."
msgstr ""
"Это устаревший метод. В классе :class:`~email.emailmessage.EmailMessage` его "
"функциональность заменяется методами ``make_`` и ``add_``."

#: ../../library/email.compat32-message.rst:588
msgid ""
"Return the value of the ``filename`` parameter of the :mailheader:`Content-"
"Disposition` header of the message.  If the header does not have a "
"``filename`` parameter, this method falls back to looking for the ``name`` "
"parameter on the :mailheader:`Content-Type` header.  If neither is found, or "
"the header is missing, then *failobj* is returned. The returned string will "
"always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Возвращает значение параметра ``filename`` заголовка :mailheader:`Content-"
"Disposition` сообщения. Если в заголовке нет параметра ``filename``, этот "
"метод возвращается к поиску параметра ``name`` в заголовке :mailheader:"
"`Content-Type`. Если ни один из них не найден или заголовок отсутствует, "
"возвращается *failobj*. Возвращенная строка всегда будет без кавычек "
"согласно :func:`email.utils.unquote`."

#: ../../library/email.compat32-message.rst:599
msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader:`Content-"
"Type` header of the message, or *failobj* if either the header is missing, "
"or has no ``boundary`` parameter.  The returned string will always be "
"unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Возвращает значение параметра ``boundary`` заголовка :mailheader:`Content-"
"Type` сообщения или *failobj*, если заголовок отсутствует или не имеет "
"параметра ``boundary``. Возвращенная строка всегда будет без кавычек "
"согласно :func:`email.utils.unquote`."

#: ../../library/email.compat32-message.rst:607
msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to "
"*boundary*.  :meth:`set_boundary` will always quote *boundary* if "
"necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the message "
"object has no :mailheader:`Content-Type` header."
msgstr ""
"Установите для параметра border заголовка :mailheader:`Content-Type` "
"значение *boundary*. :meth:`set_boundary` всегда будет заключать в кавычки "
"*boundary*, если это необходимо. Ошибка :exc:`~email.errors."
"HeaderParseError` возникает, если объект сообщения не имеет заголовка :"
"mailheader:`Content-Type`."

#: ../../library/email.compat32-message.rst:612
msgid ""
"Note that using this method is subtly different than deleting the old :"
"mailheader:`Content-Type` header and adding a new one with the new boundary "
"via :meth:`add_header`, because :meth:`set_boundary` preserves the order of "
"the :mailheader:`Content-Type` header in the list of headers. However, it "
"does *not* preserve any continuation lines which may have been present in "
"the original :mailheader:`Content-Type` header."
msgstr ""
"Обратите внимание, что использование этого метода немного отличается от "
"удаления старого заголовка :mailheader:`Content-Type` и добавления нового с "
"новой границей через :meth:`add_header`, поскольку :meth:`set_boundary` "
"сохраняет порядок :mailheader:`Content-Type` заголовок в списке заголовков. "
"Однако он *не* сохраняет какие-либо строки продолжения, которые могли "
"присутствовать в исходном заголовке :mailheader:`Content-Type`."

#: ../../library/email.compat32-message.rst:622
msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` header, "
"coerced to lower case.  If there is no :mailheader:`Content-Type` header, or "
"if that header has no ``charset`` parameter, *failobj* is returned."
msgstr ""
"Возвращает параметр ``charset`` заголовка :mailheader:`Content-Type`, "
"переведенный в нижний регистр. Если заголовок :mailheader:`Content-Type` "
"отсутствует или этот заголовок не имеет параметра ``charset``, возвращается "
"*failobj*."

#: ../../library/email.compat32-message.rst:626
msgid ""
"Note that this method differs from :meth:`get_charset` which returns the :"
"class:`~email.charset.Charset` instance for the default encoding of the "
"message body."
msgstr ""
"Обратите внимание, что этот метод отличается от :meth:`get_charset`, который "
"возвращает экземпляр :class:`~email.charset.Charset` для кодировки тела "
"сообщения по умолчанию."

#: ../../library/email.compat32-message.rst:632
msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one element "
"for each subpart in the payload, otherwise, it will be a list of length 1."
msgstr ""
"Возвращает список, содержащий имена наборов символов в сообщении. Если "
"сообщение имеет тип :mimetype:`multipart`, то список будет содержать по "
"одному элементу для каждой части полезных данных, в противном случае это "
"будет список длиной 1."

#: ../../library/email.compat32-message.rst:636
msgid ""
"Each item in the list will be a string which is the value of the ``charset`` "
"parameter in the :mailheader:`Content-Type` header for the represented "
"subpart.  However, if the subpart has no :mailheader:`Content-Type` header, "
"no ``charset`` parameter, or is not of the :mimetype:`text` main MIME type, "
"then that item in the returned list will be *failobj*."
msgstr ""
"Каждый элемент в списке будет строкой, которая является значением параметра "
"charset в заголовке :mailheader:`Content-Type` для представленной части. "
"Однако, если в подразделе нет заголовка :mailheader:`Content-Type`, нет "
"параметра ``charset`` или он не относится к основному MIME-типу :mimetype:"
"`text`, тогда этот элемент в возвращаемом списке будет * фаилобдж*."

#: ../../library/email.compat32-message.rst:646
msgid ""
"Return the lowercased value (without parameters) of the message's :"
"mailheader:`Content-Disposition` header if it has one, or ``None``.  The "
"possible values for this method are *inline*, *attachment* or ``None`` if "
"the message follows :rfc:`2183`."
msgstr ""
"Возвращает значение в нижнем регистре (без параметров) заголовка сообщения :"
"mailheader:`Content-Disposition`, если он есть, или ``None``. Возможные "
"значения для этого метода: *inline*, *attachment* или ``None``, если за "
"сообщением следует :rfc:`2183`."

#: ../../library/email.compat32-message.rst:655
msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in depth-"
"first traversal order.  You will typically use :meth:`walk` as the iterator "
"in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
"Метод :meth:`walk` — это универсальный генератор, который можно использовать "
"для перебора всех частей и подчастей дерева объектов сообщений в порядке "
"обхода в глубину. Обычно вы будете использовать :meth:`walk` в качестве "
"итератора в цикле ``for``; каждая итерация возвращает следующую подчасть."

#: ../../library/email.compat32-message.rst:660
msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr ""
"Вот пример, который печатает MIME-тип каждой части составной структуры "
"сообщения:"

#: ../../library/email.compat32-message.rst:674
msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"
msgstr ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"

#: ../../library/email.compat32-message.rst:686
msgid ""
"``walk`` iterates over the subparts of any part where :meth:`is_multipart` "
"returns ``True``, even though ``msg.get_content_maintype() == 'multipart'`` "
"may return ``False``.  We can see this in our example by making use of the "
"``_structure`` debug helper function:"
msgstr ""
"``walk`` перебирает подчасти любой части, где :meth:`is_multipart` "
"возвращает ``True``, хотя ``msg.get_content_maintype() == 'multipart'`` "
"может возвращать ``False``. Мы можем увидеть это в нашем примере, "
"воспользовавшись вспомогательной функцией отладки ``_structure``:"

#: ../../library/email.compat32-message.rst:692
msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"
msgstr ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"

#: ../../library/email.compat32-message.rst:713
msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into the "
"subparts."
msgstr ""
"Здесь части «сообщения» не являются «составными частями», но они содержат "
"подчасти. ``is_multipart()`` возвращает ``True`` и ``walk`` спускается в "
"подчасти."

#: ../../library/email.compat32-message.rst:718
msgid ""
":class:`Message` objects can also optionally contain two instance "
"attributes, which can be used when generating the plain text of a MIME "
"message."
msgstr ""
"Объекты :class:`Message` также могут содержать два атрибута экземпляра, "
"которые можно использовать при создании обычного текста сообщения MIME."

#: ../../library/email.compat32-message.rst:724
msgid ""
"The format of a MIME document allows for some text between the blank line "
"following the headers, and the first multipart boundary string. Normally, "
"this text is never visible in a MIME-aware mail reader because it falls "
"outside the standard MIME armor.  However, when viewing the raw text of the "
"message, or when viewing the message in a non-MIME aware reader, this text "
"can become visible."
msgstr ""
"Формат документа MIME допускает наличие некоторого текста между пустой "
"строкой, следующей за заголовками, и первой составной граничной строкой. "
"Обычно этот текст никогда не отображается в программе чтения почты с "
"поддержкой MIME, поскольку он выходит за рамки стандартной защиты MIME. "
"Однако при просмотре необработанного текста сообщения или при просмотре "
"сообщения в программе чтения, не поддерживающей MIME, этот текст может стать "
"видимым."

#: ../../library/email.compat32-message.rst:731
msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text after "
"the headers but before the first boundary string, it assigns this text to "
"the message's *preamble* attribute.  When the :class:`~email.generator."
"Generator` is writing out the plain text representation of a MIME message, "
"and it finds the message has a *preamble* attribute, it will write this text "
"in the area between the headers and the first boundary.  See :mod:`email."
"parser` and :mod:`email.generator` for details."
msgstr ""
"Атрибут *preamble* содержит начальный дополнительный текст для документов "
"MIME. Когда :class:`~email.parser.Parser` обнаруживает некоторый текст после "
"заголовков, но перед первой граничной строкой, он присваивает этот текст "
"атрибуту *preamble* сообщения. Когда :class:`~email.generator.Generator` "
"записывает простое текстовое представление сообщения MIME и обнаруживает, "
"что сообщение имеет атрибут *preamble*, он записывает этот текст в область "
"между заголовками и первая граница. Подробности смотрите в :mod:`email."
"parser` и :mod:`email.generator`."

#: ../../library/email.compat32-message.rst:741
msgid ""
"Note that if the message object has no preamble, the *preamble* attribute "
"will be ``None``."
msgstr ""
"Обратите внимание: если объект сообщения не имеет преамбулы, атрибут "
"*preamble* будет иметь значение «Нет»."

#: ../../library/email.compat32-message.rst:747
msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and the "
"end of the message."
msgstr ""
"Атрибут *epilogue* действует так же, как атрибут *preamble*, за исключением "
"того, что он содержит текст, который появляется между последней границей и "
"концом сообщения."

#: ../../library/email.compat32-message.rst:751
msgid ""
"You do not need to set the epilogue to the empty string in order for the :"
"class:`~email.generator.Generator` to print a newline at the end of the file."
msgstr ""
"Вам не нужно устанавливать эпилог в пустую строку, чтобы :class:`~email."
"generator.Generator` печатал новую строку в конце файла."

#: ../../library/email.compat32-message.rst:758
msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description of "
"the possible parsing defects."
msgstr ""
"Атрибут *defects* содержит список всех проблем, обнаруженных при разборе "
"этого сообщения. См. :mod:`email.errors` для подробного описания возможных "
"дефектов синтаксического анализа."
