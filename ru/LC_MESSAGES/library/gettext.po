# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# alex alev <alex.alev@bk.ru>, 2021
# Daniil Kolesnikov, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:06+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/gettext.rst:2
msgid ":mod:`!gettext` --- Multilingual internationalization services"
msgstr ":mod:`!gettext` --- Службы многоязычной интернационализации"

#: ../../library/gettext.rst:10
msgid "**Source code:** :source:`Lib/gettext.py`"
msgstr "**Исходный код:** :source:`Lib/gettext.py`"

#: ../../library/gettext.rst:14
msgid ""
"The :mod:`gettext` module provides internationalization (I18N) and "
"localization (L10N) services for your Python modules and applications. It "
"supports both the GNU :program:`gettext` message catalog API and a higher "
"level, class-based API that may be more appropriate for Python files.  The "
"interface described below allows you to write your module and application "
"messages in one natural language, and provide a catalog of translated "
"messages for running under different natural languages."
msgstr ""
"Модуль :mod:`gettext` предоставляет услуги интернационализации (I18N) и "
"локализации (L10N) для ваших модулей и приложений Python. Он поддерживает "
"как API каталога сообщений GNU :program:`gettext`, так и API более высокого "
"уровня на основе классов, который может быть более подходящим для файлов "
"Python. Описанный ниже интерфейс позволяет вам писать сообщения вашего "
"модуля и приложения на одном естественном языке и предоставлять каталог "
"переведенных сообщений для работы на разных естественных языках."

#: ../../library/gettext.rst:22
msgid ""
"Some hints on localizing your Python modules and applications are also given."
msgstr ""
"Также даются некоторые советы по локализации модулей и приложений Python."

#: ../../library/gettext.rst:26
msgid "GNU :program:`gettext` API"
msgstr "GNU :program:`gettext` API"

#: ../../library/gettext.rst:28
msgid ""
"The :mod:`gettext` module defines the following API, which is very similar "
"to the GNU :program:`gettext` API.  If you use this API you will affect the "
"translation of your entire application globally.  Often this is what you "
"want if your application is monolingual, with the choice of language "
"dependent on the locale of your user.  If you are localizing a Python "
"module, or if your application needs to switch languages on the fly, you "
"probably want to use the class-based API instead."
msgstr ""
"Модуль :mod:`gettext` определяет следующий API, который очень похож на API :"
"program:`gettext` GNU. Если вы используете этот API, вы повлияете на перевод "
"всего вашего приложения во всем мире. Часто это то, что вам нужно, если ваше "
"приложение является одноязычным, а выбор языка зависит от языкового "
"стандарта вашего пользователя. Если вы локализуете модуль Python или вашему "
"приложению необходимо переключать языки на лету, вы, вероятно, захотите "
"вместо этого использовать API на основе классов."

#: ../../library/gettext.rst:39
msgid ""
"Bind the *domain* to the locale directory *localedir*.  More concretely, :"
"mod:`gettext` will look for binary :file:`.mo` files for the given domain "
"using the path (on Unix): :file:`{localedir}/{language}/LC_MESSAGES/{domain}."
"mo`, where *language* is searched for in the environment variables :envvar:"
"`LANGUAGE`, :envvar:`LC_ALL`, :envvar:`LC_MESSAGES`, and :envvar:`LANG` "
"respectively."
msgstr ""
"Привяжите *домен* к каталогу локали *localedir*. Более конкретно, :mod:"
"`gettext` будет искать двоичные файлы :file:`.mo` для данного домена, "
"используя путь (в Unix): :file:`{localedir}/{language}/LC_MESSAGES/{domain} ."
"mo`, где *language* ищется в переменных среды :envvar:`LANGUAGE`, :envvar:"
"`LC_ALL`, :envvar:`LC_MESSAGES` и :envvar:`LANG` соответственно."

#: ../../library/gettext.rst:45
msgid ""
"If *localedir* is omitted or ``None``, then the current binding for *domain* "
"is returned. [#]_"
msgstr ""
"Если *localedir* опущен или ``None``, то возвращается текущая привязка для "
"*domain*. [#]_"

#: ../../library/gettext.rst:51
msgid ""
"Change or query the current global domain.  If *domain* is ``None``, then "
"the current global domain is returned, otherwise the global domain is set to "
"*domain*, which is returned."
msgstr ""
"Измените или запросите текущий глобальный домен. Если *domain* имеет "
"значение «None», то возвращается текущий глобальный домен, в противном "
"случае для глобального домена устанавливается значение *domain*, которое и "
"возвращается."

#: ../../library/gettext.rst:59
msgid ""
"Return the localized translation of *message*, based on the current global "
"domain, language, and locale directory.  This function is usually aliased "
"as :func:`!_` in the local namespace (see examples below)."
msgstr ""
"Возвращает локализованный перевод *message* на основе текущего глобального "
"домена, языка и каталога локали. Эта функция обычно имеет псевдоним :func:`!"
"_` в локальном пространстве имен (см. примеры ниже)."

#: ../../library/gettext.rst:66
msgid ""
"Like :func:`.gettext`, but look the message up in the specified *domain*."
msgstr "Как :func:`.gettext`, но ищите сообщение в указанном *домене*."

#: ../../library/gettext.rst:71
msgid ""
"Like :func:`.gettext`, but consider plural forms. If a translation is found, "
"apply the plural formula to *n*, and return the resulting message (some "
"languages have more than two plural forms). If no translation is found, "
"return *singular* if *n* is 1; return *plural* otherwise."
msgstr ""
"Как :func:`.gettext`, но учитывайте формы множественного числа. Если перевод "
"найден, примените формулу множественного числа к *n* и верните полученное "
"сообщение (в некоторых языках имеется более двух форм множественного числа). "
"Если перевод не найден, верните *единственное*, если *n* равно 1; в "
"противном случае верните *множественное число*."

#: ../../library/gettext.rst:76
msgid ""
"The Plural formula is taken from the catalog header. It is a C or Python "
"expression that has a free variable *n*; the expression evaluates to the "
"index of the plural in the catalog. See `the GNU gettext documentation "
"<https://www.gnu.org/software/gettext/manual/gettext.html>`__ for the "
"precise syntax to be used in :file:`.po` files and the formulas for a "
"variety of languages."
msgstr ""
"Формула множественного числа взята из шапки каталога. Это выражение C или "
"Python, имеющее свободную переменную *n*; выражение оценивается как индекс "
"множественного числа в каталоге. См. `документацию GNU gettext <https://www."
"gnu.org/software/gettext/manual/gettext.html>`__ для получения точного "
"синтаксиса, который будет использоваться в файлах :file:`.po` и формул для "
"разнообразие языков."

#: ../../library/gettext.rst:86
msgid ""
"Like :func:`ngettext`, but look the message up in the specified *domain*."
msgstr "Как :func:`ngettext`, но ищите сообщение в указанном *домене*."

#: ../../library/gettext.rst:94
msgid ""
"Similar to the corresponding functions without the ``p`` in the prefix (that "
"is, :func:`gettext`, :func:`dgettext`, :func:`ngettext`, :func:`dngettext`), "
"but the translation is restricted to the given message *context*."
msgstr ""
"Аналогично соответствующим функциям без ``p`` в префиксе (то есть :func:"
"`gettext`, :func:`dgettext`, :func:`ngettext`, :func:`dngettext`), но "
"перевод ограничен данным сообщением *контекст*."

#: ../../library/gettext.rst:101
msgid ""
"Note that GNU :program:`gettext` also defines a :func:`!dcgettext` method, "
"but this was deemed not useful and so it is currently unimplemented."
msgstr ""
"Обратите внимание, что GNU :program:`gettext` также определяет метод :func:`!"
"dcgettext`, но он был сочтен бесполезным и поэтому в настоящее время не "
"реализован."

#: ../../library/gettext.rst:104
msgid "Here's an example of typical usage for this API::"
msgstr "Вот пример типичного использования этого API:"

#: ../../library/gettext.rst:106
msgid ""
"import gettext\n"
"gettext.bindtextdomain('myapplication', '/path/to/my/language/directory')\n"
"gettext.textdomain('myapplication')\n"
"_ = gettext.gettext\n"
"# ...\n"
"print(_('This is a translatable string.'))"
msgstr ""
"import gettext\n"
"gettext.bindtextdomain('myapplication', '/path/to/my/language/directory')\n"
"gettext.textdomain('myapplication')\n"
"_ = gettext.gettext\n"
"# ...\n"
"print(_('This is a translatable string.'))"

#: ../../library/gettext.rst:115
msgid "Class-based API"
msgstr "API, основанный на классах"

#: ../../library/gettext.rst:117
msgid ""
"The class-based API of the :mod:`gettext` module gives you more flexibility "
"and greater convenience than the GNU :program:`gettext` API.  It is the "
"recommended way of localizing your Python applications and modules.  :mod:`!"
"gettext` defines a :class:`GNUTranslations` class which implements the "
"parsing of GNU :file:`.mo` format files, and has methods for returning "
"strings. Instances of this class can also install themselves in the built-in "
"namespace as the function :func:`!_`."
msgstr ""
"API-интерфейс на основе классов модуля :mod:`gettext` обеспечивает большую "
"гибкость и удобство, чем API :program:`gettext` GNU. Это рекомендуемый "
"способ локализации приложений и модулей Python. :mod:`!gettext` определяет "
"класс :class:`GNUTranslations`, который реализует синтаксический анализ "
"файлов формата GNU :file:`.mo` и имеет методы для возврата строк. Экземпляры "
"этого класса также могут устанавливаться во встроенном пространстве имен как "
"функция :func:`!_`."

#: ../../library/gettext.rst:127
msgid ""
"This function implements the standard :file:`.mo` file search algorithm.  It "
"takes a *domain*, identical to what :func:`textdomain` takes.  Optional "
"*localedir* is as in :func:`bindtextdomain`. Optional *languages* is a list "
"of strings, where each string is a language code."
msgstr ""
"Эта функция реализует стандартный алгоритм поиска файлов :file:`.mo`. Для "
"этого требуется *домен*, идентичный тому, что принимает :func:`textdomain`. "
"Необязательный *localedir* аналогичен :func:`bindtextdomain`. Необязательный "
"*languages* — это список строк, где каждая строка представляет собой код "
"языка."

#: ../../library/gettext.rst:132
msgid ""
"If *localedir* is not given, then the default system locale directory is "
"used. [#]_  If *languages* is not given, then the following environment "
"variables are searched: :envvar:`LANGUAGE`, :envvar:`LC_ALL`, :envvar:"
"`LC_MESSAGES`, and :envvar:`LANG`.  The first one returning a non-empty "
"value is used for the *languages* variable. The environment variables should "
"contain a colon separated list of languages, which will be split on the "
"colon to produce the expected list of language code strings."
msgstr ""
"Если *localedir* не указан, то используется системный каталог локали по "
"умолчанию. [#]_ Если *languages* не указан, то выполняется поиск по "
"следующим переменным среды: :envvar:`LANGUAGE`, :envvar:`LC_ALL`, :envvar:"
"`LC_MESSAGES` и :envvar:`LANG`. Первый из них, возвращающий непустое "
"значение, используется для переменной *languages*. Переменные среды должны "
"содержать список языков, разделенных двоеточием, который будет разделен на "
"двоеточие для получения ожидаемого списка строк кода языка."

#: ../../library/gettext.rst:140
msgid ""
":func:`find` then expands and normalizes the languages, and then iterates "
"through them, searching for an existing file built of these components:"
msgstr ""
":func:`find` затем расширяет и нормализует языки, а затем перебирает их в "
"поисках существующего файла, состоящего из этих компонентов:"

#: ../../library/gettext.rst:143
msgid ":file:`{localedir}/{language}/LC_MESSAGES/{domain}.mo`"
msgstr ":file:`{localedir}/{language}/LC_MESSAGES/{domain}.mo`"

#: ../../library/gettext.rst:145
msgid ""
"The first such file name that exists is returned by :func:`find`. If no such "
"file is found, then ``None`` is returned. If *all* is given, it returns a "
"list of all file names, in the order in which they appear in the languages "
"list or the environment variables."
msgstr ""
"Первое существующее такое имя файла возвращается функцией :func:`find`. Если "
"такой файл не найден, возвращается None. Если указано *all*, возвращается "
"список всех имен файлов в том порядке, в котором они появляются в списке "
"языков или переменных среды."

#: ../../library/gettext.rst:153
msgid ""
"Return a ``*Translations`` instance based on the *domain*, *localedir*, and "
"*languages*, which are first passed to :func:`find` to get a list of the "
"associated :file:`.mo` file paths.  Instances with identical :file:`.mo` "
"file names are cached.  The actual class instantiated is *class_* if "
"provided, otherwise :class:`GNUTranslations`.  The class's constructor must "
"take a single :term:`file object` argument."
msgstr ""
"Возвращает экземпляр ``*Translations`` на основе *domain*, *localedir* и "
"*languages*, которые сначала передаются в :func:`find` для получения списка "
"связанных :file:`.mo` пути к файлам. Экземпляры с идентичными именами "
"файлов :file:`.mo` кэшируются. Фактический экземпляр класса — *class_*, если "
"он указан, в противном случае — :class:`GNUTranslations`. Конструктор класса "
"должен принимать один аргумент :term:`file object`."

#: ../../library/gettext.rst:160
msgid ""
"If multiple files are found, later files are used as fallbacks for earlier "
"ones. To allow setting the fallback, :func:`copy.copy` is used to clone each "
"translation object from the cache; the actual instance data is still shared "
"with the cache."
msgstr ""
"Если обнаружено несколько файлов, более поздние файлы используются как "
"резервные копии более ранних. Чтобы разрешить установку резервного "
"варианта, :func:`copy.copy` используется для клонирования каждого объекта "
"перевода из кэша; фактические данные экземпляра по-прежнему используются "
"совместно с кешем."

#: ../../library/gettext.rst:165
msgid ""
"If no :file:`.mo` file is found, this function raises :exc:`OSError` if "
"*fallback* is false (which is the default), and returns a :class:"
"`NullTranslations` instance if *fallback* is true."
msgstr ""
"Если файл :file:`.mo` не найден, эта функция вызывает :exc:`OSError`, если "
"*fallback* имеет значение false (что является значением по умолчанию), и "
"возвращает экземпляр :class:`NullTranslations`, если *fallback* имеет "
"значение истинный."

#: ../../library/gettext.rst:169
msgid ":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr ""
":exc:`IOError` раньше использовался для возбуждения, теперь это псевдоним :"
"exc:`OSError`."

#: ../../library/gettext.rst:172
msgid "*codeset* parameter is removed."
msgstr "Параметр *codeset* удален."

#: ../../library/gettext.rst:177
msgid ""
"This installs the function :func:`!_` in Python's builtins namespace, based "
"on *domain* and *localedir* which are passed to the function :func:"
"`translation`."
msgstr ""
"Это устанавливает функцию :func:`!_` во встроенном пространстве имен Python "
"на основе *domain* и *localedir*, которые передаются в функцию :func:"
"`translation`."

#: ../../library/gettext.rst:180
msgid ""
"For the *names* parameter, please see the description of the translation "
"object's :meth:`~NullTranslations.install` method."
msgstr ""
"Для параметра *names* см. описание метода :meth:`~NullTranslations.install` "
"объекта перевода."

#: ../../library/gettext.rst:183
msgid ""
"As seen below, you usually mark the strings in your application that are "
"candidates for translation, by wrapping them in a call to the :func:`!_` "
"function, like this::"
msgstr ""
"Как показано ниже, вы обычно отмечаете в приложении строки, являющиеся "
"кандидатами на перевод, заключая их в вызов функции :func:`!_`, например:"

#: ../../library/gettext.rst:187
msgid "print(_('This string will be translated.'))"
msgstr "print(_('This string will be translated.'))"

#: ../../library/gettext.rst:189
msgid ""
"For convenience, you want the :func:`!_` function to be installed in "
"Python's builtins namespace, so it is easily accessible in all modules of "
"your application."
msgstr ""
"Для удобства вы хотите, чтобы функция :func:`!_` была установлена ​​во "
"встроенном пространстве имен Python, чтобы она была легко доступна во всех "
"модулях вашего приложения."

#: ../../library/gettext.rst:193
msgid "*names* is now a keyword-only parameter."
msgstr "*names* теперь является параметром только для ключевых слов."

#: ../../library/gettext.rst:197
msgid "The :class:`NullTranslations` class"
msgstr "Класс :class:`NullTranslations` "

#: ../../library/gettext.rst:199
msgid ""
"Translation classes are what actually implement the translation of original "
"source file message strings to translated message strings. The base class "
"used by all translation classes is :class:`NullTranslations`; this provides "
"the basic interface you can use to write your own specialized translation "
"classes.  Here are the methods of :class:`!NullTranslations`:"
msgstr ""
"Классы перевода — это то, что фактически реализует перевод строк сообщений "
"исходного файла в переведенные строки сообщений. Базовый класс, используемый "
"всеми классами перевода, — :class:`NullTranslations`; это обеспечивает "
"базовый интерфейс, который вы можете использовать для написания собственных "
"специализированных классов перевода. Вот методы :class:`!NullTranslations`:"

#: ../../library/gettext.rst:208
msgid ""
"Takes an optional :term:`file object` *fp*, which is ignored by the base "
"class. Initializes \"protected\" instance variables *_info* and *_charset* "
"which are set by derived classes, as well as *_fallback*, which is set "
"through :meth:`add_fallback`.  It then calls ``self._parse(fp)`` if *fp* is "
"not ``None``."
msgstr ""
"Принимает необязательный файловый объект *fp*, который игнорируется базовым "
"классом. Инициализирует «защищенные» переменные экземпляра *_info* и "
"*_charset*, которые устанавливаются производными классами, а также "
"*_fallback*, который устанавливается через :meth:`add_fallback`. Затем он "
"вызывает ``self._parse(fp)``, если *fp* не ``None``."

#: ../../library/gettext.rst:216
msgid ""
"No-op in the base class, this method takes file object *fp*, and reads the "
"data from the file, initializing its message catalog.  If you have an "
"unsupported message catalog file format, you should override this method to "
"parse your format."
msgstr ""
"Неактивный в базовом классе, этот метод принимает файловый объект *fp* и "
"считывает данные из файла, инициализируя его каталог сообщений. Если у вас "
"неподдерживаемый формат файла каталога сообщений, вам следует переопределить "
"этот метод для анализа вашего формата."

#: ../../library/gettext.rst:224
msgid ""
"Add *fallback* as the fallback object for the current translation object. A "
"translation object should consult the fallback if it cannot provide a "
"translation for a given message."
msgstr ""
"Добавьте *fallback* в качестве резервного объекта для текущего объекта "
"перевода. Объект перевода должен обратиться к резервному варианту, если он "
"не может обеспечить перевод для данного сообщения."

#: ../../library/gettext.rst:231
msgid ""
"If a fallback has been set, forward :meth:`!gettext` to the fallback. "
"Otherwise, return *message*.  Overridden in derived classes."
msgstr ""
"Если был установлен резервный вариант, перешлите :meth:`!gettext` к "
"резервному варианту. В противном случае верните *сообщение*. Переопределено "
"в производных классах."

#: ../../library/gettext.rst:237
msgid ""
"If a fallback has been set, forward :meth:`!ngettext` to the fallback. "
"Otherwise, return *singular* if *n* is 1; return *plural* otherwise. "
"Overridden in derived classes."
msgstr ""
"Если был установлен резервный вариант, перешлите :meth:`!ngettext` к "
"резервному варианту. В противном случае верните *singular*, если *n* равно "
"1; в противном случае верните *множественное число*. Переопределено в "
"производных классах."

#: ../../library/gettext.rst:244
msgid ""
"If a fallback has been set, forward :meth:`pgettext` to the fallback. "
"Otherwise, return the translated message.  Overridden in derived classes."
msgstr ""
"Если был установлен резервный вариант, переправьте :meth:`pgettext` на "
"резервный вариант. В противном случае верните переведенное сообщение. "
"Переопределено в производных классах."

#: ../../library/gettext.rst:252
msgid ""
"If a fallback has been set, forward :meth:`npgettext` to the fallback. "
"Otherwise, return the translated message.  Overridden in derived classes."
msgstr ""
"Если был установлен резервный вариант, переправьте :meth:`npgettext` на "
"резервный вариант. В противном случае верните переведенное сообщение. "
"Переопределено в производных классах."

#: ../../library/gettext.rst:260
msgid ""
"Return a dictionary containing the metadata found in the message catalog "
"file."
msgstr ""
"Верните словарь, содержащий метаданные, найденные в файле каталога сообщений."

#: ../../library/gettext.rst:266
msgid "Return the encoding of the message catalog file."
msgstr "Возвращает кодировку файла каталога сообщений."

#: ../../library/gettext.rst:271
msgid ""
"This method installs :meth:`.gettext` into the built-in namespace, binding "
"it to ``_``."
msgstr ""
"Этот метод устанавливает :meth:`.gettext` во встроенное пространство имен, "
"привязывая его к ``_``."

#: ../../library/gettext.rst:274
msgid ""
"If the *names* parameter is given, it must be a sequence containing the "
"names of functions you want to install in the builtins namespace in addition "
"to :func:`!_`.  Supported names are ``'gettext'``, ``'ngettext'``, "
"``'pgettext'``, and ``'npgettext'``."
msgstr ""
"Если указан параметр *names*, это должна быть последовательность, содержащая "
"имена функций, которые вы хотите установить во встроенном пространстве имен, "
"в дополнение к :func:`!_`. Поддерживаемые имена: gettext, ngettext, pgettext "
"и npgettext."

#: ../../library/gettext.rst:279
msgid ""
"Note that this is only one way, albeit the most convenient way, to make the :"
"func:`!_` function available to your application.  Because it affects the "
"entire application globally, and specifically the built-in namespace, "
"localized modules should never install :func:`!_`. Instead, they should use "
"this code to make :func:`!_` available to their module::"
msgstr ""
"Обратите внимание, что это только один, хотя и самый удобный способ сделать "
"функцию :func:`!_` доступной для вашего приложения. Поскольку это влияет на "
"все приложение глобально и, в частности, на встроенное пространство имен, "
"локализованные модули никогда не должны устанавливать :func:`!_`. Вместо "
"этого им следует использовать этот код, чтобы сделать :func:`!_` доступным "
"для своего модуля::"

#: ../../library/gettext.rst:285
msgid ""
"import gettext\n"
"t = gettext.translation('mymodule', ...)\n"
"_ = t.gettext"
msgstr ""
"import gettext\n"
"t = gettext.translation('mymodule', ...)\n"
"_ = t.gettext"

#: ../../library/gettext.rst:289
msgid ""
"This puts :func:`!_` only in the module's global namespace and so only "
"affects calls within this module."
msgstr ""
"Это помещает :func:`!_` только в глобальное пространство имен модуля и "
"поэтому влияет только на вызовы внутри этого модуля."

#: ../../library/gettext.rst:292
msgid "Added ``'pgettext'`` and ``'npgettext'``."
msgstr "Добавлены ``'pgettext'`` и ``'npgettext'``."

#: ../../library/gettext.rst:297
msgid "The :class:`GNUTranslations` class"
msgstr "Класс :class:`GNUTranslations` "

#: ../../library/gettext.rst:299
msgid ""
"The :mod:`!gettext` module provides one additional class derived from :class:"
"`NullTranslations`: :class:`GNUTranslations`.  This class overrides :meth:`!"
"_parse` to enable reading GNU :program:`gettext` format :file:`.mo` files in "
"both big-endian and little-endian format."
msgstr ""
"Модуль :mod:`!gettext` предоставляет один дополнительный класс, производный "
"от :class:`NullTranslations`: :class:`GNUTranslations`. Этот класс "
"переопределяет :meth:`!_parse`, чтобы разрешить чтение файлов GNU :program:"
"`gettext` формата :file:`.mo` как в формате с прямым порядком байтов, так и "
"с прямым порядком байтов."

#: ../../library/gettext.rst:304
msgid ""
":class:`GNUTranslations` parses optional metadata out of the translation "
"catalog. It is convention with GNU :program:`gettext` to include metadata as "
"the translation for the empty string. This metadata is in :rfc:`822`\\ -"
"style ``key: value`` pairs, and should contain the ``Project-Id-Version`` "
"key.  If the key ``Content-Type`` is found, then the ``charset`` property is "
"used to initialize the \"protected\" :attr:`!_charset` instance variable, "
"defaulting to ``None`` if not found.  If the charset encoding is specified, "
"then all message ids and message strings read from the catalog are converted "
"to Unicode using this encoding, else ASCII is assumed."
msgstr ""
":class:`GNUTranslations` анализирует дополнительные метаданные из каталога "
"переводов. В GNU :program:`gettext` принято включать метаданные в качестве "
"перевода пустой строки. Эти метаданные представлены в виде пар ``ключ: "
"значение`` в стиле :rfc:`822`\\ и должны содержать ключ ``Project-Id-"
"Version``. Если ключ ``Content-Type`` найден, то свойство ``charset`` "
"используется для инициализации \"защищенной\" переменной экземпляра :attr:`!"
"_charset`, по умолчанию используется значение ``None``, если она не найдена. "
"Если указана кодировка набора символов, то все идентификаторы сообщений и "
"строки сообщений, считанные из каталога, преобразуются в Unicode с "
"использованием этой кодировки, в противном случае предполагается ASCII."

#: ../../library/gettext.rst:314
msgid ""
"Since message ids are read as Unicode strings too, all ``*gettext()`` "
"methods will assume message ids as Unicode strings, not byte strings."
msgstr ""
"Поскольку идентификаторы сообщений также считываются как строки Unicode, все "
"методы ``*gettext()`` будут считать идентификаторы сообщений строками "
"Unicode, а не байтовыми строками."

#: ../../library/gettext.rst:317
msgid ""
"The entire set of key/value pairs are placed into a dictionary and set as "
"the \"protected\" :attr:`!_info` instance variable."
msgstr ""
"Весь набор пар ключ/значение помещается в словарь и устанавливается как "
"«защищенная» переменная экземпляра :attr:`!_info`."

#: ../../library/gettext.rst:320
msgid ""
"If the :file:`.mo` file's magic number is invalid, the major version number "
"is unexpected, or if other problems occur while reading the file, "
"instantiating a :class:`GNUTranslations` class can raise :exc:`OSError`."
msgstr ""
"Если магический номер файла :file:`.mo` недействителен, основной номер "
"версии неожиданный или если при чтении файла возникают другие проблемы, "
"создание экземпляра класса :class:`GNUTranslations` может привести к "
"возникновению :exc:`OSError`."

#: ../../library/gettext.rst:326
msgid ""
"The following methods are overridden from the base class implementation:"
msgstr "Следующие методы переопределяются из реализации базового класса:"

#: ../../library/gettext.rst:330
msgid ""
"Look up the *message* id in the catalog and return the corresponding message "
"string, as a Unicode string.  If there is no entry in the catalog for the "
"*message* id, and a fallback has been set, the look up is forwarded to the "
"fallback's :meth:`~NullTranslations.gettext` method.  Otherwise, the "
"*message* id is returned."
msgstr ""
"Найдите идентификатор *message* в каталоге и верните соответствующую строку "
"сообщения в виде строки Юникода. Если в каталоге нет записи для "
"идентификатора *message* и установлен резервный вариант, поиск "
"перенаправляется в резервный метод :meth:`~NullTranslations.gettext`. В "
"противном случае возвращается идентификатор *message*."

#: ../../library/gettext.rst:339
msgid ""
"Do a plural-forms lookup of a message id.  *singular* is used as the message "
"id for purposes of lookup in the catalog, while *n* is used to determine "
"which plural form to use.  The returned message string is a Unicode string."
msgstr ""
"Выполните поиск идентификатора сообщения во множественном числе. "
"*единственное* используется в качестве идентификатора сообщения для целей "
"поиска в каталоге, а *n* используется для определения того, какую форму "
"множественного числа использовать. Возвращаемая строка сообщения "
"представляет собой строку Юникода."

#: ../../library/gettext.rst:343
msgid ""
"If the message id is not found in the catalog, and a fallback is specified, "
"the request is forwarded to the fallback's :meth:`~NullTranslations."
"ngettext` method.  Otherwise, when *n* is 1 *singular* is returned, and "
"*plural* is returned in all other cases."
msgstr ""
"Если идентификатор сообщения не найден в каталоге и указан резервный "
"вариант, запрос перенаправляется резервному методу :meth:`~NullTranslations."
"ngettext`. В противном случае, когда *n* равно 1, возвращается "
"*единственное* число, а во всех остальных случаях возвращается "
"*множественное число*."

#: ../../library/gettext.rst:348
msgid "Here is an example::"
msgstr "Вот пример::"

#: ../../library/gettext.rst:350
msgid ""
"n = len(os.listdir('.'))\n"
"cat = GNUTranslations(somefile)\n"
"message = cat.ngettext(\n"
"    'There is %(num)d file in this directory',\n"
"    'There are %(num)d files in this directory',\n"
"    n) % {'num': n}"
msgstr ""
"n = len(os.listdir('.'))\n"
"cat = GNUTranslations(somefile)\n"
"message = cat.ngettext(\n"
"    'There is %(num)d file in this directory',\n"
"    'There are %(num)d files in this directory',\n"
"    n) % {'num': n}"

#: ../../library/gettext.rst:360
msgid ""
"Look up the *context* and *message* id in the catalog and return the "
"corresponding message string, as a Unicode string.  If there is no entry in "
"the catalog for the *message* id and *context*, and a fallback has been set, "
"the look up is forwarded to the fallback's :meth:`pgettext` method.  "
"Otherwise, the *message* id is returned."
msgstr ""
"Найдите идентификаторы *context* и *message* в каталоге и верните "
"соответствующую строку сообщения в виде строки Unicode. Если в каталоге нет "
"записи для идентификатора *message* и *context* и установлен резервный "
"вариант, поиск перенаправляется в резервный метод :meth:`pgettext`. В "
"противном случае возвращается идентификатор *message*."

#: ../../library/gettext.rst:371
msgid ""
"Do a plural-forms lookup of a message id.  *singular* is used as the message "
"id for purposes of lookup in the catalog, while *n* is used to determine "
"which plural form to use."
msgstr ""
"Выполните поиск идентификатора сообщения во множественном числе. "
"*единственное* используется в качестве идентификатора сообщения для целей "
"поиска в каталоге, а *n* используется для определения того, какую форму "
"множественного числа использовать."

#: ../../library/gettext.rst:375
msgid ""
"If the message id for *context* is not found in the catalog, and a fallback "
"is specified, the request is forwarded to the fallback's :meth:`npgettext` "
"method.  Otherwise, when *n* is 1 *singular* is returned, and *plural* is "
"returned in all other cases."
msgstr ""
"Если идентификатор сообщения для *context* не найден в каталоге и указан "
"резервный вариант, запрос перенаправляется резервному методу :meth:"
"`npgettext`. В противном случае, когда *n* равно 1, возвращается "
"*единственное* число, а во всех остальных случаях возвращается "
"*множественное число*."

#: ../../library/gettext.rst:384
msgid "Solaris message catalog support"
msgstr "Поддержка каталога сообщений Solaris"

#: ../../library/gettext.rst:386
msgid ""
"The Solaris operating system defines its own binary :file:`.mo` file format, "
"but since no documentation can be found on this format, it is not supported "
"at this time."
msgstr ""
"Операционная система Solaris определяет свой собственный двоичный формат "
"файла :file:`.mo`, но, поскольку по этому формату не найдено никакой "
"документации, в настоящее время он не поддерживается."

#: ../../library/gettext.rst:392
msgid "The Catalog constructor"
msgstr "Конструктор каталога"

#: ../../library/gettext.rst:396
msgid ""
"GNOME uses a version of the :mod:`gettext` module by James Henstridge, but "
"this version has a slightly different API.  Its documented usage was::"
msgstr ""
"GNOME использует версию модуля :mod:`gettext` Джеймса Хенстриджа, но у этой "
"версии немного другой API. Его документированное использование было:"

#: ../../library/gettext.rst:399
msgid ""
"import gettext\n"
"cat = gettext.Catalog(domain, localedir)\n"
"_ = cat.gettext\n"
"print(_('hello world'))"
msgstr ""
"import gettext\n"
"cat = gettext.Catalog(domain, localedir)\n"
"_ = cat.gettext\n"
"print(_('hello world'))"

#: ../../library/gettext.rst:404
msgid ""
"For compatibility with this older module, the function :func:`!Catalog` is "
"an alias for the :func:`translation` function described above."
msgstr ""
"Для совместимости с этим старым модулем функция :func:`!Catalog` является "
"псевдонимом функции :func:`translation`, описанной выше."

#: ../../library/gettext.rst:407
msgid ""
"One difference between this module and Henstridge's: his catalog objects "
"supported access through a mapping API, but this appears to be unused and so "
"is not currently supported."
msgstr ""
"Одно отличие между этим модулем и модулем Хенстриджа: его объекты каталога "
"поддерживают доступ через API сопоставления, но он, похоже, не используется "
"и поэтому в настоящее время не поддерживается."

#: ../../library/gettext.rst:414
msgid "Internationalizing your programs and modules"
msgstr "Интернационализация ваших программ и модулей"

#: ../../library/gettext.rst:416
msgid ""
"Internationalization (I18N) refers to the operation by which a program is "
"made aware of multiple languages.  Localization (L10N) refers to the "
"adaptation of your program, once internationalized, to the local language "
"and cultural habits. In order to provide multilingual messages for your "
"Python programs, you need to take the following steps:"
msgstr ""
"Интернационализация (I18N) относится к операции, посредством которой "
"программа распознает несколько языков. Локализация (L10N) означает адаптацию "
"вашей программы после интернационализации к местному языку и культурным "
"традициям. Чтобы обеспечить многоязычные сообщения для ваших программ "
"Python, вам необходимо предпринять следующие шаги:"

#: ../../library/gettext.rst:422
msgid ""
"prepare your program or module by specially marking translatable strings"
msgstr ""
"подготовьте свою программу или модуль, специально отметив переводимые строки"

#: ../../library/gettext.rst:424
msgid ""
"run a suite of tools over your marked files to generate raw messages catalogs"
msgstr ""
"запустите набор инструментов над отмеченными файлами для создания каталогов "
"необработанных сообщений"

#: ../../library/gettext.rst:426
msgid "create language-specific translations of the message catalogs"
msgstr "создавать языковые переводы каталогов сообщений"

#: ../../library/gettext.rst:428
msgid ""
"use the :mod:`gettext` module so that message strings are properly translated"
msgstr ""
"используйте модуль :mod:`gettext`, чтобы строки сообщений были правильно "
"переведены"

#: ../../library/gettext.rst:430
msgid ""
"In order to prepare your code for I18N, you need to look at all the strings "
"in your files.  Any string that needs to be translated should be marked by "
"wrapping it in ``_('...')`` --- that is, a call to the function :func:`_ "
"<gettext>`.  For example::"
msgstr ""
"Чтобы подготовить код для I18N, вам необходимо просмотреть все строки в "
"ваших файлах. Любая строка, которую необходимо перевести, должна быть "
"помечена путем заключения ее в ``_('...')`` --- то есть вызов функции :func:"
"`_ <gettext>`. Например::"

#: ../../library/gettext.rst:434
msgid ""
"filename = 'mylog.txt'\n"
"message = _('writing a log message')\n"
"with open(filename, 'w') as fp:\n"
"    fp.write(message)"
msgstr ""
"filename = 'mylog.txt'\n"
"message = _('writing a log message')\n"
"with open(filename, 'w') as fp:\n"
"    fp.write(message)"

#: ../../library/gettext.rst:439
msgid ""
"In this example, the string ``'writing a log message'`` is marked as a "
"candidate for translation, while the strings ``'mylog.txt'`` and ``'w'`` are "
"not."
msgstr ""
"В этом примере строка ``'запись сообщения журнала'`` помечается как кандидат "
"на перевод, а строки ``'mylog.txt'`` и ``'w'`` — нет."

#: ../../library/gettext.rst:442
msgid ""
"There are a few tools to extract the strings meant for translation. The "
"original GNU :program:`gettext` only supported C or C++ source code but its "
"extended version :program:`xgettext` scans code written in a number of "
"languages, including Python, to find strings marked as translatable.  `Babel "
"<https://babel.pocoo.org/>`__ is a Python internationalization library that "
"includes a :file:`pybabel` script to extract and compile message catalogs.  "
"François Pinard's program called :program:`xpot` does a similar job and is "
"available as part of his `po-utils package <https://github.com/pinard/po-"
"utils>`__."
msgstr ""
"Существует несколько инструментов для извлечения строк, предназначенных для "
"перевода. Исходная версия GNU :program:`gettext` поддерживала только "
"исходный код C или C++, но ее расширенная версия :program:`xgettext` "
"сканирует код, написанный на нескольких языках, включая Python, чтобы найти "
"строки, помеченные как переводимые. `Babel <https://babel.pocoo.org/>`__ — "
"это библиотека интернационализации Python, которая включает в себя скрипт :"
"file:`pybabel` для извлечения и компиляции каталогов сообщений. Программа "
"Франсуа Пинара под названием :program:`xpot` выполняет аналогичную работу и "
"доступна как часть его `po-utils пакета <https://github.com/pinard/po-"
"utils>`__."

#: ../../library/gettext.rst:452
msgid ""
"(Python also includes pure-Python versions of these programs, called :"
"program:`pygettext.py` and :program:`msgfmt.py`; some Python distributions "
"will install them for you.  :program:`pygettext.py` is similar to :program:"
"`xgettext`, but only understands Python source code and cannot handle other "
"programming languages such as C or C++. :program:`pygettext.py` supports a "
"command-line interface similar to :program:`xgettext`; for details on its "
"use, run ``pygettext.py --help``.  :program:`msgfmt.py` is binary compatible "
"with GNU :program:`msgfmt`.  With these two programs, you may not need the "
"GNU :program:`gettext` package to internationalize your Python applications.)"
msgstr ""
"(Python также включает версии этих программ на чистом Python, называемые :"
"program:`pygettext.py` и :program:`msgfmt.py`; некоторые дистрибутивы Python "
"установят их автоматически. :program:`pygettext.py` аналогичен в :program:"
"`xgettext`, но понимает только исходный код Python и не может работать с "
"другими языками программирования, такими как C или C++. :program:`pygettext."
"py` поддерживает интерфейс командной строки, аналогичный :program:`xgettext` "
"для; Подробности о его использовании запустите ``pygettext.py --help``. :"
"program:`msgfmt.py` двоично совместим с GNU :program:`msgfmt`. С этими двумя "
"программами вам может не понадобиться GNU :program. :`gettext` для "
"интернационализации ваших приложений Python.)"

#: ../../library/gettext.rst:464
msgid ""
":program:`xgettext`, :program:`pygettext`, and similar tools generate :file:"
"`.po` files that are message catalogs.  They are structured human-readable "
"files that contain every marked string in the source code, along with a "
"placeholder for the translated versions of these strings."
msgstr ""
":program:`xgettext`, :program:`pygettext` и подобные инструменты генерируют "
"файлы :file:`.po`, которые являются каталогами сообщений. Это "
"структурированные, удобочитаемые файлы, содержащие каждую помеченную строку "
"в исходном коде, а также заполнитель для переведенных версий этих строк."

#: ../../library/gettext.rst:470
msgid ""
"Copies of these :file:`.po` files are then handed over to the individual "
"human translators who write translations for every supported natural "
"language.  They send back the completed language-specific versions as a :"
"file:`<language-name>.po` file that's compiled into a machine-readable :file:"
"`.mo` binary catalog file using the :program:`msgfmt` program.  The :file:`."
"mo` files are used by the :mod:`gettext` module for the actual translation "
"processing at run-time."
msgstr ""
"Копии этих файлов :file:`.po` затем передаются отдельным переводчикам-людям, "
"которые пишут переводы для каждого поддерживаемого естественного языка. Они "
"отправляют обратно готовые версии для конкретного языка в виде файла :file:"
"`<имя-языка>.po`, который компилируется в машиночитаемый двоичный файл "
"каталога :file:`.mo` с помощью программы :program:`msgfmt`. . Файлы :file:`."
"mo` используются модулем :mod:`gettext` для фактической обработки перевода "
"во время выполнения."

#: ../../library/gettext.rst:479
msgid ""
"How you use the :mod:`gettext` module in your code depends on whether you "
"are internationalizing a single module or your entire application. The next "
"two sections will discuss each case."
msgstr ""
"То, как вы используете модуль :mod:`gettext` в своем коде, зависит от того, "
"интернационализируете ли вы отдельный модуль или все приложение. В следующих "
"двух разделах будет рассмотрен каждый случай."

#: ../../library/gettext.rst:485
msgid "Localizing your module"
msgstr "Локализация вашего модуля"

#: ../../library/gettext.rst:487
msgid ""
"If you are localizing your module, you must take care not to make global "
"changes, e.g. to the built-in namespace. You should not use the GNU :program:"
"`gettext` API but instead the class-based API."
msgstr ""
"Если вы локализуете свой модуль, вы должны позаботиться о том, чтобы не "
"вносить глобальные изменения, например, во встроенное пространство имен. Вам "
"не следует использовать API GNU :program:`gettext`, а вместо этого "
"использовать API на основе классов."

#: ../../library/gettext.rst:491
msgid ""
"Let's say your module is called \"spam\" and the module's various natural "
"language translation :file:`.mo` files reside in :file:`/usr/share/locale` "
"in GNU :program:`gettext` format.  Here's what you would put at the top of "
"your module::"
msgstr ""
"Допустим, ваш модуль называется «спам», а различные файлы перевода модуля на "
"естественный язык :file:`.mo` находятся в :file:`/usr/share/locale` в "
"формате GNU :program:`gettext`. Вот что вы бы поместили в начало вашего "
"модуля:"

#: ../../library/gettext.rst:496
msgid ""
"import gettext\n"
"t = gettext.translation('spam', '/usr/share/locale')\n"
"_ = t.gettext"
msgstr ""
"import gettext\n"
"t = gettext.translation('spam', '/usr/share/locale')\n"
"_ = t.gettext"

#: ../../library/gettext.rst:502
msgid "Localizing your application"
msgstr "Локализация вашего приложения"

#: ../../library/gettext.rst:504
msgid ""
"If you are localizing your application, you can install the :func:`!_` "
"function globally into the built-in namespace, usually in the main driver "
"file of your application.  This will let all your application-specific files "
"just use ``_('...')`` without having to explicitly install it in each file."
msgstr ""
"Если вы локализуете свое приложение, вы можете установить функцию :func:`!_` "
"глобально во встроенное пространство имен, обычно в основной файл драйвера "
"вашего приложения. Это позволит всем файлам вашего приложения просто "
"использовать ``_('...')`` без необходимости явно устанавливать его в каждый "
"файл."

#: ../../library/gettext.rst:509
msgid ""
"In the simple case then, you need only add the following bit of code to the "
"main driver file of your application::"
msgstr ""
"В простом случае вам нужно всего лишь добавить следующий фрагмент кода в "
"основной файл драйвера вашего приложения:"

#: ../../library/gettext.rst:512
msgid ""
"import gettext\n"
"gettext.install('myapplication')"
msgstr ""
"import gettext\n"
"gettext.install('myapplication')"

#: ../../library/gettext.rst:515
msgid ""
"If you need to set the locale directory, you can pass it into the :func:"
"`install` function::"
msgstr ""
"Если вам нужно установить каталог локали, вы можете передать его в функцию :"
"func:`install`::"

#: ../../library/gettext.rst:518
msgid ""
"import gettext\n"
"gettext.install('myapplication', '/usr/share/locale')"
msgstr ""
"import gettext\n"
"gettext.install('myapplication', '/usr/share/locale')"

#: ../../library/gettext.rst:523
msgid "Changing languages on the fly"
msgstr "Изменение языка на лету"

#: ../../library/gettext.rst:525
msgid ""
"If your program needs to support many languages at the same time, you may "
"want to create multiple translation instances and then switch between them "
"explicitly, like so::"
msgstr ""
"Если ваша программа должна поддерживать множество языков одновременно, вы "
"можете создать несколько экземпляров перевода, а затем явно переключаться "
"между ними, например:"

#: ../../library/gettext.rst:529
msgid ""
"import gettext\n"
"\n"
"lang1 = gettext.translation('myapplication', languages=['en'])\n"
"lang2 = gettext.translation('myapplication', languages=['fr'])\n"
"lang3 = gettext.translation('myapplication', languages=['de'])\n"
"\n"
"# start by using language1\n"
"lang1.install()\n"
"\n"
"# ... time goes by, user selects language 2\n"
"lang2.install()\n"
"\n"
"# ... more time goes by, user selects language 3\n"
"lang3.install()"
msgstr ""
"import gettext\n"
"\n"
"lang1 = gettext.translation('myapplication', languages=['en'])\n"
"lang2 = gettext.translation('myapplication', languages=['fr'])\n"
"lang3 = gettext.translation('myapplication', languages=['de'])\n"
"\n"
"# start by using language1\n"
"lang1.install()\n"
"\n"
"# ... time goes by, user selects language 2\n"
"lang2.install()\n"
"\n"
"# ... more time goes by, user selects language 3\n"
"lang3.install()"

#: ../../library/gettext.rst:546
msgid "Deferred translations"
msgstr "Отложенные переводы"

#: ../../library/gettext.rst:548
msgid ""
"In most coding situations, strings are translated where they are coded. "
"Occasionally however, you need to mark strings for translation, but defer "
"actual translation until later.  A classic example is::"
msgstr ""
"В большинстве случаев кодирования строки переводятся там, где они "
"закодированы. Однако иногда вам нужно пометить строки для перевода, но "
"отложить фактический перевод на более позднее время. Классический пример:"

#: ../../library/gettext.rst:552
msgid ""
"animals = ['mollusk',\n"
"           'albatross',\n"
"           'rat',\n"
"           'penguin',\n"
"           'python', ]\n"
"# ...\n"
"for a in animals:\n"
"    print(a)"
msgstr ""
"animals = ['mollusk',\n"
"           'albatross',\n"
"           'rat',\n"
"           'penguin',\n"
"           'python', ]\n"
"# ...\n"
"for a in animals:\n"
"    print(a)"

#: ../../library/gettext.rst:561
msgid ""
"Here, you want to mark the strings in the ``animals`` list as being "
"translatable, but you don't actually want to translate them until they are "
"printed."
msgstr ""
"Здесь вы хотите пометить строки в списке «животные» как переводимые, но на "
"самом деле вы не хотите переводить их, пока они не будут напечатаны."

#: ../../library/gettext.rst:565
msgid "Here is one way you can handle this situation::"
msgstr "Вот один из способов справиться с этой ситуацией:"

#: ../../library/gettext.rst:567
msgid ""
"def _(message): return message\n"
"\n"
"animals = [_('mollusk'),\n"
"           _('albatross'),\n"
"           _('rat'),\n"
"           _('penguin'),\n"
"           _('python'), ]\n"
"\n"
"del _\n"
"\n"
"# ...\n"
"for a in animals:\n"
"    print(_(a))"
msgstr ""
"def _(message): return message\n"
"\n"
"animals = [_('mollusk'),\n"
"           _('albatross'),\n"
"           _('rat'),\n"
"           _('penguin'),\n"
"           _('python'), ]\n"
"\n"
"del _\n"
"\n"
"# ...\n"
"for a in animals:\n"
"    print(_(a))"

#: ../../library/gettext.rst:581
msgid ""
"This works because the dummy definition of :func:`!_` simply returns the "
"string unchanged.  And this dummy definition will temporarily override any "
"definition of :func:`!_` in the built-in namespace (until the :keyword:`del` "
"command). Take care, though if you have a previous definition of :func:`!_` "
"in the local namespace."
msgstr ""
"Это работает, потому что фиктивное определение :func:`!_` просто возвращает "
"строку без изменений. И это фиктивное определение будет временно "
"переопределять любое определение :func:`!_` во встроенном пространстве имен "
"(до команды :keyword:`del`). Однако будьте осторожны, если у вас есть "
"предыдущее определение :func:`!_` в локальном пространстве имен."

#: ../../library/gettext.rst:587
msgid ""
"Note that the second use of :func:`!_` will not identify \"a\" as being "
"translatable to the :program:`gettext` program, because the parameter is not "
"a string literal."
msgstr ""
"Обратите внимание, что второе использование :func:`!_` не будет "
"идентифицировать \"a\" как преобразуемое в программу :program:`gettext`, "
"поскольку параметр не является строковым литералом."

#: ../../library/gettext.rst:591
msgid "Another way to handle this is with the following example::"
msgstr "Другой способ справиться с этим — следующий пример:"

#: ../../library/gettext.rst:593
msgid ""
"def N_(message): return message\n"
"\n"
"animals = [N_('mollusk'),\n"
"           N_('albatross'),\n"
"           N_('rat'),\n"
"           N_('penguin'),\n"
"           N_('python'), ]\n"
"\n"
"# ...\n"
"for a in animals:\n"
"    print(_(a))"
msgstr ""
"def N_(message): return message\n"
"\n"
"animals = [N_('mollusk'),\n"
"           N_('albatross'),\n"
"           N_('rat'),\n"
"           N_('penguin'),\n"
"           N_('python'), ]\n"
"\n"
"# ...\n"
"for a in animals:\n"
"    print(_(a))"

#: ../../library/gettext.rst:605
msgid ""
"In this case, you are marking translatable strings with the function :func:`!"
"N_`, which won't conflict with any definition of :func:`!_`. However, you "
"will need to teach your message extraction program to look for translatable "
"strings marked with :func:`!N_`. :program:`xgettext`, :program:`pygettext`, "
"``pybabel extract``, and :program:`xpot` all support this through the use of "
"the :option:`!-k` command-line switch. The choice of :func:`!N_` here is "
"totally arbitrary; it could have just as easily been :func:`!"
"MarkThisStringForTranslation`."
msgstr ""
"В этом случае вы помечаете переводимые строки функцией :func:`!N_`, которая "
"не будет конфликтовать с каким-либо определением :func:`!_`. Однако вам "
"нужно будет научить вашу программу извлечения сообщений искать переводимые "
"строки, отмеченные :func:`!N_`. :program:`xgettext`, :program:`pygettext`, "
"``pybabel extract`` и :program:`xpot` поддерживают это посредством "
"использования переключателя командной строки :option:`!-k`. Выбор :func:`!"
"N_` здесь совершенно произволен; с тем же успехом это могло быть и :func:`!"
"MarkThisStringForTranslation`."

#: ../../library/gettext.rst:616
msgid "Acknowledgements"
msgstr "Подтверждение"

#: ../../library/gettext.rst:618
msgid ""
"The following people contributed code, feedback, design suggestions, "
"previous implementations, and valuable experience to the creation of this "
"module:"
msgstr ""
"Следующие люди предоставили код, отзывы, предложения по дизайну, предыдущие "
"реализации и ценный опыт для создания этого модуля:"

#: ../../library/gettext.rst:621
msgid "Peter Funk"
msgstr "Peter Funk"

#: ../../library/gettext.rst:623
msgid "James Henstridge"
msgstr "James Henstridge"

#: ../../library/gettext.rst:625
msgid "Juan David Ibáñez Palomar"
msgstr "Juan David Ibáñez Palomar"

#: ../../library/gettext.rst:627
msgid "Marc-André Lemburg"
msgstr "Marc-André Lemburg"

#: ../../library/gettext.rst:629
msgid "Martin von Löwis"
msgstr "Martin von Löwis"

#: ../../library/gettext.rst:631
msgid "François Pinard"
msgstr "François Pinard"

#: ../../library/gettext.rst:633
msgid "Barry Warsaw"
msgstr "Barry Warsaw"

#: ../../library/gettext.rst:635
msgid "Gustavo Niemeyer"
msgstr "Gustavo Niemeyer"

#: ../../library/gettext.rst:638
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/gettext.rst:639
msgid ""
"The default locale directory is system dependent; for example, on Red Hat "
"Linux it is :file:`/usr/share/locale`, but on Solaris it is :file:`/usr/lib/"
"locale`. The :mod:`!gettext` module does not try to support these system "
"dependent defaults; instead its default is :file:`{sys.base_prefix}/share/"
"locale` (see :data:`sys.base_prefix`). For this reason, it is always best to "
"call :func:`bindtextdomain` with an explicit absolute path at the start of "
"your application."
msgstr ""
"Каталог локали по умолчанию зависит от системы; например, в Red Hat Linux "
"это :file:`/usr/share/locale`, а в Solaris это :file:`/usr/lib/locale`. "
"Модуль :mod:`!gettext` не пытается поддерживать эти системно-зависимые "
"значения по умолчанию; вместо этого по умолчанию используется :file:`{sys."
"base_prefix}/share/locale` (см. :data:`sys.base_prefix`). По этой причине "
"всегда лучше вызывать :func:`bindtextdomain` с явным абсолютным путем в "
"начале вашего приложения."

#: ../../library/gettext.rst:647
msgid "See the footnote for :func:`bindtextdomain` above."
msgstr "См. сноску к :func:`bindtextdomain` выше."

#: ../../library/gettext.rst:56
msgid "_ (underscore)"
msgstr "_ (подчеркивание)"

#: ../../library/gettext.rst:56
msgid "gettext"
msgstr "gettext"

#: ../../library/gettext.rst:394
msgid "GNOME"
msgstr "GNOME"
