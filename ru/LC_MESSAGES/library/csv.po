# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# alex alev <alex.alev@bk.ru>, 2021
# Daniil Kolesnikov, 2024
# Илья Панфилов, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 14:17+0000\n"
"PO-Revision-Date: 2021-06-28 01:03+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/csv.rst:2
msgid ":mod:`!csv` --- CSV File Reading and Writing"
msgstr ":mod:`!csv` --- Чтение и запись CSV-файла"

#: ../../library/csv.rst:9
msgid "**Source code:** :source:`Lib/csv.py`"
msgstr "**Исходный код:** :source:`Lib/csv.py`"

#: ../../library/csv.rst:17
msgid ""
"The so-called CSV (Comma Separated Values) format is the most common import "
"and export format for spreadsheets and databases.  CSV format was used for "
"many years prior to attempts to describe the format in a standardized way "
"in :rfc:`4180`.  The lack of a well-defined standard means that subtle "
"differences often exist in the data produced and consumed by different "
"applications.  These differences can make it annoying to process CSV files "
"from multiple sources. Still, while the delimiters and quoting characters "
"vary, the overall format is similar enough that it is possible to write a "
"single module which can efficiently manipulate such data, hiding the details "
"of reading and writing the data from the programmer."
msgstr ""
"Так называемый формат CSV (значения, разделенные запятыми) является наиболее "
"распространенным форматом импорта и экспорта для электронных таблиц и баз "
"данных. Формат CSV использовался в течение многих лет, прежде чем были "
"предприняты попытки стандартизировать его описание в :rfc:`4180`. Отсутствие "
"четко определенного стандарта означает, что в данных, создаваемых и "
"потребляемых различными приложениями, часто существуют небольшие различия. "
"Эти различия могут усложнить обработку файлов CSV из нескольких источников. "
"Тем не менее, хотя разделители и символы кавычек различаются, общий формат "
"достаточно схож, что позволяет написать один модуль, который может "
"эффективно манипулировать такими данными, скрывая детали чтения и записи "
"данных от программиста."

#: ../../library/csv.rst:28
msgid ""
"The :mod:`csv` module implements classes to read and write tabular data in "
"CSV format.  It allows programmers to say, \"write this data in the format "
"preferred by Excel,\" or \"read data from this file which was generated by "
"Excel,\" without knowing the precise details of the CSV format used by "
"Excel.  Programmers can also describe the CSV formats understood by other "
"applications or define their own special-purpose CSV formats."
msgstr ""
"Модуль :mod:`csv` реализует классы для чтения и записи табличных данных в "
"формате CSV. Это позволяет программистам сказать: «запишите эти данные в "
"формате, предпочитаемом Excel» или «прочитайте данные из этого файла, "
"созданного Excel», не зная точных деталей формата CSV, используемого Excel. "
"Программисты также могут описывать форматы CSV, понятные другим приложениям, "
"или определять свои собственные специальные форматы CSV."

#: ../../library/csv.rst:35
msgid ""
"The :mod:`csv` module's :class:`reader` and :class:`writer` objects read and "
"write sequences.  Programmers can also read and write data in dictionary "
"form using the :class:`DictReader` and :class:`DictWriter` classes."
msgstr ""
"Объекты :class:`reader` и :class:`writer` модуля :mod:`csv` читают и "
"записывают последовательности. Программисты также могут читать и записывать "
"данные в словарной форме, используя классы :class:`DictReader` и :class:"
"`DictWriter`."

#: ../../library/csv.rst:41
msgid ":pep:`305` - CSV File API"
msgstr ":pep:`305` - API CSV-файлов"

#: ../../library/csv.rst:42
msgid "The Python Enhancement Proposal which proposed this addition to Python."
msgstr ""
"Python Enhancement Proposal (Предложение по улучшению Python), в котором "
"предлагалось это дополнение к Python."

#: ../../library/csv.rst:48
msgid "Module Contents"
msgstr "Содержимое модуля"

#: ../../library/csv.rst:50
msgid "The :mod:`csv` module defines the following functions:"
msgstr "Модуль :mod:`csv` содержит следующие функции:"

#: ../../library/csv.rst:58
msgid ""
"Return a :ref:`reader object <reader-objects>` that will process lines from "
"the given *csvfile*.  A csvfile must be an iterable of strings, each in the "
"reader's defined csv format. A csvfile is most commonly a file-like object "
"or list. If *csvfile* is a file object, it should be opened with "
"``newline=''``. [1]_  An optional *dialect* parameter can be given which is "
"used to define a set of parameters specific to a particular CSV dialect.  It "
"may be an instance of a subclass of the :class:`Dialect` class or one of the "
"strings returned by the :func:`list_dialects` function.  The other optional "
"*fmtparams* keyword arguments can be given to override individual formatting "
"parameters in the current dialect.  For full details about the dialect and "
"formatting parameters, see section :ref:`csv-fmt-params`."
msgstr ""
"Возвращает :ref:`объект чтения <reader-objects>`, который будет обрабатывать "
"строки из данного *csvфайла*. CSV-файл должен представлять собой итерацию "
"строк, каждая из которых имеет формат csv, определенный читателем. CSV-файл "
"чаще всего представляет собой файловый объект или список. Если *csvfile* "
"является файловым объектом, его следует открыть с помощью ``newline=''``. "
"[1]_ Можно указать необязательный параметр *dialect*, который используется "
"для определения набора параметров, специфичных для конкретного диалекта CSV. "
"Это может быть экземпляр подкласса класса :class:`Dialect` или одна из "
"строк, возвращаемых функцией :func:`list_dialects`. Другие необязательные "
"аргументы ключевого слова *fmtparams* могут быть переданы для "
"переопределения отдельных параметров форматирования в текущем диалекте. "
"Полную информацию о диалекте и параметрах форматирования см. в разделе :ref:"
"`csv-fmt-params`."

#: ../../library/csv.rst:72
msgid ""
"Each row read from the csv file is returned as a list of strings.  No "
"automatic data type conversion is performed unless the ``QUOTE_NONNUMERIC`` "
"format option is specified (in which case unquoted fields are transformed "
"into floats)."
msgstr ""
"Каждая строка, прочитанная из файла CSV, возвращается в виде списка строк. "
"Никакое автоматическое преобразование типов данных не выполняется, если не "
"указан параметр формата QUOTE_NONNUMERIC (в этом случае поля без кавычек "
"преобразуются в числа с плавающей запятой)."

#: ../../library/csv.rst:76 ../../library/csv.rst:106 ../../library/csv.rst:181
#: ../../library/csv.rst:219
msgid "A short usage example::"
msgstr "Краткий пример использования::"

#: ../../library/csv.rst:78
msgid ""
">>> import csv\n"
">>> with open('eggs.csv', newline='') as csvfile:\n"
"...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')\n"
"...     for row in spamreader:\n"
"...         print(', '.join(row))\n"
"Spam, Spam, Spam, Spam, Spam, Baked Beans\n"
"Spam, Lovely Spam, Wonderful Spam"
msgstr ""
">>> import csv\n"
">>> with open('eggs.csv', newline='') as csvfile:\n"
"...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')\n"
"...     for row in spamreader:\n"
"...         print(', '.join(row))\n"
"Spam, Spam, Spam, Spam, Spam, Baked Beans\n"
"Spam, Lovely Spam, Wonderful Spam"

#: ../../library/csv.rst:89
msgid ""
"Return a writer object responsible for converting the user's data into "
"delimited strings on the given file-like object.  *csvfile* can be any "
"object with a :meth:`~io.TextIOBase.write` method.  If *csvfile* is a file "
"object, it should be opened with ``newline=''`` [1]_.  An optional *dialect* "
"parameter can be given which is used to define a set of parameters specific "
"to a particular CSV dialect.  It may be an instance of a subclass of the :"
"class:`Dialect` class or one of the strings returned by the :func:"
"`list_dialects` function.  The other optional *fmtparams* keyword arguments "
"can be given to override individual formatting parameters in the current "
"dialect.  For full details about dialects and formatting parameters, see "
"the :ref:`csv-fmt-params` section. To make it as easy as possible to "
"interface with modules which implement the DB API, the value :const:`None` "
"is written as the empty string.  While this isn't a reversible "
"transformation, it makes it easier to dump SQL NULL data values to CSV files "
"without preprocessing the data returned from a ``cursor.fetch*`` call. All "
"other non-string data are stringified with :func:`str` before being written."
msgstr ""
"Возвращает объект записи, ответственный за преобразование пользовательских "
"данных в строки с разделителями для данного файлового объекта. *csvfile* "
"может быть любым объектом с методом :meth:`~io.TextIOBase.write`. Если "
"*csvfile* является файловым объектом, его следует открыть с помощью "
"``newline=''`` [1]_ . Можно указать необязательный параметр *dialect*, "
"который используется для определения набора параметров, специфичных для "
"конкретного диалекта CSV. Это может быть экземпляр подкласса класса :class:"
"`Dialect` или одна из строк, возвращаемых функцией :func:`list_dialects`. "
"Другие необязательные аргументы ключевого слова *fmtparams* могут быть "
"переданы для переопределения отдельных параметров форматирования в текущем "
"диалекте. Полную информацию о диалектах и ​​параметрах форматирования см. в "
"разделе :ref:`csv-fmt-params`. Чтобы максимально упростить взаимодействие с "
"модулями, реализующими API БД, значение :const:`None` записывается как "
"пустая строка. Хотя это необратимое преобразование, оно упрощает выгрузку "
"значений данных SQL NULL в файлы CSV без предварительной обработки данных, "
"возвращаемых вызовом ``cursor.fetch*``. Все остальные нестроковые данные "
"перед записью преобразуются в строки с помощью :func:`str`."

#: ../../library/csv.rst:108
msgid ""
"import csv\n"
"with open('eggs.csv', 'w', newline='') as csvfile:\n"
"    spamwriter = csv.writer(csvfile, delimiter=' ',\n"
"                            quotechar='|', quoting=csv.QUOTE_MINIMAL)\n"
"    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])\n"
"    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])"
msgstr ""
"import csv\n"
"with open('eggs.csv', 'w', newline='') as csvfile:\n"
"    spamwriter = csv.writer(csvfile, delimiter=' ',\n"
"                            quotechar='|', quoting=csv.QUOTE_MINIMAL)\n"
"    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])\n"
"    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])"

#: ../../library/csv.rst:118
msgid ""
"Associate *dialect* with *name*.  *name* must be a string. The dialect can "
"be specified either by passing a sub-class of :class:`Dialect`, or by "
"*fmtparams* keyword arguments, or both, with keyword arguments overriding "
"parameters of the dialect. For full details about dialects and formatting "
"parameters, see section :ref:`csv-fmt-params`."
msgstr ""
"Свяжите *диалект* с *имя*. *имя* должно быть строкой. Диалект можно указать "
"либо путем передачи подкласса :class:`Dialect`, либо с помощью аргументов "
"ключевого слова *fmtparams*, либо и того, и другого, причем аргументы "
"ключевого слова переопределяют параметры диалекта. Полную информацию о "
"диалектах и ​​параметрах форматирования см. в разделе :ref:`csv-fmt-params`."

#: ../../library/csv.rst:127
msgid ""
"Delete the dialect associated with *name* from the dialect registry.  An :"
"exc:`Error` is raised if *name* is not a registered dialect name."
msgstr ""
"Удалите диалект, связанный с *name*, из реестра диалектов. Ошибка :exc:"
"`Error` возникает, если *name* не является зарегистрированным именем "
"диалекта."

#: ../../library/csv.rst:133
msgid ""
"Return the dialect associated with *name*.  An :exc:`Error` is raised if "
"*name* is not a registered dialect name.  This function returns an "
"immutable :class:`Dialect`."
msgstr ""
"Вернуть диалект, связанный с *name*. Ошибка :exc:`Error` возникает, если "
"*name* не является зарегистрированным именем диалекта. Эта функция "
"возвращает неизменяемый :class:`Dialect`."

#: ../../library/csv.rst:139
msgid "Return the names of all registered dialects."
msgstr "Возвращает имена всех зарегистрированных диалектов."

#: ../../library/csv.rst:144
msgid ""
"Returns the current maximum field size allowed by the parser. If *new_limit* "
"is given, this becomes the new limit."
msgstr ""
"Возвращает текущий максимальный размер поля, разрешенный парсером. Если "
"задан *new_limit*, то этот размер становится новым."

#: ../../library/csv.rst:148
msgid "The :mod:`csv` module defines the following classes:"
msgstr "Модуль :mod:`csv` содержит следующие классы:"

#: ../../library/csv.rst:153
msgid ""
"Create an object that operates like a regular reader but maps the "
"information in each row to a :class:`dict` whose keys are given by the "
"optional *fieldnames* parameter."
msgstr ""
"Создайте объект, который работает как обычное средство чтения, но отображает "
"информацию в каждой строке в :class:`dict`, ключи которого задаются "
"необязательным параметром *fieldnames*."

#: ../../library/csv.rst:157
msgid ""
"The *fieldnames* parameter is a :term:`sequence`.  If *fieldnames* is "
"omitted, the values in the first row of file *f* will be used as the "
"fieldnames and will be omitted from the results. If *fieldnames* is "
"provided, they will be used and the first row will be included in the "
"results.  Regardless of how the fieldnames are determined, the dictionary "
"preserves their original ordering."
msgstr ""
"Параметр *fieldnames* представляет собой :term:`sequence`. Если *fieldnames* "
"опущено, значения в первой строке файла *f* будут использоваться в качестве "
"имен полей и не будут включены в результаты. Если указаны *fieldnames*, они "
"будут использоваться, и в результаты будет включена первая строка. "
"Независимо от того, как определяются имена полей, словарь сохраняет их "
"первоначальный порядок."

#: ../../library/csv.rst:164
msgid ""
"If a row has more fields than fieldnames, the remaining data is put in a "
"list and stored with the fieldname specified by *restkey* (which defaults to "
"``None``).  If a non-blank row has fewer fields than fieldnames, the missing "
"values are filled-in with the value of *restval* (which defaults to "
"``None``)."
msgstr ""
"Если в строке больше полей, чем имен полей, оставшиеся данные помещаются в "
"список и сохраняются с именем поля, указанным *restkey* (которое по "
"умолчанию имеет значение «Нет»). Если в непустой строке меньше полей, чем "
"имен полей, отсутствующие значения заполняются значением *restval* (которое "
"по умолчанию равно ``None``)."

#: ../../library/csv.rst:170
msgid ""
"All other optional or keyword arguments are passed to the underlying :class:"
"`reader` instance."
msgstr ""
"Все остальные необязательные аргументы или аргументы с ключевыми словами "
"передаются базовому экземпляру :class:`reader`."

#: ../../library/csv.rst:173 ../../library/csv.rst:217
msgid ""
"If the argument passed to *fieldnames* is an iterator, it will be coerced to "
"a :class:`list`."
msgstr ""
"Если аргумент, переданный в *fieldnames*, является итератором, он будет "
"преобразован в :class:`list`."

#: ../../library/csv.rst:175
msgid "Returned rows are now of type :class:`OrderedDict`."
msgstr " Возвращаемые строки теперь имеют тип :class:`OrderedDict`."

#: ../../library/csv.rst:178
msgid "Returned rows are now of type :class:`dict`."
msgstr " Возвращаемые строки теперь имеют тип :class:`dict`."

#: ../../library/csv.rst:183
msgid ""
">>> import csv\n"
">>> with open('names.csv', newline='') as csvfile:\n"
"...     reader = csv.DictReader(csvfile)\n"
"...     for row in reader:\n"
"...         print(row['first_name'], row['last_name'])\n"
"...\n"
"Eric Idle\n"
"John Cleese\n"
"\n"
">>> print(row)\n"
"{'first_name': 'John', 'last_name': 'Cleese'}"
msgstr ""
">>> import csv\n"
">>> with open('names.csv', newline='') as csvfile:\n"
"...     reader = csv.DictReader(csvfile)\n"
"...     for row in reader:\n"
"...         print(row['first_name'], row['last_name'])\n"
"...\n"
"Eric Idle\n"
"John Cleese\n"
"\n"
">>> print(row)\n"
"{'first_name': 'John', 'last_name': 'Cleese'}"

#: ../../library/csv.rst:199
msgid ""
"Create an object which operates like a regular writer but maps dictionaries "
"onto output rows.  The *fieldnames* parameter is a :mod:`sequence "
"<collections.abc>` of keys that identify the order in which values in the "
"dictionary passed to the :meth:`~csvwriter.writerow` method are written to "
"file *f*.  The optional *restval* parameter specifies the value to be "
"written if the dictionary is missing a key in *fieldnames*.  If the "
"dictionary passed to the :meth:`~csvwriter.writerow` method contains a key "
"not found in *fieldnames*, the optional *extrasaction* parameter indicates "
"what action to take. If it is set to ``'raise'``, the default value, a :exc:"
"`ValueError` is raised. If it is set to ``'ignore'``, extra values in the "
"dictionary are ignored. Any other optional or keyword arguments are passed "
"to the underlying :class:`writer` instance."
msgstr ""
"Создайте объект, который работает как обычный модуль записи, но сопоставляет "
"словари с выходными строками. Параметр *fieldnames* представляет собой :mod:"
"`последовательность <collections.abc>` ключей, которые определяют порядок, в "
"котором значения из словаря, переданные методу :meth:`~csvwriter.writerow`, "
"записываются в файл *f* . Необязательный параметр *restval* указывает "
"значение, которое будет записано, если в словаре отсутствует ключ в "
"*fieldnames*. Если словарь, переданный методу :meth:`~csvwriter.writerow`, "
"содержит ключ, которого нет в *fieldnames*, необязательный параметр "
"*extrasaction* указывает, какое действие необходимо предпринять. Если для "
"него установлено значение ``'raise'``, поднимается значение по умолчанию, a :"
"exc:`ValueError`. Если установлено значение «игнорировать», дополнительные "
"значения в словаре игнорируются. Любые другие необязательные аргументы или "
"аргументы с ключевыми словами передаются базовому экземпляру :class:`writer`."

#: ../../library/csv.rst:214
msgid ""
"Note that unlike the :class:`DictReader` class, the *fieldnames* parameter "
"of the :class:`DictWriter` class is not optional."
msgstr ""
"Обратите внимание, что в отличие от класса :class:`DictReader`, параметр "
"*fieldnames* класса :class:`DictWriter` не является необязательным."

#: ../../library/csv.rst:221
msgid ""
"import csv\n"
"\n"
"with open('names.csv', 'w', newline='') as csvfile:\n"
"    fieldnames = ['first_name', 'last_name']\n"
"    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n"
"\n"
"    writer.writeheader()\n"
"    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})\n"
"    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})\n"
"    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})"
msgstr ""
"import csv\n"
"\n"
"with open('names.csv', 'w', newline='') as csvfile:\n"
"    fieldnames = ['first_name', 'last_name']\n"
"    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n"
"\n"
"    writer.writeheader()\n"
"    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})\n"
"    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})\n"
"    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})"

#: ../../library/csv.rst:235
msgid ""
"The :class:`Dialect` class is a container class whose attributes contain "
"information for how to handle doublequotes, whitespace, delimiters, etc. Due "
"to the lack of a strict CSV specification, different applications produce "
"subtly different CSV data.  :class:`Dialect` instances define how :class:"
"`reader` and :class:`writer` instances behave."
msgstr ""
"Класс :class:`Dialect` — это класс-контейнер, атрибуты которого содержат "
"информацию о том, как обрабатывать двойные кавычки, пробелы, разделители и "
"т. д. Из-за отсутствия строгой спецификации CSV разные приложения создают "
"слегка разные данные CSV. Экземпляры :class:`Dialect` определяют, как ведут "
"себя экземпляры :class:`reader` и :class:`writer`."

#: ../../library/csv.rst:241
msgid ""
"All available :class:`Dialect` names are returned by :func:`list_dialects`, "
"and they can be registered with specific :class:`reader` and :class:`writer` "
"classes through their initializer (``__init__``) functions like this::"
msgstr ""
"Все доступные имена :class:`Dialect` возвращаются :func:`list_dialects`, и "
"их можно зарегистрировать в определенных классах :class:`reader` и :class:"
"`writer` через их инициализатор (``__init__``) такие функции::"

#: ../../library/csv.rst:245
msgid ""
"import csv\n"
"\n"
"with open('students.csv', 'w', newline='') as csvfile:\n"
"    writer = csv.writer(csvfile, dialect='unix')"
msgstr ""
"import csv\n"
"\n"
"with open('students.csv', 'w', newline='') as csvfile:\n"
"    writer = csv.writer(csvfile, dialect='unix')"

#: ../../library/csv.rst:253
msgid ""
"The :class:`excel` class defines the usual properties of an Excel-generated "
"CSV file.  It is registered with the dialect name ``'excel'``."
msgstr ""
"Класс :class:`excel` определяет обычные свойства CSV-файла, созданного в "
"Excel. Он зарегистрирован под диалектным названием Excel."

#: ../../library/csv.rst:259
msgid ""
"The :class:`excel_tab` class defines the usual properties of an Excel-"
"generated TAB-delimited file.  It is registered with the dialect name "
"``'excel-tab'``."
msgstr ""
"Класс :class:`excel_tab` определяет обычные свойства файла с разделителями "
"TAB, созданного в Excel. Он зарегистрирован под диалектным именем ``'excel-"
"tab'``."

#: ../../library/csv.rst:265
msgid ""
"The :class:`unix_dialect` class defines the usual properties of a CSV file "
"generated on UNIX systems, i.e. using ``'\\n'`` as line terminator and "
"quoting all fields.  It is registered with the dialect name ``'unix'``."
msgstr ""
"Класс :class:`unix_dialect` определяет обычные свойства файла CSV, "
"созданного в системах UNIX, т.е. использование ``'\\n'`` в качестве признака "
"конца строки и заключение всех полей в кавычки. Он зарегистрирован под "
"диалектным названием unix."

#: ../../library/csv.rst:274
msgid "The :class:`Sniffer` class is used to deduce the format of a CSV file."
msgstr "Класс :class:`Sniffer` используется для определения формата файла CSV."

#: ../../library/csv.rst:276
msgid "The :class:`Sniffer` class provides two methods:"
msgstr "Класс :class:`Sniffer` предоставляет два метода:"

#: ../../library/csv.rst:280
msgid ""
"Analyze the given *sample* and return a :class:`Dialect` subclass reflecting "
"the parameters found.  If the optional *delimiters* parameter is given, it "
"is interpreted as a string containing possible valid delimiter characters."
msgstr ""
"Проанализируйте данный *образец* и верните подкласс :class:`Dialect`, "
"отражающий найденные параметры. Если задан необязательный параметр "
"*delimiters*, он интерпретируется как строка, содержащая возможные "
"допустимые символы-разделители."

#: ../../library/csv.rst:288
msgid ""
"Analyze the sample text (presumed to be in CSV format) and return :const:"
"`True` if the first row appears to be a series of column headers. Inspecting "
"each column, one of two key criteria will be considered to estimate if the "
"sample contains a header:"
msgstr ""
"Проанализируйте образец текста (предположительно в формате CSV) и верните :"
"const:`True`, если первая строка представляет собой серию заголовков "
"столбцов. При проверке каждого столбца будет учитываться один из двух "
"ключевых критериев для оценки того, содержит ли образец заголовок:"

#: ../../library/csv.rst:293
msgid "the second through n-th rows contain numeric values"
msgstr "строки со второй по n-ю содержат числовые значения"

#: ../../library/csv.rst:294
msgid ""
"the second through n-th rows contain strings where at least one value's "
"length differs from that of the putative header of that column."
msgstr ""
"строки со второй по n-ю содержат строки, длина хотя бы одного значения "
"которых отличается от длины предполагаемого заголовка этого столбца."

#: ../../library/csv.rst:297
msgid ""
"Twenty rows after the first row are sampled; if more than half of columns + "
"rows meet the criteria, :const:`True` is returned."
msgstr ""
"Выборка производится через двадцать строк после первой; если более половины "
"столбцов и строк соответствуют критериям, возвращается :const:`True`."

#: ../../library/csv.rst:302
msgid ""
"This method is a rough heuristic and may produce both false positives and "
"negatives."
msgstr ""
"Этот метод представляет собой грубую эвристику и может давать как "
"ложноположительные, так и отрицательные результаты."

#: ../../library/csv.rst:305
msgid "An example for :class:`Sniffer` use::"
msgstr "Пример использования :class:`Sniffer`::"

#: ../../library/csv.rst:307
msgid ""
"with open('example.csv', newline='') as csvfile:\n"
"    dialect = csv.Sniffer().sniff(csvfile.read(1024))\n"
"    csvfile.seek(0)\n"
"    reader = csv.reader(csvfile, dialect)\n"
"    # ... process CSV file contents here ..."
msgstr ""
"with open('example.csv', newline='') as csvfile:\n"
"    dialect = csv.Sniffer().sniff(csvfile.read(1024))\n"
"    csvfile.seek(0)\n"
"    reader = csv.reader(csvfile, dialect)\n"
"    # ... process CSV file contents here ..."

#: ../../library/csv.rst:316
msgid "The :mod:`csv` module defines the following constants:"
msgstr "Модуль :mod:`csv` определяет следующие константы:"

#: ../../library/csv.rst:320
msgid "Instructs :class:`writer` objects to quote all fields."
msgstr "Указывает объектам :class:`writer` заключать в кавычки все поля."

#: ../../library/csv.rst:325
msgid ""
"Instructs :class:`writer` objects to only quote those fields which contain "
"special characters such as *delimiter*, *quotechar* or any of the characters "
"in *lineterminator*."
msgstr ""
"Предписывает объектам :class:`writer` заключать в кавычки только те поля, "
"которые содержат специальные символы, такие как *delimiter*, *quotechar* или "
"любые символы в *lineterminator*."

#: ../../library/csv.rst:332
msgid "Instructs :class:`writer` objects to quote all non-numeric fields."
msgstr ""
"Инструктирует объекты :class:`writer` заключать в кавычки все нечисловые "
"поля."

#: ../../library/csv.rst:334
msgid ""
"Instructs :class:`reader` objects to convert all non-quoted fields to type "
"*float*."
msgstr ""
"Указывает объектам :class:`reader` преобразовать все поля, не заключенные в "
"кавычки, в тип *float*."

#: ../../library/csv.rst:339
msgid ""
"Instructs :class:`writer` objects to never quote fields.  When the current "
"*delimiter* occurs in output data it is preceded by the current *escapechar* "
"character.  If *escapechar* is not set, the writer will raise :exc:`Error` "
"if any characters that require escaping are encountered."
msgstr ""
"Инструктирует объекты :class:`writer` никогда не заключать поля в кавычки. "
"Когда текущий *разделитель* встречается в выходных данных, ему предшествует "
"текущий символ *escapechar*. Если *escapechar* не установлен, средство "
"записи выдаст :exc:`Error`, если встречаются какие-либо символы, требующие "
"экранирования."

#: ../../library/csv.rst:344
msgid ""
"Instructs :class:`reader` objects to perform no special processing of quote "
"characters."
msgstr ""
"Указывает объектам :class:`reader` не выполнять специальную обработку "
"символов кавычек."

#: ../../library/csv.rst:348
msgid ""
"Instructs :class:`writer` objects to quote all fields which are not "
"``None``.  This is similar to :data:`QUOTE_ALL`, except that if a field "
"value is ``None`` an empty (unquoted) string is written."
msgstr ""
"Инструктирует объекты :class:`writer` заключать в кавычки все поля, кроме "
"``None``. Это похоже на :data:`QUOTE_ALL`, за исключением того, что если "
"значение поля равно ``None``, записывается пустая строка (без кавычек)."

#: ../../library/csv.rst:352
msgid ""
"Instructs :class:`reader` objects to interpret an empty (unquoted) field as "
"``None`` and to otherwise behave as :data:`QUOTE_ALL`."
msgstr ""
"Указывает объектам :class:`reader` интерпретировать пустое (не заключенное в "
"кавычки) поле как ``None`` и в противном случае вести себя как :data:"
"`QUOTE_ALL`."

#: ../../library/csv.rst:359
msgid ""
"Instructs :class:`writer` objects to always place quotes around fields which "
"are strings.  This is similar to :data:`QUOTE_NONNUMERIC`, except that if a "
"field value is ``None`` an empty (unquoted) string is written."
msgstr ""
"Указывает объектам :class:`writer` всегда помещать кавычки вокруг полей, "
"которые являются строками. Это похоже на :data:`QUOTE_NONNUMERIC`, за "
"исключением того, что если значение поля равно ``None``, записывается пустая "
"строка (без кавычек)."

#: ../../library/csv.rst:363
msgid ""
"Instructs :class:`reader` objects to interpret an empty (unquoted) string as "
"``None`` and to otherwise behave as :data:`QUOTE_NONNUMERIC`."
msgstr ""
"Указывает объектам :class:`reader` интерпретировать пустую (не заключенную в "
"кавычки) строку как ``None`` и в противном случае вести себя как :data:"
"`QUOTE_NONNUMERIC`."

#: ../../library/csv.rst:368
msgid "The :mod:`csv` module defines the following exception:"
msgstr "Модуль :mod:`csv` определяет следующее исключение:"

#: ../../library/csv.rst:373
msgid "Raised by any of the functions when an error is detected."
msgstr "Вызывается любой из функций при обнаружении ошибки."

#: ../../library/csv.rst:378
msgid "Dialects and Formatting Parameters"
msgstr "Диалекты и параметры форматирования"

#: ../../library/csv.rst:380
msgid ""
"To make it easier to specify the format of input and output records, "
"specific formatting parameters are grouped together into dialects.  A "
"dialect is a subclass of the :class:`Dialect` class containing various "
"attributes describing the format of the CSV file.  When creating :class:"
"`reader` or :class:`writer` objects, the programmer can specify a string or "
"a subclass of the :class:`Dialect` class as the dialect parameter.  In "
"addition to, or instead of, the *dialect* parameter, the programmer can also "
"specify individual formatting parameters, which have the same names as the "
"attributes defined below for the :class:`Dialect` class."
msgstr ""
"Чтобы упростить задание формата входных и выходных записей, определенные "
"параметры форматирования сгруппированы в диалекты. Диалект — это подкласс "
"класса :class:`Dialect`, содержащий различные атрибуты, описывающие формат "
"файла CSV. При создании объектов :class:`reader` или :class:`writer` "
"программист может указать строку или подкласс класса :class:`Dialect` в "
"качестве параметра диалекта. В дополнение к параметру *dialect* или вместо "
"него программист может также указать отдельные параметры форматирования, "
"которые имеют те же имена, что и атрибуты, определенные ниже для класса :"
"class:`Dialect`."

#: ../../library/csv.rst:390
msgid "Dialects support the following attributes:"
msgstr "Диалекты поддерживают следующие атрибуты:"

#: ../../library/csv.rst:395
msgid ""
"A one-character string used to separate fields.  It defaults to ``','``."
msgstr ""
"Односимвольная строка, используемая для разделения полей. По умолчанию это "
"``','``."

#: ../../library/csv.rst:400
msgid ""
"Controls how instances of *quotechar* appearing inside a field should "
"themselves be quoted.  When :const:`True`, the character is doubled. When :"
"const:`False`, the *escapechar* is used as a prefix to the *quotechar*.  It "
"defaults to :const:`True`."
msgstr ""
"Управляет тем, как экземпляры *quotechar*, появляющиеся внутри поля, должны "
"заключаться в кавычки. Когда :const:`True`, символ удваивается. Если :const:"
"`False`, *escapechar* используется как префикс к *quotechar*. По умолчанию "
"установлено значение :const:`True`."

#: ../../library/csv.rst:405
msgid ""
"On output, if *doublequote* is :const:`False` and no *escapechar* is set, :"
"exc:`Error` is raised if a *quotechar* is found in a field."
msgstr ""
"При выводе, если *двойная кавычка* равна :const:`False` и не задан "
"*escapechar*, выдается :exc:`Error`, если в поле найден *quotechar*."

#: ../../library/csv.rst:411
msgid ""
"A one-character string used by the writer to escape the *delimiter* if "
"*quoting* is set to :const:`QUOTE_NONE` and the *quotechar* if *doublequote* "
"is :const:`False`. On reading, the *escapechar* removes any special meaning "
"from the following character. It defaults to :const:`None`, which disables "
"escaping."
msgstr ""
"Односимвольная строка, используемая средством записи для экранирования "
"*разделителя*, если для *quoting* установлено значение :const:`QUOTE_NONE`, "
"а для *quotechar* if *doublequote* установлено значение :const:`False`. При "
"чтении *escapechar* удаляет любое специальное значение из следующего "
"символа. По умолчанию установлено значение :const:`None`, что отключает "
"экранирование."

#: ../../library/csv.rst:416
msgid "An empty *escapechar* is not allowed."
msgstr "Пустой *escapechar* не допускается."

#: ../../library/csv.rst:421
msgid ""
"The string used to terminate lines produced by the :class:`writer`. It "
"defaults to ``'\\r\\n'``."
msgstr ""
"Строка, используемая для завершения строк, созданных :class:`writer`. По "
"умолчанию это ``'\\r\\n'``."

#: ../../library/csv.rst:426
msgid ""
"The :class:`reader` is hard-coded to recognise either ``'\\r'`` or ``'\\n'`` "
"as end-of-line, and ignores *lineterminator*. This behavior may change in "
"the future."
msgstr ""
":class:`reader` жестко запрограммирован на распознавание ``'\\r'`` или "
"``'\\n'`` как конец строки и игнорирует *lineterminator*. Такое поведение "
"может измениться в будущем."

#: ../../library/csv.rst:433
msgid ""
"A one-character string used to quote fields containing special characters, "
"such as the *delimiter* or *quotechar*, or which contain new-line "
"characters.  It defaults to ``'\"'``."
msgstr ""
"Односимвольная строка, используемая для заключения в кавычки полей, "
"содержащих специальные символы, например *разделитель* или *кавычки*, или "
"содержащих символы новой строки. По умолчанию это ``'''``."

#: ../../library/csv.rst:437
msgid "An empty *quotechar* is not allowed."
msgstr "Пустые *кавычки* не допускаются."

#: ../../library/csv.rst:442
msgid ""
"Controls when quotes should be generated by the writer and recognised by the "
"reader.  It can take on any of the :ref:`QUOTE_\\* constants <csv-"
"constants>` and defaults to :const:`QUOTE_MINIMAL`."
msgstr ""
"Определяет, когда кавычки должны создаваться автором и распознаваться "
"читателем. Он может принимать любую из констант :ref:`QUOTE_\\* <csv-"
"constants>` и по умолчанию имеет значение :const:`QUOTE_MINIMAL`."

#: ../../library/csv.rst:449
msgid ""
"When :const:`True`, spaces immediately following the *delimiter* are "
"ignored. The default is :const:`False`."
msgstr ""
"Если :const:`True`, пробелы, следующие сразу за *разделителем*, "
"игнорируются. По умолчанию используется :const:`False`."

#: ../../library/csv.rst:455
msgid ""
"When ``True``, raise exception :exc:`Error` on bad CSV input. The default is "
"``False``."
msgstr ""
"Когда ``True``, вызывает исключение :exc:`Error` при неправильном вводе CSV. "
"По умолчанию установлено значение «Ложь»."

#: ../../library/csv.rst:461
msgid "Reader Objects"
msgstr "Объекты чтения"

#: ../../library/csv.rst:463
msgid ""
"Reader objects (:class:`DictReader` instances and objects returned by the :"
"func:`reader` function) have the following public methods:"
msgstr ""
"Объекты Reader (экземпляры :class:`DictReader` и объекты, возвращаемые "
"функцией :func:`reader`) имеют следующие общедоступные методы:"

#: ../../library/csv.rst:468
msgid ""
"Return the next row of the reader's iterable object as a list (if the object "
"was returned from :func:`reader`) or a dict (if it is a :class:`DictReader` "
"instance), parsed according to the current :class:`Dialect`.  Usually you "
"should call this as ``next(reader)``."
msgstr ""
"Вернуть следующую строку итерируемого объекта читателя в виде списка (если "
"объект был возвращен из :func:`reader`) или словаря (если это экземпляр :"
"class:`DictReader`), проанализированного в соответствии с текущим :class :"
"`Диалект`. Обычно вам следует называть это ``next(reader)``."

#: ../../library/csv.rst:474
msgid "Reader objects have the following public attributes:"
msgstr "Объекты чтения имеют следующие общедоступные атрибуты:"

#: ../../library/csv.rst:478
msgid "A read-only description of the dialect in use by the parser."
msgstr ""
"Доступное только для чтения описание диалекта, используемого анализатором."

#: ../../library/csv.rst:483
msgid ""
"The number of lines read from the source iterator. This is not the same as "
"the number of records returned, as records can span multiple lines."
msgstr ""
"Количество строк, прочитанных из исходного итератора. Это не то же самое, "
"что количество возвращаемых записей, поскольку записи могут занимать "
"несколько строк."

#: ../../library/csv.rst:487
msgid "DictReader objects have the following public attribute:"
msgstr "Объекты DictReader имеют следующий общедоступный атрибут:"

#: ../../library/csv.rst:491
msgid ""
"If not passed as a parameter when creating the object, this attribute is "
"initialized upon first access or when the first record is read from the file."
msgstr ""
"Если этот атрибут не передается в качестве параметра при создании объекта, "
"этот атрибут инициализируется при первом доступе или при чтении первой "
"записи из файла."

#: ../../library/csv.rst:498
msgid "Writer Objects"
msgstr "Объекты записи"

#: ../../library/csv.rst:500
msgid ""
":class:`writer` objects (:class:`DictWriter` instances and objects returned "
"by the :func:`writer` function) have the following public methods.  A *row* "
"must be an iterable of strings or numbers for :class:`writer` objects and a "
"dictionary mapping fieldnames to strings or numbers (by passing them "
"through :func:`str` first) for :class:`DictWriter` objects.  Note that "
"complex numbers are written out surrounded by parens. This may cause some "
"problems for other programs which read CSV files (assuming they support "
"complex numbers at all)."
msgstr ""
"Объекты :class:`writer` (экземпляры :class:`DictWriter` и объекты, "
"возвращаемые функцией :func:`writer`) имеют следующие общедоступные методы. "
"*row* должен быть итерацией строк или чисел для объектов :class:`writer` и "
"словарем, сопоставляющим имена полей со строками или числами (сначала "
"передавая их через :func:`str`) для объектов :class:`DictWriter` . Обратите "
"внимание, что комплексные числа записываются в скобках. Это может вызвать "
"некоторые проблемы для других программ, читающих файлы CSV (при условии, что "
"они вообще поддерживают комплексные числа)."

#: ../../library/csv.rst:511
msgid ""
"Write the *row* parameter to the writer's file object, formatted according "
"to the current :class:`Dialect`. Return the return value of the call to the "
"*write* method of the underlying file object."
msgstr ""
"Запишите параметр *row* в файловый объект средства записи, отформатированный "
"в соответствии с текущим :class:`Dialect`. Возвращает возвращаемое значение "
"вызова метода *write* базового файлового объекта."

#: ../../library/csv.rst:515
msgid "Added support of arbitrary iterables."
msgstr "Добавлена ​​поддержка произвольных итераций."

#: ../../library/csv.rst:520
msgid ""
"Write all elements in *rows* (an iterable of *row* objects as described "
"above) to the writer's file object, formatted according to the current "
"dialect."
msgstr ""
"Запишите все элементы в *rows* (итерацию объектов *row*, как описано выше) в "
"файловый объект средства записи, отформатированный в соответствии с текущим "
"диалектом."

#: ../../library/csv.rst:524
msgid "Writer objects have the following public attribute:"
msgstr "Объекты Writer имеют следующий общедоступный атрибут:"

#: ../../library/csv.rst:529
msgid "A read-only description of the dialect in use by the writer."
msgstr "Доступное только для чтения описание диалекта, используемого автором."

#: ../../library/csv.rst:532
msgid "DictWriter objects have the following public method:"
msgstr "Объекты DictWriter имеют следующий общедоступный метод:"

#: ../../library/csv.rst:537
msgid ""
"Write a row with the field names (as specified in the constructor) to the "
"writer's file object, formatted according to the current dialect. Return the "
"return value of the :meth:`csvwriter.writerow` call used internally."
msgstr ""
"Запишите строку с именами полей (как указано в конструкторе) в файловый "
"объект средства записи, отформатированный в соответствии с текущим "
"диалектом. Возвращает возвращаемое значение вызова :meth:`csvwriter."
"writerow`, используемого внутри."

#: ../../library/csv.rst:542
msgid ""
":meth:`writeheader` now also returns the value returned by the :meth:"
"`csvwriter.writerow` method it uses internally."
msgstr ""
":meth:`writeheader` теперь также возвращает значение, возвращаемое методом :"
"meth:`csvwriter.writerow`, который он использует внутри себя."

#: ../../library/csv.rst:550
msgid "Examples"
msgstr "Примеры"

#: ../../library/csv.rst:552
msgid "The simplest example of reading a CSV file::"
msgstr "Простейший пример чтения файла CSV::"

#: ../../library/csv.rst:554
msgid ""
"import csv\n"
"with open('some.csv', newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csv\n"
"with open('some.csv', newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"

#: ../../library/csv.rst:560
msgid "Reading a file with an alternate format::"
msgstr "Чтение файла в альтернативном формате::"

#: ../../library/csv.rst:562
msgid ""
"import csv\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csv\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)\n"
"    for row in reader:\n"
"        print(row)"

#: ../../library/csv.rst:568
msgid "The corresponding simplest possible writing example is::"
msgstr "Соответствующий простейший пример записи:"

#: ../../library/csv.rst:570
msgid ""
"import csv\n"
"with open('some.csv', 'w', newline='') as f:\n"
"    writer = csv.writer(f)\n"
"    writer.writerows(someiterable)"
msgstr ""
"import csv\n"
"with open('some.csv', 'w', newline='') as f:\n"
"    writer = csv.writer(f)\n"
"    writer.writerows(someiterable)"

#: ../../library/csv.rst:575
msgid ""
"Since :func:`open` is used to open a CSV file for reading, the file will by "
"default be decoded into unicode using the system default encoding (see :func:"
"`locale.getencoding`).  To decode a file using a different encoding, use the "
"``encoding`` argument of open::"
msgstr ""
"Поскольку :func:`open` используется для открытия файла CSV для чтения, файл "
"по умолчанию будет декодирован в Юникод с использованием системной кодировки "
"по умолчанию (см. :func:`locale.getencoding`). Чтобы декодировать файл с "
"использованием другой кодировки, используйте аргумент ``encoding`` команды "
"open::"

#: ../../library/csv.rst:580
msgid ""
"import csv\n"
"with open('some.csv', newline='', encoding='utf-8') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csv\n"
"with open('some.csv', newline='', encoding='utf-8') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"

#: ../../library/csv.rst:586
msgid ""
"The same applies to writing in something other than the system default "
"encoding: specify the encoding argument when opening the output file."
msgstr ""
"То же самое относится и к записи в кодировке, отличной от системной по "
"умолчанию: укажите аргумент кодировки при открытии выходного файла."

#: ../../library/csv.rst:589
msgid "Registering a new dialect::"
msgstr "Регистрация нового диалекта::"

#: ../../library/csv.rst:591
msgid ""
"import csv\n"
"csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, 'unixpwd')"
msgstr ""
"import csv\n"
"csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, 'unixpwd')"

#: ../../library/csv.rst:596
msgid ""
"A slightly more advanced use of the reader --- catching and reporting "
"errors::"
msgstr ""
"Немного более продвинутое использование средства чтения --- выявление ошибок "
"и сообщение об ошибках::"

#: ../../library/csv.rst:598
msgid ""
"import csv, sys\n"
"filename = 'some.csv'\n"
"with open(filename, newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    try:\n"
"        for row in reader:\n"
"            print(row)\n"
"    except csv.Error as e:\n"
"        sys.exit('file {}, line {}: {}'.format(filename, reader.line_num, e))"
msgstr ""
"import csv, sys\n"
"filename = 'some.csv'\n"
"with open(filename, newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    try:\n"
"        for row in reader:\n"
"            print(row)\n"
"    except csv.Error as e:\n"
"        sys.exit('file {}, line {}: {}'.format(filename, reader.line_num, e))"

#: ../../library/csv.rst:608
msgid ""
"And while the module doesn't directly support parsing strings, it can easily "
"be done::"
msgstr ""
"И хотя модуль напрямую не поддерживает синтаксический анализ строк, это "
"можно легко сделать::"

#: ../../library/csv.rst:611
msgid ""
"import csv\n"
"for row in csv.reader(['one,two,three']):\n"
"    print(row)"
msgstr ""
"import csv\n"
"for row in csv.reader(['one,two,three']):\n"
"    print(row)"

#: ../../library/csv.rst:617
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/csv.rst:618
msgid ""
"If ``newline=''`` is not specified, newlines embedded inside quoted fields "
"will not be interpreted correctly, and on platforms that use ``\\r\\n`` "
"linendings on write an extra ``\\r`` will be added.  It should always be "
"safe to specify ``newline=''``, since the csv module does its own (:term:"
"`universal <universal newlines>`) newline handling."
msgstr ""
"Если ``newline=''`` не указан, символы новой строки, встроенные в поля в "
"кавычках, не будут интерпретироваться правильно, а на платформах, "
"использующих ``\\r\\n`` при записи, дополнительный ``\\r`` будет добавлен. "
"Всегда безопасно указывать ``newline=''``, поскольку модуль csv выполняет "
"собственную (:term:`universal <universal newlines>`) обработку новой строки."

#: ../../library/csv.rst:11
msgid "csv"
msgstr "csv"

#: ../../library/csv.rst:11
msgid "data"
msgstr "данные"

#: ../../library/csv.rst:11
msgid "tabular"
msgstr "табличный"

#: ../../library/csv.rst:53
msgid "universal newlines"
msgstr "универсальные переводы строк"

#: ../../library/csv.rst:53
msgid "csv.reader function"
msgstr "функция csv.reader"
