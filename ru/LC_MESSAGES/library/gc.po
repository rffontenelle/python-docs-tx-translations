# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-13 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:06+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/gc.rst:2
msgid ":mod:`!gc` --- Garbage Collector interface"
msgstr ":mod:`!gc` --- Интерфейс сборщика мусора"

#: ../../library/gc.rst:12
msgid ""
"This module provides an interface to the optional garbage collector.  It "
"provides the ability to disable the collector, tune the collection "
"frequency, and set debugging options.  It also provides access to "
"unreachable objects that the collector found but cannot free.  Since the "
"collector supplements the reference counting already used in Python, you can "
"disable the collector if you are sure your program does not create reference "
"cycles.  Automatic collection can be disabled by calling ``gc.disable()``.  "
"To debug a leaking program call ``gc.set_debug(gc.DEBUG_LEAK)``. Notice that "
"this includes ``gc.DEBUG_SAVEALL``, causing garbage-collected objects to be "
"saved in gc.garbage for inspection."
msgstr ""
"Этот модуль предоставляет интерфейс для дополнительного сборщика мусора. Он "
"предоставляет возможность отключить сборщик, настроить частоту сбора и "
"установить параметры отладки. Он также обеспечивает доступ к недоступным "
"объектам, которые сборщик нашел, но не может освободить. Поскольку сборщик "
"дополняет подсчет ссылок, уже используемый в Python, вы можете отключить "
"сборщик, если уверены, что ваша программа не создает циклы ссылок. "
"Автоматический сбор можно отключить, вызвав gc.disable(). Для отладки "
"программы, вызывающей утечку, вызовите ``gc.set_debug(gc.DEBUG_LEAK)``. "
"Обратите внимание, что сюда входит ``gc.DEBUG_SAVEALL``, в результате чего "
"объекты, собранные мусором, сохраняются в gc.garbage для проверки."

#: ../../library/gc.rst:23
msgid "The :mod:`gc` module provides the following functions:"
msgstr "Модуль :mod:`gc` предоставляет следующие функции:"

#: ../../library/gc.rst:28
msgid "Enable automatic garbage collection."
msgstr "Включите автоматическую сборку мусора."

#: ../../library/gc.rst:33
msgid "Disable automatic garbage collection."
msgstr "Отключите автоматическую сборку мусора."

#: ../../library/gc.rst:38
msgid "Return ``True`` if automatic collection is enabled."
msgstr "Возвращайте True, если включен автоматический сбор."

#: ../../library/gc.rst:43
msgid ""
"Perform a collection.  The optional argument *generation* may be an integer "
"specifying which generation to collect (from 0 to 2).  A :exc:`ValueError` "
"is raised if the generation number is invalid. The sum of collected objects "
"and uncollectable objects is returned."
msgstr ""
"Выполните сбор. Необязательный аргумент *генерация* может быть целым числом, "
"указывающим, какое поколение собирать (от 0 до 2). Ошибка :exc:`ValueError` "
"возникает, если номер поколения недействителен. Возвращается сумма собранных "
"и несобираемых объектов."

#: ../../library/gc.rst:48
msgid ""
"Calling ``gc.collect(0)`` will perform a GC collection on the young "
"generation."
msgstr "Вызов gc.collect(0) выполнит сбор GC для молодого поколения."

#: ../../library/gc.rst:50
msgid ""
"Calling ``gc.collect(1)`` will perform a GC collection on the young "
"generation and an increment of the old generation."
msgstr ""
"Вызов gc.collect(1) выполнит сбор GC для молодого поколения и приращение "
"старого поколения."

#: ../../library/gc.rst:53
msgid ""
"Calling ``gc.collect(2)`` or ``gc.collect()`` performs a full collection"
msgstr "Вызов gc.collect(2) или gc.collect() выполняет полный сбор."

#: ../../library/gc.rst:55
msgid ""
"The free lists maintained for a number of built-in types are cleared "
"whenever a full collection or collection of the highest generation (2) is "
"run.  Not all items in some free lists may be freed due to the particular "
"implementation, in particular :class:`float`."
msgstr ""
"Списки свободных, поддерживаемые для ряда встроенных типов, очищаются при "
"каждом запуске полной коллекции или коллекции самого высокого поколения (2). "
"Не все элементы в некоторых свободных списках могут быть освобождены из-за "
"конкретной реализации, в частности :class:`float`."

#: ../../library/gc.rst:60
msgid ""
"The effect of calling ``gc.collect()`` while the interpreter is already "
"performing a collection is undefined."
msgstr ""
"Эффект от вызова gc.collect(), когда интерпретатор уже выполняет сбор, не "
"определен."

#: ../../library/gc.rst:63
msgid "``generation=1`` performs an increment of collection."
msgstr "``Generation=1`` выполняет приращение коллекции."

#: ../../library/gc.rst:69
msgid ""
"Set the garbage collection debugging flags. Debugging information will be "
"written to ``sys.stderr``.  See below for a list of debugging flags which "
"can be combined using bit operations to control debugging."
msgstr ""
"Установите флаги отладки сборки мусора. Отладочная информация будет записана "
"в ``sys.stderr``. Ниже приведен список флагов отладки, которые можно "
"комбинировать с помощью битовых операций для управления отладкой."

#: ../../library/gc.rst:76
msgid "Return the debugging flags currently set."
msgstr "Возвращает текущие установленные флаги отладки."

#: ../../library/gc.rst:82
msgid ""
"Returns a list of all objects tracked by the collector, excluding the list "
"returned. If *generation* is not ``None``, return only the objects as "
"follows:"
msgstr ""
"Возвращает список всех объектов, отслеживаемых сборщиком, за исключением "
"возвращаемого списка. Если *генерация* не равна ``Нет``, возвращайте только "
"объекты следующим образом:"

#: ../../library/gc.rst:85
msgid "0: All objects in the young generation"
msgstr "0: Все объекты молодого поколения."

#: ../../library/gc.rst:86
msgid "1: No objects, as there is no generation 1 (as of Python 3.13)"
msgstr "1: нет объектов, так как нет поколения 1 (начиная с Python 3.13)."

#: ../../library/gc.rst:87
msgid "2: All objects in the old generation"
msgstr "2: Все объекты старого поколения"

#: ../../library/gc.rst:89
msgid "New *generation* parameter."
msgstr "Новый параметр *поколения*."

#: ../../library/gc.rst:92
msgid "Generation 1 is removed"
msgstr "Первое поколение удалено."

#: ../../library/gc.rst:95
msgid ""
"Raises an :ref:`auditing event <auditing>` ``gc.get_objects`` with argument "
"``generation``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``gc.get_objects`` с аргументом "
"``генерация``."

#: ../../library/gc.rst:99
msgid ""
"Return a list of three per-generation dictionaries containing collection "
"statistics since interpreter start.  The number of keys may change in the "
"future, but currently each dictionary will contain the following items:"
msgstr ""
"Возвращает список из трех словарей каждого поколения, содержащих статистику "
"сбора с момента запуска интерпретатора. Количество ключей может измениться в "
"будущем, но в настоящее время каждый словарь будет содержать следующие "
"элементы:"

#: ../../library/gc.rst:104
msgid "``collections`` is the number of times this generation was collected;"
msgstr "``коллекции`` – это количество сборов данных этого поколения;"

#: ../../library/gc.rst:106
msgid ""
"``collected`` is the total number of objects collected inside this "
"generation;"
msgstr "``collected`` — общее количество объектов, собранных в этом поколении;"

#: ../../library/gc.rst:109
msgid ""
"``uncollectable`` is the total number of objects which were found to be "
"uncollectable (and were therefore moved to the :data:`garbage` list) inside "
"this generation."
msgstr ""
"``uncollectable`` — это общее количество объектов, которые оказались "
"невозможными для сбора (и поэтому были перемещены в список :data:`garbage`) "
"внутри этого поколения."

#: ../../library/gc.rst:118
msgid ""
"Set the garbage collection thresholds (the collection frequency). Setting "
"*threshold0* to zero disables collection."
msgstr ""
"Set the garbage collection thresholds (the collection frequency). Setting "
"*threshold0* to zero disables collection."

#: ../../library/gc.rst:121
msgid ""
"The GC classifies objects into two generations depending on whether they "
"have survived a collection. New objects are placed in the young generation. "
"If an object survives a collection it is moved into the old generation."
msgstr ""
"GC классифицирует объекты на два поколения в зависимости от того, "
"сохранились ли они в коллекции. Новые объекты помещаются в молодое "
"поколение. Если объект сохраняется в коллекции, он перемещается в старое "
"поколение."

#: ../../library/gc.rst:125
msgid ""
"In order to decide when to run, the collector keeps track of the number of "
"object allocations and deallocations since the last collection.  When the "
"number of allocations minus the number of deallocations exceeds "
"*threshold0*, collection starts. For each collection, all the objects in the "
"young generation and some fraction of the old generation is collected."
msgstr ""
"Чтобы решить, когда запускать, сборщик отслеживает количество выделений и "
"освобождений объектов с момента последней коллекции. Когда количество "
"выделений минус количество освобождений превышает *threshold0*, начинается "
"сбор. Для каждой коллекции собираются все объекты молодого поколения и "
"некоторая часть объектов старого поколения."

#: ../../library/gc.rst:131
msgid ""
"The fraction of the old generation that is collected is **inversely** "
"proportional to *threshold1*. The larger *threshold1* is, the slower objects "
"in the old generation are collected. For the default value of 10, 1% of the "
"old generation is scanned during each collection."
msgstr ""
"Собираемая доля старого поколения **обратно** пропорциональна *threshold1*. "
"Чем больше *threshold1*, тем медленнее собираются объекты старого поколения. "
"При значении по умолчанию 10 во время каждой коллекции сканируется 1% "
"старого поколения."

#: ../../library/gc.rst:136
msgid "*threshold2* is ignored."
msgstr "*threshold2* игнорируется."

#: ../../library/gc.rst:138
msgid ""
"See `Garbage collector design <https://devguide.python.org/"
"garbage_collector>`_ for more information."
msgstr ""
"Дополнительную информацию см. в разделе «Проектирование сборщика мусора "
"<https://devguide.python.org/garbage_collector>»."

#: ../../library/gc.rst:140
msgid "*threshold2* is ignored"
msgstr "*threshold2* игнорируется"

#: ../../library/gc.rst:146
msgid ""
"Return the current collection  counts as a tuple of ``(count0, count1, "
"count2)``."
msgstr ""
"Возвращает счетчики текущей коллекции в виде кортежа ``(count0, count1, "
"count2)``."

#: ../../library/gc.rst:152
msgid ""
"Return the current collection thresholds as a tuple of ``(threshold0, "
"threshold1, threshold2)``."
msgstr ""
"Возвращает текущие пороговые значения коллекции в виде кортежа "
"``(threshold0, Threshold1, Threshold2)``."

#: ../../library/gc.rst:158
msgid ""
"Return the list of objects that directly refer to any of objs. This function "
"will only locate those containers which support garbage collection; "
"extension types which do refer to other objects but do not support garbage "
"collection will not be found."
msgstr ""
"Верните список объектов, которые напрямую ссылаются на любой из объектов. "
"Эта функция найдет только те контейнеры, которые поддерживают сбор мусора; "
"типы расширений, которые ссылаются на другие объекты, но не поддерживают "
"сборку мусора, не будут найдены."

#: ../../library/gc.rst:163
msgid ""
"Note that objects which have already been dereferenced, but which live in "
"cycles and have not yet been collected by the garbage collector can be "
"listed among the resulting referrers.  To get only currently live objects, "
"call :func:`collect` before calling :func:`get_referrers`."
msgstr ""
"Обратите внимание, что среди результирующих рефереров могут быть указаны "
"объекты, которые уже были разыменованы, но живут в циклах и еще не были "
"собраны сборщиком мусора. Чтобы получить только текущие активные объекты, "
"вызовите :func:`collect` перед вызовом :func:`get_referrers`."

#: ../../library/gc.rst:169
msgid ""
"Care must be taken when using objects returned by :func:`get_referrers` "
"because some of them could still be under construction and hence in a "
"temporarily invalid state. Avoid using :func:`get_referrers` for any purpose "
"other than debugging."
msgstr ""
"Необходимо соблюдать осторожность при использовании объектов, возвращаемых :"
"func:`get_referrers`, поскольку некоторые из них все еще могут находиться в "
"стадии разработки и, следовательно, находиться во временно недопустимом "
"состоянии. Избегайте использования :func:`get_referrers` для каких-либо "
"целей, кроме отладки."

#: ../../library/gc.rst:174
msgid ""
"Raises an :ref:`auditing event <auditing>` ``gc.get_referrers`` with "
"argument ``objs``."
msgstr ""
"Вызывает событие аудита <auditing>`gc.get_referrers`` с аргументом ``objs``."

#: ../../library/gc.rst:179
msgid ""
"Return a list of objects directly referred to by any of the arguments. The "
"referents returned are those objects visited by the arguments' C-level :c:"
"member:`~PyTypeObject.tp_traverse` methods (if any), and may not be all "
"objects actually directly reachable.  :c:member:`~PyTypeObject.tp_traverse` "
"methods are supported only by objects that support garbage collection, and "
"are only required to visit objects that may be involved in a cycle.  So, for "
"example, if an integer is directly reachable from an argument, that integer "
"object may or may not appear in the result list."
msgstr ""
"Возвращает список объектов, на которые напрямую ссылается любой из "
"аргументов. Возвращаемые референты — это те объекты, которые посещаются "
"методами аргументов C-уровня :c:member:`~PyTypeObject.tp_traverse` (если "
"таковые имеются), и могут не быть всеми объектами, которые на самом деле "
"доступны напрямую. Методы :c:member:`~PyTypeObject.tp_traverse` "
"поддерживаются только объектами, поддерживающими сборку мусора, и необходимы "
"только для посещения объектов, которые могут участвовать в цикле. Так, "
"например, если целое число напрямую доступно из аргумента, этот "
"целочисленный объект может появиться или не появиться в списке результатов."

#: ../../library/gc.rst:187
msgid ""
"Raises an :ref:`auditing event <auditing>` ``gc.get_referents`` with "
"argument ``objs``."
msgstr ""
"Вызывает событие аудита <auditing>`gc.get_referents`` с аргументом ``objs``."

#: ../../library/gc.rst:191
msgid ""
"Returns ``True`` if the object is currently tracked by the garbage "
"collector, ``False`` otherwise.  As a general rule, instances of atomic "
"types aren't tracked and instances of non-atomic types (containers, user-"
"defined objects...) are.  However, some type-specific optimizations can be "
"present in order to suppress the garbage collector footprint of simple "
"instances (e.g. dicts containing only atomic keys and values)::"
msgstr ""
"Возвращает True, если объект в данный момент отслеживается сборщиком мусора, "
"в противном случае — False. Как правило, экземпляры атомарных типов не "
"отслеживаются, а экземпляры неатомарных типов (контейнеры, определяемые "
"пользователем объекты...). Однако могут быть предусмотрены некоторые "
"оптимизации для конкретного типа, чтобы подавить влияние сборщика мусора на "
"простые экземпляры (например, словари, содержащие только атомарные ключи и "
"значения)::"

#: ../../library/gc.rst:198
msgid ""
">>> gc.is_tracked(0)\n"
"False\n"
">>> gc.is_tracked(\"a\")\n"
"False\n"
">>> gc.is_tracked([])\n"
"True\n"
">>> gc.is_tracked({})\n"
"False\n"
">>> gc.is_tracked({\"a\": 1})\n"
"False\n"
">>> gc.is_tracked({\"a\": []})\n"
"True"
msgstr ""
">>> gc.is_tracked(0)\n"
"False\n"
">>> gc.is_tracked(\"a\")\n"
"False\n"
">>> gc.is_tracked([])\n"
"True\n"
">>> gc.is_tracked({})\n"
"False\n"
">>> gc.is_tracked({\"a\": 1})\n"
"False\n"
">>> gc.is_tracked({\"a\": []})\n"
"True"

#: ../../library/gc.rst:216
msgid ""
"Returns ``True`` if the given object has been finalized by the garbage "
"collector, ``False`` otherwise. ::"
msgstr ""
"Возвращает True, если данный объект был финализирован сборщиком мусора, в "
"противном случае — False. ::"

#: ../../library/gc.rst:219
msgid ""
">>> x = None\n"
">>> class Lazarus:\n"
"...     def __del__(self):\n"
"...         global x\n"
"...         x = self\n"
"...\n"
">>> lazarus = Lazarus()\n"
">>> gc.is_finalized(lazarus)\n"
"False\n"
">>> del lazarus\n"
">>> gc.is_finalized(x)\n"
"True"
msgstr ""
">>> x = None\n"
">>> class Lazarus:\n"
"...     def __del__(self):\n"
"...         global x\n"
"...         x = self\n"
"...\n"
">>> lazarus = Lazarus()\n"
">>> gc.is_finalized(lazarus)\n"
"False\n"
">>> del lazarus\n"
">>> gc.is_finalized(x)\n"
"True"

#: ../../library/gc.rst:237
msgid ""
"Freeze all the objects tracked by the garbage collector; move them to a "
"permanent generation and ignore them in all the future collections."
msgstr ""
"Заморозить все объекты, отслеживаемые сборщиком мусора; переместите их в "
"постоянное поколение и игнорируйте во всех будущих коллекциях."

#: ../../library/gc.rst:240
msgid ""
"If a process will ``fork()`` without ``exec()``, avoiding unnecessary copy-"
"on-write in child processes will maximize memory sharing and reduce overall "
"memory usage. This requires both avoiding creation of freed \"holes\" in "
"memory pages in the parent process and ensuring that GC collections in child "
"processes won't touch the ``gc_refs`` counter of long-lived objects "
"originating in the parent process. To accomplish both, call ``gc.disable()`` "
"early in the parent process, ``gc.freeze()`` right before ``fork()``, and "
"``gc.enable()`` early in child processes."
msgstr ""
"Если процесс будет разветвляться() без exec(), избежание ненужного "
"копирования при записи в дочерних процессах позволит максимизировать "
"совместное использование памяти и снизить общее использование памяти. Для "
"этого необходимо как избегать создания освобожденных «дыр» в страницах "
"памяти родительского процесса, так и гарантировать, что коллекции GC в "
"дочерних процессах не будут касаться счетчика gc_refs долгоживущих объектов, "
"происходящих из родительского процесса. Чтобы выполнить и то, и другое, "
"вызовите gc.disable() в начале родительского процесса, gc.freeze() прямо "
"перед fork() и gc.enable() раньше. в дочерних процессах."

#: ../../library/gc.rst:254
msgid ""
"Unfreeze the objects in the permanent generation, put them back into the "
"oldest generation."
msgstr ""
"Разморозьте объекты в постоянном поколении и поместите их обратно в самое "
"старое поколение."

#: ../../library/gc.rst:262
msgid "Return the number of objects in the permanent generation."
msgstr "Возвращает количество объектов в постоянном поколении."

#: ../../library/gc.rst:267
msgid ""
"The following variables are provided for read-only access (you can mutate "
"the values but should not rebind them):"
msgstr ""
"Следующие переменные доступны только для чтения (вы можете изменять "
"значения, но не должны их повторно привязывать):"

#: ../../library/gc.rst:272
msgid ""
"A list of objects which the collector found to be unreachable but could not "
"be freed (uncollectable objects).  Starting with Python 3.4, this list "
"should be empty most of the time, except when using instances of C extension "
"types with a non-``NULL`` ``tp_del`` slot."
msgstr ""
"Список объектов, которые сборщик посчитал недоступными, но которые не "
"удалось освободить (невозможность сбора). Начиная с Python 3.4, этот список "
"должен быть пустым большую часть времени, за исключением случаев "
"использования экземпляров типов расширения C со слотом ``tp_del``, отличным "
"от ``NULL``."

#: ../../library/gc.rst:277
msgid ""
"If :const:`DEBUG_SAVEALL` is set, then all unreachable objects will be added "
"to this list rather than freed."
msgstr ""
"Если установлен :const:`DEBUG_SAVEALL`, то все недоступные объекты будут "
"добавлены в этот список, а не освобождены."

#: ../../library/gc.rst:280
msgid ""
"If this list is non-empty at :term:`interpreter shutdown`, a :exc:"
"`ResourceWarning` is emitted, which is silent by default.  If :const:"
"`DEBUG_UNCOLLECTABLE` is set, in addition all uncollectable objects are "
"printed."
msgstr ""
"Если этот список непустой в момент :term:`interpreter Shutdown`, выдается :"
"exc:`ResourceWarning`, который по умолчанию неактивен. Если установлен :"
"const:`DEBUG_UNCOLLECTABLE`, дополнительно печатаются все несобираемые "
"объекты."

#: ../../library/gc.rst:286
msgid ""
"Following :pep:`442`, objects with a :meth:`~object.__del__` method don't "
"end up in :data:`gc.garbage` anymore."
msgstr ""
"После :pep:`442` объекты с методом :meth:`~object.__del__` больше не "
"попадают в :data:`gc.garbage`."

#: ../../library/gc.rst:292
msgid ""
"A list of callbacks that will be invoked by the garbage collector before and "
"after collection.  The callbacks will be called with two arguments, *phase* "
"and *info*."
msgstr ""
"Список обратных вызовов, которые будут вызываться сборщиком мусора до и "
"после сбора. Обратные вызовы будут вызываться с двумя аргументами: *phase* и "
"*info*."

#: ../../library/gc.rst:296
msgid "*phase* can be one of two values:"
msgstr "*фаза* может иметь одно из двух значений:"

#: ../../library/gc.rst:298
msgid "\"start\": The garbage collection is about to start."
msgstr "«start»: скоро начнется сбор мусора."

#: ../../library/gc.rst:300
msgid "\"stop\": The garbage collection has finished."
msgstr "«стоп»: сбор мусора завершен."

#: ../../library/gc.rst:302
msgid ""
"*info* is a dict providing more information for the callback.  The following "
"keys are currently defined:"
msgstr ""
"*info* — это текст, предоставляющий дополнительную информацию для обратного "
"вызова. В настоящее время определены следующие ключи:"

#: ../../library/gc.rst:305
msgid "\"generation\": The oldest generation being collected."
msgstr "«поколение»: самое старое собираемое поколение."

#: ../../library/gc.rst:307
msgid ""
"\"collected\": When *phase* is \"stop\", the number of objects successfully "
"collected."
msgstr "«собрано»: когда *фаза* «стоп», количество успешно собранных объектов."

#: ../../library/gc.rst:310
msgid ""
"\"uncollectable\": When *phase* is \"stop\", the number of objects that "
"could not be collected and were put in :data:`garbage`."
msgstr ""
"«uncollectable»: Когда *фаза* установлена ​​на «стоп», количество объектов, "
"которые не удалось собрать и которые были помещены в :data:`garbage`."

#: ../../library/gc.rst:313
msgid ""
"Applications can add their own callbacks to this list.  The primary use "
"cases are:"
msgstr ""
"Приложения могут добавлять в этот список свои собственные обратные вызовы. "
"Основные варианты использования:"

#: ../../library/gc.rst:316
msgid ""
"Gathering statistics about garbage collection, such as how often various "
"generations are collected, and how long the collection takes."
msgstr ""
"Сбор статистики о сборе мусора, например, о том, как часто собираются "
"различные поколения и сколько времени занимает сбор."

#: ../../library/gc.rst:320
msgid ""
"Allowing applications to identify and clear their own uncollectable types "
"when they appear in :data:`garbage`."
msgstr ""
"Разрешение приложениям идентифицировать и очищать свои собственные типы, "
"которые невозможно собрать, когда они появляются в :data:`мусоре`."

#: ../../library/gc.rst:326
msgid "The following constants are provided for use with :func:`set_debug`:"
msgstr ""
"Следующие константы предусмотрены для использования с :func:`set_debug`:"

#: ../../library/gc.rst:331
msgid ""
"Print statistics during collection.  This information can be useful when "
"tuning the collection frequency."
msgstr ""
"Печать статистики во время сбора. Эта информация может быть полезна при "
"настройке частоты сбора данных."

#: ../../library/gc.rst:337
msgid "Print information on collectable objects found."
msgstr "Распечатайте информацию о найденных коллекционных предметах."

#: ../../library/gc.rst:342
msgid ""
"Print information of uncollectable objects found (objects which are not "
"reachable but cannot be freed by the collector).  These objects will be "
"added to the ``garbage`` list."
msgstr ""
"Вывести информацию о найденных объектах, которые невозможно собрать "
"(объекты, которые недоступны, но не могут быть освобождены сборщиком). Эти "
"объекты будут добавлены в список «мусор»."

#: ../../library/gc.rst:346
msgid ""
"Also print the contents of the :data:`garbage` list at :term:`interpreter "
"shutdown`, if it isn't empty."
msgstr ""
"Также распечатайте содержимое списка :data:`мусора` в :term:`interpreter "
"Shutdown`, если он не пуст."

#: ../../library/gc.rst:352
msgid ""
"When set, all unreachable objects found will be appended to *garbage* rather "
"than being freed.  This can be useful for debugging a leaking program."
msgstr ""
"Если установлено, все найденные недоступные объекты будут добавлены в "
"*мусор*, а не освобождены. Это может быть полезно для отладки программы с "
"утечкой."

#: ../../library/gc.rst:358
msgid ""
"The debugging flags necessary for the collector to print information about a "
"leaking program (equal to ``DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | "
"DEBUG_SAVEALL``)."
msgstr ""
"Флаги отладки, необходимые сборщику для печати информации об утечке "
"программы (равны ``DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | "
"DEBUG_SAVEALL``)."
