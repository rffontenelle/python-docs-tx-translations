# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 14:17+0000\n"
"PO-Revision-Date: 2024-06-20 06:42+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../howto/free-threading-extensions.rst:7
msgid "C API Extension Support for Free Threading"
msgstr "Поддержка расширения C API для свободной многопоточности"

#: ../../howto/free-threading-extensions.rst:9
msgid ""
"Starting with the 3.13 release, CPython has experimental support for running "
"with the :term:`global interpreter lock` (GIL) disabled in a configuration "
"called :term:`free threading`.  This document describes how to adapt C API "
"extensions to support free threading."
msgstr ""
"Начиная с версии 3.13, CPython имеет экспериментальную поддержку работы с "
"отключенной :term:`глобальной блокировкой интерпретатора` (GIL) в "
"конфигурации под названием :term:`free threading`. В этом документе "
"описывается, как адаптировать расширения C API для поддержки свободной "
"многопоточности."

#: ../../howto/free-threading-extensions.rst:16
msgid "Identifying the Free-Threaded Build in C"
msgstr "Идентификация сборки со свободным потоком на C"

#: ../../howto/free-threading-extensions.rst:18
msgid ""
"The CPython C API exposes the ``Py_GIL_DISABLED`` macro: in the free-"
"threaded build it's defined to ``1``, and in the regular build it's not "
"defined. You can use it to enable code that only runs under the free-"
"threaded build::"
msgstr ""
"API CPython C предоставляет макрос Py_GIL_DISABLED: в сборке со свободным "
"потоком он определен как «1», а в обычной сборке он не определен. Вы можете "
"использовать его, чтобы включить код, который работает только в сборке со "
"свободным потоком::"

#: ../../howto/free-threading-extensions.rst:22
msgid ""
"#ifdef Py_GIL_DISABLED\n"
"/* code that only runs in the free-threaded build */\n"
"#endif"
msgstr ""
"#ifdef Py_GIL_DISABLED\n"
"/* code that only runs in the free-threaded build */\n"
"#endif"

#: ../../howto/free-threading-extensions.rst:27
msgid "Module Initialization"
msgstr "Инициализация модуля"

#: ../../howto/free-threading-extensions.rst:29
msgid ""
"Extension modules need to explicitly indicate that they support running with "
"the GIL disabled; otherwise importing the extension will raise a warning and "
"enable the GIL at runtime."
msgstr ""
"Модули расширения должны явно указать, что они поддерживают работу с "
"отключенным GIL; в противном случае импорт расширения вызовет предупреждение "
"и включит GIL во время выполнения."

#: ../../howto/free-threading-extensions.rst:33
msgid ""
"There are two ways to indicate that an extension module supports running "
"with the GIL disabled depending on whether the extension uses multi-phase or "
"single-phase initialization."
msgstr ""
"Существует два способа указать, что модуль расширения поддерживает работу с "
"отключенным GIL, в зависимости от того, использует ли расширение многофазную "
"или однофазную инициализацию."

#: ../../howto/free-threading-extensions.rst:38
msgid "Multi-Phase Initialization"
msgstr "Многофазная инициализация"

#: ../../howto/free-threading-extensions.rst:40
msgid ""
"Extensions that use multi-phase initialization (i.e., :c:func:"
"`PyModuleDef_Init`) should add a :c:data:`Py_mod_gil` slot in the module "
"definition.  If your extension supports older versions of CPython, you "
"should guard the slot with a :c:data:`PY_VERSION_HEX` check."
msgstr ""
"Расширения, использующие многофазную инициализацию (т. е. :c:func:"
"`PyModuleDef_Init`), должны добавить слот :c:data:`Py_mod_gil` в определение "
"модуля. Если ваше расширение поддерживает более старые версии CPython, вам "
"следует защитить слот проверкой :c:data:`PY_VERSION_HEX`."

#: ../../howto/free-threading-extensions.rst:47
msgid ""
"static struct PyModuleDef_Slot module_slots[] = {\n"
"    ...\n"
"#if PY_VERSION_HEX >= 0x030D0000\n"
"    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n"
"#endif\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static struct PyModuleDef moduledef = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    .m_slots = module_slots,\n"
"    ...\n"
"};"
msgstr ""
"static struct PyModuleDef_Slot module_slots[] = {\n"
"    ...\n"
"#if PY_VERSION_HEX >= 0x030D0000\n"
"    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n"
"#endif\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static struct PyModuleDef moduledef = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    .m_slots = module_slots,\n"
"    ...\n"
"};"

#: ../../howto/free-threading-extensions.rst:63
msgid "Single-Phase Initialization"
msgstr "Однофазная инициализация"

#: ../../howto/free-threading-extensions.rst:65
msgid ""
"Extensions that use single-phase initialization (i.e., :c:func:"
"`PyModule_Create`) should call :c:func:`PyUnstable_Module_SetGIL` to "
"indicate that they support running with the GIL disabled.  The function is "
"only defined in the free-threaded build, so you should guard the call with "
"``#ifdef Py_GIL_DISABLED`` to avoid compilation errors in the regular build."
msgstr ""
"Расширения, использующие однофазную инициализацию (т. е. :c:func:"
"`PyModule_Create`), должны вызывать :c:func:`PyUnstable_Module_SetGIL`, "
"чтобы указать, что они поддерживают работу с отключенным GIL. Функция "
"определена только в сборке со свободным потоком, поэтому вам следует "
"защитить вызов с помощью ``#ifdef Py_GIL_DISABLED``, чтобы избежать ошибок "
"компиляции в обычной сборке."

#: ../../howto/free-threading-extensions.rst:73
msgid ""
"static struct PyModuleDef moduledef = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    ...\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_mymodule(void)\n"
"{\n"
"    PyObject *m = PyModule_Create(&moduledef);\n"
"    if (m == NULL) {\n"
"        return NULL;\n"
"    }\n"
"#ifdef Py_GIL_DISABLED\n"
"    PyUnstable_Module_SetGIL(m, Py_MOD_GIL_NOT_USED);\n"
"#endif\n"
"    return m;\n"
"}"
msgstr ""
"static struct PyModuleDef moduledef = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    ...\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_mymodule(void)\n"
"{\n"
"    PyObject *m = PyModule_Create(&moduledef);\n"
"    if (m == NULL) {\n"
"        return NULL;\n"
"    }\n"
"#ifdef Py_GIL_DISABLED\n"
"    PyUnstable_Module_SetGIL(m, Py_MOD_GIL_NOT_USED);\n"
"#endif\n"
"    return m;\n"
"}"

#: ../../howto/free-threading-extensions.rst:93
msgid "General API Guidelines"
msgstr "Общие рекомендации по API"

#: ../../howto/free-threading-extensions.rst:95
msgid "Most of the C API is thread-safe, but there are some exceptions."
msgstr ""
"Большая часть C API является поточно-ориентированной, но есть и некоторые "
"исключения."

#: ../../howto/free-threading-extensions.rst:97
msgid ""
"**Struct Fields**: Accessing fields in Python C API objects or structs "
"directly is not thread-safe if the field may be concurrently modified."
msgstr ""
"**Поля структуры**: прямой доступ к полям в объектах или структурах Python C "
"API не является потокобезопасным, если поле может быть одновременно изменено."

#: ../../howto/free-threading-extensions.rst:99
msgid ""
"**Macros**: Accessor macros like :c:macro:`PyList_GET_ITEM` and :c:macro:"
"`PyList_SET_ITEM` do not perform any error checking or locking. These macros "
"are not thread-safe if the container object may be modified concurrently."
msgstr ""
"**Макросы**: Макросы доступа, такие как :c:macro:`PyList_GET_ITEM` и :c:"
"macro:`PyList_SET_ITEM`, не выполняют никакой проверки ошибок или "
"блокировки. Эти макросы не являются потокобезопасными, если объект-контейнер "
"может быть изменен одновременно."

#: ../../howto/free-threading-extensions.rst:103
msgid ""
"**Borrowed References**: C API functions that return :term:`borrowed "
"references <borrowed reference>` may not be thread-safe if the containing "
"object is modified concurrently.  See the section on :ref:`borrowed "
"references <borrowed-references>` for more information."
msgstr ""
"**Заимствованные ссылки**: функции C API, которые возвращают :term:"
"`заимствованные ссылки <заимствованная ссылка>`, могут быть не поточно-"
"ориентированными, если содержащий их объект изменяется одновременно. "
"Дополнительную информацию смотрите в разделе :ref:`заимствованные ссылки "
"<borrowed-references>`."

#: ../../howto/free-threading-extensions.rst:110
msgid "Container Thread Safety"
msgstr "Безопасность потоков контейнеров"

#: ../../howto/free-threading-extensions.rst:112
msgid ""
"Containers like :c:struct:`PyListObject`, :c:struct:`PyDictObject`, and :c:"
"struct:`PySetObject` perform internal locking in the free-threaded build.  "
"For example, the :c:func:`PyList_Append` will lock the list before appending "
"an item."
msgstr ""
"Контейнеры, такие как :c:struct:`PyListObject`, :c:struct:`PyDictObject` и :"
"c:struct:`PySetObject`, выполняют внутреннюю блокировку в свободнопоточной "
"сборке. Например, :c:func:`PyList_Append` заблокирует список перед "
"добавлением элемента."

#: ../../howto/free-threading-extensions.rst:120
msgid "``PyDict_Next``"
msgstr "``PyDict_Next``"

#: ../../howto/free-threading-extensions.rst:122
msgid ""
"A notable exception is :c:func:`PyDict_Next`, which does not lock the "
"dictionary.  You should use :c:macro:`Py_BEGIN_CRITICAL_SECTION` to protect "
"the dictionary while iterating over it if the dictionary may be concurrently "
"modified::"
msgstr ""
"Заметным исключением является :c:func:`PyDict_Next`, который не блокирует "
"словарь. Вы должны использовать :c:macro:`Py_BEGIN_CRITICAL_SECTION` для "
"защиты словаря во время итерации по нему, если словарь может быть "
"одновременно изменен::"

#: ../../howto/free-threading-extensions.rst:127
msgid ""
"Py_BEGIN_CRITICAL_SECTION(dict);\n"
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"while (PyDict_Next(dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"
msgstr ""
"Py_BEGIN_CRITICAL_SECTION(dict);\n"
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"while (PyDict_Next(dict, &pos, &key, &value)) {\n"
"    ...\n"
"}\n"
"Py_END_CRITICAL_SECTION();"

#: ../../howto/free-threading-extensions.rst:137
msgid "Borrowed References"
msgstr "Заимствованные ссылки"

#: ../../howto/free-threading-extensions.rst:141
msgid ""
"Some C API functions return :term:`borrowed references <borrowed "
"reference>`. These APIs are not thread-safe if the containing object is "
"modified concurrently.  For example, it's not safe to use :c:func:"
"`PyList_GetItem` if the list may be modified concurrently."
msgstr ""
"Некоторые функции C API возвращают :term:`заимствованные ссылки "
"<заимствованная ссылка>`. Эти API не являются потокобезопасными, если "
"содержащий их объект изменяется одновременно. Например, небезопасно "
"использовать :c:func:`PyList_GetItem`, если список может быть изменен "
"одновременно."

#: ../../howto/free-threading-extensions.rst:146
msgid ""
"The following table lists some borrowed reference APIs and their "
"replacements that return :term:`strong references <strong reference>`."
msgstr ""
"В следующей таблице перечислены некоторые заимствованные справочные API и их "
"замены, которые возвращают :term:`strong references <strong reference>`."

#: ../../howto/free-threading-extensions.rst:150
msgid "Borrowed reference API"
msgstr "Заимствованный эталонный API"

#: ../../howto/free-threading-extensions.rst:150
msgid "Strong reference API"
msgstr "Надежный эталонный API"

#: ../../howto/free-threading-extensions.rst:152
msgid ":c:func:`PyList_GetItem`"
msgstr ":c:func:`PyList_GetItem`"

#: ../../howto/free-threading-extensions.rst:152
msgid ":c:func:`PyList_GetItemRef`"
msgstr ":c:func:`PyList_GetItemRef`"

#: ../../howto/free-threading-extensions.rst:154
msgid ":c:func:`PyDict_GetItem`"
msgstr ":c:func:`PyDict_GetItem`"

#: ../../howto/free-threading-extensions.rst:154
#: ../../howto/free-threading-extensions.rst:156
msgid ":c:func:`PyDict_GetItemRef`"
msgstr ":c:func:`PyDict_GetItemRef`"

#: ../../howto/free-threading-extensions.rst:156
msgid ":c:func:`PyDict_GetItemWithError`"
msgstr ":c:func:`PyDict_GetItemWithError`"

#: ../../howto/free-threading-extensions.rst:158
msgid ":c:func:`PyDict_GetItemString`"
msgstr ":c:func:`PyDict_GetItemString`"

#: ../../howto/free-threading-extensions.rst:158
msgid ":c:func:`PyDict_GetItemStringRef`"
msgstr ":c:func:`PyDict_GetItemStringRef`"

#: ../../howto/free-threading-extensions.rst:160
msgid ":c:func:`PyDict_SetDefault`"
msgstr ":c:func:`PyDict_SetDefault`"

#: ../../howto/free-threading-extensions.rst:160
msgid ":c:func:`PyDict_SetDefaultRef`"
msgstr ":c:func:`PyDict_SetDefaultRef`"

#: ../../howto/free-threading-extensions.rst:162
msgid ":c:func:`PyDict_Next`"
msgstr ":c:func:`PyDict_Next`"

#: ../../howto/free-threading-extensions.rst:162
msgid "none (see :ref:`PyDict_Next`)"
msgstr "нет (см. :ref:`PyDict_Next`)"

#: ../../howto/free-threading-extensions.rst:164
msgid ":c:func:`PyWeakref_GetObject`"
msgstr ":c:func:`PyWeakref_GetObject`"

#: ../../howto/free-threading-extensions.rst:164
#: ../../howto/free-threading-extensions.rst:166
msgid ":c:func:`PyWeakref_GetRef`"
msgstr ":c:func:`PyWeakref_GetRef`"

#: ../../howto/free-threading-extensions.rst:166
msgid ":c:func:`PyWeakref_GET_OBJECT`"
msgstr ":c:func:`PyWeakref_GET_OBJECT`"

#: ../../howto/free-threading-extensions.rst:168
msgid ":c:func:`PyImport_AddModule`"
msgstr ":c:func:`PyImport_AddModule`"

#: ../../howto/free-threading-extensions.rst:168
msgid ":c:func:`PyImport_AddModuleRef`"
msgstr ":c:func:`PyImport_AddModuleRef`"

#: ../../howto/free-threading-extensions.rst:171
msgid ""
"Not all APIs that return borrowed references are problematic.  For example, :"
"c:func:`PyTuple_GetItem` is safe because tuples are immutable. Similarly, "
"not all uses of the above APIs are problematic.  For example, :c:func:"
"`PyDict_GetItem` is often used for parsing keyword argument dictionaries in "
"function calls; those keyword argument dictionaries are effectively private "
"(not accessible by other threads), so using borrowed references in that "
"context is safe."
msgstr ""
"Не все API, возвращающие заимствованные ссылки, являются проблематичными. "
"Например, :c:func:`PyTuple_GetItem` безопасен, поскольку кортежи "
"неизменяемы. Аналогично, не все способы использования вышеуказанных API "
"являются проблематичными. Например, :c:func:`PyDict_GetItem` часто "
"используется для анализа словарей аргументов ключевых слов в вызовах "
"функций; эти словари аргументов ключевых слов фактически являются частными "
"(не доступны другим потокам), поэтому использование заимствованных ссылок в "
"этом контексте безопасно."

#: ../../howto/free-threading-extensions.rst:179
msgid ""
"Some of these functions were added in Python 3.13.  You can use the "
"`pythoncapi-compat <https://github.com/python/pythoncapi-compat>`_ package "
"to provide implementations of these functions for older Python versions."
msgstr ""
"Некоторые из этих функций были добавлены в Python 3.13. Вы можете "
"использовать пакет `pythoncapi-compat <https://github.com/python/pythoncapi-"
"compat>`_, чтобы предоставить реализации этих функций для более старых "
"версий Python."

#: ../../howto/free-threading-extensions.rst:187
msgid "Memory Allocation APIs"
msgstr "API распределения памяти"

#: ../../howto/free-threading-extensions.rst:189
msgid ""
"Python's memory management C API provides functions in three different :ref:"
"`allocation domains <allocator-domains>`: \"raw\", \"mem\", and \"object\". "
"For thread-safety, the free-threaded build requires that only Python objects "
"are allocated using the object domain, and that all Python object are "
"allocated using that domain.  This differs from the prior Python versions, "
"where this was only a best practice and not a hard requirement."
msgstr ""
"API C управления памятью Python предоставляет функции в трех различных :ref:"
"`доменах распределения <allocator-domains>`: «raw», «mem» и «object». В "
"целях безопасности потоков при сборке со свободным потоком требуется, чтобы "
"только объекты Python выделялись с использованием объектного домена и чтобы "
"все объекты Python размещались с использованием этого домена. Это отличается "
"от предыдущих версий Python, где это было лишь рекомендуемой практикой, а не "
"жестким требованием."

#: ../../howto/free-threading-extensions.rst:198
msgid ""
"Search for uses of :c:func:`PyObject_Malloc` in your extension and check "
"that the allocated memory is used for Python objects. Use :c:func:"
"`PyMem_Malloc` to allocate buffers instead of :c:func:`PyObject_Malloc`."
msgstr ""
"Найдите использование :c:func:`PyObject_Malloc` в вашем расширении и "
"проверьте, используется ли выделенная память для объектов Python. "
"Используйте :c:func:`PyMem_Malloc` для выделения буферов вместо :c:func:"
"`PyObject_Malloc`."

#: ../../howto/free-threading-extensions.rst:205
msgid "Thread State and GIL APIs"
msgstr "Состояние потока и GIL API"

#: ../../howto/free-threading-extensions.rst:207
msgid ""
"Python provides a set of functions and macros to manage thread state and the "
"GIL, such as:"
msgstr ""
"Python предоставляет набор функций и макросов для управления состоянием "
"потока и GIL, например:"

#: ../../howto/free-threading-extensions.rst:210
msgid ":c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release`"
msgstr ":c:func:`PyGILState_Ensure` и :c:func:`PyGILState_Release`"

#: ../../howto/free-threading-extensions.rst:211
msgid ":c:func:`PyEval_SaveThread` and :c:func:`PyEval_RestoreThread`"
msgstr ":c:func:`PyEval_SaveThread` и :c:func:`PyEval_RestoreThread`"

#: ../../howto/free-threading-extensions.rst:212
msgid ":c:macro:`Py_BEGIN_ALLOW_THREADS` and :c:macro:`Py_END_ALLOW_THREADS`"
msgstr ":c:macro:`Py_BEGIN_ALLOW_THREADS` и :c:macro:`Py_END_ALLOW_THREADS`"

#: ../../howto/free-threading-extensions.rst:214
msgid ""
"These functions should still be used in the free-threaded build to manage "
"thread state even when the :term:`GIL` is disabled.  For example, if you "
"create a thread outside of Python, you must call :c:func:`PyGILState_Ensure` "
"before calling into the Python API to ensure that the thread has a valid "
"Python thread state."
msgstr ""
"Эти функции по-прежнему следует использовать в сборке со свободным потоком "
"для управления состоянием потока, даже если :term:`GIL` отключен. Например, "
"если вы создаете поток вне Python, вы должны вызвать :c:func:"
"`PyGILState_Ensure` перед вызовом API Python, чтобы убедиться, что поток "
"имеет допустимое состояние потока Python."

#: ../../howto/free-threading-extensions.rst:220
msgid ""
"You should continue to call :c:func:`PyEval_SaveThread` or :c:macro:"
"`Py_BEGIN_ALLOW_THREADS` around blocking operations, such as I/O or lock "
"acquisitions, to allow other threads to run the :term:`cyclic garbage "
"collector <garbage collection>`."
msgstr ""
"Вам следует продолжать вызывать :c:func:`PyEval_SaveThread` или :c:macro:"
"`Py_BEGIN_ALLOW_THREADS` для операций блокировки, таких как ввод-вывод или "
"получение блокировок, чтобы позволить другим потокам запускать :term:"
"`циклический сборщик мусора < сбор мусора>`."

#: ../../howto/free-threading-extensions.rst:227
msgid "Protecting Internal Extension State"
msgstr "Защита состояния внутреннего расширения"

#: ../../howto/free-threading-extensions.rst:229
msgid ""
"Your extension may have internal state that was previously protected by the "
"GIL.  You may need to add locking to protect this state.  The approach will "
"depend on your extension, but some common patterns include:"
msgstr ""
"Ваше расширение может иметь внутреннее состояние, которое ранее было "
"защищено GIL. Возможно, вам придется добавить блокировку для защиты этого "
"состояния. Подход будет зависеть от вашего расширения, но некоторые общие "
"шаблоны включают в себя:"

#: ../../howto/free-threading-extensions.rst:233
msgid ""
"**Caches**: global caches are a common source of shared state.  Consider "
"using a lock to protect the cache or disabling it in the free-threaded build "
"if the cache is not critical for performance."
msgstr ""
"**Кэши**: глобальные кеши являются распространенным источником общего "
"состояния. Рассмотрите возможность использования блокировки для защиты кеша "
"или ее отключения в сборке со свободным потоком, если кеш не критичен для "
"производительности."

#: ../../howto/free-threading-extensions.rst:236
msgid ""
"**Global State**: global state may need to be protected by a lock or moved "
"to thread local storage. C11 and C++11 provide the ``thread_local`` or "
"``_Thread_local`` for `thread-local storage <https://en.cppreference.com/w/c/"
"language/storage_duration>`_."
msgstr ""
"**Глобальное состояние**: возможно, глобальное состояние необходимо защитить "
"блокировкой или перенести в локальное хранилище потока. C11 и C++11 "
"предоставляют ``thread_local`` или ``_Thread_local`` для ``thread-local "
"Storage <https://en.cppreference.com/w/c/language/storage_duration>`_."

#: ../../howto/free-threading-extensions.rst:243
msgid "Building Extensions for the Free-Threaded Build"
msgstr "Создание расширений для свободнопоточной сборки"

#: ../../howto/free-threading-extensions.rst:245
msgid ""
"C API extensions need to be built specifically for the free-threaded build. "
"The wheels, shared libraries, and binaries are indicated by a ``t`` suffix."
msgstr ""
"Расширения C API необходимо создавать специально для сборки со свободной "
"резьбой. Колеса, общие библиотеки и двоичные файлы обозначаются суффиксом "
"«t»."

#: ../../howto/free-threading-extensions.rst:248
msgid ""
"`pypa/manylinux <https://github.com/pypa/manylinux>`_ supports the free-"
"threaded build, with the ``t`` suffix, such as ``python3.13t``."
msgstr ""
"`pypa/manylinux <https://github.com/pypa/manylinux>`_ поддерживает сборку со "
"свободным потоком с суффиксом ``t``, например ``python3.13t``."

#: ../../howto/free-threading-extensions.rst:250
msgid ""
"`pypa/cibuildwheel <https://github.com/pypa/cibuildwheel>`_ supports the "
"free-threaded build if you set `CIBW_FREE_THREADED_SUPPORT <https://"
"cibuildwheel.pypa.io/en/stable/options/#free-threaded-support>`_."
msgstr ""
"`pypa/cibuildwheel <https://github.com/pypa/cibuildwheel>`_ поддерживает "
"сборку со свободным потоком, если вы установите `CIBW_FREE_THREADED_SUPPORT "
"<https://cibuildwheel.pypa.io/en/stable/options/#free- поддержка резьбы>`_."

#: ../../howto/free-threading-extensions.rst:255
msgid "Limited C API and Stable ABI"
msgstr "Ограниченный API C и стабильный ABI"

#: ../../howto/free-threading-extensions.rst:257
msgid ""
"The free-threaded build does not currently support the :ref:`Limited C API "
"<limited-c-api>` or the stable ABI.  If you use `setuptools <https://"
"setuptools.pypa.io/en/latest/setuptools.html>`_ to build your extension and "
"currently set ``py_limited_api=True`` you can use ``py_limited_api=not "
"sysconfig.get_config_var(\"Py_GIL_DISABLED\")`` to opt out of the limited "
"API when building with the free-threaded build."
msgstr ""
"Сборка со свободным потоком в настоящее время не поддерживает :ref:`Limited "
"C API <limited-c-api>` или стабильный ABI. Если вы используете `setuptools "
"<https://setuptools.pypa.io/en/latest/setuptools.html>`_ для сборки вашего "
"расширения и в настоящее время установлено ``py_limited_api=True``, вы "
"можете использовать ``py_limited_api=not sysconfig. "
"get_config_var(\"Py_GIL_DISABLED\")``, чтобы отказаться от ограниченного API "
"при сборке с использованием свободнопоточной сборки."

#: ../../howto/free-threading-extensions.rst:265
msgid ""
"You will need to build separate wheels specifically for the free-threaded "
"build.  If you currently use the stable ABI, you can continue to build a "
"single wheel for multiple non-free-threaded Python versions."
msgstr ""
"Вам нужно будет построить отдельные колеса специально для сборки со "
"свободной резьбой. Если вы в настоящее время используете стабильную версию "
"ABI, вы можете продолжать создавать одно колесо для нескольких версий Python "
"с несвободной резьбой."

#: ../../howto/free-threading-extensions.rst:271
msgid "Windows"
msgstr "Windows"

#: ../../howto/free-threading-extensions.rst:273
msgid ""
"Due to a limitation of the official Windows installer, you will need to "
"manually define ``Py_GIL_DISABLED=1`` when building extensions from source."
msgstr ""
"Из-за ограничений официального установщика Windows вам нужно будет вручную "
"определить Py_GIL_DISABLED=1 при сборке расширений из исходного кода."

#: ../../howto/free-threading-extensions.rst:278
msgid ""
"`Porting Extension Modules to Support Free-Threading <https://py-free-"
"threading.github.io/porting/>`_: A community-maintained porting guide for "
"extension authors."
msgstr ""
"`Портирование модулей расширения для поддержки свободной многопоточности "
"<https://py-free-threading.github.io/porting/>`_: поддерживаемое сообществом "
"руководство по портированию для авторов расширений."
