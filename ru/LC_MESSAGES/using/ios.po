# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-11 14:17+0000\n"
"PO-Revision-Date: 2024-05-11 01:08+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../using/ios.rst:5
msgid "Using Python on iOS"
msgstr "Использование Python на iOS"

#: ../../using/ios.rst:0
msgid "Authors"
msgstr "Авторы"

#: ../../using/ios.rst:8
msgid "Russell Keith-Magee (2024-03)"
msgstr "Рассел Кейт-Маги (2024–03)"

#: ../../using/ios.rst:10
msgid ""
"Python on iOS is unlike Python on desktop platforms. On a desktop platform, "
"Python is generally installed as a system resource that can be used by any "
"user of that computer. Users then interact with Python by running a :program:"
"`python` executable and entering commands at an interactive prompt, or by "
"running a Python script."
msgstr ""
"Python для iOS отличается от Python на настольных платформах. На настольной "
"платформе Python обычно устанавливается как системный ресурс, который может "
"использовать любой пользователь этого компьютера. Затем пользователи "
"взаимодействуют с Python, запуская исполняемый файл :program:`python` и "
"вводя команды в интерактивной подсказке или запуская скрипт Python."

#: ../../using/ios.rst:16
msgid ""
"On iOS, there is no concept of installing as a system resource. The only "
"unit of software distribution is an \"app\". There is also no console where "
"you could run a :program:`python` executable, or interact with a Python REPL."
msgstr ""
"В iOS нет понятия установки как системного ресурса. Единственной единицей "
"распространения программного обеспечения является «приложение». Также нет "
"консоли, на которой вы могли бы запустить исполняемый файл :program:`python` "
"или взаимодействовать с Python REPL."

#: ../../using/ios.rst:20
msgid ""
"As a result, the only way you can use Python on iOS is in embedded mode - "
"that is, by writing a native iOS application, and embedding a Python "
"interpreter using ``libPython``, and invoking Python code using the :ref:"
"`Python embedding API <embedding>`. The full Python interpreter, the "
"standard library, and all your Python code is then packaged as a standalone "
"bundle that can be distributed via the iOS App Store."
msgstr ""
"В результате единственный способ использовать Python в iOS — это встроенный "
"режим, то есть написание собственного приложения для iOS, встраивание "
"интерпретатора Python с помощью libPython и вызов кода Python с помощью :ref:"
"` API встраивания Python <embedding>`. Полный интерпретатор Python, "
"стандартная библиотека и весь ваш код Python затем упаковываются в отдельный "
"пакет, который можно распространять через iOS App Store."

#: ../../using/ios.rst:27
msgid ""
"If you're looking to experiment for the first time with writing an iOS app "
"in Python, projects such as `BeeWare <https://beeware.org>`__ and `Kivy "
"<https://kivy.org>`__ will provide a much more approachable user experience. "
"These projects manage the complexities associated with getting an iOS "
"project running, so you only need to deal with the Python code itself."
msgstr ""
"Если вы впервые хотите поэкспериментировать с написанием приложения iOS на "
"Python, вам подойдут такие проекты, как `BeeWare <https://beeware.org>`__ и "
"`Kivy <https://kivy.org>`__. обеспечить гораздо более доступный "
"пользовательский опыт. Эти проекты решают сложности, связанные с запуском "
"проекта iOS, поэтому вам нужно иметь дело только с самим кодом Python."

#: ../../using/ios.rst:34
msgid "Python at runtime on iOS"
msgstr "Python во время выполнения на iOS"

#: ../../using/ios.rst:37
msgid "iOS version compatibility"
msgstr "Совместимость версий iOS"

#: ../../using/ios.rst:39
msgid ""
"The minimum supported iOS version is specified at compile time, using the :"
"option:`--host` option to ``configure``. By default, when compiled for iOS, "
"Python will be compiled with a minimum supported iOS version of 13.0. To use "
"a different minimum iOS version, provide the version number as part of the :"
"option:`!--host` argument - for example, ``--host=arm64-apple-ios15.4-"
"simulator`` would compile an ARM64 simulator build with a deployment target "
"of 15.4."
msgstr ""
"Минимальная поддерживаемая версия iOS указывается во время компиляции с "
"использованием параметра :option:`--host` для ``configure``. По умолчанию "
"при компиляции для iOS Python будет скомпилирован с минимальной "
"поддерживаемой версией iOS 13.0. Чтобы использовать другую минимальную "
"версию iOS, укажите номер версии как часть аргумента :option:`!--host` — "
"например, ``--host=arm64-apple-ios15.4-simulator`` скомпилирует Сборка "
"симулятора ARM64 с целевой версией 15.4."

#: ../../using/ios.rst:48
msgid "Platform identification"
msgstr "Идентификация платформы"

#: ../../using/ios.rst:50
msgid ""
"When executing on iOS, ``sys.platform`` will report as ``ios``. This value "
"will be returned on an iPhone or iPad, regardless of whether the app is "
"running on the simulator or a physical device."
msgstr ""
"При запуске на iOS ``sys.platform`` будет сообщаться как ``ios``. Это "
"значение будет возвращено на iPhone или iPad независимо от того, работает ли "
"приложение на симуляторе или на физическом устройстве."

#: ../../using/ios.rst:54
msgid ""
"Information about the specific runtime environment, including the iOS "
"version, device model, and whether the device is a simulator, can be "
"obtained using :func:`platform.ios_ver`. :func:`platform.system` will report "
"``iOS`` or ``iPadOS``, depending on the device."
msgstr ""
"Информацию о конкретной среде выполнения, включая версию iOS, модель "
"устройства и то, является ли устройство симулятором, можно получить с "
"помощью :func:`platform.ios_ver`. :func:`platform.system` сообщит ``iOS`` "
"или ``iPadOS``, в зависимости от устройства."

#: ../../using/ios.rst:59
msgid ""
":func:`os.uname` reports kernel-level details; it will report a name of "
"``Darwin``."
msgstr ""
":func:`os.uname` сообщает подробности уровня ядра; он сообщит имя «Дарвин»."

#: ../../using/ios.rst:63
msgid "Standard library availability"
msgstr "Наличие стандартной библиотеки"

#: ../../using/ios.rst:65
msgid ""
"The Python standard library has some notable omissions and restrictions on "
"iOS. See the :ref:`API availability guide for iOS <mobile-availability>` for "
"details."
msgstr ""
"Стандартная библиотека Python имеет некоторые заметные упущения и "
"ограничения для iOS. Подробности см. в руководстве по доступности API для "
"iOS <mobile-availability>."

#: ../../using/ios.rst:70
msgid "Binary extension modules"
msgstr "Бинарные модули расширения"

#: ../../using/ios.rst:72
msgid ""
"One notable difference about iOS as a platform is that App Store "
"distribution imposes hard requirements on the packaging of an application. "
"One of these requirements governs how binary extension modules are "
"distributed."
msgstr ""
"Одним из заметных отличий iOS как платформы является то, что распространение "
"в App Store предъявляет жесткие требования к упаковке приложения. Одно из "
"этих требований определяет способ распространения двоичных модулей "
"расширения."

#: ../../using/ios.rst:76
msgid ""
"The iOS App Store requires that *all* binary modules in an iOS app must be "
"dynamic libraries, contained in a framework with appropriate metadata, "
"stored in the ``Frameworks`` folder of the packaged app. There can be only a "
"single binary per framework, and there can be no executable binary material "
"outside the ``Frameworks`` folder."
msgstr ""
"Магазин приложений iOS требует, чтобы *все* бинарные модули в приложении iOS "
"были динамическими библиотеками, содержащимися в фреймворке с "
"соответствующими метаданными, хранящимися в папке ``Frameworks`` "
"упакованного приложения. Для каждого фреймворка может быть только один "
"двоичный файл, и за пределами папки «Frameworks» не может быть исполняемого "
"двоичного материала."

#: ../../using/ios.rst:82
msgid ""
"This conflicts with the usual Python approach for distributing binaries, "
"which allows a binary extension module to be loaded from any location on "
"``sys.path``. To ensure compliance with App Store policies, an iOS project "
"must post-process any Python packages, converting ``.so`` binary modules "
"into individual standalone frameworks with appropriate metadata and signing. "
"For details on how to perform this post-processing, see the guide for :ref:"
"`adding Python to your project <adding-ios>`."
msgstr ""
"Это противоречит обычному подходу Python к распространению двоичных файлов, "
"который позволяет загружать двоичный модуль расширения из любого места в "
"``sys.path``. Чтобы обеспечить соответствие политикам App Store, проект iOS "
"должен выполнить постобработку любых пакетов Python, преобразовав двоичные "
"модули ``.so`` в отдельные автономные платформы с соответствующими "
"метаданными и подписью. Подробную информацию о том, как выполнить эту "
"постобработку, см. в руководстве по :ref:`добавлению Python в ваш проект "
"<adding-ios>`."

#: ../../using/ios.rst:90
msgid ""
"To help Python discover binaries in their new location, the original ``.so`` "
"file on ``sys.path`` is replaced with a ``.fwork`` file. This file is a text "
"file containing the location of the framework binary, relative to the app "
"bundle. To allow the framework to resolve back to the original location, the "
"framework must contain a ``.origin`` file that contains the location of the "
"``.fwork`` file, relative to the app bundle."
msgstr ""
"Чтобы помочь Python обнаружить двоичные файлы в новом расположении, исходный "
"файл ``.so`` в ``sys.path`` заменяется файлом ``.fwork``. Этот файл "
"представляет собой текстовый файл, содержащий расположение двоичного файла "
"платформы относительно пакета приложения. Чтобы платформа могла вернуться в "
"исходное местоположение, она должна содержать файл ``.origin``, содержащий "
"местоположение файла ``.fwork`` относительно пакета приложения."

#: ../../using/ios.rst:97
msgid ""
"For example, consider the case of an import ``from foo.bar import _whiz``, "
"where ``_whiz`` is implemented with the binary module ``sources/foo/bar/"
"_whiz.abi3.so``, with ``sources`` being the location registered on ``sys."
"path``, relative to the application bundle. This module *must* be "
"distributed as ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` "
"(creating the framework name from the full import path of the module), with "
"an ``Info.plist`` file in the ``.framework`` directory identifying the "
"binary as a framework. The ``foo.bar._whiz`` module would be represented in "
"the original location with a ``sources/foo/bar/_whiz.abi3.fwork`` marker "
"file, containing the path ``Frameworks/foo.bar._whiz/foo.bar._whiz``. The "
"framework would also contain ``Frameworks/foo.bar._whiz.framework/foo.bar."
"_whiz.origin``, containing the path to the ``.fwork`` file."
msgstr ""
"Например, рассмотрим случай импорта ``из foo.bar import _whiz``, где "
"``_whiz`` реализуется с помощью двоичного модуля ``sources/foo/bar/_whiz."
"abi3.so``, с `` `sources`` — это местоположение, зарегистрированное в ``sys."
"path`` относительно пакета приложения. Этот модуль *должен* распространяться "
"как ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` (имя платформы "
"создается из полного пути импорта модуля) с ``Info.plist` `файл в каталоге "
"``.framework``, идентифицирующий двоичный файл как фреймворк. Модуль ``foo."
"bar._whiz`` будет представлен в исходном месте с помощью файла маркера "
"``sources/foo/bar/_whiz.abi3.fwork``, содержащего путь ``Frameworks/foo.bar."
"_whiz``. /foo.bar._whiz``. Фреймворк также будет содержать ``Frameworks/foo."
"bar._whiz.framework/foo.bar._whiz.origin``, содержащий путь к файлу ``."
"fwork``."

#: ../../using/ios.rst:110
msgid ""
"When running on iOS, the Python interpreter will install an :class:"
"`~importlib.machinery.AppleFrameworkLoader` that is able to read and import "
"``.fwork`` files. Once imported, the ``__file__`` attribute of the binary "
"module will report as the location of the ``.fwork`` file. However, the :"
"class:`~importlib.machinery.ModuleSpec` for the loaded module will report "
"the ``origin`` as the location of the binary in the framework folder."
msgstr ""
"При работе на iOS интерпретатор Python установит :class:`~importlib."
"machinery.AppleFrameworkLoader`, который сможет читать и импортировать файлы "
"``.fwork``. После импорта атрибут ``__file__`` двоичного модуля будет "
"указывать местоположение файла ``.fwork``. Однако :class:`~importlib."
"machinery.ModuleSpec` для загруженного модуля сообщит ``origin`` как "
"местоположение двоичного файла в папке фреймворка."

#: ../../using/ios.rst:118
msgid "Compiler stub binaries"
msgstr "Двоичные файлы-заглушки компилятора"

#: ../../using/ios.rst:120
msgid ""
"Xcode doesn't expose explicit compilers for iOS; instead, it uses an "
"``xcrun`` script that resolves to a full compiler path (e.g., ``xcrun --sdk "
"iphoneos clang`` to get the ``clang`` for an iPhone device). However, using "
"this script poses two problems:"
msgstr ""
"Xcode не предоставляет явных компиляторов для iOS; вместо этого он "
"использует сценарий ``xcrun``, который преобразует полный путь компилятора "
"(например, ``xcrun --sdk iphoneos clang`` для получения ``clang`` для "
"устройства iPhone). Однако использование этого сценария создает две проблемы:"

#: ../../using/ios.rst:125
msgid ""
"The output of ``xcrun`` includes paths that are machine specific, resulting "
"in a sysconfig module that cannot be shared between users; and"
msgstr ""
"Вывод ``xcrun`` включает в себя пути, специфичные для машины, в результате "
"чего модуль sysconfig не может быть разделен между пользователями; и"

#: ../../using/ios.rst:128
msgid ""
"It results in ``CC``/``CPP``/``LD``/``AR`` definitions that include spaces. "
"There is a lot of C ecosystem tooling that assumes that you can split a "
"command line at the first space to get the path to the compiler executable; "
"this isn't the case when using ``xcrun``."
msgstr ""
"В результате получаются определения ``CC``/``CPP``/``LD``/``AR``, содержащие "
"пробелы. Существует множество инструментов экосистемы C, которые "
"предполагают, что вы можете разделить командную строку на первый пробел, "
"чтобы получить путь к исполняемому файлу компилятора; это не тот случай, "
"когда используется ``xcrun``."

#: ../../using/ios.rst:133
msgid ""
"To avoid these problems, Python provided stubs for these tools. These stubs "
"are shell script wrappers around the underingly ``xcrun`` tools, distributed "
"in a ``bin`` folder distributed alongside the compiled iOS framework. These "
"scripts are relocatable, and will always resolve to the appropriate local "
"system paths. By including these scripts in the bin folder that accompanies "
"a framework, the contents of the ``sysconfig`` module becomes useful for end-"
"users to compile their own modules. When compiling third-party Python "
"modules for iOS, you should ensure these stub binaries are on your path."
msgstr ""
"Чтобы избежать этих проблем, Python предоставил заглушки для этих "
"инструментов. Эти заглушки представляют собой оболочки сценариев оболочки "
"вокруг инструментов xcrun, распространяемых в папке bin, распространяемой "
"вместе со скомпилированной платформой iOS. Эти сценарии можно перемещать, и "
"они всегда будут соответствовать соответствующим локальным системным путям. "
"Включив эти сценарии в папку bin, которая прилагается к фреймворку, "
"содержимое модуля ``sysconfig`` становится полезным для конечных "
"пользователей при компиляции своих собственных модулей. При компиляции "
"сторонних модулей Python для iOS вам следует убедиться, что эти двоичные "
"файлы-заглушки находятся на вашем пути."

#: ../../using/ios.rst:143
msgid "Installing Python on iOS"
msgstr "Установка Python на iOS"

#: ../../using/ios.rst:146
msgid "Tools for building iOS apps"
msgstr "Инструменты для создания приложений iOS"

#: ../../using/ios.rst:148
msgid ""
"Building for iOS requires the use of Apple's Xcode tooling. It is strongly "
"recommended that you use the most recent stable release of Xcode. This will "
"require the use of the most (or second-most) recently released macOS "
"version, as Apple does not maintain Xcode for older macOS versions. The "
"Xcode Command Line Tools are not sufficient for iOS development; you need a "
"*full* Xcode install."
msgstr ""
"Для сборки iOS требуется использование инструментов Apple Xcode. "
"Настоятельно рекомендуется использовать самую последнюю стабильную версию "
"Xcode. Для этого потребуется использовать самую последнюю (или вторую по "
"популярности) недавно выпущенную версию macOS, поскольку Apple не "
"поддерживает Xcode для более старых версий macOS. Инструментов командной "
"строки Xcode недостаточно для разработки iOS; вам нужна *полная* установка "
"Xcode."

#: ../../using/ios.rst:155
msgid ""
"If you want to run your code on the iOS simulator, you'll also need to "
"install an iOS Simulator Platform. You should be prompted to select an iOS "
"Simulator Platform when you first run Xcode. Alternatively, you can add an "
"iOS Simulator Platform by selecting from the Platforms tab of the Xcode "
"Settings panel."
msgstr ""
"Если вы хотите запустить свой код на симуляторе iOS, вам также потребуется "
"установить платформу симулятора iOS. При первом запуске Xcode вам будет "
"предложено выбрать платформу симулятора iOS. Альтернативно вы можете "
"добавить платформу симулятора iOS, выбрав ее на вкладке «Платформы» на "
"панели «Настройки Xcode»."

#: ../../using/ios.rst:163
msgid "Adding Python to an iOS project"
msgstr "Добавление Python в проект iOS"

#: ../../using/ios.rst:165
msgid ""
"Python can be added to any iOS project, using either Swift or Objective C. "
"The following examples will use Objective C; if you are using Swift, you may "
"find a library like `PythonKit <https://github.com/pvieito/PythonKit>`__ to "
"be helpful."
msgstr ""
"Python можно добавить в любой проект iOS, используя Swift или Objective C. В "
"следующих примерах будет использоваться Objective C; если вы используете "
"Swift, вам может пригодиться такая библиотека, как `PythonKit <https://"
"github.com/pvieito/PythonKit>`__."

#: ../../using/ios.rst:170
msgid "To add Python to an iOS Xcode project:"
msgstr "Чтобы добавить Python в проект iOS Xcode:"

#: ../../using/ios.rst:172
msgid ""
"Build or obtain a Python ``XCFramework``. See the instructions in :source:"
"`iOS/README.rst` (in the CPython source distribution) for details on how to "
"build a Python ``XCFramework``. At a minimum, you will need a build that "
"supports ``arm64-apple-ios``, plus one of either ``arm64-apple-ios-"
"simulator`` or ``x86_64-apple-ios-simulator``."
msgstr ""
"Создайте или получите Python XCFramework. См. инструкции в :source:`iOS/"
"README.rst` (в дистрибутиве исходного кода CPython) для получения подробной "
"информации о том, как собрать Python ``XCFramework``. Как минимум, вам "
"понадобится сборка, поддерживающая «arm64-apple-ios», а также один из «arm64-"
"apple-ios-simulator» или «x86_64-apple-ios-simulator»."

#: ../../using/ios.rst:178
msgid ""
"Drag the ``XCframework`` into your iOS project. In the following "
"instructions, we'll assume you've dropped the ``XCframework`` into the root "
"of your project; however, you can use any other location that you want by "
"adjusting paths as needed."
msgstr ""
"Перетащите XCframework в свой проект iOS. В следующих инструкциях мы "
"предполагаем, что вы поместили XCframework в корень вашего проекта; однако "
"вы можете использовать любое другое местоположение, изменив пути по мере "
"необходимости."

#: ../../using/ios.rst:183
msgid ""
"Drag the ``iOS/Resources/dylib-Info-template.plist`` file into your project, "
"and ensure it is associated with the app target."
msgstr ""
"Перетащите файл ``iOS/Resources/dylib-Info-template.plist`` в свой проект и "
"убедитесь, что он связан с целевым приложением."

#: ../../using/ios.rst:186
msgid ""
"Add your application code as a folder in your Xcode project. In the "
"following instructions, we'll assume that your user code is in a folder "
"named ``app`` in the root of your project; you can use any other location by "
"adjusting paths as needed. Ensure that this folder is associated with your "
"app target."
msgstr ""
"Добавьте код приложения в виде папки в свой проект Xcode. В следующих "
"инструкциях мы предполагаем, что ваш пользовательский код находится в папке "
"с именем ``app`` в корне вашего проекта; вы можете использовать любое другое "
"местоположение, изменив пути по мере необходимости. Убедитесь, что эта папка "
"связана с целью вашего приложения."

#: ../../using/ios.rst:192
msgid ""
"Select the app target by selecting the root node of your Xcode project, then "
"the target name in the sidebar that appears."
msgstr ""
"Выберите цель приложения, выбрав корневой узел вашего проекта Xcode, а затем "
"имя цели на появившейся боковой панели."

#: ../../using/ios.rst:195
msgid ""
"In the \"General\" settings, under \"Frameworks, Libraries and Embedded "
"Content\", add ``Python.xcframework``, with \"Embed & Sign\" selected."
msgstr ""
"В настройках «Общие» в разделе «Фреймворки, библиотеки и встроенный контент» "
"добавьте Python.xcframework с выбранным параметром «Встроить и подписать»."

#: ../../using/ios.rst:198
msgid "In the \"Build Settings\" tab, modify the following:"
msgstr "На вкладке «Настройки сборки» измените следующее:"

#: ../../using/ios.rst:200
msgid "Build Options"
msgstr "Варианты сборки"

#: ../../using/ios.rst:202
msgid "User Script Sandboxing: No"
msgstr "Песочница пользовательских сценариев: Нет"

#: ../../using/ios.rst:203
msgid "Enable Testability: Yes"
msgstr "Включить возможность тестирования: Да"

#: ../../using/ios.rst:205
msgid "Search Paths"
msgstr "Пути поиска"

#: ../../using/ios.rst:207
msgid "Framework Search Paths: ``$(PROJECT_DIR)``"
msgstr "Пути поиска платформы: ``$(PROJECT_DIR)``"

#: ../../using/ios.rst:208
msgid ""
"Header Search Paths: ``\"$(BUILT_PRODUCTS_DIR)/Python.framework/Headers\"``"
msgstr ""
"Header Search Paths: ``\"$(BUILT_PRODUCTS_DIR)/Python.framework/Headers\"``"

#: ../../using/ios.rst:210
msgid "Apple Clang - Warnings - All languages"
msgstr "Apple Clang – Предупреждения – Все языки"

#: ../../using/ios.rst:212
msgid "Quoted Include In Framework Header: No"
msgstr "Цитируемое включение в заголовок платформы: Нет"

#: ../../using/ios.rst:214
msgid ""
"Add a build step that copies the Python standard library into your app. In "
"the \"Build Phases\" tab, add a new \"Run Script\" build step *before* the "
"\"Embed Frameworks\" step, but *after* the \"Copy Bundle Resources\" step. "
"Name the step \"Install Target Specific Python Standard Library\", disable "
"the \"Based on dependency analysis\" checkbox, and set the script content to:"
msgstr ""
"Добавьте шаг сборки, который копирует стандартную библиотеку Python в ваше "
"приложение. На вкладке «Фазы сборки» добавьте новый шаг сборки «Запуск "
"сценария» *перед* шагом «Внедрение платформ», но *после* шага «Копировать "
"ресурсы пакета». Назовите шаг «Установить целевую стандартную библиотеку "
"Python», снимите флажок «На основе анализа зависимостей» и установите для "
"содержимого сценария следующее значение:"

#: ../../using/ios.rst:220
msgid ""
"set -e\n"
"\n"
"mkdir -p \"$CODESIGNING_FOLDER_PATH/python/lib\"\n"
"if [ \"$EFFECTIVE_PLATFORM_NAME\" = \"-iphonesimulator\" ]; then\n"
"    echo \"Installing Python modules for iOS Simulator\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64_x86_64-"
"simulator/lib/\" \"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"else\n"
"    echo \"Installing Python modules for iOS Device\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64/lib/\" "
"\"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"fi"
msgstr ""
"set -e\n"
"\n"
"mkdir -p \"$CODESIGNING_FOLDER_PATH/python/lib\"\n"
"if [ \"$EFFECTIVE_PLATFORM_NAME\" = \"-iphonesimulator\" ]; then\n"
"    echo \"Installing Python modules for iOS Simulator\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64_x86_64-"
"simulator/lib/\" \"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"else\n"
"    echo \"Installing Python modules for iOS Device\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64/lib/\" "
"\"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"fi"

#: ../../using/ios.rst:233
msgid ""
"Note that the name of the simulator \"slice\" in the XCframework may be "
"different, depending the CPU architectures your ``XCFramework`` supports."
msgstr ""
"Обратите внимание, что имя «среза» симулятора в XCframework может быть "
"другим, в зависимости от архитектуры ЦП, которую поддерживает ваш "
"«XCFramework»."

#: ../../using/ios.rst:236
msgid ""
"Add a second build step that processes the binary extension modules in the "
"standard library into \"Framework\" format. Add a \"Run Script\" build step "
"*directly after* the one you added in step 8, named \"Prepare Python Binary "
"Modules\". It should also have \"Based on dependency analysis\" unchecked, "
"with the following script content:"
msgstr ""
"Добавьте второй шаг сборки, который преобразует двоичные модули расширения "
"стандартной библиотеки в формат «Framework». Добавьте шаг сборки «Выполнить "
"сценарий» *сразу после* того, который вы добавили на шаге 8, под названием "
"«Подготовка двоичных модулей Python». Также должен быть снят флажок «На "
"основе анализа зависимостей» со следующим содержимым сценария:"

#: ../../using/ios.rst:242
msgid ""
"set -e\n"
"\n"
"install_dylib () {\n"
"    INSTALL_BASE=$1\n"
"    FULL_EXT=$2\n"
"\n"
"    # The name of the extension file\n"
"    EXT=$(basename \"$FULL_EXT\")\n"
"    # The location of the extension file, relative to the bundle\n"
"    RELATIVE_EXT=${FULL_EXT#$CODESIGNING_FOLDER_PATH/}\n"
"    # The path to the extension file, relative to the install base\n"
"    PYTHON_EXT=${RELATIVE_EXT/$INSTALL_BASE/}\n"
"    # The full dotted name of the extension module, constructed from the "
"file path.\n"
"    FULL_MODULE_NAME=$(echo $PYTHON_EXT | cut -d \".\" -f 1 | tr \"/\" \"."
"\");\n"
"    # A bundle identifier; not actually used, but required by Xcode "
"framework packaging\n"
"    FRAMEWORK_BUNDLE_ID=$(echo $PRODUCT_BUNDLE_IDENTIFIER.$FULL_MODULE_NAME "
"| tr \"_\" \"-\")\n"
"    # The name of the framework folder.\n"
"    FRAMEWORK_FOLDER=\"Frameworks/$FULL_MODULE_NAME.framework\"\n"
"\n"
"    # If the framework folder doesn't exist, create it.\n"
"    if [ ! -d \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\" ]; then\n"
"        echo \"Creating framework for $RELATIVE_EXT\"\n"
"        mkdir -p \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\"\n"
"        cp \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleExecutable -string \"$FULL_MODULE_NAME\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleIdentifier -string \"$FRAMEWORK_BUNDLE_ID\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"    fi\n"
"\n"
"    echo \"Installing binary for $FRAMEWORK_FOLDER/$FULL_MODULE_NAME\"\n"
"    mv \"$FULL_EXT\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/"
"$FULL_MODULE_NAME\"\n"
"    # Create a placeholder .fwork file where the .so was\n"
"    echo \"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME\" > ${FULL_EXT%.so}.fwork\n"
"    # Create a back reference to the .so file location in the framework\n"
"    echo \"${RELATIVE_EXT%.so}.fwork\" > \"$CODESIGNING_FOLDER_PATH/"
"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME.origin\"\n"
" }\n"
"\n"
" PYTHON_VER=$(ls -1 \"$CODESIGNING_FOLDER_PATH/python/lib\")\n"
" echo \"Install Python $PYTHON_VER standard library extension modules...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/python/lib/$PYTHON_VER/lib-dynload\" -name "
"\"*.so\" | while read FULL_EXT; do\n"
"    install_dylib python/lib/$PYTHON_VER/lib-dynload/ \"$FULL_EXT\"\n"
" done\n"
"\n"
" # Clean up dylib template\n"
" rm -f \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\"\n"
"\n"
" echo \"Signing frameworks as $EXPANDED_CODE_SIGN_IDENTITY_NAME "
"($EXPANDED_CODE_SIGN_IDENTITY)...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/Frameworks\" -name \"*.framework\" -exec /"
"usr/bin/codesign --force --sign \"$EXPANDED_CODE_SIGN_IDENTITY\" "
"${OTHER_CODE_SIGN_FLAGS:-} -o runtime --timestamp=none --preserve-"
"metadata=identifier,entitlements,flags --generate-entitlement-der \"{}\" \\;"
msgstr ""
"set -e\n"
"\n"
"install_dylib () {\n"
"    INSTALL_BASE=$1\n"
"    FULL_EXT=$2\n"
"\n"
"    # The name of the extension file\n"
"    EXT=$(basename \"$FULL_EXT\")\n"
"    # The location of the extension file, relative to the bundle\n"
"    RELATIVE_EXT=${FULL_EXT#$CODESIGNING_FOLDER_PATH/}\n"
"    # The path to the extension file, relative to the install base\n"
"    PYTHON_EXT=${RELATIVE_EXT/$INSTALL_BASE/}\n"
"    # The full dotted name of the extension module, constructed from the "
"file path.\n"
"    FULL_MODULE_NAME=$(echo $PYTHON_EXT | cut -d \".\" -f 1 | tr \"/\" \"."
"\");\n"
"    # A bundle identifier; not actually used, but required by Xcode "
"framework packaging\n"
"    FRAMEWORK_BUNDLE_ID=$(echo $PRODUCT_BUNDLE_IDENTIFIER.$FULL_MODULE_NAME "
"| tr \"_\" \"-\")\n"
"    # The name of the framework folder.\n"
"    FRAMEWORK_FOLDER=\"Frameworks/$FULL_MODULE_NAME.framework\"\n"
"\n"
"    # If the framework folder doesn't exist, create it.\n"
"    if [ ! -d \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\" ]; then\n"
"        echo \"Creating framework for $RELATIVE_EXT\"\n"
"        mkdir -p \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\"\n"
"        cp \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleExecutable -string \"$FULL_MODULE_NAME\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleIdentifier -string \"$FRAMEWORK_BUNDLE_ID\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"    fi\n"
"\n"
"    echo \"Installing binary for $FRAMEWORK_FOLDER/$FULL_MODULE_NAME\"\n"
"    mv \"$FULL_EXT\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/"
"$FULL_MODULE_NAME\"\n"
"    # Create a placeholder .fwork file where the .so was\n"
"    echo \"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME\" > ${FULL_EXT%.so}.fwork\n"
"    # Create a back reference to the .so file location in the framework\n"
"    echo \"${RELATIVE_EXT%.so}.fwork\" > \"$CODESIGNING_FOLDER_PATH/"
"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME.origin\"\n"
" }\n"
"\n"
" PYTHON_VER=$(ls -1 \"$CODESIGNING_FOLDER_PATH/python/lib\")\n"
" echo \"Install Python $PYTHON_VER standard library extension modules...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/python/lib/$PYTHON_VER/lib-dynload\" -name "
"\"*.so\" | while read FULL_EXT; do\n"
"    install_dylib python/lib/$PYTHON_VER/lib-dynload/ \"$FULL_EXT\"\n"
" done\n"
"\n"
" # Clean up dylib template\n"
" rm -f \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\"\n"
"\n"
" echo \"Signing frameworks as $EXPANDED_CODE_SIGN_IDENTITY_NAME "
"($EXPANDED_CODE_SIGN_IDENTITY)...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/Frameworks\" -name \"*.framework\" -exec /"
"usr/bin/codesign --force --sign \"$EXPANDED_CODE_SIGN_IDENTITY\" "
"${OTHER_CODE_SIGN_FLAGS:-} -o runtime --timestamp=none --preserve-"
"metadata=identifier,entitlements,flags --generate-entitlement-der \"{}\" \\;"

#: ../../using/ios.rst:292
msgid ""
"Add Objective C code to initialize and use a Python interpreter in embedded "
"mode. You should ensure that:"
msgstr ""
"Добавьте код Objective C для инициализации и использования интерпретатора "
"Python во встроенном режиме. Вы должны убедиться, что:"

#: ../../using/ios.rst:295
msgid ":c:member:`UTF-8 mode <PyPreConfig.utf8_mode>` is *enabled*;"
msgstr ":c:member:`Режим UTF-8 <PyPreConfig.utf8_mode>` *включен*;"

#: ../../using/ios.rst:296
msgid ":c:member:`Buffered stdio <PyConfig.buffered_stdio>` is *disabled*;"
msgstr ""
":c:member:`Буферизованное stdio <PyConfig.buffered_stdio>` *отключено*;"

#: ../../using/ios.rst:297
msgid ":c:member:`Writing bytecode <PyConfig.write_bytecode>` is *disabled*;"
msgstr ":c:member:`Запись байт-кода <PyConfig.write_bytecode>` *отключена*;"

#: ../../using/ios.rst:298
msgid ""
":c:member:`Signal handlers <PyConfig.install_signal_handlers>` are *enabled*;"
msgstr ""
":c:member:`Обработчики сигналов <PyConfig.install_signal_handlers>` "
"*включены*;"

#: ../../using/ios.rst:299
msgid ""
"``PYTHONHOME`` for the interpreter is configured to point at the ``python`` "
"subfolder of your app's bundle; and"
msgstr ""
"``PYTHONHOME`` для интерпретатора настроен так, чтобы указывать на подпапку "
"``python`` в комплекте вашего приложения; и"

#: ../../using/ios.rst:301
msgid "The ``PYTHONPATH`` for the interpreter includes:"
msgstr "``PYTHONPATH`` для интерпретатора включает в себя:"

#: ../../using/ios.rst:303
msgid "the ``python/lib/python3.X`` subfolder of your app's bundle,"
msgstr "подпапка ``python/lib/python3.X`` в комплекте вашего приложения,"

#: ../../using/ios.rst:304
msgid ""
"the ``python/lib/python3.X/lib-dynload`` subfolder of your app's bundle, and"
msgstr ""
"подпапка ``python/lib/python3.X/lib-dynload`` в комплекте вашего приложения и"

#: ../../using/ios.rst:305
msgid "the ``app`` subfolder of your app's bundle"
msgstr "подпапка ``app`` в пакете вашего приложения"

#: ../../using/ios.rst:307
msgid ""
"Your app's bundle location can be determined using ``[[NSBundle mainBundle] "
"resourcePath]``."
msgstr ""
"Местоположение пакета вашего приложения можно определить с помощью "
"``[[NSBundle mainBundle] resourcesPath]``."

#: ../../using/ios.rst:310
msgid ""
"Steps 8, 9 and 10 of these instructions assume that you have a single folder "
"of pure Python application code, named ``app``. If you have third-party "
"binary modules in your app, some additional steps will be required:"
msgstr ""
"Шаги 8, 9 и 10 этих инструкций предполагают, что у вас есть одна папка с "
"чистым кодом приложения Python с именем «app». Если в вашем приложении есть "
"сторонние бинарные модули, потребуются некоторые дополнительные действия:"

#: ../../using/ios.rst:314
msgid ""
"You need to ensure that any folders containing third-party binaries are "
"either associated with the app target, or copied in as part of step 8. Step "
"8 should also purge any binaries that are not appropriate for the platform a "
"specific build is targeting (i.e., delete any device binaries if you're "
"building an app targeting the simulator)."
msgstr ""
"Вам необходимо убедиться, что все папки, содержащие сторонние двоичные "
"файлы, либо связаны с целевым приложением, либо скопированы в рамках шага 8. "
"Шаг 8 также должен удалить все двоичные файлы, которые не подходят для "
"платформы, на которую нацелена конкретная сборка (т. е. , удалите все "
"двоичные файлы устройств, если вы создаете приложение, предназначенное для "
"симулятора)."

#: ../../using/ios.rst:320
msgid ""
"Any folders that contain third-party binaries must be processed into "
"framework form by step 9. The invocation of ``install_dylib`` that processes "
"the ``lib-dynload`` folder can be copied and adapted for this purpose."
msgstr ""
"Любые папки, содержащие сторонние двоичные файлы, должны быть преобразованы "
"в форму платформы на шаге 9. Вызов install_dylib, который обрабатывает папку "
"lib-dynload, можно скопировать и адаптировать для этой цели."

#: ../../using/ios.rst:324
msgid ""
"If you're using a separate folder for third-party packages, ensure that "
"folder is included as part of the ``PYTHONPATH`` configuration in step 10."
msgstr ""
"Если вы используете отдельную папку для сторонних пакетов, убедитесь, что "
"эта папка включена в конфигурацию PYTHONPATH на шаге 10."

#: ../../using/ios.rst:328
msgid "App Store Compliance"
msgstr "Соответствие магазинам приложений"

#: ../../using/ios.rst:330
msgid ""
"The only mechanism for distributing apps to third-party iOS devices is to "
"submit the app to the iOS App Store; apps submitted for distribution must "
"pass Apple's app review process. This process includes a set of automated "
"validation rules that inspect the submitted application bundle for "
"problematic code."
msgstr ""
"Единственный механизм распространения приложений на сторонние устройства iOS "
"— это размещение приложения в iOS App Store; приложения, представленные для "
"распространения, должны пройти процедуру проверки приложений Apple. Этот "
"процесс включает в себя набор автоматических правил проверки, которые "
"проверяют отправленный пакет приложения на наличие проблемного кода."

#: ../../using/ios.rst:335
msgid ""
"The Python standard library contains some code that is known to violate "
"these automated rules. While these violations appear to be false positives, "
"Apple's review rules cannot be challenged; so, it is necessary to modify the "
"Python standard library for an app to pass App Store review."
msgstr ""
"Стандартная библиотека Python содержит некоторый код, который, как известно, "
"нарушает эти автоматические правила. Хотя эти нарушения кажутся "
"ложноположительными, правила проверки Apple не могут быть оспорены; поэтому "
"необходимо изменить стандартную библиотеку Python, чтобы приложение прошло "
"проверку в App Store."

#: ../../using/ios.rst:340
msgid ""
"The Python source tree contains :source:`a patch file <Mac/Resources/app-"
"store-compliance.patch>` that will remove all code that is known to cause "
"issues with the App Store review process. This patch is applied "
"automatically when building for iOS."
msgstr ""
"Дерево исходного кода Python содержит :source:`файл исправления <Mac/"
"Resources/app-store-compliance.patch>`, который удалит весь код, который, "
"как известно, вызывает проблемы в процессе проверки App Store. Этот патч "
"применяется автоматически при сборке для iOS."
