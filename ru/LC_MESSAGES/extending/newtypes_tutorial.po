# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# alex alev <alex.alev@bk.ru>, 2021
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../extending/newtypes_tutorial.rst:7
msgid "Defining Extension Types: Tutorial"
msgstr "Определение типов расширений: Учебное пособие"

#: ../../extending/newtypes_tutorial.rst:14
msgid ""
"Python allows the writer of a C extension module to define new types that "
"can be manipulated from Python code, much like the built-in :class:`str` "
"and :class:`list` types.  The code for all extension types follows a "
"pattern, but there are some details that you need to understand before you "
"can get started.  This document is a gentle introduction to the topic."
msgstr ""
"Python позволяет разработчику модуля расширения C определять новые типы, "
"которыми можно манипулировать из кода Python, во многом подобно встроенным "
"типам :class:`str` и :class:`list`. Код для всех типов расширений "
"соответствует шаблону, но есть некоторые детали, которые вам необходимо "
"понять, прежде чем приступить к работе. Этот документ представляет собой "
"краткое введение в тему."

#: ../../extending/newtypes_tutorial.rst:24
msgid "The Basics"
msgstr "Основы"

#: ../../extending/newtypes_tutorial.rst:26
msgid ""
"The :term:`CPython` runtime sees all Python objects as variables of type :c:"
"expr:`PyObject*`, which serves as a \"base type\" for all Python objects. "
"The :c:type:`PyObject` structure itself only contains the object's :term:"
"`reference count` and a pointer to the object's \"type object\". This is "
"where the action is; the type object determines which (C) functions get "
"called by the interpreter when, for instance, an attribute gets looked up on "
"an object, a method called, or it is multiplied by another object.  These C "
"functions are called \"type methods\"."
msgstr ""
"Среда выполнения :term:`CPython` рассматривает все объекты Python как "
"переменные типа :c:expr:`PyObject*`, который служит «базовым типом» для всех "
"объектов Python. Сама структура :c:type:`PyObject` содержит только :term:"
"`счётчик ссылок` объекта и указатель на «тип объекта». Вот где действие; "
"объект типа определяет, какие функции (C) вызываются интерпретатором, когда, "
"например, атрибут ищется в объекте, вызывается метод или он умножается на "
"другой объект. Эти функции C называются «методами типов»."

#: ../../extending/newtypes_tutorial.rst:35
msgid ""
"So, if you want to define a new extension type, you need to create a new "
"type object."
msgstr ""
"Итак, если вы хотите определить новый тип расширения, вам необходимо создать "
"объект нового типа."

#: ../../extending/newtypes_tutorial.rst:38
msgid ""
"This sort of thing can only be explained by example, so here's a minimal, "
"but complete, module that defines a new type named :class:`!Custom` inside a "
"C extension module :mod:`!custom`:"
msgstr ""
"Подобные вещи можно объяснить только на примере, поэтому вот минимальный, но "
"полный модуль, который определяет новый тип с именем :class:`!Custom` внутри "
"модуля расширения C :mod:`!custom`:"

#: ../../extending/newtypes_tutorial.rst:43
msgid ""
"What we're showing here is the traditional way of defining *static* "
"extension types.  It should be adequate for most uses.  The C API also "
"allows defining heap-allocated extension types using the :c:func:"
"`PyType_FromSpec` function, which isn't covered in this tutorial."
msgstr ""
"Здесь мы показываем традиционный способ определения *статических* типов "
"расширений. Этого должно быть достаточно для большинства применений. API C "
"также позволяет определять типы расширений, выделяемые в куче, с помощью "
"функции :c:func:`PyType_FromSpec`, которая не рассматривается в этом "
"руководстве."

#: ../../extending/newtypes_tutorial.rst:48
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    /* Type-specific fields go here. */\n"
"} CustomObject;\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    /* Type-specific fields go here. */\n"
"} CustomObject;\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"

#: ../../extending/newtypes_tutorial.rst:50
msgid ""
"Now that's quite a bit to take in at once, but hopefully bits will seem "
"familiar from the previous chapter.  This file defines three things:"
msgstr ""
"Это довольно много, что нужно усвоить сразу, но, надеюсь, некоторые моменты "
"покажутся вам знакомыми из предыдущей главы. Этот файл определяет три вещи:"

#: ../../extending/newtypes_tutorial.rst:53
msgid ""
"What a :class:`!Custom` **object** contains: this is the ``CustomObject`` "
"struct, which is allocated once for each :class:`!Custom` instance."
msgstr ""
"Что содержит :class:`!Custom` **объект**: это структура ``CustomObject``, "
"которая выделяется один раз для каждого экземпляра :class:`!Custom`."

#: ../../extending/newtypes_tutorial.rst:55
msgid ""
"How the :class:`!Custom` **type** behaves: this is the ``CustomType`` "
"struct, which defines a set of flags and function pointers that the "
"interpreter inspects when specific operations are requested."
msgstr ""
"Как ведет себя :class:`!Custom` **type**: это структура ``CustomType``, "
"которая определяет набор флагов и указателей на функции, которые "
"интерпретатор проверяет при запросе определенных операций."

#: ../../extending/newtypes_tutorial.rst:58
msgid ""
"How to initialize the :mod:`!custom` module: this is the ``PyInit_custom`` "
"function and the associated ``custommodule`` struct."
msgstr ""
"Как инициализировать модуль :mod:`!custom`: это функция ``PyInit_custom`` и "
"связанная с ней структура ``custommodule``."

#: ../../extending/newtypes_tutorial.rst:61
msgid "The first bit is::"
msgstr "Первый бит::"

#: ../../extending/newtypes_tutorial.rst:63
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} CustomObject;"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} CustomObject;"

#: ../../extending/newtypes_tutorial.rst:67
msgid ""
"This is what a Custom object will contain.  ``PyObject_HEAD`` is mandatory "
"at the start of each object struct and defines a field called ``ob_base`` of "
"type :c:type:`PyObject`, containing a pointer to a type object and a "
"reference count (these can be accessed using the macros :c:macro:`Py_TYPE` "
"and :c:macro:`Py_REFCNT` respectively).  The reason for the macro is to "
"abstract away the layout and to enable additional fields in :ref:`debug "
"builds <debug-build>`."
msgstr ""
"Это то, что будет содержать пользовательский объект. ``PyObject_HEAD`` "
"является обязательным в начале каждой структуры объекта и определяет поле "
"``ob_base`` типа :c:type:`PyObject`, содержащее указатель на объект типа и "
"счетчик ссылок (они могут быть доступ осуществляется с помощью макросов :c:"
"macro:`Py_TYPE` и :c:macro:`Py_REFCNT` соответственно). Целью использования "
"макроса является абстрагирование макета и включение дополнительных полей в :"
"ref:`debug builds <debug-build>`."

#: ../../extending/newtypes_tutorial.rst:76
msgid ""
"There is no semicolon above after the :c:macro:`PyObject_HEAD` macro. Be "
"wary of adding one by accident: some compilers will complain."
msgstr ""
"Точка с запятой выше после макроса :c:macro:`PyObject_HEAD` отсутствует. "
"Будьте осторожны, добавляя его случайно: некоторые компиляторы будут "
"жаловаться."

#: ../../extending/newtypes_tutorial.rst:79
msgid ""
"Of course, objects generally store additional data besides the standard "
"``PyObject_HEAD`` boilerplate; for example, here is the definition for "
"standard Python floats::"
msgstr ""
"Конечно, объекты обычно хранят дополнительные данные помимо стандартного "
"шаблона PyObject_HEAD; например, вот определение стандартных чисел с "
"плавающей точкой Python:"

#: ../../extending/newtypes_tutorial.rst:83
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    double ob_fval;\n"
"} PyFloatObject;"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    double ob_fval;\n"
"} PyFloatObject;"

#: ../../extending/newtypes_tutorial.rst:88
msgid "The second bit is the definition of the type object. ::"
msgstr "Второй бит — это определение типа объекта. ::"

#: ../../extending/newtypes_tutorial.rst:90
msgid ""
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};"
msgstr ""
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};"

#: ../../extending/newtypes_tutorial.rst:101
msgid ""
"We recommend using C99-style designated initializers as above, to avoid "
"listing all the :c:type:`PyTypeObject` fields that you don't care about and "
"also to avoid caring about the fields' declaration order."
msgstr ""
"Мы рекомендуем использовать назначенные инициализаторы в стиле C99, как "
"указано выше, чтобы не перечислять все поля :c:type:`PyTypeObject`, которые "
"вам не нужны, а также чтобы не заботиться о порядке объявления полей."

#: ../../extending/newtypes_tutorial.rst:105
msgid ""
"The actual definition of :c:type:`PyTypeObject` in :file:`object.h` has many "
"more :ref:`fields <type-structs>` than the definition above.  The remaining "
"fields will be filled with zeros by the C compiler, and it's common practice "
"to not specify them explicitly unless you need them."
msgstr ""
"Фактическое определение :c:type:`PyTypeObject` в :file:`object.h` имеет "
"гораздо больше :ref:`полей <type-structs>`, чем определение выше. Остальные "
"поля будут заполнены нулями компилятором C, и общепринятой практикой "
"является не указывать их явно, если они вам не нужны."

#: ../../extending/newtypes_tutorial.rst:110
msgid "We're going to pick it apart, one field at a time::"
msgstr "Мы собираемся разобрать его по одному полю за раз::"

#: ../../extending/newtypes_tutorial.rst:112
msgid ".ob_base = PyVarObject_HEAD_INIT(NULL, 0)"
msgstr ".ob_base = PyVarObject_HEAD_INIT(NULL, 0)"

#: ../../extending/newtypes_tutorial.rst:114
msgid ""
"This line is mandatory boilerplate to initialize the ``ob_base`` field "
"mentioned above. ::"
msgstr ""
"Эта строка является обязательным шаблоном для инициализации поля ob_base, "
"упомянутого выше. ::"

#: ../../extending/newtypes_tutorial.rst:117
msgid ".tp_name = \"custom.Custom\","
msgstr ".tp_name = \"custom.Custom\","

#: ../../extending/newtypes_tutorial.rst:119
msgid ""
"The name of our type.  This will appear in the default textual "
"representation of our objects and in some error messages, for example:"
msgstr ""
"Название нашего типа. Это будет отображаться в текстовом представлении наших "
"объектов по умолчанию и в некоторых сообщениях об ошибках, например:"

#: ../../extending/newtypes_tutorial.rst:122
msgid ""
">>> \"\" + custom.Custom()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: can only concatenate str (not \"custom.Custom\") to str"
msgstr ""
">>> \"\" + custom.Custom()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: can only concatenate str (not \"custom.Custom\") to str"

#: ../../extending/newtypes_tutorial.rst:129
msgid ""
"Note that the name is a dotted name that includes both the module name and "
"the name of the type within the module. The module in this case is :mod:`!"
"custom` and the type is :class:`!Custom`, so we set the type name to :class:"
"`!custom.Custom`. Using the real dotted import path is important to make "
"your type compatible with the :mod:`pydoc` and :mod:`pickle` modules. ::"
msgstr ""
"Обратите внимание, что имя представляет собой имя, разделенное точками, "
"которое включает в себя как имя модуля, так и имя типа внутри модуля. В "
"данном случае модуль — :mod:`!custom`, а тип — :class:`!Custom`, поэтому мы "
"устанавливаем имя типа :class:`!custom.Custom`. Использование реального пути "
"импорта, разделенного точками, важно для обеспечения совместимости вашего "
"типа с модулями :mod:`pydoc` и :mod:`pickle`. ::"

#: ../../extending/newtypes_tutorial.rst:135
msgid ""
".tp_basicsize = sizeof(CustomObject),\n"
".tp_itemsize = 0,"
msgstr ""
".tp_basicsize = sizeof(CustomObject),\n"
".tp_itemsize = 0,"

#: ../../extending/newtypes_tutorial.rst:138
msgid ""
"This is so that Python knows how much memory to allocate when creating new :"
"class:`!Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is only "
"used for variable-sized objects and should otherwise be zero."
msgstr ""
"Это сделано для того, чтобы Python знал, сколько памяти следует выделить при "
"создании новых экземпляров :class:`!Custom`. :c:member:`~PyTypeObject."
"tp_itemsize` используется только для объектов переменного размера и в "
"противном случае должен быть равен нулю."

#: ../../extending/newtypes_tutorial.rst:144
msgid ""
"If you want your type to be subclassable from Python, and your type has the "
"same :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have "
"problems with multiple inheritance.  A Python subclass of your type will "
"have to list your type first in its :attr:`~type.__bases__`, or else it will "
"not be able to call your type's :meth:`~object.__new__` method without "
"getting an error.  You can avoid this problem by ensuring that your type has "
"a larger value for :c:member:`~PyTypeObject.tp_basicsize` than its base type "
"does.  Most of the time, this will be true anyway, because either your base "
"type will be :class:`object`, or else you will be adding data members to "
"your base type, and therefore increasing its size."
msgstr ""
"Если вы хотите, чтобы ваш тип был подклассом Python, и ваш тип имеет тот же :"
"c:member:`~PyTypeObject.tp_basicsize`, что и его базовый тип, у вас могут "
"возникнуть проблемы с множественным наследованием. Подкласс Python вашего "
"типа должен будет сначала указать ваш тип в своем :attr:`~type.__bases__`, "
"иначе он не сможет вызвать метод :meth:`~object.__new__` вашего типа без "
"получения ошибки. . Вы можете избежать этой проблемы, гарантируя, что ваш "
"тип имеет большее значение для :c:member:`~PyTypeObject.tp_basicsize`, чем "
"его базовый тип. В большинстве случаев это будет верно в любом случае, "
"потому что либо вашим базовым типом будет :class:`object`, либо вы будете "
"добавлять элементы данных к своему базовому типу и, следовательно, "
"увеличивать его размер."

#: ../../extending/newtypes_tutorial.rst:154
msgid "We set the class flags to :c:macro:`Py_TPFLAGS_DEFAULT`. ::"
msgstr "Мы устанавливаем флаги класса :c:macro:`Py_TPFLAGS_DEFAULT`. ::"

#: ../../extending/newtypes_tutorial.rst:156
msgid ".tp_flags = Py_TPFLAGS_DEFAULT,"
msgstr ".tp_flags = Py_TPFLAGS_DEFAULT,"

#: ../../extending/newtypes_tutorial.rst:158
msgid ""
"All types should include this constant in their flags.  It enables all of "
"the members defined until at least Python 3.3.  If you need further members, "
"you will need to OR the corresponding flags."
msgstr ""
"Все типы должны включать эту константу в свои флаги. Он включает все члены, "
"определенные как минимум до версии Python 3.3. Если вам нужны дополнительные "
"члены, вам нужно будет ИЛИ соответствующие флаги."

#: ../../extending/newtypes_tutorial.rst:162
msgid ""
"We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`. ::"
msgstr ""
"Мы предоставляем строку документа для типа в :c:member:`~PyTypeObject."
"tp_doc`. ::"

#: ../../extending/newtypes_tutorial.rst:164
msgid ".tp_doc = PyDoc_STR(\"Custom objects\"),"
msgstr ".tp_doc = PyDoc_STR(\"Custom objects\"),"

#: ../../extending/newtypes_tutorial.rst:166
msgid ""
"To enable object creation, we have to provide a :c:member:`~PyTypeObject."
"tp_new` handler.  This is the equivalent of the Python method :meth:`~object."
"__new__`, but has to be specified explicitly.  In this case, we can just use "
"the default implementation provided by the API function :c:func:"
"`PyType_GenericNew`. ::"
msgstr ""
"Чтобы включить создание объекта, мы должны предоставить обработчик :c:member:"
"`~PyTypeObject.tp_new`. Это эквивалент метода Python :meth:`~object."
"__new__`, но его необходимо указать явно. В этом случае мы можем просто "
"использовать реализацию по умолчанию, предоставляемую функцией API :c:func:"
"`PyType_GenericNew`. ::"

#: ../../extending/newtypes_tutorial.rst:171
msgid ".tp_new = PyType_GenericNew,"
msgstr ".tp_new = PyType_GenericNew,"

#: ../../extending/newtypes_tutorial.rst:173
msgid ""
"Everything else in the file should be familiar, except for some code in :c:"
"func:`!PyInit_custom`::"
msgstr ""
"Все остальное в файле должно быть вам знакомо, за исключением некоторого "
"кода в :c:func:`!PyInit_custom`::"

#: ../../extending/newtypes_tutorial.rst:176
msgid ""
"if (PyType_Ready(&CustomType) < 0)\n"
"    return;"
msgstr ""
"if (PyType_Ready(&CustomType) < 0)\n"
"    return;"

#: ../../extending/newtypes_tutorial.rst:179
msgid ""
"This initializes the :class:`!Custom` type, filling in a number of members "
"to the appropriate default values, including :c:member:`~PyObject.ob_type` "
"that we initially set to ``NULL``. ::"
msgstr ""
"Это инициализирует тип :class:`!Custom`, заполняя ряд членов "
"соответствующими значениями по умолчанию, включая :c:member:`~PyObject."
"ob_type`, для которого мы изначально установили значение ``NULL``. ::"

#: ../../extending/newtypes_tutorial.rst:183
msgid ""
"if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\n"
"    Py_DECREF(m);\n"
"    return NULL;\n"
"}"
msgstr ""
"if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\n"
"    Py_DECREF(m);\n"
"    return NULL;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:188
msgid ""
"This adds the type to the module dictionary.  This allows us to create :"
"class:`!Custom` instances by calling the :class:`!Custom` class:"
msgstr ""
"Это добавит тип в словарь модуля. Это позволяет нам создавать экземпляры :"
"class:`!Custom`, вызывая класс :class:`!Custom`:"

#: ../../extending/newtypes_tutorial.rst:191
msgid ""
">>> import custom\n"
">>> mycustom = custom.Custom()"
msgstr ""
">>> import custom\n"
">>> mycustom = custom.Custom()"

#: ../../extending/newtypes_tutorial.rst:196
msgid ""
"That's it!  All that remains is to build it; put the above code in a file "
"called :file:`custom.c`,"
msgstr ""
"Вот и все! Остается только построить его; поместите приведенный выше код в "
"файл с именем :file:`custom.c`,"

#: ../../extending/newtypes_tutorial.rst:199
msgid ""
"[build-system]\n"
"requires = [\"setuptools\"]\n"
"build-backend = \"setuptools.build_meta\"\n"
"\n"
"[project]\n"
"name = \"custom\"\n"
"version = \"1\"\n"
msgstr ""
"[build-system]\n"
"requires = [\"setuptools\"]\n"
"build-backend = \"setuptools.build_meta\"\n"
"\n"
"[project]\n"
"name = \"custom\"\n"
"version = \"1\"\n"

#: ../../extending/newtypes_tutorial.rst:201
msgid "in a file called :file:`pyproject.toml`, and"
msgstr "в файле с именем :file:`pyproject.toml` и"

#: ../../extending/newtypes_tutorial.rst:203
msgid ""
"from setuptools import Extension, setup\n"
"setup(ext_modules=[Extension(\"custom\", [\"custom.c\"])])"
msgstr ""
"from setuptools import Extension, setup\n"
"setup(ext_modules=[Extension(\"custom\", [\"custom.c\"])])"

#: ../../extending/newtypes_tutorial.rst:208
msgid "in a file called :file:`setup.py`; then typing"
msgstr "в файле с именем :file:`setup.py`; затем набираю"

#: ../../extending/newtypes_tutorial.rst:210
#: ../../extending/newtypes_tutorial.rst:525
msgid "$ python -m pip install ."
msgstr "$ python -m pip install ."

#: ../../extending/newtypes_tutorial.rst:214
msgid ""
"in a shell should produce a file :file:`custom.so` in a subdirectory and "
"install it; now fire up Python --- you should be able to ``import custom`` "
"and play around with ``Custom`` objects."
msgstr ""
"в оболочке следует создать файл :file:`custom.so` в подкаталоге и установить "
"его; теперь запустите Python --- вы сможете ``импортировать "
"пользовательские`` и экспериментировать с ``Пользовательскими`` объектами."

#: ../../extending/newtypes_tutorial.rst:218
msgid "That wasn't so hard, was it?"
msgstr "Это было не так уж сложно, не так ли?"

#: ../../extending/newtypes_tutorial.rst:220
msgid ""
"Of course, the current Custom type is pretty uninteresting. It has no data "
"and doesn't do anything. It can't even be subclassed."
msgstr ""
"Конечно, нынешний тип Custom довольно неинтересен. Он не имеет данных и "
"ничего не делает. Его даже нельзя разделить на подклассы."

#: ../../extending/newtypes_tutorial.rst:225
msgid "Adding data and methods to the Basic example"
msgstr "Добавление данных и методов в пример Basic"

#: ../../extending/newtypes_tutorial.rst:227
msgid ""
"Let's extend the basic example to add some data and methods.  Let's also "
"make the type usable as a base class. We'll create a new module, :mod:`!"
"custom2` that adds these capabilities:"
msgstr ""
"Давайте расширим базовый пример, добавив некоторые данные и методы. Давайте "
"также сделаем этот тип пригодным для использования в качестве базового "
"класса. Мы создадим новый модуль :mod:`!custom2`, который добавит следующие "
"возможности:"

#: ../../extending/newtypes_tutorial.rst:231
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_XSETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_XSETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"first name\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"last name\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        return NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        return NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom2.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = (initproc) Custom_init,\n"
"    .tp_dealloc = (destructor) Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base =PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom2\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom2(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_XSETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_XSETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"first name\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"last name\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        return NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        return NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom2.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = (initproc) Custom_init,\n"
"    .tp_dealloc = (destructor) Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base =PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom2\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom2(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"

#: ../../extending/newtypes_tutorial.rst:234
msgid "This version of the module has a number of changes."
msgstr "В этой версии модуля имеется ряд изменений."

#: ../../extending/newtypes_tutorial.rst:236
msgid ""
"The  :class:`!Custom` type now has three data attributes in its C struct, "
"*first*, *last*, and *number*.  The *first* and *last* variables are Python "
"strings containing first and last names.  The *number* attribute is a C "
"integer."
msgstr ""
"Тип :class:`!Custom` теперь имеет три атрибута данных в своей структуре C: "
"*first*, *last* и *number*. Переменные *first* и *last* представляют собой "
"строки Python, содержащие имя и фамилию. Атрибут *number* представляет собой "
"целое число C."

#: ../../extending/newtypes_tutorial.rst:240
msgid "The object structure is updated accordingly::"
msgstr "Структура объекта обновляется соответствующим образом:"

#: ../../extending/newtypes_tutorial.rst:242
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;"

#: ../../extending/newtypes_tutorial.rst:249
msgid ""
"Because we now have data to manage, we have to be more careful about object "
"allocation and deallocation.  At a minimum, we need a deallocation method::"
msgstr ""
"Поскольку теперь у нас есть данные, которыми нужно управлять, нам следует "
"быть более осторожными при распределении и освобождении объектов. Как "
"минимум, нам нужен метод освобождения::"

#: ../../extending/newtypes_tutorial.rst:252
msgid ""
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}"
msgstr ""
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}"

#: ../../extending/newtypes_tutorial.rst:260
msgid "which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::"
msgstr "который назначен члену :c:member:`~PyTypeObject.tp_dealloc`::"

#: ../../extending/newtypes_tutorial.rst:262
msgid ".tp_dealloc = (destructor) Custom_dealloc,"
msgstr ".tp_dealloc = (destructor) Custom_dealloc,"

#: ../../extending/newtypes_tutorial.rst:264
msgid ""
"This method first clears the reference counts of the two Python attributes. :"
"c:func:`Py_XDECREF` correctly handles the case where its argument is "
"``NULL`` (which might happen here if ``tp_new`` failed midway).  It then "
"calls the :c:member:`~PyTypeObject.tp_free` member of the object's type "
"(computed by ``Py_TYPE(self)``) to free the object's memory.  Note that the "
"object's type might not be :class:`!CustomType`, because the object may be "
"an instance of a subclass."
msgstr ""
"Этот метод сначала очищает счетчики ссылок двух атрибутов Python. :c:func:"
"`Py_XDECREF` правильно обрабатывает случай, когда его аргумент равен "
"``NULL`` (что может произойти здесь, если ``tp_new`` не удалось выполнить на "
"полпути). Затем он вызывает член :c:member:`~PyTypeObject.tp_free` типа "
"объекта (вычисленный ``Py_TYPE(self)``), чтобы освободить память объекта. "
"Обратите внимание, что тип объекта может отличаться от :class:`!CustomType`, "
"поскольку объект может быть экземпляром подкласса."

#: ../../extending/newtypes_tutorial.rst:273
msgid ""
"The explicit cast to ``destructor`` above is needed because we defined "
"``Custom_dealloc`` to take a ``CustomObject *`` argument, but the "
"``tp_dealloc`` function pointer expects to receive a ``PyObject *`` "
"argument.  Otherwise, the compiler will emit a warning.  This is object-"
"oriented polymorphism, in C!"
msgstr ""
"Явное приведение к ``destructor``, указанное выше, необходимо, поскольку мы "
"определили ``Custom_dealloc`` для приема аргумента ``CustomObject *``, но "
"указатель функции ``tp_dealloc`` ожидает получения ``PyObject *`` аргумент. "
"В противном случае компилятор выдаст предупреждение. Это объектно-"
"ориентированный полиморфизм в C!"

#: ../../extending/newtypes_tutorial.rst:279
msgid ""
"We want to make sure that the first and last names are initialized to empty "
"strings, so we provide a ``tp_new`` implementation::"
msgstr ""
"Мы хотим быть уверены, что имя и фамилия инициализируются пустыми строками, "
"поэтому мы предоставляем реализацию ``tp_new``::"

#: ../../extending/newtypes_tutorial.rst:282
msgid ""
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}"
msgstr ""
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:303
msgid "and install it in the :c:member:`~PyTypeObject.tp_new` member::"
msgstr "и установите его в элементе :c:member:`~PyTypeObject.tp_new`::"

#: ../../extending/newtypes_tutorial.rst:305
msgid ".tp_new = Custom_new,"
msgstr ".tp_new = Custom_new,"

#: ../../extending/newtypes_tutorial.rst:307
msgid ""
"The ``tp_new`` handler is responsible for creating (as opposed to "
"initializing) objects of the type.  It is exposed in Python as the :meth:"
"`~object.__new__` method. It is not required to define a ``tp_new`` member, "
"and indeed many extension types will simply reuse :c:func:"
"`PyType_GenericNew` as done in the first version of the :class:`!Custom` "
"type above.  In this case, we use the ``tp_new`` handler to initialize the "
"``first`` and ``last`` attributes to non-``NULL`` default values."
msgstr ""
"Обработчик tp_new отвечает за создание (в отличие от инициализации) объектов "
"этого типа. В Python он представлен как метод :meth:`~object.__new__`. Не "
"требуется определять член ``tp_new``, и действительно, многие типы "
"расширений будут просто повторно использовать :c:func:`PyType_GenericNew`, "
"как это было сделано в первой версии типа :class:`!Custom` выше. В этом "
"случае мы используем обработчик tp_new для инициализации атрибутов first и "
"Last со значениями по умолчанию, отличными от NULL."

#: ../../extending/newtypes_tutorial.rst:315
msgid ""
"``tp_new`` is passed the type being instantiated (not necessarily "
"``CustomType``, if a subclass is instantiated) and any arguments passed when "
"the type was called, and is expected to return the instance created.  "
"``tp_new`` handlers always accept positional and keyword arguments, but they "
"often ignore the arguments, leaving the argument handling to initializer (a."
"k.a. ``tp_init`` in C or ``__init__`` in Python) methods."
msgstr ""
"``tp_new`` передается тип, экземпляр которого создается (не обязательно "
"CustomType, если создается экземпляр подкласса) и все аргументы, "
"передаваемые при вызове типа, и ожидается, что он вернет созданный "
"экземпляр. Обработчики ``tp_new`` всегда принимают позиционные и ключевые "
"аргументы, но они часто игнорируют аргументы, оставляя обработку аргументов "
"методам инициализатора (также известного как ``tp_init`` в C или "
"``__init__`` в Python)."

#: ../../extending/newtypes_tutorial.rst:323
msgid ""
"``tp_new`` shouldn't call ``tp_init`` explicitly, as the interpreter will do "
"it itself."
msgstr ""
"``tp_new`` не должен вызывать ``tp_init`` явно, поскольку интерпретатор "
"сделает это сам."

#: ../../extending/newtypes_tutorial.rst:326
msgid ""
"The ``tp_new`` implementation calls the :c:member:`~PyTypeObject.tp_alloc` "
"slot to allocate memory::"
msgstr ""
"Реализация tp_new вызывает слот :c:member:`~PyTypeObject.tp_alloc` для "
"выделения памяти:"

#: ../../extending/newtypes_tutorial.rst:329
msgid "self = (CustomObject *) type->tp_alloc(type, 0);"
msgstr "self = (CustomObject *) type->tp_alloc(type, 0);"

#: ../../extending/newtypes_tutorial.rst:331
msgid ""
"Since memory allocation may fail, we must check the :c:member:`~PyTypeObject."
"tp_alloc` result against ``NULL`` before proceeding."
msgstr ""
"Поскольку выделение памяти может оказаться неудачным, мы должны проверить "
"результат :c:member:`~PyTypeObject.tp_alloc` на соответствие ``NULL``, "
"прежде чем продолжить."

#: ../../extending/newtypes_tutorial.rst:335
msgid ""
"We didn't fill the :c:member:`~PyTypeObject.tp_alloc` slot ourselves. "
"Rather :c:func:`PyType_Ready` fills it for us by inheriting it from our base "
"class, which is :class:`object` by default.  Most types use the default "
"allocation strategy."
msgstr ""
"Мы не заполняли слот :c:member:`~PyTypeObject.tp_alloc` самостоятельно. "
"Скорее :c:func:`PyType_Ready` заполняет его за нас, наследуя от нашего "
"базового класса, которым по умолчанию является :class:`object`. Большинство "
"типов используют стратегию распределения по умолчанию."

#: ../../extending/newtypes_tutorial.rst:341
msgid ""
"If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one "
"that calls a base type's :c:member:`~PyTypeObject.tp_new` or :meth:`~object."
"__new__`), you must *not* try to determine what method to call using method "
"resolution order at runtime.  Always statically determine what type you are "
"going to call, and call its :c:member:`~PyTypeObject.tp_new` directly, or "
"via ``type->tp_base->tp_new``.  If you do not do this, Python subclasses of "
"your type that also inherit from other Python-defined classes may not work "
"correctly. (Specifically, you may not be able to create instances of such "
"subclasses without getting a :exc:`TypeError`.)"
msgstr ""
"Если вы создаете кооператив :c:member:`~PyTypeObject.tp_new` (который "
"вызывает :c:member:`~PyTypeObject.tp_new` или :meth:`~object.__new__` "
"базового типа), вы *не* должен пытаться определить, какой метод вызывать, "
"используя порядок разрешения методов во время выполнения. Всегда статически "
"определяйте, какой тип вы собираетесь вызывать, и вызывайте его :c:member:"
"`~PyTypeObject.tp_new` напрямую или через ``type->tp_base->tp_new``. Если вы "
"этого не сделаете, подклассы Python вашего типа, которые также наследуются "
"от других классов, определенных Python, могут работать неправильно. (В "
"частности, вы не сможете создавать экземпляры таких подклассов без "
"получения :exc:`TypeError`.)"

#: ../../extending/newtypes_tutorial.rst:351
msgid ""
"We also define an initialization function which accepts arguments to provide "
"initial values for our instance::"
msgstr ""
"Мы также определяем функцию инициализации, которая принимает аргументы для "
"предоставления начальных значений для нашего экземпляра:"

#: ../../extending/newtypes_tutorial.rst:354
msgid ""
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        tmp = self->first;\n"
"        Py_INCREF(first);\n"
"        self->first = first;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    if (last) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(last);\n"
"        self->last = last;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        tmp = self->first;\n"
"        Py_INCREF(first);\n"
"        self->first = first;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    if (last) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(last);\n"
"        self->last = last;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:380
msgid "by filling the :c:member:`~PyTypeObject.tp_init` slot. ::"
msgstr "заполнив слот :c:member:`~PyTypeObject.tp_init`. ::"

#: ../../extending/newtypes_tutorial.rst:382
msgid ".tp_init = (initproc) Custom_init,"
msgstr ".tp_init = (initproc) Custom_init,"

#: ../../extending/newtypes_tutorial.rst:384
msgid ""
"The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the :meth:"
"`~object.__init__` method.  It is used to initialize an object after it's "
"created.  Initializers always accept positional and keyword arguments, and "
"they should return either ``0`` on success or ``-1`` on error."
msgstr ""
"Слот :c:member:`~PyTypeObject.tp_init` представлен в Python как метод :meth:"
"`~object.__init__`. Он используется для инициализации объекта после его "
"создания. Инициализаторы всегда принимают позиционные и ключевые аргументы и "
"должны возвращать либо «0» в случае успеха, либо «-1» в случае ошибки."

#: ../../extending/newtypes_tutorial.rst:389
msgid ""
"Unlike the ``tp_new`` handler, there is no guarantee that ``tp_init`` is "
"called at all (for example, the :mod:`pickle` module by default doesn't "
"call :meth:`~object.__init__` on unpickled instances).  It can also be "
"called multiple times.  Anyone can call the :meth:`!__init__` method on our "
"objects.  For this reason, we have to be extra careful when assigning the "
"new attribute values.  We might be tempted, for example to assign the "
"``first`` member like this::"
msgstr ""
"В отличие от обработчика tp_new, нет никакой гарантии, что tp_init вообще "
"будет вызван (например, модуль :mod:`pickle` по умолчанию не вызывает :meth:"
"`~object.__init__` на немаринованных экземплярах). Его также можно вызывать "
"несколько раз. Любой может вызвать метод :meth:`!__init__` для наших "
"объектов. По этой причине мы должны быть особенно осторожны при назначении "
"новых значений атрибутов. У нас может возникнуть соблазн, например, "
"назначить ``первый`` член следующим образом:"

#: ../../extending/newtypes_tutorial.rst:397
msgid ""
"if (first) {\n"
"    Py_XDECREF(self->first);\n"
"    Py_INCREF(first);\n"
"    self->first = first;\n"
"}"
msgstr ""
"if (first) {\n"
"    Py_XDECREF(self->first);\n"
"    Py_INCREF(first);\n"
"    self->first = first;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:403
msgid ""
"But this would be risky.  Our type doesn't restrict the type of the "
"``first`` member, so it could be any kind of object.  It could have a "
"destructor that causes code to be executed that tries to access the "
"``first`` member; or that destructor could release the :term:`Global "
"interpreter Lock <GIL>` and let arbitrary code run in other threads that "
"accesses and modifies our object."
msgstr ""
"Но это было бы рискованно. Наш тип не ограничивает тип «первого» члена, "
"поэтому это может быть объект любого типа. Он может иметь деструктор, "
"вызывающий выполнение кода, пытающегося получить доступ к «первому» члену; "
"или этот деструктор может освободить :term:`Глобальную блокировку "
"интерпретатора <GIL>` и позволить произвольному коду выполняться в других "
"потоках, которые обращаются к нашему объекту и изменяют его."

#: ../../extending/newtypes_tutorial.rst:410
msgid ""
"To be paranoid and protect ourselves against this possibility, we almost "
"always reassign members before decrementing their reference counts.  When "
"don't we have to do this?"
msgstr ""
"Чтобы быть параноиками и защитить себя от такой возможности, мы почти всегда "
"переназначаем членов перед уменьшением их счетчика ссылок. Когда нам не "
"нужно это делать?"

#: ../../extending/newtypes_tutorial.rst:414
msgid "when we absolutely know that the reference count is greater than 1;"
msgstr "когда мы абсолютно знаем, что счетчик ссылок больше 1;"

#: ../../extending/newtypes_tutorial.rst:416
msgid ""
"when we know that deallocation of the object [#]_ will neither release the :"
"term:`GIL` nor cause any calls back into our type's code;"
msgstr ""
"когда мы знаем, что освобождение объекта [#]_ не будет ни освобождать :term:"
"`GIL`, ни вызывать какие-либо обратные вызовы в код нашего типа;"

#: ../../extending/newtypes_tutorial.rst:419
msgid ""
"when decrementing a reference count in a :c:member:`~PyTypeObject."
"tp_dealloc` handler on a type which doesn't support cyclic garbage "
"collection [#]_."
msgstr ""
"при уменьшении счетчика ссылок в обработчике :c:member:`~PyTypeObject."
"tp_dealloc` для типа, который не поддерживает циклическую сборку мусора "
"[#]_ ."

#: ../../extending/newtypes_tutorial.rst:422
msgid ""
"We want to expose our instance variables as attributes. There are a number "
"of ways to do that. The simplest way is to define member definitions::"
msgstr ""
"Мы хотим представить переменные экземпляра как атрибуты. Есть несколько "
"способов сделать это. Самый простой способ — определить определения членов:"

#: ../../extending/newtypes_tutorial.rst:425
msgid ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"first name\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"last name\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"first name\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"last name\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};"

#: ../../extending/newtypes_tutorial.rst:435
msgid ""
"and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::"
msgstr "и поместите определения в слот :c:member:`~PyTypeObject.tp_members`::"

#: ../../extending/newtypes_tutorial.rst:437
msgid ".tp_members = Custom_members,"
msgstr ".tp_members = Custom_members,"

#: ../../extending/newtypes_tutorial.rst:439
msgid ""
"Each member definition has a member name, type, offset, access flags and "
"documentation string.  See the :ref:`Generic-Attribute-Management` section "
"below for details."
msgstr ""
"Каждое определение члена имеет имя члена, тип, смещение, флаги доступа и "
"строку документации. Подробности смотрите в разделе Generic-Attribute-"
"Management ниже."

#: ../../extending/newtypes_tutorial.rst:443
msgid ""
"A disadvantage of this approach is that it doesn't provide a way to restrict "
"the types of objects that can be assigned to the Python attributes.  We "
"expect the first and last names to be strings, but any Python objects can be "
"assigned. Further, the attributes can be deleted, setting the C pointers to "
"``NULL``.  Even though we can make sure the members are initialized to non-"
"``NULL`` values, the members can be set to ``NULL`` if the attributes are "
"deleted."
msgstr ""
"Недостатком этого подхода является то, что он не позволяет ограничить типы "
"объектов, которые можно назначать атрибутам Python. Мы ожидаем, что имя и "
"фамилия будут строками, но можно присваивать любые объекты Python. Кроме "
"того, атрибуты можно удалить, установив для указателей C значение NULL. "
"Несмотря на то, что мы можем быть уверены, что члены инициализируются "
"значениями, отличными от NULL, члены могут быть установлены в NULL, если "
"атрибуты удалены."

#: ../../extending/newtypes_tutorial.rst:450
msgid ""
"We define a single method, :meth:`!Custom.name`, that outputs the objects "
"name as the concatenation of the first and last names. ::"
msgstr ""
"Мы определяем единственный метод :meth:`!Custom.name`, который выводит имя "
"объекта как объединение имени и фамилии. ::"

#: ../../extending/newtypes_tutorial.rst:453
msgid ""
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        return NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        return NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}"
msgstr ""
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        return NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        return NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}"

#: ../../extending/newtypes_tutorial.rst:467
msgid ""
"The method is implemented as a C function that takes a :class:`!Custom` (or :"
"class:`!Custom` subclass) instance as the first argument.  Methods always "
"take an instance as the first argument. Methods often take positional and "
"keyword arguments as well, but in this case we don't take any and don't need "
"to accept a positional argument tuple or keyword argument dictionary. This "
"method is equivalent to the Python method:"
msgstr ""
"Метод реализован как функция C, которая принимает экземпляр :class:`!Custom` "
"(или подкласса :class:`!Custom`) в качестве первого аргумента. Методы всегда "
"принимают экземпляр в качестве первого аргумента. Методы также часто "
"принимают позиционные аргументы и аргументы по ключевым словам, но в этом "
"случае мы их не принимаем и нам не нужно принимать кортеж позиционных "
"аргументов или словарь аргументов ключевых слов. Этот метод эквивалентен "
"методу Python:"

#: ../../extending/newtypes_tutorial.rst:474
msgid ""
"def name(self):\n"
"    return \"%s %s\" % (self.first, self.last)"
msgstr ""
"def name(self):\n"
"    return \"%s %s\" % (self.first, self.last)"

#: ../../extending/newtypes_tutorial.rst:479
msgid ""
"Note that we have to check for the possibility that our :attr:`!first` and :"
"attr:`!last` members are ``NULL``.  This is because they can be deleted, in "
"which case they are set to ``NULL``.  It would be better to prevent deletion "
"of these attributes and to restrict the attribute values to be strings.  "
"We'll see how to do that in the next section."
msgstr ""
"Обратите внимание, что нам нужно проверить возможность того, что наши члены :"
"attr:`!first` и :attr:`!last` имеют значение ``NULL``. Это связано с тем, "
"что их можно удалить, и в этом случае для них устанавливается значение NULL. "
"Было бы лучше предотвратить удаление этих атрибутов и ограничить значения "
"атрибутов строками. Мы увидим, как это сделать, в следующем разделе."

#: ../../extending/newtypes_tutorial.rst:485
msgid ""
"Now that we've defined the method, we need to create an array of method "
"definitions::"
msgstr ""
"Теперь, когда мы определили метод, нам нужно создать массив определений "
"методов::"

#: ../../extending/newtypes_tutorial.rst:488
msgid ""
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};"

#: ../../extending/newtypes_tutorial.rst:495
msgid ""
"(note that we used the :c:macro:`METH_NOARGS` flag to indicate that the "
"method is expecting no arguments other than *self*)"
msgstr ""
"(обратите внимание, что мы использовали флаг :c:macro:`METH_NOARGS`, чтобы "
"указать, что метод не ожидает никаких аргументов, кроме *self*)"

#: ../../extending/newtypes_tutorial.rst:498
msgid "and assign it to the :c:member:`~PyTypeObject.tp_methods` slot::"
msgstr "и назначьте его слоту :c:member:`~PyTypeObject.tp_methods`::"

#: ../../extending/newtypes_tutorial.rst:500
msgid ".tp_methods = Custom_methods,"
msgstr ".tp_methods = Custom_methods,"

#: ../../extending/newtypes_tutorial.rst:502
msgid ""
"Finally, we'll make our type usable as a base class for subclassing.  We've "
"written our methods carefully so far so that they don't make any assumptions "
"about the type of the object being created or used, so all we need to do is "
"to add the :c:macro:`Py_TPFLAGS_BASETYPE` to our class flag definition::"
msgstr ""
"Наконец, мы сделаем наш тип пригодным для использования в качестве базового "
"класса для создания подклассов. До сих пор мы тщательно писали наши методы, "
"чтобы они не делали никаких предположений о типе создаваемого или "
"используемого объекта, поэтому все, что нам нужно сделать, это добавить :c:"
"macro:`Py_TPFLAGS_BASETYPE` в наш класс. определение флага::"

#: ../../extending/newtypes_tutorial.rst:507
msgid ".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,"
msgstr ".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,"

#: ../../extending/newtypes_tutorial.rst:509
msgid ""
"We rename :c:func:`!PyInit_custom` to :c:func:`!PyInit_custom2`, update the "
"module name in the :c:type:`PyModuleDef` struct, and update the full class "
"name in the :c:type:`PyTypeObject` struct."
msgstr ""
"Мы переименовываем :c:func:`!PyInit_custom` в :c:func:`!PyInit_custom2`, "
"обновляем имя модуля в структуре :c:type:`PyModuleDef` и обновляем полное "
"имя класса в :c:type :`PyTypeObject` структура."

#: ../../extending/newtypes_tutorial.rst:513
msgid "Finally, we update our :file:`setup.py` file to include the new module,"
msgstr ""
"Наконец, мы обновляем наш файл :file:`setup.py`, включив в него новый модуль:"

#: ../../extending/newtypes_tutorial.rst:515
msgid ""
"from setuptools import Extension, setup\n"
"setup(ext_modules=[\n"
"    Extension(\"custom\", [\"custom.c\"]),\n"
"    Extension(\"custom2\", [\"custom2.c\"]),\n"
"])"
msgstr ""
"from setuptools import Extension, setup\n"
"setup(ext_modules=[\n"
"    Extension(\"custom\", [\"custom.c\"]),\n"
"    Extension(\"custom2\", [\"custom2.c\"]),\n"
"])"

#: ../../extending/newtypes_tutorial.rst:523
msgid "and then we re-install so that we can ``import custom2``:"
msgstr ""
"а затем переустанавливаем, чтобы иметь возможность ``импортировать custom2``:"

#: ../../extending/newtypes_tutorial.rst:530
msgid "Providing finer control over data attributes"
msgstr "Обеспечение более точного контроля над атрибутами данных."

#: ../../extending/newtypes_tutorial.rst:532
msgid ""
"In this section, we'll provide finer control over how the :attr:`!first` "
"and :attr:`!last` attributes are set in the :class:`!Custom` example. In the "
"previous version of our module, the instance variables :attr:`!first` and :"
"attr:`!last` could be set to non-string values or even deleted. We want to "
"make sure that these attributes always contain strings."
msgstr ""
"В этом разделе мы предоставим более тонкий контроль над тем, как "
"устанавливаются атрибуты :attr:`!first` и :attr:`!last` в примере :class:`!"
"Custom`. В предыдущей версии нашего модуля переменным экземпляра :attr:`!"
"first` и :attr:`!last` можно было присвоить нестроковые значения или даже "
"удалить. Мы хотим быть уверены, что эти атрибуты всегда содержат строки."

#: ../../extending/newtypes_tutorial.rst:538
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", (getter) Custom_getfirst, (setter) Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", (getter) Custom_getlast, (setter) Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom3.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = (initproc) Custom_init,\n"
"    .tp_dealloc = (destructor) Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom3\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom3(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", (getter) Custom_getfirst, (setter) Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", (getter) Custom_getlast, (setter) Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom3.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = (initproc) Custom_init,\n"
"    .tp_dealloc = (destructor) Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom3\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom3(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"

#: ../../extending/newtypes_tutorial.rst:541
msgid ""
"To provide greater control, over the :attr:`!first` and :attr:`!last` "
"attributes, we'll use custom getter and setter functions.  Here are the "
"functions for getting and setting the :attr:`!first` attribute::"
msgstr ""
"Чтобы обеспечить больший контроль над атрибутами :attr:`!first` и :attr:`!"
"last`, мы будем использовать специальные функции получения и установки. Вот "
"функции для получения и установки атрибута :attr:`!first`::"

#: ../../extending/newtypes_tutorial.rst:545
msgid ""
"static PyObject *\n"
"Custom_getfirst(CustomObject *self, void *closure)\n"
"{\n"
"    Py_INCREF(self->first);\n"
"    return self->first;\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    PyObject *tmp;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    tmp = self->first;\n"
"    Py_INCREF(value);\n"
"    self->first = value;\n"
"    Py_DECREF(tmp);\n"
"    return 0;\n"
"}"
msgstr ""
"static PyObject *\n"
"Custom_getfirst(CustomObject *self, void *closure)\n"
"{\n"
"    Py_INCREF(self->first);\n"
"    return self->first;\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    PyObject *tmp;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    tmp = self->first;\n"
"    Py_INCREF(value);\n"
"    self->first = value;\n"
"    Py_DECREF(tmp);\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:572
msgid ""
"The getter function is passed a :class:`!Custom` object and a \"closure\", "
"which is a void pointer.  In this case, the closure is ignored.  (The "
"closure supports an advanced usage in which definition data is passed to the "
"getter and setter. This could, for example, be used to allow a single set of "
"getter and setter functions that decide the attribute to get or set based on "
"data in the closure.)"
msgstr ""
"В функцию-получатель передается объект :class:`!Custom` и «замыкание», "
"которое представляет собой пустой указатель. В этом случае замыкание "
"игнорируется. (Замыкание поддерживает расширенное использование, при котором "
"данные определения передаются методам получения и установки. Это можно, "
"например, использовать для того, чтобы разрешить единый набор функций "
"получения и установки, которые решают, какой атрибут получить или установить "
"на основе данных в закрытие.)"

#: ../../extending/newtypes_tutorial.rst:578
msgid ""
"The setter function is passed the :class:`!Custom` object, the new value, "
"and the closure.  The new value may be ``NULL``, in which case the attribute "
"is being deleted.  In our setter, we raise an error if the attribute is "
"deleted or if its new value is not a string."
msgstr ""
"В функцию установки передается объект :class:`!Custom`, новое значение и "
"замыкание. Новое значение может быть ``NULL``, и в этом случае атрибут "
"удаляется. В нашем установщике мы выдаем ошибку, если атрибут удален или его "
"новое значение не является строкой."

#: ../../extending/newtypes_tutorial.rst:583
msgid "We create an array of :c:type:`PyGetSetDef` structures::"
msgstr "Мы создаем массив структур :c:type:`PyGetSetDef`::"

#: ../../extending/newtypes_tutorial.rst:585
msgid ""
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", (getter) Custom_getfirst, (setter) Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", (getter) Custom_getlast, (setter) Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", (getter) Custom_getfirst, (setter) Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", (getter) Custom_getlast, (setter) Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};"

#: ../../extending/newtypes_tutorial.rst:593
msgid "and register it in the :c:member:`~PyTypeObject.tp_getset` slot::"
msgstr "и зарегистрируйте его в слоте :c:member:`~PyTypeObject.tp_getset`::"

#: ../../extending/newtypes_tutorial.rst:595
msgid ".tp_getset = Custom_getsetters,"
msgstr ".tp_getset = Custom_getsetters,"

#: ../../extending/newtypes_tutorial.rst:597
msgid ""
"The last item in a :c:type:`PyGetSetDef` structure is the \"closure\" "
"mentioned above.  In this case, we aren't using a closure, so we just pass "
"``NULL``."
msgstr ""
"Последний элемент в структуре :c:type:`PyGetSetDef` — это упомянутое выше "
"«замыкание». В этом случае мы не используем замыкание, поэтому просто "
"передаем NULL."

#: ../../extending/newtypes_tutorial.rst:600
msgid "We also remove the member definitions for these attributes::"
msgstr "Мы также удаляем определения членов для этих атрибутов:"

#: ../../extending/newtypes_tutorial.rst:602
msgid ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};"

#: ../../extending/newtypes_tutorial.rst:608
msgid ""
"We also need to update the :c:member:`~PyTypeObject.tp_init` handler to only "
"allow strings [#]_ to be passed::"
msgstr ""
"Нам также необходимо обновить обработчик :c:member:`~PyTypeObject.tp_init`, "
"чтобы он разрешал только строки. [#]_ предстоит пройти::"

#: ../../extending/newtypes_tutorial.rst:611
msgid ""
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        tmp = self->first;\n"
"        Py_INCREF(first);\n"
"        self->first = first;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    if (last) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(last);\n"
"        self->last = last;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        tmp = self->first;\n"
"        Py_INCREF(first);\n"
"        self->first = first;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    if (last) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(last);\n"
"        self->last = last;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:637
msgid ""
"With these changes, we can assure that the ``first`` and ``last`` members "
"are never ``NULL`` so we can remove checks for ``NULL`` values in almost all "
"cases. This means that most of the :c:func:`Py_XDECREF` calls can be "
"converted to :c:func:`Py_DECREF` calls.  The only place we can't change "
"these calls is in the ``tp_dealloc`` implementation, where there is the "
"possibility that the initialization of these members failed in ``tp_new``."
msgstr ""
"Благодаря этим изменениям мы можем гарантировать, что члены ``first`` и "
"``last`` никогда не будут равны ``NULL``, поэтому мы можем удалить проверки "
"для значений ``NULL`` почти во всех случаях. Это означает, что большинство "
"вызовов :c:func:`Py_XDECREF` можно преобразовать в вызовы :c:func:"
"`Py_DECREF`. Единственное место, где мы не можем изменить эти вызовы, — это "
"реализация tp_dealloc, где существует вероятность того, что инициализация "
"этих членов не удалась в tp_new."

#: ../../extending/newtypes_tutorial.rst:644
msgid ""
"We also rename the module initialization function and module name in the "
"initialization function, as we did before, and we add an extra definition to "
"the :file:`setup.py` file."
msgstr ""
"Мы также переименовываем функцию инициализации модуля и имя модуля в функции "
"инициализации, как мы делали раньше, и добавляем дополнительное определение "
"в файл :file:`setup.py`."

#: ../../extending/newtypes_tutorial.rst:650
msgid "Supporting cyclic garbage collection"
msgstr "Поддержка циклической сборки мусора"

#: ../../extending/newtypes_tutorial.rst:652
msgid ""
"Python has a :term:`cyclic garbage collector (GC) <garbage collection>` that "
"can identify unneeded objects even when their reference counts are not zero. "
"This can happen when objects are involved in cycles.  For example, consider:"
msgstr ""
"В Python есть циклический сборщик мусора (GC) <сборка мусора>, который может "
"идентифицировать ненужные объекты, даже если их счетчик ссылок не равен "
"нулю. Это может произойти, когда объекты участвуют в циклах. Например, "
"рассмотрим:"

#: ../../extending/newtypes_tutorial.rst:656
msgid ""
">>> l = []\n"
">>> l.append(l)\n"
">>> del l"
msgstr ""
">>> l = []\n"
">>> l.append(l)\n"
">>> del l"

#: ../../extending/newtypes_tutorial.rst:662
msgid ""
"In this example, we create a list that contains itself. When we delete it, "
"it still has a reference from itself. Its reference count doesn't drop to "
"zero. Fortunately, Python's cyclic garbage collector will eventually figure "
"out that the list is garbage and free it."
msgstr ""
"В этом примере мы создаем список, содержащий самого себя. Когда мы его "
"удаляем, он все еще имеет ссылку на самого себя. Его счетчик ссылок не "
"падает до нуля. К счастью, циклический сборщик мусора Python в конечном "
"итоге обнаружит, что список — мусор, и освободит его."

#: ../../extending/newtypes_tutorial.rst:667
msgid ""
"In the second version of the :class:`!Custom` example, we allowed any kind "
"of object to be stored in the :attr:`!first` or :attr:`!last` attributes "
"[#]_. Besides, in the second and third versions, we allowed subclassing :"
"class:`!Custom`, and subclasses may add arbitrary attributes.  For any of "
"those two reasons, :class:`!Custom` objects can participate in cycles:"
msgstr ""
"Во второй версии примера :class:`!Custom` мы разрешили хранить объекты "
"любого типа в атрибутах :attr:`!first` или :attr:`!last`. [#]_ . Кроме того, "
"во второй и третьей версиях мы разрешили создание подклассов :class:`!"
"Custom`, а подклассы могут добавлять произвольные атрибуты. По любой из этих "
"двух причин объекты :class:`!Custom` могут участвовать в циклах:"

#: ../../extending/newtypes_tutorial.rst:673
msgid ""
">>> import custom3\n"
">>> class Derived(custom3.Custom): pass\n"
"...\n"
">>> n = Derived()\n"
">>> n.some_attribute = n"
msgstr ""
">>> import custom3\n"
">>> class Derived(custom3.Custom): pass\n"
"...\n"
">>> n = Derived()\n"
">>> n.some_attribute = n"

#: ../../extending/newtypes_tutorial.rst:681
msgid ""
"To allow a :class:`!Custom` instance participating in a reference cycle to "
"be properly detected and collected by the cyclic GC, our :class:`!Custom` "
"type needs to fill two additional slots and to enable a flag that enables "
"these slots:"
msgstr ""
"Чтобы позволить экземпляру :class:`!Custom`, участвующему в эталонном цикле, "
"быть должным образом обнаруженным и собранным циклическим сборщиком мусора, "
"наш тип :class:`!Custom` должен заполнить два дополнительных слота и "
"включить флаг, который включает их. слоты:"

#: ../../extending/newtypes_tutorial.rst:685
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static int\n"
"Custom_traverse(CustomObject *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static int\n"
"Custom_clear(CustomObject *self)\n"
"{\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    PyObject_GC_UnTrack(self);\n"
"    Custom_clear(self);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", (getter) Custom_getfirst, (setter) Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", (getter) Custom_getlast, (setter) Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom4.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | "
"Py_TPFLAGS_HAVE_GC,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = (initproc) Custom_init,\n"
"    .tp_dealloc = (destructor) Custom_dealloc,\n"
"    .tp_traverse = (traverseproc) Custom_traverse,\n"
"    .tp_clear = (inquiry) Custom_clear,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom4\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom4(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static int\n"
"Custom_traverse(CustomObject *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static int\n"
"Custom_clear(CustomObject *self)\n"
"{\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    PyObject_GC_UnTrack(self);\n"
"    Custom_clear(self);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(CustomObject *self, void *closure)\n"
"{\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(CustomObject *self, PyObject *value, void *closure)\n"
"{\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", (getter) Custom_getfirst, (setter) Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", (getter) Custom_getlast, (setter) Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))\n"
"{\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", (PyCFunction) Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom4.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | "
"Py_TPFLAGS_HAVE_GC,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = (initproc) Custom_init,\n"
"    .tp_dealloc = (destructor) Custom_dealloc,\n"
"    .tp_traverse = (traverseproc) Custom_traverse,\n"
"    .tp_clear = (inquiry) Custom_clear,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static PyModuleDef custommodule = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom4\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom4(void)\n"
"{\n"
"    PyObject *m;\n"
"    if (PyType_Ready(&CustomType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&custommodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"

#: ../../extending/newtypes_tutorial.rst:688
msgid ""
"First, the traversal method lets the cyclic GC know about subobjects that "
"could participate in cycles::"
msgstr ""
"Во-первых, метод обхода позволяет циклическому сборщику мусора узнать о "
"подобъектах, которые могут участвовать в циклах:"

#: ../../extending/newtypes_tutorial.rst:691
msgid ""
"static int\n"
"Custom_traverse(CustomObject *self, visitproc visit, void *arg)\n"
"{\n"
"    int vret;\n"
"    if (self->first) {\n"
"        vret = visit(self->first, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    if (self->last) {\n"
"        vret = visit(self->last, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"Custom_traverse(CustomObject *self, visitproc visit, void *arg)\n"
"{\n"
"    int vret;\n"
"    if (self->first) {\n"
"        vret = visit(self->first, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    if (self->last) {\n"
"        vret = visit(self->last, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:708
msgid ""
"For each subobject that can participate in cycles, we need to call the :c:"
"func:`!visit` function, which is passed to the traversal method. The :c:func:"
"`!visit` function takes as arguments the subobject and the extra argument "
"*arg* passed to the traversal method.  It returns an integer value that must "
"be returned if it is non-zero."
msgstr ""
"Для каждого подобъекта, который может участвовать в циклах, нам нужно "
"вызвать функцию :c:func:`!visit`, которая передается методу обхода. Функция :"
"c:func:`!visit` принимает в качестве аргументов подобъект и дополнительный "
"аргумент *arg*, передаваемый методу обхода. Он возвращает целочисленное "
"значение, которое должно быть возвращено, если оно не равно нулю."

#: ../../extending/newtypes_tutorial.rst:714
msgid ""
"Python provides a :c:func:`Py_VISIT` macro that automates calling visit "
"functions.  With :c:func:`Py_VISIT`, we can minimize the amount of "
"boilerplate in ``Custom_traverse``::"
msgstr ""
"Python предоставляет макрос :c:func:`Py_VISIT`, который автоматизирует вызов "
"функций посещения. С помощью :c:func:`Py_VISIT` мы можем минимизировать "
"количество шаблонного кода в ``Custom_traverse``::"

#: ../../extending/newtypes_tutorial.rst:718
msgid ""
"static int\n"
"Custom_traverse(CustomObject *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"Custom_traverse(CustomObject *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:727
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` implementation must name its "
"arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`."
msgstr ""
"Реализация :c:member:`~PyTypeObject.tp_traverse` должна точно называть свои "
"аргументы *visit* и *arg*, чтобы использовать :c:func:`Py_VISIT`."

#: ../../extending/newtypes_tutorial.rst:730
msgid ""
"Second, we need to provide a method for clearing any subobjects that can "
"participate in cycles::"
msgstr ""
"Во-вторых, нам нужно предоставить метод очистки любых подобъектов, которые "
"могут участвовать в циклах:"

#: ../../extending/newtypes_tutorial.rst:733
msgid ""
"static int\n"
"Custom_clear(CustomObject *self)\n"
"{\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"Custom_clear(CustomObject *self)\n"
"{\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:741
msgid ""
"Notice the use of the :c:func:`Py_CLEAR` macro.  It is the recommended and "
"safe way to clear data attributes of arbitrary types while decrementing "
"their reference counts.  If you were to call :c:func:`Py_XDECREF` instead on "
"the attribute before setting it to ``NULL``, there is a possibility that the "
"attribute's destructor would call back into code that reads the attribute "
"again (*especially* if there is a reference cycle)."
msgstr ""
"Обратите внимание на использование макроса :c:func:`Py_CLEAR`. Это "
"рекомендуемый и безопасный способ очистки атрибутов данных произвольных "
"типов при уменьшении их счетчика ссылок. Если бы вы вместо этого вызвали :c:"
"func:`Py_XDECREF` для атрибута перед установкой его в ``NULL``, существует "
"вероятность того, что деструктор атрибута вызовет обратный вызов в код, "
"который снова прочитает атрибут (*особенно*, если есть эталонный цикл)."

#: ../../extending/newtypes_tutorial.rst:749
msgid "You could emulate :c:func:`Py_CLEAR` by writing::"
msgstr "You could emulate :c:func:`Py_CLEAR` by writing::"

#: ../../extending/newtypes_tutorial.rst:751
msgid ""
"PyObject *tmp;\n"
"tmp = self->first;\n"
"self->first = NULL;\n"
"Py_XDECREF(tmp);"
msgstr ""
"PyObject *tmp;\n"
"tmp = self->first;\n"
"self->first = NULL;\n"
"Py_XDECREF(tmp);"

#: ../../extending/newtypes_tutorial.rst:756
msgid ""
"Nevertheless, it is much easier and less error-prone to always use :c:func:"
"`Py_CLEAR` when deleting an attribute.  Don't try to micro-optimize at the "
"expense of robustness!"
msgstr ""
"Тем не менее, гораздо проще и менее подвержено ошибкам всегда использовать :"
"c:func:`Py_CLEAR` при удалении атрибута. Не пытайтесь микрооптимизировать в "
"ущерб надежности!"

#: ../../extending/newtypes_tutorial.rst:760
msgid ""
"The deallocator ``Custom_dealloc`` may call arbitrary code when clearing "
"attributes.  It means the circular GC can be triggered inside the function. "
"Since the GC assumes reference count is not zero, we need to untrack the "
"object from the GC by calling :c:func:`PyObject_GC_UnTrack` before clearing "
"members. Here is our reimplemented deallocator using :c:func:"
"`PyObject_GC_UnTrack` and ``Custom_clear``::"
msgstr ""
"Освободитель Custom_dealloc может вызывать произвольный код при очистке "
"атрибутов. Это означает, что круговой сборщик мусора может быть запущен "
"внутри функции. Поскольку сборщик мусора предполагает, что счетчик ссылок не "
"равен нулю, нам нужно отменить отслеживание объекта из сборщика мусора, "
"вызвав :c:func:`PyObject_GC_UnTrack` перед очисткой членов. Вот наш "
"переопределенный механизм освобождения с использованием :c:func:"
"`PyObject_GC_UnTrack` и ``Custom_clear``::"

#: ../../extending/newtypes_tutorial.rst:767
msgid ""
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    PyObject_GC_UnTrack(self);\n"
"    Custom_clear(self);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}"
msgstr ""
"static void\n"
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    PyObject_GC_UnTrack(self);\n"
"    Custom_clear(self);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}"

#: ../../extending/newtypes_tutorial.rst:775
msgid ""
"Finally, we add the :c:macro:`Py_TPFLAGS_HAVE_GC` flag to the class flags::"
msgstr ""
"Наконец, мы добавляем флаг :c:macro:`Py_TPFLAGS_HAVE_GC` к флагам класса::"

#: ../../extending/newtypes_tutorial.rst:777
msgid ""
".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,"
msgstr ""
".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,"

#: ../../extending/newtypes_tutorial.rst:779
msgid ""
"That's pretty much it.  If we had written custom :c:member:`~PyTypeObject."
"tp_alloc` or :c:member:`~PyTypeObject.tp_free` handlers, we'd need to modify "
"them for cyclic garbage collection.  Most extensions will use the versions "
"automatically provided."
msgstr ""
"Вот и все. Если бы мы написали собственные обработчики :c:member:"
"`~PyTypeObject.tp_alloc` или :c:member:`~PyTypeObject.tp_free`, нам нужно "
"было бы изменить их для циклической сборки мусора. Большинство расширений "
"будут использовать автоматически предоставленные версии."

#: ../../extending/newtypes_tutorial.rst:785
msgid "Subclassing other types"
msgstr "Создание подклассов других типов"

#: ../../extending/newtypes_tutorial.rst:787
msgid ""
"It is possible to create new extension types that are derived from existing "
"types. It is easiest to inherit from the built in types, since an extension "
"can easily use the :c:type:`PyTypeObject` it needs. It can be difficult to "
"share these :c:type:`PyTypeObject` structures between extension modules."
msgstr ""
"Можно создавать новые типы расширений, производные от существующих типов. "
"Проще всего наследовать встроенные типы, поскольку расширение может легко "
"использовать необходимый ему :c:type:`PyTypeObject`. Может быть сложно "
"разделить эти структуры :c:type:`PyTypeObject` между модулями расширения."

#: ../../extending/newtypes_tutorial.rst:792
msgid ""
"In this example we will create a :class:`!SubList` type that inherits from "
"the built-in :class:`list` type. The new type will be completely compatible "
"with regular lists, but will have an additional :meth:`!increment` method "
"that increases an internal counter:"
msgstr ""
"В этом примере мы создадим тип :class:`!SubList`, который наследуется от "
"встроенного типа :class:`list`. Новый тип будет полностью совместим с "
"обычными списками, но будет иметь дополнительный метод :meth:`!increment`, "
"увеличивающий внутренний счетчик:"

#: ../../extending/newtypes_tutorial.rst:797
msgid ""
">>> import sublist\n"
">>> s = sublist.SubList(range(3))\n"
">>> s.extend(s)\n"
">>> print(len(s))\n"
"6\n"
">>> print(s.increment())\n"
"1\n"
">>> print(s.increment())\n"
"2"
msgstr ""
">>> import sublist\n"
">>> s = sublist.SubList(range(3))\n"
">>> s.extend(s)\n"
">>> print(len(s))\n"
"6\n"
">>> print(s.increment())\n"
"1\n"
">>> print(s.increment())\n"
"2"

#: ../../extending/newtypes_tutorial.rst:809
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;\n"
"\n"
"static PyObject *\n"
"SubList_increment(SubListObject *self, PyObject *unused)\n"
"{\n"
"    self->state++;\n"
"    return PyLong_FromLong(self->state);\n"
"}\n"
"\n"
"static PyMethodDef SubList_methods[] = {\n"
"    {\"increment\", (PyCFunction) SubList_increment, METH_NOARGS,\n"
"     PyDoc_STR(\"increment state counter\")},\n"
"    {NULL},\n"
"};\n"
"\n"
"static int\n"
"SubList_init(SubListObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    if (PyList_Type.tp_init((PyObject *) self, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}\n"
"\n"
"static PyTypeObject SubListType = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"sublist.SubList\",\n"
"    .tp_doc = PyDoc_STR(\"SubList objects\"),\n"
"    .tp_basicsize = sizeof(SubListObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_init = (initproc) SubList_init,\n"
"    .tp_methods = SubList_methods,\n"
"};\n"
"\n"
"static PyModuleDef sublistmodule = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"sublist\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_sublist(void)\n"
"{\n"
"    PyObject *m;\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&sublistmodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;\n"
"\n"
"static PyObject *\n"
"SubList_increment(SubListObject *self, PyObject *unused)\n"
"{\n"
"    self->state++;\n"
"    return PyLong_FromLong(self->state);\n"
"}\n"
"\n"
"static PyMethodDef SubList_methods[] = {\n"
"    {\"increment\", (PyCFunction) SubList_increment, METH_NOARGS,\n"
"     PyDoc_STR(\"increment state counter\")},\n"
"    {NULL},\n"
"};\n"
"\n"
"static int\n"
"SubList_init(SubListObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    if (PyList_Type.tp_init((PyObject *) self, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}\n"
"\n"
"static PyTypeObject SubListType = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"sublist.SubList\",\n"
"    .tp_doc = PyDoc_STR(\"SubList objects\"),\n"
"    .tp_basicsize = sizeof(SubListObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_init = (initproc) SubList_init,\n"
"    .tp_methods = SubList_methods,\n"
"};\n"
"\n"
"static PyModuleDef sublistmodule = {\n"
"    PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"sublist\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = -1,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_sublist(void)\n"
"{\n"
"    PyObject *m;\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&sublistmodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}\n"

#: ../../extending/newtypes_tutorial.rst:812
msgid ""
"As you can see, the source code closely resembles the :class:`!Custom` "
"examples in previous sections. We will break down the main differences "
"between them. ::"
msgstr ""
"Как видите, исходный код очень похож на примеры :class:`!Custom` из "
"предыдущих разделов. Мы разберем основные различия между ними. ::"

#: ../../extending/newtypes_tutorial.rst:815
msgid ""
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;"
msgstr ""
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;"

#: ../../extending/newtypes_tutorial.rst:820
msgid ""
"The primary difference for derived type objects is that the base type's "
"object structure must be the first value.  The base type will already "
"include the :c:func:`PyObject_HEAD` at the beginning of its structure."
msgstr ""
"Основное отличие объектов производного типа состоит в том, что структура "
"объекта базового типа должна быть первым значением. Базовый тип уже будет "
"включать :c:func:`PyObject_HEAD` в начале своей структуры."

#: ../../extending/newtypes_tutorial.rst:824
msgid ""
"When a Python object is a :class:`!SubList` instance, its ``PyObject *`` "
"pointer can be safely cast to both ``PyListObject *`` and ``SubListObject "
"*``::"
msgstr ""
"Когда объект Python является экземпляром :class:`!SubList`, его указатель "
"``PyObject *`` можно безопасно привести как к ``PyListObject *``, так и к "
"``SubListObject *``::"

#: ../../extending/newtypes_tutorial.rst:827
msgid ""
"static int\n"
"SubList_init(SubListObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    if (PyList_Type.tp_init((PyObject *) self, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"SubList_init(SubListObject *self, PyObject *args, PyObject *kwds)\n"
"{\n"
"    if (PyList_Type.tp_init((PyObject *) self, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:836
msgid ""
"We see above how to call through to the :meth:`~object.__init__` method of "
"the base type."
msgstr ""
"Выше мы видели, как вызвать метод :meth:`~object.__init__` базового типа."

#: ../../extending/newtypes_tutorial.rst:839
msgid ""
"This pattern is important when writing a type with custom :c:member:"
"`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_dealloc` members.  "
"The :c:member:`~PyTypeObject.tp_new` handler should not actually create the "
"memory for the object with its :c:member:`~PyTypeObject.tp_alloc`, but let "
"the base class handle it by calling its own :c:member:`~PyTypeObject.tp_new`."
msgstr ""
"Этот шаблон важен при написании типа с пользовательскими членами :c:member:"
"`~PyTypeObject.tp_new` и :c:member:`~PyTypeObject.tp_dealloc`. Обработчик :c:"
"member:`~PyTypeObject.tp_new` на самом деле не должен создавать память для "
"объекта с его :c:member:`~PyTypeObject.tp_alloc`, а должен позволить "
"базовому классу обрабатывать его, вызывая свой собственный :c: член:"
"`~PyTypeObject.tp_new`."

#: ../../extending/newtypes_tutorial.rst:845
msgid ""
"The :c:type:`PyTypeObject` struct supports a :c:member:`~PyTypeObject."
"tp_base` specifying the type's concrete base class.  Due to cross-platform "
"compiler issues, you can't fill that field directly with a reference to :c:"
"type:`PyList_Type`; it should be done later in the module initialization "
"function::"
msgstr ""
"Структура :c:type:`PyTypeObject` поддерживает :c:member:`~PyTypeObject."
"tp_base`, определяющий конкретный базовый класс типа. Из-за проблем с кросс-"
"платформенным компилятором вы не можете заполнить это поле напрямую ссылкой "
"на :c:type:`PyList_Type`; это следует сделать позже в функции инициализации "
"модуля::"

#: ../../extending/newtypes_tutorial.rst:851
msgid ""
"PyMODINIT_FUNC\n"
"PyInit_sublist(void)\n"
"{\n"
"    PyObject* m;\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&sublistmodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}"
msgstr ""
"PyMODINIT_FUNC\n"
"PyInit_sublist(void)\n"
"{\n"
"    PyObject* m;\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0)\n"
"        return NULL;\n"
"\n"
"    m = PyModule_Create(&sublistmodule);\n"
"    if (m == NULL)\n"
"        return NULL;\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        Py_DECREF(m);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return m;\n"
"}"

#: ../../extending/newtypes_tutorial.rst:871
msgid ""
"Before calling :c:func:`PyType_Ready`, the type structure must have the :c:"
"member:`~PyTypeObject.tp_base` slot filled in.  When we are deriving an "
"existing type, it is not necessary to fill out the :c:member:`~PyTypeObject."
"tp_alloc` slot with :c:func:`PyType_GenericNew` -- the allocation function "
"from the base type will be inherited."
msgstr ""
"Перед вызовом :c:func:`PyType_Ready` в структуре типа должен быть заполнен "
"слот :c:member:`~PyTypeObject.tp_base`. Когда мы получаем существующий тип, "
"нет необходимости заполнять :c :member:`~PyTypeObject.tp_alloc` слот с :c:"
"func:`PyType_GenericNew` — функция выделения из базового типа будет "
"унаследована."

#: ../../extending/newtypes_tutorial.rst:877
msgid ""
"After that, calling :c:func:`PyType_Ready` and adding the type object to the "
"module is the same as with the basic :class:`!Custom` examples."
msgstr ""
"После этого вызов :c:func:`PyType_Ready` и добавление объекта типа в модуль "
"осуществляется так же, как и в базовых примерах :class:`!Custom`."

#: ../../extending/newtypes_tutorial.rst:882
msgid "Footnotes"
msgstr "Сноски"

#: ../../extending/newtypes_tutorial.rst:883
msgid ""
"This is true when we know that the object is a basic type, like a string or "
"a float."
msgstr ""
"Это верно, когда мы знаем, что объект имеет базовый тип, например строку или "
"число с плавающей запятой."

#: ../../extending/newtypes_tutorial.rst:886
msgid ""
"We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler in "
"this example, because our type doesn't support garbage collection."
msgstr ""
"В этом примере мы полагались на это в обработчике :c:member:`~PyTypeObject."
"tp_dealloc`, поскольку наш тип не поддерживает сборку мусора."

#: ../../extending/newtypes_tutorial.rst:889
msgid ""
"We now know that the first and last members are strings, so perhaps we could "
"be less careful about decrementing their reference counts, however, we "
"accept instances of string subclasses.  Even though deallocating normal "
"strings won't call back into our objects, we can't guarantee that "
"deallocating an instance of a string subclass won't call back into our "
"objects."
msgstr ""
"Теперь мы знаем, что первый и последний члены являются строками, поэтому, "
"возможно, нам следует быть менее осторожными при уменьшении их счетчиков "
"ссылок, однако мы принимаем экземпляры подклассов строк. Несмотря на то, что "
"освобождение обычных строк не приведет к обратному вызову наших объектов, мы "
"не можем гарантировать, что освобождение экземпляра подкласса строк не "
"приведет к обратному вызову наших объектов."

#: ../../extending/newtypes_tutorial.rst:895
msgid ""
"Also, even with our attributes restricted to strings instances, the user "
"could pass arbitrary :class:`str` subclasses and therefore still create "
"reference cycles."
msgstr ""
"Кроме того, даже несмотря на то, что наши атрибуты ограничены экземплярами "
"строк, пользователь может передавать произвольные подклассы :class:`str` и, "
"следовательно, по-прежнему создавать ссылочные циклы."
