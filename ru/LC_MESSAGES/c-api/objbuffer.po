# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/objbuffer.rst:4
msgid "Old Buffer Protocol"
msgstr "Старый буферный протокол"

#: ../../c-api/objbuffer.rst:8
msgid ""
"These functions were part of the \"old buffer protocol\" API in Python 2. In "
"Python 3, this protocol doesn't exist anymore but the functions are still "
"exposed to ease porting 2.x code.  They act as a compatibility wrapper "
"around the :ref:`new buffer protocol <bufferobjects>`, but they don't give "
"you control over the lifetime of the resources acquired when a buffer is "
"exported."
msgstr ""
"Эти функции были частью API «старого буферного протокола» в Python 2. В "
"Python 3 этот протокол больше не существует, но функции по-прежнему доступны "
"для облегчения переноса кода 2.x. Они действуют как оболочка совместимости "
"вокруг :ref:`нового буферного протокола <bufferobjects>`, но не дают вам "
"контроля над временем жизни ресурсов, полученных при экспорте буфера."

#: ../../c-api/objbuffer.rst:15
msgid ""
"Therefore, it is recommended that you call :c:func:`PyObject_GetBuffer` (or "
"the ``y*`` or ``w*`` :ref:`format codes <arg-parsing>` with the :c:func:"
"`PyArg_ParseTuple` family of functions) to get a buffer view over an object, "
"and :c:func:`PyBuffer_Release` when the buffer view can be released."
msgstr ""
"Поэтому рекомендуется вызывать :c:func:`PyObject_GetBuffer` (или ``y*`` или "
"``w*`` :ref:`format code <arg-parsing>` с помощью :c:func Семейство функций :"
"`PyArg_ParseTuple`) для получения представления буфера объекта и :c:func:"
"`PyBuffer_Release`, когда представление буфера можно освободить."

#: ../../c-api/objbuffer.rst:23
msgid ""
"Returns a pointer to a read-only memory location usable as character-based "
"input.  The *obj* argument must support the single-segment character buffer "
"interface.  On success, returns ``0``, sets *buffer* to the memory location "
"and *buffer_len* to the buffer length.  Returns ``-1`` and sets a :exc:"
"`TypeError` on error."
msgstr ""
"Возвращает указатель на область памяти, доступную только для чтения, которую "
"можно использовать для ввода символов. Аргумент *obj* должен поддерживать "
"интерфейс односегментного символьного буфера. В случае успеха возвращает "
"``0``, устанавливает *buffer* в ячейку памяти и *buffer_len* в длину буфера. "
"Возвращает ``-1`` и устанавливает :exc:`TypeError` в случае ошибки."

#: ../../c-api/objbuffer.rst:32
msgid ""
"Returns a pointer to a read-only memory location containing arbitrary data. "
"The *obj* argument must support the single-segment readable buffer "
"interface.  On success, returns ``0``, sets *buffer* to the memory location "
"and *buffer_len* to the buffer length.  Returns ``-1`` and sets a :exc:"
"`TypeError` on error."
msgstr ""
"Возвращает указатель на область памяти только для чтения, содержащую "
"произвольные данные. Аргумент *obj* должен поддерживать интерфейс "
"односегментного читаемого буфера. В случае успеха возвращает ``0``, "
"устанавливает *buffer* в ячейку памяти и *buffer_len* в длину буфера. "
"Возвращает ``-1`` и устанавливает :exc:`TypeError` в случае ошибки."

#: ../../c-api/objbuffer.rst:41
msgid ""
"Returns ``1`` if *o* supports the single-segment readable buffer interface. "
"Otherwise returns ``0``.  This function always succeeds."
msgstr ""
"Возвращает ``1``, если *o* поддерживает интерфейс односегментного читаемого "
"буфера. В противном случае возвращается ``0``. Эта функция всегда "
"завершается успешно."

#: ../../c-api/objbuffer.rst:44
msgid ""
"Note that this function tries to get and release a buffer, and exceptions "
"which occur while calling corresponding functions will get suppressed. To "
"get error reporting use :c:func:`PyObject_GetBuffer()` instead."
msgstr ""
"Обратите внимание, что эта функция пытается получить и освободить буфер, а "
"исключения, возникающие при вызове соответствующих функций, будут "
"подавляться. Чтобы получить отчет об ошибках, используйте вместо этого :c:"
"func:`PyObject_GetBuffer()`."

#: ../../c-api/objbuffer.rst:51
msgid ""
"Returns a pointer to a writable memory location.  The *obj* argument must "
"support the single-segment, character buffer interface.  On success, returns "
"``0``, sets *buffer* to the memory location and *buffer_len* to the buffer "
"length.  Returns ``-1`` and sets a :exc:`TypeError` on error."
msgstr ""
"Возвращает указатель на доступную для записи ячейку памяти. Аргумент *obj* "
"должен поддерживать интерфейс односегментного символьного буфера. В случае "
"успеха возвращает ``0``, устанавливает *buffer* в ячейку памяти и "
"*buffer_len* в длину буфера. Возвращает ``-1`` и устанавливает :exc:"
"`TypeError` в случае ошибки."
