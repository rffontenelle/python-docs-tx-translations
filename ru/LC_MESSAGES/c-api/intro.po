# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# 256c6f581e7306f8fe260875df9dd39f_33ba001, 2017
# Kristina Mironova, 2019
# Daniil Kolesnikov, 2024
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-08 16:35+0000\n"
"PO-Revision-Date: 2017-02-16 17:36+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/intro.rst:8
msgid "Introduction"
msgstr "Введение"

#: ../../c-api/intro.rst:10
msgid ""
"The Application Programmer's Interface to Python gives C and C++ programmers "
"access to the Python interpreter at a variety of levels.  The API is equally "
"usable from C++, but for brevity it is generally referred to as the Python/C "
"API.  There are two fundamentally different reasons for using the Python/C "
"API. The first reason is to write *extension modules* for specific purposes; "
"these are C modules that extend the Python interpreter.  This is probably "
"the most common use.  The second reason is to use Python as a component in a "
"larger application; this technique is generally referred to as :dfn:"
"`embedding` Python in an application."
msgstr ""
"Интерфейс прикладного программиста для Python предоставляет программистам C "
"и C++ доступ к интерпретатору Python на различных уровнях. Этот API можно "
"использовать и в C++, но для краткости его обычно называют API Python/C. "
"Есть две принципиально разные причины для использования API Python/C. Первая "
"причина — написать *модули расширения* для конкретных целей; это модули C, "
"расширяющие интерпретатор Python. Это, пожалуй, самое распространенное "
"использование. Вторая причина — использовать Python как компонент более "
"крупного приложения; этот метод обычно называется :dfn:`встраиванием` Python "
"в приложение."

#: ../../c-api/intro.rst:20
msgid ""
"Writing an extension module is a relatively well-understood process, where a "
"\"cookbook\" approach works well.  There are several tools that automate the "
"process to some extent.  While people have embedded Python in other "
"applications since its early existence, the process of embedding Python is "
"less straightforward than writing an extension."
msgstr ""
"Написание модуля расширения — относительно хорошо понятный процесс, в "
"котором хорошо работает подход «поваренной книги». Существует несколько "
"инструментов, которые в некоторой степени автоматизируют этот процесс. Хотя "
"люди встраивали Python в другие приложения с самого начала его "
"существования, процесс внедрения Python не так прост, как написание "
"расширения."

#: ../../c-api/intro.rst:26
msgid ""
"Many API functions are useful independent of whether you're embedding  or "
"extending Python; moreover, most applications that embed Python  will need "
"to provide a custom extension as well, so it's probably a  good idea to "
"become familiar with writing an extension before  attempting to embed Python "
"in a real application."
msgstr ""
"Многие функции API полезны независимо от того, встраиваете ли вы Python или "
"расширяете его; более того, большинству приложений, встраивающих Python, "
"также потребуется предоставить собственное расширение, поэтому, вероятно, "
"будет хорошей идеей ознакомиться с написанием расширения, прежде чем "
"пытаться встроить Python в реальное приложение."

#: ../../c-api/intro.rst:34
msgid "Coding standards"
msgstr "Стандарты кодирования"

#: ../../c-api/intro.rst:36
msgid ""
"If you're writing C code for inclusion in CPython, you **must** follow the "
"guidelines and standards defined in :PEP:`7`.  These guidelines apply "
"regardless of the version of Python you are contributing to.  Following "
"these conventions is not necessary for your own third party extension "
"modules, unless you eventually expect to contribute them to Python."
msgstr ""
"Если вы пишете код C для включения в CPython, вы **должны** следовать "
"рекомендациям и стандартам, определенным в :PEP:`7`. Эти рекомендации "
"применяются независимо от версии Python, в которую вы вносите свой вклад. "
"Следование этим соглашениям не является обязательным для ваших собственных "
"сторонних модулей расширения, если только вы в конечном итоге не планируете "
"внедрить их в Python."

#: ../../c-api/intro.rst:46
msgid "Include Files"
msgstr "Включаемые файлы"

#: ../../c-api/intro.rst:48
msgid ""
"All function, type and macro definitions needed to use the Python/C API are "
"included in your code by the following line::"
msgstr ""
"Все определения функций, типов и макросов, необходимые для использования API "
"Python/C, включаются в ваш код следующей строкой:"

#: ../../c-api/intro.rst:54
msgid ""
"This implies inclusion of the following standard headers: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>`` and ``<stdlib."
"h>`` (if available)."
msgstr ""
"Это подразумевает включение следующих стандартных заголовков: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, `` `<assert.h>`` и ``<stdlib."
"h>`` (если доступны)."

#: ../../c-api/intro.rst:60
msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before "
"any standard headers are included."
msgstr ""
"Поскольку Python может определять некоторые определения препроцессора, "
"которые влияют на стандартные заголовки в некоторых системах, вы *должны* "
"включить :file:`Python.h` перед включением любых стандартных заголовков."

#: ../../c-api/intro.rst:64
msgid ""
"It is recommended to always define ``PY_SSIZE_T_CLEAN`` before including "
"``Python.h``.  See :ref:`arg-parsing` for a description of this macro."
msgstr ""
"Рекомендуется всегда определять PY_SSIZE_T_CLEAN перед включением Python.h. "
"См. :ref:`arg-parsing` для описания этого макроса."

#: ../../c-api/intro.rst:67
msgid ""
"All user visible names defined by Python.h (except those defined by the "
"included standard headers) have one of the prefixes ``Py`` or ``_Py``.  "
"Names beginning with ``_Py`` are for internal use by the Python "
"implementation and should not be used by extension writers. Structure member "
"names do not have a reserved prefix."
msgstr ""
"Все видимые пользователем имена, определенные в Python.h (кроме тех, которые "
"определены включенными стандартными заголовками), имеют один из префиксов "
"``Py`` или ``_Py``. Имена, начинающиеся с ``_Py``, предназначены для "
"внутреннего использования реализацией Python и не должны использоваться "
"авторами расширений. Имена членов структуры не имеют зарезервированного "
"префикса."

#: ../../c-api/intro.rst:74
msgid ""
"User code should never define names that begin with ``Py`` or ``_Py``. This "
"confuses the reader, and jeopardizes the portability of the user code to "
"future Python versions, which may define additional names beginning with one "
"of these prefixes."
msgstr ""
"Пользовательский код никогда не должен определять имена, начинающиеся с "
"``Py`` или ``_Py``. Это сбивает с толку читателя и ставит под угрозу "
"переносимость пользовательского кода в будущие версии Python, которые могут "
"определять дополнительные имена, начинающиеся с одного из этих префиксов."

#: ../../c-api/intro.rst:79
msgid ""
"The header files are typically installed with Python.  On Unix, these  are "
"located in the directories :file:`{prefix}/include/pythonversion/` and :file:"
"`{exec_prefix}/include/pythonversion/`, where :envvar:`prefix` and :envvar:"
"`exec_prefix` are defined by the corresponding parameters to Python's :"
"program:`configure` script and *version* is ``'%d.%d' % sys."
"version_info[:2]``.  On Windows, the headers are installed in :file:"
"`{prefix}/include`, where :envvar:`prefix` is the installation directory "
"specified to the installer."
msgstr ""

#: ../../c-api/intro.rst:88
msgid ""
"To include the headers, place both directories (if different) on your "
"compiler's search path for includes.  Do *not* place the parent directories "
"on the search path and then use ``#include <pythonX.Y/Python.h>``; this will "
"break on multi-platform builds since the platform independent headers under :"
"envvar:`prefix` include the platform specific headers from :envvar:"
"`exec_prefix`."
msgstr ""

#: ../../c-api/intro.rst:95
msgid ""
"C++ users should note that although the API is defined entirely using C, the "
"header files properly declare the entry points to be ``extern \"C\"``. As a "
"result, there is no need to do anything special to use the API from C++."
msgstr ""
"Пользователи C++ должны учитывать, что хотя API полностью определен с "
"использованием C, в файлах заголовков правильно объявляются точки входа как "
"«extern «C»». В результате для использования API из C++ не нужно делать "
"ничего особенного."

#: ../../c-api/intro.rst:101
msgid "Useful macros"
msgstr "Полезные макросы"

#: ../../c-api/intro.rst:103
msgid ""
"Several useful macros are defined in the Python header files.  Many are "
"defined closer to where they are useful (e.g. :c:macro:`Py_RETURN_NONE`). "
"Others of a more general utility are defined here.  This is not necessarily "
"a complete listing."
msgstr ""
"Несколько полезных макросов определены в файлах заголовков Python. Многие из "
"них определены ближе к тому месту, где они полезны (например, :c:macro:"
"`Py_RETURN_NONE`). Здесь определены другие, более общего назначения. Это не "
"обязательно полный список."

#: ../../c-api/intro.rst:110
msgid ""
"Use this when you have a code path that cannot be reached by design. For "
"example, in the ``default:`` clause in a ``switch`` statement for which all "
"possible values are covered in ``case`` statements.  Use this in places "
"where you might be tempted to put an ``assert(0)`` or ``abort()`` call."
msgstr ""
"Используйте это, когда у вас есть путь кода, который не может быть достигнут "
"по замыслу. Например, в предложении ``default:`` в операторе ``switch``, для "
"которого все возможные значения охвачены операторами ``case``. Используйте "
"это в тех местах, где у вас может возникнуть соблазн поместить вызов "
"``assert(0)`` или ``abort()``."

#: ../../c-api/intro.rst:115
msgid ""
"In release mode, the macro helps the compiler to optimize the code, and "
"avoids a warning about unreachable code.  For example, the macro is "
"implemented with ``__builtin_unreachable()`` on GCC in release mode."
msgstr ""
"В режиме выпуска макрос помогает компилятору оптимизировать код и позволяет "
"избежать предупреждения о недостижимом коде. Например, макрос реализован с "
"помощью ``__builtin_unreachable()`` в GCC в режиме выпуска."

#: ../../c-api/intro.rst:119
msgid ""
"A use for ``Py_UNREACHABLE()`` is following a call a function that never "
"returns but that is not declared :c:macro:`_Py_NO_RETURN`."
msgstr ""
"Использование ``Py_UNREACHABLE()`` происходит после вызова функции, которая "
"никогда не возвращает результат, но не объявлена ​​:c:macro:`_Py_NO_RETURN`."

#: ../../c-api/intro.rst:122
msgid ""
"If a code path is very unlikely code but can be reached under exceptional "
"case, this macro must not be used.  For example, under low memory condition "
"or if a system call returns a value out of the expected range.  In this "
"case, it's better to report the error to the caller.  If the error cannot be "
"reported to caller, :c:func:`Py_FatalError` can be used."
msgstr ""
"Если путь кода маловероятен, но может быть достигнут в исключительных "
"случаях, этот макрос использовать нельзя. Например, при нехватке памяти или "
"если системный вызов возвращает значение, выходящее за пределы ожидаемого "
"диапазона. В этом случае лучше сообщить об ошибке вызывающему абоненту. Если "
"об ошибке невозможно сообщить вызывающему абоненту, можно использовать :c:"
"func:`Py_FatalError`."

#: ../../c-api/intro.rst:132
msgid "Return the absolute value of ``x``."
msgstr "Вернуть абсолютное значение ``x``."

#: ../../c-api/intro.rst:138
msgid "Return the minimum value between ``x`` and ``y``."
msgstr "Возвращает минимальное значение между ``x`` и ``y``."

#: ../../c-api/intro.rst:144
msgid "Return the maximum value between ``x`` and ``y``."
msgstr "Возвращает максимальное значение между ``x`` и ``y``."

#: ../../c-api/intro.rst:150
msgid ""
"Convert ``x`` to a C string.  E.g. ``Py_STRINGIFY(123)`` returns ``\"123\"``."
msgstr ""
"Преобразуйте ``x`` в строку C. Например, ``Py_STRINGIFY(123)`` возвращает "
"``\"123\"``."

#: ../../c-api/intro.rst:157
msgid "Return the size of a structure (``type``) ``member`` in bytes."
msgstr "Возвращает размер структуры («типа») «члена» в байтах."

#: ../../c-api/intro.rst:163
msgid ""
"Argument must be a character or an integer in the range [-128, 127] or [0, "
"255].  This macro returns ``c`` cast to an ``unsigned char``."
msgstr ""
"Аргумент должен быть символом или целым числом в диапазоне [-128, 127] или "
"[0, 255]. Этот макрос возвращает приведение ``c`` к ``unsigned char``."

#: ../../c-api/intro.rst:168
msgid ""
"Like ``getenv(s)``, but returns ``NULL`` if :option:`-E` was passed on the "
"command line (i.e. if ``Py_IgnoreEnvironmentFlag`` is set)."
msgstr ""

#: ../../c-api/intro.rst:173
msgid ""
"Use this for unused arguments in a function definition to silence compiler "
"warnings. Example: ``int func(int a, int Py_UNUSED(b)) { return a; }``."
msgstr ""
"Используйте это для неиспользуемых аргументов в определении функции, чтобы "
"отключить предупреждения компилятора. Пример: ``int func(int a, int "
"Py_UNUSED(b)) { return a; }``."

#: ../../c-api/intro.rst:180
msgid ""
"Use this for deprecated declarations.  The macro must be placed before the "
"symbol name."
msgstr ""
"Используйте это для устаревших объявлений. Макрос должен быть помещен перед "
"именем символа."

#: ../../c-api/intro.rst:183 ../../c-api/intro.rst:198
#: ../../c-api/intro.rst:216
msgid "Example::"
msgstr "Пример::"

#: ../../c-api/intro.rst:187
msgid "MSVC support was added."
msgstr "Добавлена ​​поддержка MSVC."

#: ../../c-api/intro.rst:192
msgid ""
"Creates a variable with name ``name`` that can be used in docstrings. If "
"Python is built without docstrings, the value will be empty."
msgstr ""
"Создает переменную с именем ``name``, которую можно использовать в строках "
"документации. Если Python собран без строк документации, значение будет "
"пустым."

#: ../../c-api/intro.rst:195
msgid ""
"Use :c:macro:`PyDoc_STRVAR` for docstrings to support building Python "
"without docstrings, as specified in :pep:`7`."
msgstr ""
"Используйте :c:macro:`PyDoc_STRVAR` для строк документации, чтобы "
"поддерживать сборку Python без строк документации, как указано в :pep:`7`."

#: ../../c-api/intro.rst:210
msgid ""
"Creates a docstring for the given input string or an empty string if "
"docstrings are disabled."
msgstr ""
"Создает строку документации для данной входной строки или пустую строку, "
"если строки документации отключены."

#: ../../c-api/intro.rst:213
msgid ""
"Use :c:macro:`PyDoc_STR` in specifying docstrings to support building Python "
"without docstrings, as specified in :pep:`7`."
msgstr ""
"Используйте :c:macro:`PyDoc_STR` при указании строк документации для "
"поддержки сборки Python без строк документации, как указано в :pep:`7`."

#: ../../c-api/intro.rst:227
msgid "Objects, Types and Reference Counts"
msgstr "Объекты, типы и счетчики ссылок"

#: ../../c-api/intro.rst:231
msgid ""
"Most Python/C API functions have one or more arguments as well as a return "
"value of type :c:type:`PyObject*`.  This type is a pointer to an opaque data "
"type representing an arbitrary Python object.  Since all Python object types "
"are treated the same way by the Python language in most situations (e.g., "
"assignments, scope rules, and argument passing), it is only fitting that "
"they should be represented by a single C type.  Almost all Python objects "
"live on the heap: you never declare an automatic or static variable of type :"
"c:type:`PyObject`, only pointer variables of type :c:type:`PyObject*` can  "
"be declared.  The sole exception are the type objects; since these must "
"never be deallocated, they are typically static :c:type:`PyTypeObject` "
"objects."
msgstr ""

#: ../../c-api/intro.rst:242
msgid ""
"All Python objects (even Python integers) have a :dfn:`type` and a :dfn:"
"`reference count`.  An object's type determines what kind of object it is (e."
"g., an integer, a list, or a user-defined function; there are many more as "
"explained in :ref:`types`).  For each of the well-known types there is a "
"macro to check whether an object is of that type; for instance, "
"``PyList_Check(a)`` is true if (and only if) the object pointed to by *a* is "
"a Python list."
msgstr ""
"Все объекты Python (даже целые числа Python) имеют :dfn:`type` и :dfn:"
"`счетчик ссылок`. Тип объекта определяет, какой это тип объекта (например, "
"целое число, список или определяемая пользователем функция; их гораздо "
"больше, как описано в :ref:`types`). Для каждого из известных типов "
"существует макрос, проверяющий, относится ли объект к этому типу; например, "
"``PyList_Check(a)`` истинно, если (и только если) объект, на который "
"указывает *a*, является списком Python."

#: ../../c-api/intro.rst:253
msgid "Reference Counts"
msgstr "Количество ссылок"

#: ../../c-api/intro.rst:255
msgid ""
"The reference count is important because today's computers have a  finite "
"(and often severely limited) memory size; it counts how many  different "
"places there are that have a reference to an object.  Such a  place could be "
"another object, or a global (or static) C variable, or  a local variable in "
"some C function. When an object's reference count  becomes zero, the object "
"is deallocated.  If it contains references to  other objects, their "
"reference count is decremented. Those other  objects may be deallocated in "
"turn, if this decrement makes their reference count become zero, and so on.  "
"(There's an obvious problem  with objects that reference each other here; "
"for now, the solution is  \"don't do that.\")"
msgstr ""

#: ../../c-api/intro.rst:270
msgid ""
"Reference counts are always manipulated explicitly.  The normal way is  to "
"use the macro :c:func:`Py_INCREF` to increment an object's reference count "
"by one, and :c:func:`Py_DECREF` to decrement it by   one.  The :c:func:"
"`Py_DECREF` macro is considerably more complex than the incref one, since it "
"must check whether the reference count becomes zero and then cause the "
"object's deallocator to be called. The deallocator is a function pointer "
"contained in the object's type structure.  The type-specific deallocator "
"takes care of decrementing the reference counts for other objects contained "
"in the object if this is a compound object type, such as a list, as well as "
"performing any additional finalization that's needed.  There's no chance "
"that the reference count can overflow; at least as many bits are used to "
"hold the reference count as there are distinct memory locations in virtual "
"memory (assuming ``sizeof(Py_ssize_t) >= sizeof(void*)``). Thus, the "
"reference count increment is a simple operation."
msgstr ""

#: ../../c-api/intro.rst:284
msgid ""
"It is not necessary to increment an object's reference count for every  "
"local variable that contains a pointer to an object.  In theory, the  "
"object's reference count goes up by one when the variable is made to  point "
"to it and it goes down by one when the variable goes out of  scope.  "
"However, these two cancel each other out, so at the end the  reference count "
"hasn't changed.  The only real reason to use the  reference count is to "
"prevent the object from being deallocated as  long as our variable is "
"pointing to it.  If we know that there is at  least one other reference to "
"the object that lives at least as long as our variable, there is no need to "
"increment the reference count  temporarily. An important situation where "
"this arises is in objects  that are passed as arguments to C functions in an "
"extension module  that are called from Python; the call mechanism guarantees "
"to hold a  reference to every argument for the duration of the call."
msgstr ""

#: ../../c-api/intro.rst:298
msgid ""
"However, a common pitfall is to extract an object from a list and hold on to "
"it for a while without incrementing its reference count. Some other "
"operation might conceivably remove the object from the list, decrementing "
"its reference count and possibly deallocating it. The real danger is that "
"innocent-looking operations may invoke arbitrary Python code which could do "
"this; there is a code path which allows control to flow back to the user "
"from a :c:func:`Py_DECREF`, so almost any operation is potentially dangerous."
msgstr ""

#: ../../c-api/intro.rst:306
msgid ""
"A safe approach is to always use the generic operations (functions  whose "
"name begins with ``PyObject_``, ``PyNumber_``, ``PySequence_`` or "
"``PyMapping_``). These operations always increment the reference count of "
"the object they return. This leaves the caller with the responsibility to "
"call :c:func:`Py_DECREF` when they are done with the result; this soon "
"becomes second nature."
msgstr ""

#: ../../c-api/intro.rst:316
msgid "Reference Count Details"
msgstr "Сведения о количестве ссылок"

#: ../../c-api/intro.rst:318
msgid ""
"The reference count behavior of functions in the Python/C API is best  "
"explained in terms of *ownership of references*.  Ownership pertains to "
"references, never to objects (objects are not owned: they are always "
"shared).  \"Owning a reference\" means being responsible for calling "
"Py_DECREF on it when the reference is no longer needed.  Ownership can also "
"be transferred, meaning that the code that receives ownership of the "
"reference then becomes responsible for eventually decref'ing it by calling :"
"c:func:`Py_DECREF` or :c:func:`Py_XDECREF` when it's no longer needed---or "
"passing on this responsibility (usually to its caller). When a function "
"passes ownership of a reference on to its caller, the caller is said to "
"receive a *new* reference.  When no ownership is transferred, the caller is "
"said to *borrow* the reference. Nothing needs to be done for a borrowed "
"reference."
msgstr ""

#: ../../c-api/intro.rst:331
msgid ""
"Conversely, when a calling function passes in a reference to an  object, "
"there are two possibilities: the function *steals* a  reference to the "
"object, or it does not.  *Stealing a reference* means that when you pass a "
"reference to a function, that function assumes that it now owns that "
"reference, and you are not responsible for it any longer."
msgstr ""
"И наоборот, когда вызывающая функция передает ссылку на объект, есть две "
"возможности: функция *крадет* ссылку на объект или нет. *Кража ссылки* "
"означает, что когда вы передаете ссылку функции, эта функция предполагает, "
"что теперь эта ссылка принадлежит ей, и вы больше не несете за нее "
"ответственности."

#: ../../c-api/intro.rst:341
msgid ""
"Few functions steal references; the two notable exceptions are :c:func:"
"`PyList_SetItem` and :c:func:`PyTuple_SetItem`, which  steal a reference to "
"the item (but not to the tuple or list into which the item is put!).  These "
"functions were designed to steal a reference because of a common idiom for "
"populating a tuple or list with newly created objects; for example, the code "
"to create the tuple ``(1, 2, \"three\")`` could look like this (forgetting "
"about error handling for the moment; a better way to code this is shown "
"below)::"
msgstr ""
"Лишь немногие функции крадут ссылки; двумя заметными исключениями являются :"
"c:func:`PyList_SetItem` и :c:func:`PyTuple_SetItem`, которые крадут ссылку "
"на элемент (но не на кортеж или список, в который помещен этот элемент!). "
"Эти функции были разработаны для кражи ссылки из-за распространенной идиомы "
"заполнения кортежа или списка вновь созданными объектами; например, код для "
"создания кортежа ``(1, 2, \"three\")\" может выглядеть так (на данный момент "
"мы забываем об обработке ошибок; лучший способ закодировать это показан "
"ниже):"

#: ../../c-api/intro.rst:356
msgid ""
"Here, :c:func:`PyLong_FromLong` returns a new reference which is immediately "
"stolen by :c:func:`PyTuple_SetItem`.  When you want to keep using an object "
"although the reference to it will be stolen, use :c:func:`Py_INCREF` to grab "
"another reference before calling the reference-stealing function."
msgstr ""
"Здесь :c:func:`PyLong_FromLong` возвращает новую ссылку, которая немедленно "
"украдена :c:func:`PyTuple_SetItem`. Если вы хотите продолжать использовать "
"объект, хотя ссылка на него будет украдена, используйте :c:func:`Py_INCREF`, "
"чтобы получить другую ссылку перед вызовом функции кражи ссылки."

#: ../../c-api/intro.rst:361
msgid ""
"Incidentally, :c:func:`PyTuple_SetItem` is the *only* way to set tuple "
"items; :c:func:`PySequence_SetItem` and :c:func:`PyObject_SetItem` refuse to "
"do this since tuples are an immutable data type.  You should only use :c:"
"func:`PyTuple_SetItem` for tuples that you are creating yourself."
msgstr ""
"Кстати, :c:func:`PyTuple_SetItem` — это *единственный* способ установить "
"элементы кортежа; :c:func:`PySequence_SetItem` и :c:func:`PyObject_SetItem` "
"отказываются это делать, поскольку кортежи являются неизменяемым типом "
"данных. Вам следует использовать :c:func:`PyTuple_SetItem` только для "
"кортежей, которые вы создаете самостоятельно."

#: ../../c-api/intro.rst:366
msgid ""
"Equivalent code for populating a list can be written using :c:func:"
"`PyList_New` and :c:func:`PyList_SetItem`."
msgstr ""
"Эквивалентный код для заполнения списка можно написать с помощью :c:func:"
"`PyList_New` и :c:func:`PyList_SetItem`."

#: ../../c-api/intro.rst:369
msgid ""
"However, in practice, you will rarely use these ways of creating and "
"populating a tuple or list.  There's a generic function, :c:func:"
"`Py_BuildValue`, that can create most common objects from C values, directed "
"by a :dfn:`format string`. For example, the above two blocks of code could "
"be replaced by the following (which also takes care of the error checking)::"
msgstr ""
"Однако на практике вы редко будете использовать эти способы создания и "
"заполнения кортежа или списка. Существует общая функция :c:func:"
"`Py_BuildValue`, которая может создавать наиболее распространенные объекты "
"из значений C, управляемых :dfn:`строкой формата`. Например, приведенные "
"выше два блока кода можно заменить следующим (который также обеспечивает "
"проверку ошибок):"

#: ../../c-api/intro.rst:380
msgid ""
"It is much more common to use :c:func:`PyObject_SetItem` and friends with "
"items whose references you are only borrowing, like arguments that were "
"passed in to the function you are writing.  In that case, their behaviour "
"regarding reference counts is much saner, since you don't have to increment "
"a reference count so you can give a reference away (\"have it be stolen\").  "
"For example, this function sets all items of a list (actually, any mutable "
"sequence) to a given item::"
msgstr ""

#: ../../c-api/intro.rst:410
msgid ""
"The situation is slightly different for function return values.   While "
"passing a reference to most functions does not change your  ownership "
"responsibilities for that reference, many functions that  return a reference "
"to an object give you ownership of the reference. The reason is simple: in "
"many cases, the returned object is created  on the fly, and the reference "
"you get is the only reference to the  object.  Therefore, the generic "
"functions that return object references, like :c:func:`PyObject_GetItem` "
"and  :c:func:`PySequence_GetItem`, always return a new reference (the caller "
"becomes the owner of the reference)."
msgstr ""
"Ситуация немного отличается для возвращаемых значений функции. Хотя передача "
"ссылки на большинство функций не меняет ваших обязанностей владения этой "
"ссылкой, многие функции, возвращающие ссылку на объект, дают вам право "
"собственности на ссылку. Причина проста: во многих случаях возвращаемый "
"объект создается «на лету», и полученная вами ссылка является единственной "
"ссылкой на объект. Поэтому универсальные функции, возвращающие ссылки на "
"объекты, такие как :c:func:`PyObject_GetItem` и :c:func:"
"`PySequence_GetItem`, всегда возвращают новую ссылку (вызывающая сторона "
"становится владельцем ссылки)."

#: ../../c-api/intro.rst:419
msgid ""
"It is important to realize that whether you own a reference returned  by a "
"function depends on which function you call only --- *the plumage* (the type "
"of the object passed as an argument to the function) *doesn't enter into it!"
"* Thus, if you  extract an item from a list using :c:func:`PyList_GetItem`, "
"you don't own the reference --- but if you obtain the same item from the "
"same list using :c:func:`PySequence_GetItem` (which happens to take exactly "
"the same arguments), you do own a reference to the returned object."
msgstr ""
"Важно понимать, что то, являетесь ли вы владельцем ссылки, возвращаемой "
"функцией, зависит только от того, какую функцию вы вызываете --- *оперение* "
"(тип объекта, передаваемого в качестве аргумента функции) *не входит в него !"
"* Таким образом, если вы извлекаете элемент из списка, используя :c:func:"
"`PyList_GetItem`, вы не являетесь владельцем ссылки --- но если вы получаете "
"тот же элемент из того же списка, используя :c:func:` PySequence_GetItem` "
"(который принимает точно такие же аргументы), у вас есть ссылка на "
"возвращаемый объект."

#: ../../c-api/intro.rst:431
msgid ""
"Here is an example of how you could write a function that computes the sum "
"of the items in a list of integers; once using  :c:func:`PyList_GetItem`, "
"and once using :c:func:`PySequence_GetItem`. ::"
msgstr ""
"Вот пример того, как можно написать функцию, вычисляющую сумму элементов в "
"списке целых чисел; один раз с использованием :c:func:`PyList_GetItem` и "
"один раз с использованием :c:func:`PySequence_GetItem`. ::"

#: ../../c-api/intro.rst:495
msgid "Types"
msgstr "Типы"

#: ../../c-api/intro.rst:497
msgid ""
"There are few other data types that play a significant role in  the Python/C "
"API; most are simple C types such as :c:type:`int`,  :c:type:`long`, :c:type:"
"`double` and :c:type:`char*`.  A few structure types  are used to describe "
"static tables used to list the functions exported  by a module or the data "
"attributes of a new object type, and another is used to describe the value "
"of a complex number.  These will  be discussed together with the functions "
"that use them."
msgstr ""

#: ../../c-api/intro.rst:507
msgid ""
"A signed integral type such that ``sizeof(Py_ssize_t) == sizeof(size_t)``. "
"C99 doesn't define such a thing directly (size_t is an unsigned integral "
"type). See :pep:`353` for details. ``PY_SSIZE_T_MAX`` is the largest "
"positive value of type :c:type:`Py_ssize_t`."
msgstr ""
"Целочисленный тип со знаком, такой как ``sizeof(Py_ssize_t) == "
"sizeof(size_t)``. C99 не определяет такую ​​вещь напрямую (size_t — это "
"целочисленный тип без знака). Подробности смотрите в :pep:`353`. "
"``PY_SSIZE_T_MAX`` ​​— это наибольшее положительное значение типа :c:type:"
"`Py_ssize_t`."

#: ../../c-api/intro.rst:516
msgid "Exceptions"
msgstr "Исключения"

#: ../../c-api/intro.rst:518
msgid ""
"The Python programmer only needs to deal with exceptions if specific  error "
"handling is required; unhandled exceptions are automatically  propagated to "
"the caller, then to the caller's caller, and so on, until they reach the top-"
"level interpreter, where they are reported to the  user accompanied by a "
"stack traceback."
msgstr ""
"Программисту Python необходимо иметь дело с исключениями только в том "
"случае, если требуется специальная обработка ошибок; необработанные "
"исключения автоматически передаются вызывающему объекту, затем вызывающему "
"объекту и так далее, пока не достигнут интерпретатора верхнего уровня, где о "
"них сообщается пользователю вместе с обратной трассировкой стека."

#: ../../c-api/intro.rst:526
msgid ""
"For C programmers, however, error checking always has to be explicit.  All "
"functions in the Python/C API can raise exceptions, unless an explicit claim "
"is made otherwise in a function's documentation.  In general, when a "
"function encounters an error, it sets an exception, discards any object "
"references that it owns, and returns an error indicator.  If not documented "
"otherwise, this indicator is either ``NULL`` or ``-1``, depending on the "
"function's return type. A few functions return a Boolean true/false result, "
"with false indicating an error.  Very few functions return no explicit error "
"indicator or have an ambiguous return value, and require explicit testing "
"for errors with :c:func:`PyErr_Occurred`.  These exceptions are always "
"explicitly documented."
msgstr ""
"Однако для программистов на C проверка ошибок всегда должна быть явной. Все "
"функции в API Python/C могут вызывать исключения, если иное не указано в "
"документации к функции. Обычно, когда функция обнаруживает ошибку, она "
"устанавливает исключение, отбрасывает все ссылки на объекты, которыми она "
"владеет, и возвращает индикатор ошибки. Если не указано иное, этот индикатор "
"имеет значение либо NULL, либо -1, в зависимости от типа возвращаемого "
"значения функции. Некоторые функции возвращают логический результат true/"
"false, где false указывает на ошибку. Очень немногие функции не возвращают "
"явного индикатора ошибки или имеют неоднозначное возвращаемое значение и "
"требуют явного тестирования на наличие ошибок с помощью :c:func:"
"`PyErr_Occurred`. Эти исключения всегда явно документируются."

#: ../../c-api/intro.rst:541
msgid ""
"Exception state is maintained in per-thread storage (this is  equivalent to "
"using global storage in an unthreaded application).  A  thread can be in one "
"of two states: an exception has occurred, or not. The function :c:func:"
"`PyErr_Occurred` can be used to check for this: it returns a borrowed "
"reference to the exception type object when an exception has occurred, and "
"``NULL`` otherwise.  There are a number of functions to set the exception "
"state: :c:func:`PyErr_SetString` is the most common (though not the most "
"general) function to set the exception state, and :c:func:`PyErr_Clear` "
"clears the exception state."
msgstr ""
"Состояние исключения поддерживается в хранилище каждого потока (это "
"эквивалентно использованию глобального хранилища в беспоточном приложении). "
"Поток может находиться в одном из двух состояний: произошло исключение или "
"нет. Для проверки этого можно использовать функцию :c:func:`PyErr_Occurred`: "
"она возвращает заимствованную ссылку на объект типа исключения, если "
"исключение произошло, и ``NULL`` в противном случае. Существует ряд функций "
"для установки состояния исключения: :c:func:`PyErr_SetString` — самая "
"распространенная (хотя и не самая общая) функция для установки состояния "
"исключения, а :c:func:`PyErr_Clear` очищает исключение. состояние."

#: ../../c-api/intro.rst:551
msgid ""
"The full exception state consists of three objects (all of which can  be "
"``NULL``): the exception type, the corresponding exception  value, and the "
"traceback.  These have the same meanings as the Python result of ``sys."
"exc_info()``; however, they are not the same: the Python objects represent "
"the last exception being handled by a Python  :keyword:`try` ... :keyword:"
"`except` statement, while the C level exception state only exists while an "
"exception is being passed on between C functions until it reaches the Python "
"bytecode interpreter's  main loop, which takes care of transferring it to "
"``sys.exc_info()`` and friends."
msgstr ""
"Полное состояние исключения состоит из трех объектов (каждый из которых "
"может иметь значение NULL): тип исключения, соответствующее значение "
"исключения и обратная трассировка. Они имеют тот же смысл, что и результат "
"Python ``sys.exc_info()``; однако они не одинаковы: объекты Python "
"представляют собой последнее исключение, обрабатываемое оператором Python :"
"keyword:`try` ... :keyword:`Exception`, в то время как состояние исключения "
"уровня C существует только во время возникновения исключения. передается "
"между функциями C, пока не достигнет основного цикла интерпретатора байт-"
"кода Python, который заботится о передаче его в ``sys.exc_info()`` и его "
"друзей."

#: ../../c-api/intro.rst:563
msgid ""
"Note that starting with Python 1.5, the preferred, thread-safe way to access "
"the exception state from Python code is to call the function :func:`sys."
"exc_info`, which returns the per-thread exception state for Python code.  "
"Also, the semantics of both ways to access the exception state have changed "
"so that a function which catches an exception will save and restore its "
"thread's exception state so as to preserve the exception state of its "
"caller.  This prevents common bugs in exception handling code caused by an "
"innocent-looking function overwriting the exception being handled; it also "
"reduces the often unwanted lifetime extension for objects that are "
"referenced by the stack frames in the traceback."
msgstr ""
"Обратите внимание, что начиная с Python 1.5 предпочтительным "
"потокобезопасным способом доступа к состоянию исключения из кода Python "
"является вызов функции :func:`sys.exc_info`, которая возвращает состояние "
"исключения для каждого потока для кода Python. Кроме того, семантика обоих "
"способов доступа к состоянию исключения изменилась: функция, перехватывающая "
"исключение, сохраняет и восстанавливает состояние исключения своего потока, "
"чтобы сохранить состояние исключения вызывающего объекта. Это предотвращает "
"распространенные ошибки в коде обработки исключений, вызванные тем, что "
"невинно выглядящая функция перезаписывает обрабатываемое исключение; это "
"также уменьшает часто нежелательное продление срока службы для объектов, на "
"которые ссылаются кадры стека в обратной трассировке."

#: ../../c-api/intro.rst:574
msgid ""
"As a general principle, a function that calls another function to  perform "
"some task should check whether the called function raised an  exception, and "
"if so, pass the exception state on to its caller.  It  should discard any "
"object references that it owns, and return an  error indicator, but it "
"should *not* set another exception --- that would overwrite the exception "
"that was just raised, and lose important information about the exact cause "
"of the error."
msgstr ""
"В качестве общего принципа функция, которая вызывает другую функцию для "
"выполнения некоторой задачи, должна проверить, вызвала ли вызванная функция "
"исключение, и если да, передать состояние исключения вызывающей стороне. Он "
"должен отбрасывать все ссылки на объекты, которыми он владеет, и возвращать "
"индикатор ошибки, но он *не* должен устанавливать другое исключение, которое "
"перезапишет только что созданное исключение и потеряет важную информацию о "
"точной причине ошибки."

#: ../../c-api/intro.rst:583
msgid ""
"A simple example of detecting exceptions and passing them on is shown in "
"the :c:func:`sum_sequence` example above.  It so happens that this example "
"doesn't need to clean up any owned references when it detects an error.  The "
"following example function shows some error cleanup.  First, to remind you "
"why you like Python, we show the equivalent Python code::"
msgstr ""

#: ../../c-api/intro.rst:598
msgid "Here is the corresponding C code, in all its glory::"
msgstr "Вот соответствующий код C во всей красе:"

#: ../../c-api/intro.rst:650
msgid ""
"This example represents an endorsed use of the ``goto`` statement  in C! It "
"illustrates the use of :c:func:`PyErr_ExceptionMatches` and :c:func:"
"`PyErr_Clear` to handle specific exceptions, and the use of :c:func:"
"`Py_XDECREF` to dispose of owned references that may be ``NULL`` (note the "
"``'X'`` in the name; :c:func:`Py_DECREF` would crash when confronted with a "
"``NULL`` reference).  It is important that the variables used to hold owned "
"references are initialized to ``NULL`` for this to work; likewise, the "
"proposed return value is initialized to ``-1`` (failure) and only set to "
"success after the final call made is successful."
msgstr ""
"Этот пример представляет собой одобренное использование оператора goto в C! "
"Он иллюстрирует использование :c:func:`PyErr_ExceptionMatches` и :c:func:"
"`PyErr_Clear` для обработки определенных исключений, а также использование :"
"c:func:`Py_XDECREF` для удаления собственных ссылок, которые могут иметь "
"значение ``NULL'. `` (обратите внимание на ``'X'`` в имени; :c:func:"
"`Py_DECREF` приведет к сбою при столкновении со ссылкой ``NULL``). Для того "
"чтобы это работало, важно, чтобы переменные, используемые для хранения "
"собственных ссылок, были инициализированы значением NULL; аналогично, "
"предлагаемое возвращаемое значение инициализируется как «-1» (сбой) и "
"устанавливается на успех только после того, как последний сделанный вызов "
"окажется успешным."

#: ../../c-api/intro.rst:664
msgid "Embedding Python"
msgstr "Внедрение Python"

#: ../../c-api/intro.rst:666
msgid ""
"The one important task that only embedders (as opposed to extension writers) "
"of the Python interpreter have to worry about is the initialization, and "
"possibly the finalization, of the Python interpreter.  Most functionality of "
"the interpreter can only be used after the interpreter has been initialized."
msgstr ""
"Единственная важная задача, о которой должны беспокоиться только "
"разработчики (в отличие от разработчиков расширений) интерпретатора Python, "
"— это инициализация и, возможно, завершение интерпретатора Python. Большую "
"часть функций интерпретатора можно использовать только после его "
"инициализации."

#: ../../c-api/intro.rst:679
msgid ""
"The basic initialization function is :c:func:`Py_Initialize`. This "
"initializes the table of loaded modules, and creates the fundamental "
"modules :mod:`builtins`, :mod:`__main__`, and :mod:`sys`.  It also "
"initializes the module search path (``sys.path``)."
msgstr ""
"Базовая функция инициализации — :c:func:`Py_Initialize`. Это инициализирует "
"таблицу загруженных модулей и создает основные модули :mod:`builtins`, :mod:"
"`__main__` и :mod:`sys`. Он также инициализирует путь поиска модуля (``sys."
"path``)."

#: ../../c-api/intro.rst:686
msgid ""
":c:func:`Py_Initialize` does not set the \"script argument list\"  (``sys."
"argv``). If this variable is needed by Python code that will be executed "
"later, it must be set explicitly with a call to  ``PySys_SetArgvEx(argc, "
"argv, updatepath)`` after the call to :c:func:`Py_Initialize`."
msgstr ""

#: ../../c-api/intro.rst:691
msgid ""
"On most systems (in particular, on Unix and Windows, although the details "
"are slightly different), :c:func:`Py_Initialize` calculates the module "
"search path based upon its best guess for the location of the standard "
"Python interpreter executable, assuming that the Python library is found in "
"a fixed location relative to the Python interpreter executable.  In "
"particular, it looks for a directory named :file:`lib/python{X.Y}` relative "
"to the parent directory where the executable named :file:`python` is found "
"on the shell command search path (the environment variable :envvar:`PATH`)."
msgstr ""
"В большинстве систем (в частности, в Unix и Windows, хотя детали немного "
"различаются), :c:func:`Py_Initialize` вычисляет путь поиска модуля на основе "
"наилучшего предположения о расположении стандартного исполняемого файла "
"интерпретатора Python, предполагая, что библиотека Python находится в "
"фиксированном месте относительно исполняемого файла интерпретатора Python. В "
"частности, он ищет каталог с именем :file:`lib/python{XY}` относительно "
"родительского каталога, в котором исполняемый файл с именем :file:`python` "
"находится в пути поиска команд оболочки (переменная среды :envvar: «ПУТЬ»)."

#: ../../c-api/intro.rst:700
msgid ""
"For instance, if the Python executable is found in :file:`/usr/local/bin/"
"python`, it will assume that the libraries are in :file:`/usr/local/lib/"
"python{X.Y}`.  (In fact, this particular path is also the \"fallback\" "
"location, used when no executable file named :file:`python` is found along :"
"envvar:`PATH`.)  The user can override this behavior by setting the "
"environment variable :envvar:`PYTHONHOME`, or insert additional directories "
"in front of the standard path by setting :envvar:`PYTHONPATH`."
msgstr ""
"Например, если исполняемый файл Python находится в :file:`/usr/local/bin/"
"python`, предполагается, что библиотеки находятся в :file:`/usr/local/lib/"
"python{XY}`. (Фактически, этот конкретный путь также является «запасным» "
"местоположением, используемым, когда в :envvar:`PATH` не найден исполняемый "
"файл с именем :file:`python`.) Пользователь может переопределить это "
"поведение, установив переменную среды: envvar:`PYTHONHOME` или вставьте "
"дополнительные каталоги перед стандартным путем, установив :envvar:"
"`PYTHONPATH`."

#: ../../c-api/intro.rst:715
msgid ""
"The embedding application can steer the search by calling "
"``Py_SetProgramName(file)`` *before* calling  :c:func:`Py_Initialize`.  Note "
"that :envvar:`PYTHONHOME` still overrides this and :envvar:`PYTHONPATH` is "
"still inserted in front of the standard path.  An application that requires "
"total control has to provide its own implementation of :c:func:"
"`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, and :c:"
"func:`Py_GetProgramFullPath` (all defined in :file:`Modules/getpath.c`)."
msgstr ""
"Приложение для внедрения может управлять поиском, вызывая "
"``Py_SetProgramName(file)`` *перед* вызовом :c:func:`Py_Initialize`. "
"Обратите внимание, что :envvar:`PYTHONHOME` по-прежнему переопределяет это, "
"а :envvar:`PYTHONPATH` по-прежнему вставляется перед стандартным путем. "
"Приложение, которому требуется полный контроль, должно предоставить "
"собственную реализацию :c:func:`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:func:"
"`Py_GetExecPrefix` и :c:func:`Py_GetProgramFullPath` ( все определено в :"
"file:`Modules/getpath.c`)."

#: ../../c-api/intro.rst:725
msgid ""
"Sometimes, it is desirable to \"uninitialize\" Python.  For instance,  the "
"application may want to start over (make another call to :c:func:"
"`Py_Initialize`) or the application is simply done with its  use of Python "
"and wants to free memory allocated by Python.  This can be accomplished by "
"calling :c:func:`Py_FinalizeEx`.  The function :c:func:`Py_IsInitialized` "
"returns true if Python is currently in the initialized state.  More "
"information about these functions is given in a later chapter. Notice that :"
"c:func:`Py_FinalizeEx` does *not* free all memory allocated by the Python "
"interpreter, e.g. memory allocated by extension modules currently cannot be "
"released."
msgstr ""
"Иногда желательно «неинициализировать» Python. Например, приложение может "
"захотеть начать заново (сделать еще один вызов :c:func:`Py_Initialize`) или "
"приложение просто использует Python и хочет освободить память, выделенную "
"Python. Это можно сделать, вызвав :c:func:`Py_FinalizeEx`. Функция :c:func:"
"`Py_IsInitialized` возвращает true, если Python в данный момент находится в "
"инициализированном состоянии. Более подробная информация об этих функциях "
"приведена в следующей главе. Обратите внимание, что :c:func:`Py_FinalizeEx` "
"*не* освобождает всю память, выделенную интерпретатором Python, например, "
"память, выделенная модулями расширения, в настоящее время не может быть "
"освобождена."

#: ../../c-api/intro.rst:739
msgid "Debugging Builds"
msgstr "Отладочные сборки"

#: ../../c-api/intro.rst:741
msgid ""
"Python can be built with several macros to enable extra checks of the "
"interpreter and extension modules.  These checks tend to add a large amount "
"of overhead to the runtime so they are not enabled by default."
msgstr ""
"Python можно собрать с несколькими макросами, позволяющими проводить "
"дополнительные проверки интерпретатора и модулей расширения. Эти проверки, "
"как правило, увеличивают нагрузку на среду выполнения, поэтому по умолчанию "
"они не включены."

#: ../../c-api/intro.rst:745
msgid ""
"A full list of the various types of debugging builds is in the file :file:"
"`Misc/SpecialBuilds.txt` in the Python source distribution. Builds are "
"available that support tracing of reference counts, debugging the memory "
"allocator, or low-level profiling of the main interpreter loop.  Only the "
"most frequently-used builds will be described in the remainder of this "
"section."
msgstr ""

#: ../../c-api/intro.rst:751
msgid ""
"Compiling the interpreter with the :c:macro:`Py_DEBUG` macro defined "
"produces what is generally meant by \"a debug build\" of Python. :c:macro:"
"`Py_DEBUG` is enabled in the Unix build by adding ``--with-pydebug`` to the :"
"file:`./configure` command.  It is also implied by the presence of the not-"
"Python-specific :c:macro:`_DEBUG` macro.  When :c:macro:`Py_DEBUG` is "
"enabled in the Unix build, compiler optimization is disabled."
msgstr ""

#: ../../c-api/intro.rst:758
msgid ""
"In addition to the reference count debugging described below, the following "
"extra checks are performed:"
msgstr ""

#: ../../c-api/intro.rst:761
msgid "Extra checks are added to the object allocator."
msgstr ""

#: ../../c-api/intro.rst:763
msgid "Extra checks are added to the parser and compiler."
msgstr ""

#: ../../c-api/intro.rst:765
msgid ""
"Downcasts from wide types to narrow types are checked for loss of "
"information."
msgstr ""

#: ../../c-api/intro.rst:767
msgid ""
"A number of assertions are added to the dictionary and set implementations. "
"In addition, the set object acquires a :meth:`test_c_api` method."
msgstr ""

#: ../../c-api/intro.rst:770
msgid "Sanity checks of the input arguments are added to frame creation."
msgstr ""

#: ../../c-api/intro.rst:772
msgid ""
"The storage for ints is initialized with a known invalid pattern to catch "
"reference to uninitialized digits."
msgstr ""

#: ../../c-api/intro.rst:775
msgid ""
"Low-level tracing and extra exception checking are added to the runtime "
"virtual machine."
msgstr ""

#: ../../c-api/intro.rst:778
msgid "Extra checks are added to the memory arena implementation."
msgstr ""

#: ../../c-api/intro.rst:780
msgid "Extra debugging is added to the thread module."
msgstr ""

#: ../../c-api/intro.rst:782
msgid "There may be additional checks not mentioned here."
msgstr ""

#: ../../c-api/intro.rst:784
msgid ""
"Defining :c:macro:`Py_TRACE_REFS` enables reference tracing.  When defined, "
"a circular doubly linked list of active objects is maintained by adding two "
"extra fields to every :c:type:`PyObject`.  Total allocations are tracked as "
"well.  Upon exit, all existing references are printed.  (In interactive mode "
"this happens after every statement run by the interpreter.)  Implied by :c:"
"macro:`Py_DEBUG`."
msgstr ""

#: ../../c-api/intro.rst:790
msgid ""
"Please refer to :file:`Misc/SpecialBuilds.txt` in the Python source "
"distribution for more detailed information."
msgstr ""
"Пожалуйста, обратитесь к :file:`Misc/SpecialBuilds.txt` в дистрибутиве "
"исходного кода Python для получения более подробной информации."
