# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Jon Britva, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:11+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../glossary.rst:5
msgid "Glossary"
msgstr "Глоссарий"

#: ../../glossary.rst:10
msgid "``>>>``"
msgstr "``>>>``"

#: ../../glossary.rst:12
msgid ""
"The default Python prompt of the interactive shell.  Often seen for code "
"examples which can be executed interactively in the interpreter."
msgstr ""
"Приглашение Python по умолчанию интерактивной оболочки. Часто встречается в "
"примерах кода, которые можно выполнить в интерпретаторе в интерактивном "
"режиме."

#: ../../glossary.rst:14
msgid "``...``"
msgstr "``...``"

#: ../../glossary.rst:16
msgid "Can refer to:"
msgstr "Может относиться к:"

#: ../../glossary.rst:18
msgid ""
"The default Python prompt of the interactive shell when entering the code "
"for an indented code block, when within a pair of matching left and right "
"delimiters (parentheses, square brackets, curly braces or triple quotes), or "
"after specifying a decorator."
msgstr ""
"Запрос Python интерактивной оболочки по умолчанию при вводе кода для блока "
"кода с отступом, если он находится внутри пары совпадающих левого и правого "
"разделителей (круглых, квадратных, фигурных скобок или тройных кавычек) или "
"после указания декоратора."

#: ../../glossary.rst:23
msgid "The :const:`Ellipsis` built-in constant."
msgstr "Встроенная константа :const:`Ellipsis`."

#: ../../glossary.rst:24
msgid "2to3"
msgstr "2to3"

#: ../../glossary.rst:26
msgid ""
"A tool that tries to convert Python 2.x code to Python 3.x code by handling "
"most of the incompatibilities which can be detected by parsing the source "
"and traversing the parse tree."
msgstr ""
"Инструмент, который пытается преобразовать код Python 2.x в код Python 3.x, "
"обрабатывая большинство несовместимостей, которые можно обнаружить путем "
"анализа источника и обхода дерева разбора."

#: ../../glossary.rst:30
msgid ""
"2to3 is available in the standard library as :mod:`lib2to3`; a standalone "
"entry point is provided as :file:`Tools/scripts/2to3`.  See :ref:`2to3-"
"reference`."
msgstr ""
"2to3 доступен в стандартной библиотеке как :mod:`lib2to3`; отдельная точка "
"входа предоставляется в виде :file:`Tools/scripts/2to3`. См. :ref:`2to3-"
"reference`."

#: ../../glossary.rst:33
msgid "abstract base class"
msgstr "абстрактный базовый класс"

#: ../../glossary.rst:35
msgid ""
"Abstract base classes complement :term:`duck-typing` by providing a way to "
"define interfaces when other techniques like :func:`hasattr` would be clumsy "
"or subtly wrong (for example with :ref:`magic methods <special-lookup>`).  "
"ABCs introduce virtual subclasses, which are classes that don't inherit from "
"a class but are still recognized by :func:`isinstance` and :func:"
"`issubclass`; see the :mod:`abc` module documentation.  Python comes with "
"many built-in ABCs for data structures (in the :mod:`collections.abc` "
"module), numbers (in the :mod:`numbers` module), streams (in the :mod:`io` "
"module), import finders and loaders (in the :mod:`importlib.abc` module).  "
"You can create your own ABCs with the :mod:`abc` module."
msgstr ""
"Абстрактные базовые классы дополняют «утиную типизацию», предоставляя способ "
"определения интерфейсов, когда другие методы, такие как :func:`hasattr` было "
"бы неуклюже или слегка неправильно (например, с :ref:`магическими методами\n"
"`). ABC вводит виртуальные подклассы — классы, которые не наследуются от "
"класса, но по-прежнему распознаются :func:`isinstance` и :func:"
"`issubclass` ; увидеть :mod:`abc` документация модуля. Python поставляется "
"со множеством встроенных азбук для структур данных (в :mod:`collections.abc` "
"module), numbers (in the :mod:`numbers` module), streams (in the :mod:`io` "
"module), import finders and loaders (in the :mod:`importlib.abc` module). "
"You can create your own ABCs with the :mod:`abc` модуль."

#: ../../glossary.rst:46
msgid "annotation"
msgstr "аннотация"

#: ../../glossary.rst:48
msgid ""
"A label associated with a variable, a class attribute or a function "
"parameter or return value, used by convention as a :term:`type hint`."
msgstr ""
"Метка, связанная с переменной, атрибутом класса или параметром функции или "
"возвращаемым значением, используемая по соглашению как подсказка типа."

#: ../../glossary.rst:52
msgid ""
"Annotations of local variables cannot be accessed at runtime, but "
"annotations of global variables, class attributes, and functions are stored "
"in the :attr:`__annotations__` special attribute of modules, classes, and "
"functions, respectively."
msgstr ""
"Доступ к аннотациям локальных переменных недоступен во время выполнения, но "
"аннотации глобальных переменных, атрибутов классов и функций хранятся в :"
"attr:`__аннотации__` специальный атрибут модулей, классов и функций "
"соответственно."

#: ../../glossary.rst:58
msgid ""
"See :term:`variable annotation`, :term:`function annotation`, :pep:`484` "
"and :pep:`526`, which describe this functionality. Also see :ref:"
"`annotations-howto` for best practices on working with annotations."
msgstr ""
"Доступ к аннотациям локальных переменных недоступен во время выполнения, но "
"аннотации глобальных переменных, атрибутов классов и функций хранятся в :"
"attr:`__аннотации__` специальный атрибут модулей, классов и функций "
"соответственно."

#: ../../glossary.rst:62
msgid "argument"
msgstr "аргумент"

#: ../../glossary.rst:64
msgid ""
"A value passed to a :term:`function` (or :term:`method`) when calling the "
"function.  There are two kinds of argument:"
msgstr ""
"Значение, передаваемое в :term:`функцию` (или :term:`метод`) при вызове "
"функции. Есть два вида аргументов:"

#: ../../glossary.rst:67
msgid ""
":dfn:`keyword argument`: an argument preceded by an identifier (e.g. "
"``name=``) in a function call or passed as a value in a dictionary preceded "
"by ``**``.  For example, ``3`` and ``5`` are both keyword arguments in the "
"following calls to :func:`complex`::"
msgstr ""
"Доступ к аннотациям локальных переменных недоступен во время выполнения, но "
"аннотации глобальных переменных, атрибутов классов и функций хранятся в :"
"attr:`__аннотации__` специальный атрибут модулей, классов и функций "
"соответственно."

#: ../../glossary.rst:75
msgid ""
":dfn:`positional argument`: an argument that is not a keyword argument. "
"Positional arguments can appear at the beginning of an argument list and/or "
"be passed as elements of an :term:`iterable` preceded by ``*``. For example, "
"``3`` and ``5`` are both positional arguments in the following calls::"
msgstr ""
":dfn:`позиционный аргумент`: аргумент, который не является аргументом "
"ключевого слова. Позиционные аргументы могут появляться в начале списка "
"аргументов и/или передаваться как элементы :term:`iterable`, которым "
"предшествует ``*``. Например, ``3`` и ``5`` являются позиционными "
"аргументами в следующих вызовах:"

#: ../../glossary.rst:84
msgid ""
"Arguments are assigned to the named local variables in a function body. See "
"the :ref:`calls` section for the rules governing this assignment. "
"Syntactically, any expression can be used to represent an argument; the "
"evaluated value is assigned to the local variable."
msgstr ""
"Аргументы присваиваются именованным локальным переменным в теле функции. "
"Правила, регулирующие это назначение, см. в разделе :ref:`calls`. "
"Синтаксически для представления аргумента можно использовать любое "
"выражение; вычисленное значение присваивается локальной переменной."

#: ../../glossary.rst:89
msgid ""
"See also the :term:`parameter` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"and :pep:`362`."
msgstr ""
"См. также статью глоссария :term:`parameter`, вопрос часто задаваемых "
"вопросов о :ref:`разнице между аргументами и параметрами <faq-argument-vs-"
"parameter>` и :pep:`362`."

#: ../../glossary.rst:92
msgid "asynchronous context manager"
msgstr "асинхронный контекстный менеджер"

#: ../../glossary.rst:94
msgid ""
"An object which controls the environment seen in an :keyword:`async with` "
"statement by defining :meth:`~object.__aenter__` and :meth:`~object."
"__aexit__` methods.  Introduced by :pep:`492`."
msgstr ""
"Объект, который управляет средой, видимой в операторе :keyword:`async with`, "
"путем определения методов :meth:`~object.__aenter__` и :meth:`~object."
"__aexit__`. Представлено :pep:`492`."

#: ../../glossary.rst:97
msgid "asynchronous generator"
msgstr "асинхронный генератор"

#: ../../glossary.rst:99
msgid ""
"A function which returns an :term:`asynchronous generator iterator`.  It "
"looks like a coroutine function defined with :keyword:`async def` except "
"that it contains :keyword:`yield` expressions for producing a series of "
"values usable in an :keyword:`async for` loop."
msgstr ""
"Функция, которая возвращает :term:`итератор асинхронного генератора`. Она "
"выглядит как функция сопрограммы, определенная с помощью :keyword:`async "
"def`, за исключением того, что она содержит выражения :keyword:`yield` для "
"создания серии значений, которые можно использовать в цикле :keyword:`async "
"for`."

#: ../../glossary.rst:104
msgid ""
"Usually refers to an asynchronous generator function, but may refer to an "
"*asynchronous generator iterator* in some contexts.  In cases where the "
"intended meaning isn't clear, using the full terms avoids ambiguity."
msgstr ""
"Значение, передаваемое в :term:`функцию` (или :term:`метод`) при вызове "
"функции. Есть два вида аргументов:"

#: ../../glossary.rst:108
msgid ""
"An asynchronous generator function may contain :keyword:`await` expressions "
"as well as :keyword:`async for`, and :keyword:`async with` statements."
msgstr ""
"Функция асинхронного генератора может содержать выражения :keyword:`await`, "
"а также операторы :keyword:`async for` и :keyword:`async with`."

#: ../../glossary.rst:111
msgid "asynchronous generator iterator"
msgstr "итератор асинхронного генератора"

#: ../../glossary.rst:113
msgid "An object created by a :term:`asynchronous generator` function."
msgstr "Объект, созданный функцией асинхронного генератора."

#: ../../glossary.rst:115
msgid ""
"This is an :term:`asynchronous iterator` which when called using the :meth:"
"`~object.__anext__` method returns an awaitable object which will execute "
"the body of the asynchronous generator function until the next :keyword:"
"`yield` expression."
msgstr ""
"Это :term:`асинхронный итератор`, который при вызове с использованием "
"метода :meth:`~object.__anext__` возвращает ожидаемый объект, который будет "
"выполнять тело функции асинхронного генератора до следующего выражения :"
"keyword:`yield`."

#: ../../glossary.rst:120
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *asynchronous generator iterator* effectively resumes "
"with another awaitable returned by :meth:`~object.__anext__`, it picks up "
"where it left off.  See :pep:`492` and :pep:`525`."
msgstr ""
"Каждый :keyword:`yield` временно приостанавливает обработку, запоминая "
"состояние выполнения местоположения (включая локальные переменные и "
"ожидающие операторы try). Когда *итератор асинхронного генератора* "
"эффективно возобновляет работу с другим ожидаемым объектом, возвращаемым :"
"meth:`~object.__anext__`, он возобновляет работу с того места, где "
"остановился. См. :pep:`492` и :pep:`525`."

#: ../../glossary.rst:125
msgid "asynchronous iterable"
msgstr "асинхронный итерируемый объект"

#: ../../glossary.rst:127
msgid ""
"An object, that can be used in an :keyword:`async for` statement. Must "
"return an :term:`asynchronous iterator` from its :meth:`~object.__aiter__` "
"method.  Introduced by :pep:`492`."
msgstr ""
"Объект, который можно использовать в операторе :keyword:`async for`. Должен "
"возвращать :term:`асинхронный итератор` из своего :meth:`~object.__aiter__` "
"метода. Представлено :pep:`492`."

#: ../../glossary.rst:130
msgid "asynchronous iterator"
msgstr "асинхронный итератор"

#: ../../glossary.rst:132
msgid ""
"An object that implements the :meth:`~object.__aiter__` and :meth:`~object."
"__anext__` methods.  :meth:`~object.__anext__` must return an :term:"
"`awaitable` object. :keyword:`async for` resolves the awaitables returned by "
"an asynchronous iterator's :meth:`~object.__anext__` method until it raises "
"a :exc:`StopAsyncIteration` exception.  Introduced by :pep:`492`."
msgstr ""
"Объект, реализующий методы :meth:`~object.__aiter__` и :meth:`~object."
"__anext__`. :meth:`~object.__anext__` должен возвращать объект :term:"
"`awaitable`. :keyword:`async for` разрешает ожидаемые объекты, возвращаемые "
"методом :meth:`~object.__anext__` асинхронного итератора, пока не вызовет "
"исключение :exc:`StopAsyncIteration`. Представлено :pep:`492`."

#: ../../glossary.rst:137
msgid "attribute"
msgstr "атрибут"

#: ../../glossary.rst:139
msgid ""
"A value associated with an object which is usually referenced by name using "
"dotted expressions. For example, if an object *o* has an attribute *a* it "
"would be referenced as *o.a*."
msgstr ""
"Значение, связанное с объектом, на который обычно ссылаются по имени, "
"используя выражения, разделенные точками. Например, если объект *o* имеет "
"атрибут *a*, на него будет ссылаться как *oa*."

#: ../../glossary.rst:144
msgid ""
"It is possible to give an object an attribute whose name is not an "
"identifier as defined by :ref:`identifiers`, for example using :func:"
"`setattr`, if the object allows it. Such an attribute will not be accessible "
"using a dotted expression, and would instead need to be retrieved with :func:"
"`getattr`."
msgstr ""
"Можно присвоить объекту атрибут, имя которого не является идентификатором, "
"как определено в :ref:`identifiers`, например, используя :func:`setattr`, "
"если объект это позволяет. Такой атрибут не будет доступен с помощью "
"выражения, разделенного точками, и вместо этого его необходимо будет "
"получить с помощью :func:`getattr`."

#: ../../glossary.rst:149
msgid "awaitable"
msgstr "ожидаемый объект"

#: ../../glossary.rst:151
msgid ""
"An object that can be used in an :keyword:`await` expression.  Can be a :"
"term:`coroutine` or an object with an :meth:`~object.__await__` method. See "
"also :pep:`492`."
msgstr ""
"Объект, который можно использовать в выражении :keyword:`await`. Может быть :"
"term:`coroutine` или объектом с :meth:`~object.__await__`. См. также :pep:"
"`492`."

#: ../../glossary.rst:154
msgid "BDFL"
msgstr "BDFL"

#: ../../glossary.rst:156
msgid ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum <https://gvanrossum."
"github.io/>`_, Python's creator."
msgstr ""
"Доброжелательный диктатор на всю жизнь, он же `Гвидо ван Россум <https://"
"gvanrossum.github.io/>`_, создатель Python."

#: ../../glossary.rst:158
msgid "binary file"
msgstr "бинарный файл"

#: ../../glossary.rst:160
msgid ""
"A :term:`file object` able to read and write :term:`bytes-like objects "
"<bytes-like object>`. Examples of binary files are files opened in binary "
"mode (``'rb'``, ``'wb'`` or ``'rb+'``), :data:`sys.stdin.buffer <sys."
"stdin>`, :data:`sys.stdout.buffer <sys.stdout>`, and instances of :class:`io."
"BytesIO` and :class:`gzip.GzipFile`."
msgstr ""
":term:`файловый объект`, способный читать и записывать :term:`байтоподобные "
"объекты <байтоподобный объект>`. Примерами двоичных файлов являются файлы, "
"открытые в двоичном режиме (``'rb'``, ``'wb'`` или ``'rb+'``), :data:`sys."
"stdin.buffer <sys.stdin> `, :data:`sys.stdout.buffer <sys.stdout>` и "
"экземпляры :class:`io.BytesIO` и :class:`gzip.GzipFile`."

#: ../../glossary.rst:167
msgid ""
"See also :term:`text file` for a file object able to read and write :class:"
"`str` objects."
msgstr ""
"См. также :term:`text file` для файлового объекта, способного читать и "
"записывать объекты :class:`str`."

#: ../../glossary.rst:169
msgid "borrowed reference"
msgstr "заимствованная ссылка"

#: ../../glossary.rst:171
msgid ""
"In Python's C API, a borrowed reference is a reference to an object, where "
"the code using the object does not own the reference. It becomes a dangling "
"pointer if the object is destroyed. For example, a garbage collection can "
"remove the last :term:`strong reference` to the object and so destroy it."
msgstr ""
"В API C Python заимствованная ссылка — это ссылка на объект, при этом код, "
"использующий этот объект, не владеет ссылкой. Он становится висячим "
"указателем, если объект уничтожается. Например, сборщик мусора может удалить "
"последнюю :term:`строгую ссылку` на объект и тем самым уничтожить его."

#: ../../glossary.rst:177
msgid ""
"Calling :c:func:`Py_INCREF` on the :term:`borrowed reference` is recommended "
"to convert it to a :term:`strong reference` in-place, except when the object "
"cannot be destroyed before the last usage of the borrowed reference. The :c:"
"func:`Py_NewRef` function can be used to create a new :term:`strong "
"reference`."
msgstr ""
"Вызов :c:func:`Py_INCREF` для :term:`заимствованной ссылки` рекомендуется "
"преобразовать в :term:`строгую ссылку` на месте, за исключением случаев, "
"когда объект не может быть уничтожен до последнего использования "
"заимствованной ссылки. ссылка. Функцию :c:func:`Py_NewRef` можно "
"использовать для создания новой :term:`сильной ссылки`."

#: ../../glossary.rst:182
msgid "bytes-like object"
msgstr "байто-подобный объект"

#: ../../glossary.rst:184
msgid ""
"An object that supports the :ref:`bufferobjects` and can export a C-:term:"
"`contiguous` buffer. This includes all :class:`bytes`, :class:`bytearray`, "
"and :class:`array.array` objects, as well as many common :class:`memoryview` "
"objects.  Bytes-like objects can be used for various operations that work "
"with binary data; these include compression, saving to a binary file, and "
"sending over a socket."
msgstr ""
"Объект, который поддерживает :ref:`bufferobjects` и может экспортировать C-:"
"term:`непрерывный` буфер. Сюда входят все объекты :class:`bytes`, :class:"
"`bytearray` и :class:`array.array`, а также многие распространенные объекты :"
"class:`memoryview`. Байтоподобные объекты можно использовать для различных "
"операций, работающих с двоичными данными; к ним относятся сжатие, сохранение "
"в двоичный файл и отправка через сокет."

#: ../../glossary.rst:191
msgid ""
"Some operations need the binary data to be mutable.  The documentation often "
"refers to these as \"read-write bytes-like objects\".  Example mutable "
"buffer objects include :class:`bytearray` and a :class:`memoryview` of a :"
"class:`bytearray`. Other operations require the binary data to be stored in "
"immutable objects (\"read-only bytes-like objects\"); examples of these "
"include :class:`bytes` and a :class:`memoryview` of a :class:`bytes` object."
msgstr ""
"Для некоторых операций необходимо, чтобы двоичные данные были изменяемыми. В "
"документации они часто называются «байтовыми объектами, подобными чтению и "
"записи». Примеры изменяемых буферных объектов включают :class:`bytearray` и :"
"class:`memoryview` :class:`bytearray`. Другие операции требуют, чтобы "
"двоичные данные хранились в неизменяемых объектах («байтоподобные объекты "
"только для чтения»); примеры таких объектов включают :class:`bytes` и :class:"
"`memoryview` объекта :class:`bytes`."

#: ../../glossary.rst:199
msgid "bytecode"
msgstr "байт-код"

#: ../../glossary.rst:201
msgid ""
"Python source code is compiled into bytecode, the internal representation of "
"a Python program in the CPython interpreter.  The bytecode is also cached in "
"``.pyc`` files so that executing the same file is faster the second time "
"(recompilation from source to bytecode can be avoided).  This \"intermediate "
"language\" is said to run on a :term:`virtual machine` that executes the "
"machine code corresponding to each bytecode. Do note that bytecodes are not "
"expected to work between different Python virtual machines, nor to be stable "
"between Python releases."
msgstr ""
"Исходный код Python компилируется в байт-код — внутреннее представление "
"программы Python в интерпретаторе CPython. Байт-код также кэшируется в "
"файлах ``.pyc``, чтобы второй раз выполнить тот же файл быстрее "
"(перекомпиляции из исходного кода в байт-код можно избежать). Говорят, что "
"этот «промежуточный язык» работает на «виртуальной машине», которая "
"выполняет машинный код, соответствующий каждому байт-коду. Обратите "
"внимание, что байт-коды не должны работать между разными виртуальными "
"машинами Python и не должны быть стабильными между выпусками Python."

#: ../../glossary.rst:211
msgid ""
"A list of bytecode instructions can be found in the documentation for :ref:"
"`the dis module <bytecodes>`."
msgstr ""
"Список инструкций байт-кода можно найти в документации к :ref:`модулю dis "
"<bytecodes>`."

#: ../../glossary.rst:213
msgid "callable"
msgstr "вызываемый объект"

#: ../../glossary.rst:215
msgid ""
"A callable is an object that can be called, possibly with a set of arguments "
"(see :term:`argument`), with the following syntax::"
msgstr ""
"Вызываемый объект — это объект, который можно вызвать, возможно, с набором "
"аргументов (см. :term:`argument`), используя следующий синтаксис::"

#: ../../glossary.rst:220
msgid ""
"A :term:`function`, and by extension a :term:`method`, is a callable. An "
"instance of a class that implements the :meth:`~object.__call__` method is "
"also a callable."
msgstr ""
":term:`function` и, как следствие, :term:`method` являются вызываемыми. "
"Экземпляр класса, реализующего метод :meth:`~object.__call__`, также "
"является вызываемым."

#: ../../glossary.rst:223
msgid "callback"
msgstr "функция обратного вызова"

#: ../../glossary.rst:225
msgid ""
"A subroutine function which is passed as an argument to be executed at some "
"point in the future."
msgstr ""
"Подпрограмма, которая передается в качестве аргумента для выполнения в какой-"
"то момент в будущем."

#: ../../glossary.rst:227
msgid "class"
msgstr "класс"

#: ../../glossary.rst:229
msgid ""
"A template for creating user-defined objects. Class definitions normally "
"contain method definitions which operate on instances of the class."
msgstr ""
"Шаблон для создания пользовательских объектов. Определения классов обычно "
"содержат определения методов, которые работают с экземплярами класса."

#: ../../glossary.rst:232
msgid "class variable"
msgstr "переменная класса"

#: ../../glossary.rst:234
msgid ""
"A variable defined in a class and intended to be modified only at class "
"level (i.e., not in an instance of the class)."
msgstr ""
"Переменная, определенная в классе и предназначенная для изменения только на "
"уровне класса (т. е. не в экземпляре класса)."

#: ../../glossary.rst:236
msgid "complex number"
msgstr "комплексное число"

#: ../../glossary.rst:238
msgid ""
"An extension of the familiar real number system in which all numbers are "
"expressed as a sum of a real part and an imaginary part.  Imaginary numbers "
"are real multiples of the imaginary unit (the square root of ``-1``), often "
"written ``i`` in mathematics or ``j`` in engineering.  Python has built-in "
"support for complex numbers, which are written with this latter notation; "
"the imaginary part is written with a ``j`` suffix, e.g., ``3+1j``.  To get "
"access to complex equivalents of the :mod:`math` module, use :mod:`cmath`.  "
"Use of complex numbers is a fairly advanced mathematical feature.  If you're "
"not aware of a need for them, it's almost certain you can safely ignore them."
msgstr ""
"Расширение знакомой системы действительных чисел, в которой все числа "
"выражаются как сумма действительной и мнимой частей. Мнимые числа — это "
"действительные кратные мнимой единицы (квадратный корень из «-1»), часто "
"обозначаемой «i» в математике или «j» в технике. Python имеет встроенную "
"поддержку комплексных чисел, которые записываются с использованием этой "
"последней записи; мнимая часть записывается с суффиксом j, например, 3+1j. "
"Чтобы получить доступ к сложным эквивалентам модуля :mod:`math`, "
"используйте :mod:`cmath`. Использование комплексных чисел — довольно сложная "
"математическая функция. Если вы не осознаете их необходимости, вы почти "
"наверняка можете их спокойно игнорировать."

#: ../../glossary.rst:248
msgid "context manager"
msgstr "контекстный менеджер"

#: ../../glossary.rst:250
msgid ""
"An object which controls the environment seen in a :keyword:`with` statement "
"by defining :meth:`~object.__enter__` and :meth:`~object.__exit__` methods. "
"See :pep:`343`."
msgstr ""
"Объект, который управляет средой, видимой в операторе :keyword:`with`, путем "
"определения методов :meth:`~object.__enter__` и :meth:`~object.__exit__`. "
"См. :pep:`343`."

#: ../../glossary.rst:253
msgid "context variable"
msgstr "контекстная переменная"

#: ../../glossary.rst:255
msgid ""
"A variable which can have different values depending on its context. This is "
"similar to Thread-Local Storage in which each execution thread may have a "
"different value for a variable. However, with context variables, there may "
"be several contexts in one execution thread and the main usage for context "
"variables is to keep track of variables in concurrent asynchronous tasks. "
"See :mod:`contextvars`."
msgstr ""
"Переменная, которая может иметь разные значения в зависимости от контекста. "
"Это похоже на локальное хранилище потоков, в котором каждый поток выполнения "
"может иметь другое значение переменной. Однако при использовании контекстных "
"переменных в одном потоке выполнения может быть несколько контекстов, и "
"основное использование контекстных переменных — отслеживание переменных в "
"одновременных асинхронных задачах. См. :mod:`contextvars`."

#: ../../glossary.rst:262
msgid "contiguous"
msgstr "непрерывный"

#: ../../glossary.rst:266
msgid ""
"A buffer is considered contiguous exactly if it is either *C-contiguous* or "
"*Fortran contiguous*.  Zero-dimensional buffers are C and Fortran "
"contiguous.  In one-dimensional arrays, the items must be laid out in memory "
"next to each other, in order of increasing indexes starting from zero.  In "
"multidimensional C-contiguous arrays, the last index varies the fastest when "
"visiting items in order of memory address.  However, in Fortran contiguous "
"arrays, the first index varies the fastest."
msgstr ""
"Буфер считается непрерывным, если он *C-непрерывен* или *Fortran "
"непрерывен*. Нульмерные буферы являются смежными в C и Fortran. В одномерных "
"массивах элементы должны располагаться в памяти рядом друг с другом в "
"порядке возрастания индексов, начиная с нуля. В многомерных C-непрерывных "
"массивах последний индекс меняется быстрее всего при посещении элементов в "
"порядке адреса памяти. Однако в смежных массивах Фортрана первый индекс "
"меняется быстрее всего."

#: ../../glossary.rst:274
msgid "coroutine"
msgstr "корутина"

#: ../../glossary.rst:276
msgid ""
"Coroutines are a more generalized form of subroutines. Subroutines are "
"entered at one point and exited at another point.  Coroutines can be "
"entered, exited, and resumed at many different points.  They can be "
"implemented with the :keyword:`async def` statement.  See also :pep:`492`."
msgstr ""
"Сопрограммы — это более обобщенная форма подпрограмм. Вход в подпрограммы "
"осуществляется в одной точке, а выход — в другой. В сопрограммы можно "
"входить, выходить и возобновлять работу в самых разных точках. Их можно "
"реализовать с помощью оператора :keyword:`async def`. См. также :pep:`492`."

#: ../../glossary.rst:281
msgid "coroutine function"
msgstr "корутинная функция"

#: ../../glossary.rst:283
msgid ""
"A function which returns a :term:`coroutine` object.  A coroutine function "
"may be defined with the :keyword:`async def` statement, and may contain :"
"keyword:`await`, :keyword:`async for`, and :keyword:`async with` keywords.  "
"These were introduced by :pep:`492`."
msgstr ""
"Функция, которая возвращает объект :term:`coroutine`. Функция сопрограммы "
"может быть определена с помощью оператора :keyword:`async def` и может "
"содержать ключевые слова :keyword:`await`, :keyword:`async for` и :keyword:"
"`async with`. Их представил :pep:`492`."

#: ../../glossary.rst:288
msgid "CPython"
msgstr "CPython"

#: ../../glossary.rst:290
msgid ""
"The canonical implementation of the Python programming language, as "
"distributed on `python.org <https://www.python.org>`_.  The term \"CPython\" "
"is used when necessary to distinguish this implementation from others such "
"as Jython or IronPython."
msgstr ""
"Каноническая реализация языка программирования Python, распространяемая на "
"`python.org <https://www.python.org>`_. Термин «CPython» используется, когда "
"необходимо отличить эту реализацию от других, таких как Jython или "
"IronPython."

#: ../../glossary.rst:294
msgid "decorator"
msgstr "декоратор"

#: ../../glossary.rst:296
msgid ""
"A function returning another function, usually applied as a function "
"transformation using the ``@wrapper`` syntax.  Common examples for "
"decorators are :func:`classmethod` and :func:`staticmethod`."
msgstr ""
"Функция, возвращающая другую функцию, обычно применяется как преобразование "
"функции с использованием синтаксиса @wrapper. Типичными примерами "
"декораторов являются :func:`classmethod` и :func:`staticmethod`."

#: ../../glossary.rst:300
msgid ""
"The decorator syntax is merely syntactic sugar, the following two function "
"definitions are semantically equivalent::"
msgstr ""
"Синтаксис декоратора — это всего лишь синтаксический сахар, следующие два "
"определения функций семантически эквивалентны:"

#: ../../glossary.rst:311
msgid ""
"The same concept exists for classes, but is less commonly used there.  See "
"the documentation for :ref:`function definitions <function>` and :ref:`class "
"definitions <class>` for more about decorators."
msgstr ""
"Та же концепция существует и для классов, но используется там реже. "
"Дополнительную информацию о декораторах смотрите в документации по :ref:"
"`определениям функций <function>` и :ref:`определениям классов <class>`."

#: ../../glossary.rst:314
msgid "descriptor"
msgstr "дескриптор"

#: ../../glossary.rst:316
msgid ""
"Any object which defines the methods :meth:`~object.__get__`, :meth:`~object."
"__set__`, or :meth:`~object.__delete__`. When a class attribute is a "
"descriptor, its special binding behavior is triggered upon attribute "
"lookup.  Normally, using *a.b* to get, set or delete an attribute looks up "
"the object named *b* in the class dictionary for *a*, but if *b* is a "
"descriptor, the respective descriptor method gets called.  Understanding "
"descriptors is a key to a deep understanding of Python because they are the "
"basis for many features including functions, methods, properties, class "
"methods, static methods, and reference to super classes."
msgstr ""
"Любой объект, который определяет методы :meth:`~object.__get__`, :meth:"
"`~object.__set__` или :meth:`~object.__delete__`. Если атрибут класса "
"является дескриптором, его особое поведение привязки запускается при поиске "
"атрибута. Обычно использование *ab* для получения, установки или удаления "
"атрибута ищет объект с именем *b* в словаре класса для *a*, но если *b* "
"является дескриптором, вызывается соответствующий метод дескриптора. "
"Понимание дескрипторов является ключом к глубокому пониманию Python, "
"поскольку они являются основой для многих функций, включая функции, методы, "
"свойства, методы классов, статические методы и ссылки на суперклассы."

#: ../../glossary.rst:327
msgid ""
"For more information about descriptors' methods, see :ref:`descriptors` or "
"the :ref:`Descriptor How To Guide <descriptorhowto>`."
msgstr ""
"Для получения дополнительной информации о методах дескрипторов см. :ref:"
"`descriptors` или :ref:`Descriptor How To Guide <descriptorhowto>`."

#: ../../glossary.rst:329
msgid "dictionary"
msgstr "словарь"

#: ../../glossary.rst:331
msgid ""
"An associative array, where arbitrary keys are mapped to values.  The keys "
"can be any object with :meth:`~object.__hash__` and :meth:`~object.__eq__` "
"methods. Called a hash in Perl."
msgstr ""
"Ассоциативный массив, в котором произвольные ключи сопоставляются значениям. "
"Ключами может быть любой объект с методами :meth:`~object.__hash__` и :meth:"
"`~object.__eq__`. Вызывается хешем в Perl."

#: ../../glossary.rst:335
msgid "dictionary comprehension"
msgstr "включение из словаря"

#: ../../glossary.rst:337
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a dictionary with the results. ``results = {n: n ** 2 for n in "
"range(10)}`` generates a dictionary containing key ``n`` mapped to value ``n "
"** 2``. See :ref:`comprehensions`."
msgstr ""
"Компактный способ обработки всех или части элементов в итерации и возврата "
"словаря с результатами. ``results = {n: n ** 2 for n in range(10)}`` "
"генерирует словарь, содержащий ключ ``n``, сопоставленный со значением ``n "
"** 2``. См. :ref:`понимания`."

#: ../../glossary.rst:341
msgid "dictionary view"
msgstr "представление словаря"

#: ../../glossary.rst:343
msgid ""
"The objects returned from :meth:`dict.keys`, :meth:`dict.values`, and :meth:"
"`dict.items` are called dictionary views. They provide a dynamic view on the "
"dictionary’s entries, which means that when the dictionary changes, the view "
"reflects these changes. To force the dictionary view to become a full list "
"use ``list(dictview)``.  See :ref:`dict-views`."
msgstr ""
"Объекты, возвращаемые из :meth:`dict.keys`, :meth:`dict.values` и :meth:"
"`dict.items`, называются представлениями словаря. Они обеспечивают "
"динамическое представление записей словаря, а это означает, что при "
"изменении словаря представление отражает эти изменения. Чтобы заставить "
"представление словаря стать полным списком, используйте list(dictview). См. :"
"ref:`dict-views`."

#: ../../glossary.rst:349
msgid "docstring"
msgstr "строка документации"

#: ../../glossary.rst:351
msgid ""
"A string literal which appears as the first expression in a class, function "
"or module.  While ignored when the suite is executed, it is recognized by "
"the compiler and put into the :attr:`!__doc__` attribute of the enclosing "
"class, function or module.  Since it is available via introspection, it is "
"the canonical place for documentation of the object."
msgstr ""

#: ../../glossary.rst:357
msgid "duck-typing"
msgstr "утиная типизация"

#: ../../glossary.rst:359
msgid ""
"A programming style which does not look at an object's type to determine if "
"it has the right interface; instead, the method or attribute is simply "
"called or used (\"If it looks like a duck and quacks like a duck, it must be "
"a duck.\")  By emphasizing interfaces rather than specific types, well-"
"designed code improves its flexibility by allowing polymorphic "
"substitution.  Duck-typing avoids tests using :func:`type` or :func:"
"`isinstance`.  (Note, however, that duck-typing can be complemented with :"
"term:`abstract base classes <abstract base class>`.)  Instead, it typically "
"employs :func:`hasattr` tests or :term:`EAFP` programming."
msgstr ""
"Стиль программирования, который не рассматривает тип объекта, чтобы "
"определить, имеет ли он правильный интерфейс; вместо этого метод или атрибут "
"просто вызывается или используется («Если он выглядит как утка и крякает как "
"утка, значит, это и есть утка».) Делая акцент на интерфейсах, а не на "
"конкретных типах, хорошо спроектированный код повышает свою гибкость, "
"позволяя полиморфное замещение. Утиная типизация позволяет избежать тестов с "
"использованием :func:`type` или :func:`isinstance`. (Однако обратите "
"внимание, что утиная типизация может быть дополнена :term:`абстрактными "
"базовыми классами <abstract base class>`.) Вместо этого обычно используются :"
"func:`hasattr` тесты или :term:`EAFP`."

#: ../../glossary.rst:368
msgid "EAFP"
msgstr "EAFP"

#: ../../glossary.rst:370
msgid ""
"Easier to ask for forgiveness than permission.  This common Python coding "
"style assumes the existence of valid keys or attributes and catches "
"exceptions if the assumption proves false.  This clean and fast style is "
"characterized by the presence of many :keyword:`try` and :keyword:`except` "
"statements.  The technique contrasts with the :term:`LBYL` style common to "
"many other languages such as C."
msgstr ""
"Легче попросить прощения, чем разрешения. Этот распространенный стиль "
"кодирования Python предполагает наличие допустимых ключей или атрибутов и "
"перехватывает исключения, если предположение оказывается ложным. Этот чистый "
"и быстрый стиль характеризуется наличием множества операторов :keyword:`try` "
"и :keyword:`Exception`. Этот метод контрастирует со стилем :term:`LBYL`, "
"общим для многих других языков, таких как C."

#: ../../glossary.rst:376
msgid "expression"
msgstr "выражение"

#: ../../glossary.rst:378
msgid ""
"A piece of syntax which can be evaluated to some value.  In other words, an "
"expression is an accumulation of expression elements like literals, names, "
"attribute access, operators or function calls which all return a value.  In "
"contrast to many other languages, not all language constructs are "
"expressions.  There are also :term:`statement`\\s which cannot be used as "
"expressions, such as :keyword:`while`.  Assignments are also statements, not "
"expressions."
msgstr ""
"Часть синтаксиса, которая может быть оценена как некоторое значение. Другими "
"словами, выражение представляет собой совокупность элементов выражения, "
"таких как литералы, имена, доступ к атрибутам, операторы или вызовы функций, "
"которые возвращают значение. В отличие от многих других языков, не все "
"языковые конструкции являются выражениями. Существуют также :term:"
"`statement`\\s, которые нельзя использовать в качестве выражений, например :"
"keyword:` while`. Присвоения также являются утверждениями, а не выражениями."

#: ../../glossary.rst:385
msgid "extension module"
msgstr "модуль расширения"

#: ../../glossary.rst:387
msgid ""
"A module written in C or C++, using Python's C API to interact with the core "
"and with user code."
msgstr ""
"Модуль, написанный на C или C++, использующий C API Python для "
"взаимодействия с ядром и пользовательским кодом."

#: ../../glossary.rst:389
msgid "f-string"
msgstr "f-строка"

#: ../../glossary.rst:391
msgid ""
"String literals prefixed with ``'f'`` or ``'F'`` are commonly called \"f-"
"strings\" which is short for :ref:`formatted string literals <f-strings>`.  "
"See also :pep:`498`."
msgstr ""
"Строковые литералы с префиксом ``'f'`` или ``'F'`` обычно называются \"f-"
"строками\", что является сокращением от форматированных строковых литералов "
"<f-strings>`. См. также :pep:`498`."

#: ../../glossary.rst:394
msgid "file object"
msgstr "файловый объект"

#: ../../glossary.rst:396
msgid ""
"An object exposing a file-oriented API (with methods such as :meth:`!read` "
"or :meth:`!write`) to an underlying resource.  Depending on the way it was "
"created, a file object can mediate access to a real on-disk file or to "
"another type of storage or communication device (for example standard input/"
"output, in-memory buffers, sockets, pipes, etc.).  File objects are also "
"called :dfn:`file-like objects` or :dfn:`streams`."
msgstr ""
"Объект, предоставляющий файлово-ориентированный API (с такими методами, как :"
"meth:`!read` или :meth:`!write`) базовому ресурсу. В зависимости от способа "
"создания файловый объект может обеспечивать доступ к реальному файлу на "
"диске или к другому типу устройства хранения или связи (например, "
"стандартному вводу/выводу, буферам в памяти, сокетам, каналам и т. д.). . "
"Файловые объекты также называются :dfn:`файлоподобными объектами` или :dfn:"
"`streams`."

#: ../../glossary.rst:404
msgid ""
"There are actually three categories of file objects: raw :term:`binary files "
"<binary file>`, buffered :term:`binary files <binary file>` and :term:`text "
"files <text file>`. Their interfaces are defined in the :mod:`io` module.  "
"The canonical way to create a file object is by using the :func:`open` "
"function."
msgstr ""
"На самом деле существует три категории файловых объектов: необработанные :"
"term:`бинарные файлы <двоичный файл>`, буферизованные :term:`бинарные файлы "
"<двоичный файл>` и :term:`текстовые файлы <текстовый файл>`. Их интерфейсы "
"определены в модуле :mod:`io`. Канонический способ создания файлового "
"объекта — использование функции :func:`open`."

#: ../../glossary.rst:409
msgid "file-like object"
msgstr "файлообразный объект"

#: ../../glossary.rst:411
msgid "A synonym for :term:`file object`."
msgstr "Синоним для :term:`file object`."

#: ../../glossary.rst:412
msgid "filesystem encoding and error handler"
msgstr "кодировка файловой системы и обработчик ошибок"

#: ../../glossary.rst:414
msgid ""
"Encoding and error handler used by Python to decode bytes from the operating "
"system and encode Unicode to the operating system."
msgstr ""
"Обработчик кодирования и ошибок, используемый Python для декодирования "
"байтов из операционной системы и кодирования Unicode в операционную систему."

#: ../../glossary.rst:417
msgid ""
"The filesystem encoding must guarantee to successfully decode all bytes "
"below 128. If the file system encoding fails to provide this guarantee, API "
"functions can raise :exc:`UnicodeError`."
msgstr ""
"Кодировка файловой системы должна гарантировать успешное декодирование всех "
"байтов ниже 128. Если кодировка файловой системы не может обеспечить эту "
"гарантию, функции API могут вызвать ошибку :exc:`UnicodeError`."

#: ../../glossary.rst:421
msgid ""
"The :func:`sys.getfilesystemencoding` and :func:`sys."
"getfilesystemencodeerrors` functions can be used to get the filesystem "
"encoding and error handler."
msgstr ""
"Функции :func:`sys.getfilesystemencoding` и :func:`sys."
"getfilesystemencodeerrors` можно использовать для получения кодировки "
"файловой системы и обработчика ошибок."

#: ../../glossary.rst:425
msgid ""
"The :term:`filesystem encoding and error handler` are configured at Python "
"startup by the :c:func:`PyConfig_Read` function: see :c:member:`~PyConfig."
"filesystem_encoding` and :c:member:`~PyConfig.filesystem_errors` members of :"
"c:type:`PyConfig`."
msgstr ""
":term:`Кодировка файловой системы и обработчик ошибок` настраиваются при "
"запуске Python с помощью :c:func:`PyConfig_Read` функция: см. :c:member:"
"`~PyConfig.filesystem_encoding` и :c:member:`~PyConfig.filesystem_errors` "
"члены :c:type:`PyConfig` ."

#: ../../glossary.rst:430
msgid "See also the :term:`locale encoding`."
msgstr "См. также :term:`кодировку локали`."

#: ../../glossary.rst:431
msgid "finder"
msgstr "искатель"

#: ../../glossary.rst:433
msgid ""
"An object that tries to find the :term:`loader` for a module that is being "
"imported."
msgstr ""
"Объект, который пытается найти :term:`loader` для импортируемого модуля."

#: ../../glossary.rst:436
msgid ""
"Since Python 3.3, there are two types of finder: :term:`meta path finders "
"<meta path finder>` for use with :data:`sys.meta_path`, and :term:`path "
"entry finders <path entry finder>` for use with :data:`sys.path_hooks`."
msgstr ""

#: ../../glossary.rst:440
msgid "See :pep:`302`, :pep:`420` and :pep:`451` for much more detail."
msgstr ""

#: ../../glossary.rst:441
msgid "floor division"
msgstr "целочисленное деление с округлением вниз"

#: ../../glossary.rst:443
msgid ""
"Mathematical division that rounds down to nearest integer.  The floor "
"division operator is ``//``.  For example, the expression ``11 // 4`` "
"evaluates to ``2`` in contrast to the ``2.75`` returned by float true "
"division.  Note that ``(-11) // 4`` is ``-3`` because that is ``-2.75`` "
"rounded *downward*. See :pep:`238`."
msgstr ""
"Математическое деление, округляющее до ближайшего целого числа. Оператор "
"разделения этажей — ``//``. Например, выражение ``11 // 4`` оценивается как "
"``2`` в отличие от ``2,75``, возвращаемого делением float true. Обратите "
"внимание, что ``(-11) // 4`` равно ``-3``, потому что это ``-2,75`` "
"округлено *в меньшую сторону*. См. :pep:`238`."

#: ../../glossary.rst:448
msgid "function"
msgstr "функция"

#: ../../glossary.rst:450
msgid ""
"A series of statements which returns some value to a caller. It can also be "
"passed zero or more :term:`arguments <argument>` which may be used in the "
"execution of the body. See also :term:`parameter`, :term:`method`, and the :"
"ref:`function` section."
msgstr ""
"Ряд операторов, которые возвращают некоторую ценность вызывающему объекту. "
"Ему также может быть передано ноль или более :term:`argument <argument>`, "
"которые могут использоваться при выполнении тела. См. также раздел :term:"
"`parameter`, :term:`method` и :ref:`function`."

#: ../../glossary.rst:454
msgid "function annotation"
msgstr "функциональная аннотация"

#: ../../glossary.rst:456
msgid "An :term:`annotation` of a function parameter or return value."
msgstr ":term:`аннотация` параметра функции или возвращаемого значения."

#: ../../glossary.rst:458
msgid ""
"Function annotations are usually used for :term:`type hints <type hint>`: "
"for example, this function is expected to take two :class:`int` arguments "
"and is also expected to have an :class:`int` return value::"
msgstr ""
"Аннотации к функциям обычно используются для :term:`typehints <typehint>`: "
"например, ожидается, что эта функция будет принимать два аргумента :class:"
"`int`, а также будет иметь возвращаемое значение :class:`int` ::"

#: ../../glossary.rst:466
msgid "Function annotation syntax is explained in section :ref:`function`."
msgstr "Синтаксис аннотации функции описан в разделе :ref:`function`."

#: ../../glossary.rst:468
msgid ""
"See :term:`variable annotation` and :pep:`484`, which describe this "
"functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"См. :term:`variable annotation` и :pep:`484`, которые описывают эту "
"функциональность. Также см. :ref:`annotations-howto` для получения "
"рекомендаций по работе с аннотациями."

#: ../../glossary.rst:472
msgid "__future__"
msgstr "__future__"

#: ../../glossary.rst:474
msgid ""
"A :ref:`future statement <future>`, ``from __future__ import <feature>``, "
"directs the compiler to compile the current module using syntax or semantics "
"that will become standard in a future release of Python. The :mod:"
"`__future__` module documents the possible values of *feature*.  By "
"importing this module and evaluating its variables, you can see when a new "
"feature was first added to the language and when it will (or did) become the "
"default::"
msgstr ""
"Оператор :ref:`future <future>`, ``from __future__ import <feature>``, "
"предписывает компилятору скомпилировать текущий модуль, используя синтаксис "
"или семантику, которые станут стандартными в будущей версии Python. Модуль :"
"mod:`__future__` документирует возможные значения *feature*. Импортировав "
"этот модуль и оценив его переменные, вы сможете увидеть, когда новая функция "
"была впервые добавлена ​​в язык и когда она станет (или станет) функцией по "
"умолчанию:"

#: ../../glossary.rst:485
msgid "garbage collection"
msgstr "сбор мусора"

#: ../../glossary.rst:487
msgid ""
"The process of freeing memory when it is not used anymore.  Python performs "
"garbage collection via reference counting and a cyclic garbage collector "
"that is able to detect and break reference cycles.  The garbage collector "
"can be controlled using the :mod:`gc` module."
msgstr ""
"Процесс освобождения памяти, когда она больше не используется. Python "
"выполняет сбор мусора посредством подсчета ссылок и циклического сборщика "
"мусора, который способен обнаруживать и прерывать циклы ссылок. Сборщиком "
"мусора можно управлять с помощью модуля :mod:`gc`."

#: ../../glossary.rst:492 ../../glossary.rst:493
msgid "generator"
msgstr "генератор"

#: ../../glossary.rst:495
msgid ""
"A function which returns a :term:`generator iterator`.  It looks like a "
"normal function except that it contains :keyword:`yield` expressions for "
"producing a series of values usable in a for-loop or that can be retrieved "
"one at a time with the :func:`next` function."
msgstr ""
"Функция, которая возвращает :term:`итератор-генератор`. Она выглядит как "
"обычная функция, за исключением того, что она содержит выражения :keyword:"
"`yield` для создания серии значений, которые можно использовать в цикле for "
"или которые можно получать по одному с помощью функции :func:`next`."

#: ../../glossary.rst:500
msgid ""
"Usually refers to a generator function, but may refer to a *generator "
"iterator* in some contexts.  In cases where the intended meaning isn't "
"clear, using the full terms avoids ambiguity."
msgstr ""
"Обычно относится к функции-генератору, но в некоторых контекстах может "
"относиться к *итератору-генератору*. В случаях, когда предполагаемое "
"значение неясно, использование полных терминов позволяет избежать "
"двусмысленности."

#: ../../glossary.rst:503
msgid "generator iterator"
msgstr "генератор-итератор"

#: ../../glossary.rst:505
msgid "An object created by a :term:`generator` function."
msgstr "Объект, созданный функцией :term:`generator`."

#: ../../glossary.rst:507
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *generator iterator* resumes, it picks up where it "
"left off (in contrast to functions which start fresh on every invocation)."
msgstr ""
"Каждый :keyword:`yield` временно приостанавливает обработку, запоминая "
"состояние выполнения местоположения (включая локальные переменные и "
"ожидающие операторы try). Когда *итератор-генератор* возобновляет работу, он "
"продолжает работу с того места, где остановился (в отличие от функций, "
"которые начинаются заново при каждом вызове)."

#: ../../glossary.rst:513 ../../glossary.rst:514
msgid "generator expression"
msgstr "генерирующее выражение"

#: ../../glossary.rst:516
msgid ""
"An expression that returns an iterator.  It looks like a normal expression "
"followed by a :keyword:`!for` clause defining a loop variable, range, and an "
"optional :keyword:`!if` clause.  The combined expression generates values "
"for an enclosing function::"
msgstr ""
"Выражение, возвращающее итератор. Оно выглядит как обычное выражение, за "
"которым следует предложение :keyword:`!for`, определяющее переменную цикла, "
"диапазон, и необязательное предложение :keyword:`!if`. Комбинированное "
"выражение генерирует значения для включающей функции::"

#: ../../glossary.rst:523
msgid "generic function"
msgstr "общая функция"

#: ../../glossary.rst:525
msgid ""
"A function composed of multiple functions implementing the same operation "
"for different types. Which implementation should be used during a call is "
"determined by the dispatch algorithm."
msgstr ""
"Функция, состоящая из нескольких функций, реализующих одну и ту же операцию "
"для разных типов. Какая реализация должна использоваться во время вызова, "
"определяется алгоритмом диспетчеризации."

#: ../../glossary.rst:529
msgid ""
"See also the :term:`single dispatch` glossary entry, the :func:`functools."
"singledispatch` decorator, and :pep:`443`."
msgstr ""
"См. также статью в глоссарии :term:`single send`, декоратор :func:`functools."
"singledispatch` и :pep:`443`."

#: ../../glossary.rst:531
msgid "generic type"
msgstr "обобщённый"

#: ../../glossary.rst:533
msgid ""
"A :term:`type` that can be parameterized; typically a :ref:`container "
"class<sequence-types>` such as :class:`list` or :class:`dict`. Used for :"
"term:`type hints <type hint>` and :term:`annotations <annotation>`."
msgstr ""
"A :term:`type`  который можно параметризовать; обычно это   :ref:`container "
"class<sequence-types>` , например :class:`list` или :class:`dict`. "
"Используется для :term:`typehints <typehint>` и :term:`annotations "
"<annotation>`. "

#: ../../glossary.rst:538
msgid ""
"For more details, see :ref:`generic alias types<types-genericalias>`, :pep:"
"`483`, :pep:`484`, :pep:`585`, and the :mod:`typing` module."
msgstr ""
"Дополнительные сведения см. в разделах :ref:`generic alias type<types-"
"genericalias>`, :pep:`483`, :pep:`484`, :pep:`585` и модуле :mod:`typing`."

#: ../../glossary.rst:540
msgid "GIL"
msgstr "GIL"

#: ../../glossary.rst:542
msgid "See :term:`global interpreter lock`."
msgstr "Смотри :term:`global interpreter lock`."

#: ../../glossary.rst:543
msgid "global interpreter lock"
msgstr "глобальная блокировка интерпретатора"

#: ../../glossary.rst:545
msgid ""
"The mechanism used by the :term:`CPython` interpreter to assure that only "
"one thread executes Python :term:`bytecode` at a time. This simplifies the "
"CPython implementation by making the object model (including critical built-"
"in types such as :class:`dict`) implicitly safe against concurrent access.  "
"Locking the entire interpreter makes it easier for the interpreter to be "
"multi-threaded, at the expense of much of the parallelism afforded by multi-"
"processor machines."
msgstr ""
"Механизм, используемый интерпретатором :term:`CPython` для обеспечения того, "
"чтобы только один поток выполнял Python :term:`bytecode` одновременно. Это "
"упрощает реализацию CPython, делая объектную модель (включая важные "
"встроенные типы, такие как :class:`dict`) неявно защищенной от "
"одновременного доступа. Блокировка всего интерпретатора упрощает его "
"многопоточную работу за счет большей части параллелизма, обеспечиваемого "
"многопроцессорными машинами."

#: ../../glossary.rst:554
msgid ""
"However, some extension modules, either standard or third-party, are "
"designed so as to release the GIL when doing computationally intensive tasks "
"such as compression or hashing.  Also, the GIL is always released when doing "
"I/O."
msgstr ""
"Однако некоторые модули расширения, как стандартные, так и сторонние, "
"разработаны таким образом, чтобы освобождать GIL при выполнении ресурсоемких "
"задач, таких как сжатие или хеширование. Кроме того, GIL всегда "
"освобождается при выполнении ввода-вывода."

#: ../../glossary.rst:559
msgid ""
"Past efforts to create a \"free-threaded\" interpreter (one which locks "
"shared data at a much finer granularity) have not been successful because "
"performance suffered in the common single-processor case. It is believed "
"that overcoming this performance issue would make the implementation much "
"more complicated and therefore costlier to maintain."
msgstr ""
"Предыдущие попытки создать интерпретатор со свободным потоком (тот, который "
"блокирует общие данные с гораздо большей степенью детализации) не увенчались "
"успехом, поскольку в обычном однопроцессорном случае снизилась "
"производительность. Считается, что решение этой проблемы с "
"производительностью сделает реализацию намного более сложной и, "
"следовательно, более дорогостоящей в обслуживании."

#: ../../glossary.rst:565
msgid "hash-based pyc"
msgstr "pyc на основе хэша"

#: ../../glossary.rst:567
msgid ""
"A bytecode cache file that uses the hash rather than the last-modified time "
"of the corresponding source file to determine its validity. See :ref:`pyc-"
"invalidation`."
msgstr ""
"Файл кэша байт-кода, который использует хэш, а не время последнего изменения "
"соответствующего исходного файла для определения его достоверности. См. :ref:"
"`pyc-invalidation`."

#: ../../glossary.rst:570
msgid "hashable"
msgstr "хэшируемый"

#: ../../glossary.rst:572
msgid ""
"An object is *hashable* if it has a hash value which never changes during "
"its lifetime (it needs a :meth:`~object.__hash__` method), and can be "
"compared to other objects (it needs an :meth:`~object.__eq__` method). "
"Hashable objects which compare equal must have the same hash value."
msgstr ""
"Объект является *хешируемым*, если он имеет хеш-значение, которое никогда не "
"меняется в течение его существования (для этого требуется метод :meth:"
"`~object.__hash__`) и его можно сравнивать с другими объектами (для этого "
"нужен :meth:`~ метод object.__eq__`). Хешируемые объекты, которые "
"сравниваются равными, должны иметь одинаковое значение хеш-функции."

#: ../../glossary.rst:578
msgid ""
"Hashability makes an object usable as a dictionary key and a set member, "
"because these data structures use the hash value internally."
msgstr ""
"Хешируемость делает объект пригодным для использования в качестве ключа "
"словаря и члена множества, поскольку эти структуры данных внутренне "
"используют хеш-значение."

#: ../../glossary.rst:581
msgid ""
"Most of Python's immutable built-in objects are hashable; mutable containers "
"(such as lists or dictionaries) are not; immutable containers (such as "
"tuples and frozensets) are only hashable if their elements are hashable.  "
"Objects which are instances of user-defined classes are hashable by "
"default.  They all compare unequal (except with themselves), and their hash "
"value is derived from their :func:`id`."
msgstr ""
"Большинство неизменяемых встроенных объектов Python являются хешируемыми; "
"изменяемые контейнеры (такие как списки или словари) — нет; неизменяемые "
"контейнеры (такие как кортежи и замороженные наборы) хешируются только в том "
"случае, если их элементы хешируются. Объекты, являющиеся экземплярами "
"пользовательских классов, по умолчанию хешируются. Все они сравниваются "
"неравными (кроме самих себя), а их хеш-значение получается из их :func:`id`."

#: ../../glossary.rst:588
msgid "IDLE"
msgstr "IDLE"

#: ../../glossary.rst:590
msgid ""
"An Integrated Development and Learning Environment for Python. :ref:`idle` "
"is a basic editor and interpreter environment which ships with the standard "
"distribution of Python."
msgstr ""
"Большинство неизменяемых встроенных объектов Python являются хешируемыми; "
"изменяемые контейнеры (такие как списки или словари) — нет; неизменяемые "
"контейнеры (такие как кортежи и замороженные наборы) хешируются только в том "
"случае, если их элементы хешируются. Объекты, являющиеся экземплярами "
"пользовательских классов, по умолчанию хешируются. Все они сравниваются "
"неравными (кроме самих себя), а их хеш-значение получается из их :func:`id`."

#: ../../glossary.rst:593
msgid "immutable"
msgstr "неизменяемый"

#: ../../glossary.rst:595
msgid ""
"An object with a fixed value.  Immutable objects include numbers, strings "
"and tuples.  Such an object cannot be altered.  A new object has to be "
"created if a different value has to be stored.  They play an important role "
"in places where a constant hash value is needed, for example as a key in a "
"dictionary."
msgstr ""
"Объект с фиксированной стоимостью. Неизменяемые объекты включают числа, "
"строки и кортежи. Такой объект невозможно изменить. Если необходимо "
"сохранить другое значение, необходимо создать новый объект. Они играют "
"важную роль там, где требуется постоянное значение хеш-функции, например, в "
"качестве ключа в словаре."

#: ../../glossary.rst:600
msgid "import path"
msgstr "путь импорта"

#: ../../glossary.rst:602
msgid ""
"A list of locations (or :term:`path entries <path entry>`) that are searched "
"by the :term:`path based finder` for modules to import. During import, this "
"list of locations usually comes from :data:`sys.path`, but for subpackages "
"it may also come from the parent package's ``__path__`` attribute."
msgstr ""
"Список местоположений (или записей :term:`path <path input>`), в которых с "
"помощью средства поиска на основе пути :term:`path` выполняется поиск "
"модулей для импорта. Во время импорта этот список расположений обычно "
"берется из :data:`sys.path`, но для подпакетов он также может быть получен "
"из атрибута ``__path__`` родительского пакета."

#: ../../glossary.rst:607
msgid "importing"
msgstr "импортирование"

#: ../../glossary.rst:609
msgid ""
"The process by which Python code in one module is made available to Python "
"code in another module."
msgstr ""
"Процесс, посредством которого код Python в одном модуле становится доступным "
"для кода Python в другом модуле."

#: ../../glossary.rst:611
msgid "importer"
msgstr "импортер"

#: ../../glossary.rst:613
msgid ""
"An object that both finds and loads a module; both a :term:`finder` and :"
"term:`loader` object."
msgstr ""
"Объект, который находит и загружает модуль; оба объекта :term:`finder` и :"
"term:`loader`."

#: ../../glossary.rst:615
msgid "interactive"
msgstr "интерактивный"

#: ../../glossary.rst:617
msgid ""
"Python has an interactive interpreter which means you can enter statements "
"and expressions at the interpreter prompt, immediately execute them and see "
"their results.  Just launch ``python`` with no arguments (possibly by "
"selecting it from your computer's main menu). It is a very powerful way to "
"test out new ideas or inspect modules and packages (remember ``help(x)``)."
msgstr ""
"Python имеет интерактивный интерпретатор, что означает, что вы можете "
"вводить операторы и выражения в приглашении интерпретатора, немедленно "
"выполнять их и видеть результаты. Просто запустите Python без аргументов "
"(возможно, выбрав его в главном меню вашего компьютера). Это очень мощный "
"способ протестировать новые идеи или проверить модули и пакеты (помните "
"``help(x)``)."

#: ../../glossary.rst:623
msgid "interpreted"
msgstr "интерпретированный"

#: ../../glossary.rst:625
msgid ""
"Python is an interpreted language, as opposed to a compiled one, though the "
"distinction can be blurry because of the presence of the bytecode compiler.  "
"This means that source files can be run directly without explicitly creating "
"an executable which is then run. Interpreted languages typically have a "
"shorter development/debug cycle than compiled ones, though their programs "
"generally also run more slowly.  See also :term:`interactive`."
msgstr ""
"Python — это интерпретируемый язык, а не компилируемый, хотя различие может "
"быть размытым из-за наличия компилятора байт-кода. Это означает, что "
"исходные файлы можно запускать напрямую, без явного создания исполняемого "
"файла, который затем запускается. Интерпретируемые языки обычно имеют более "
"короткий цикл разработки/отладки, чем скомпилированные, хотя их программы "
"обычно работают медленнее. См. также:term:`интерактивный`."

#: ../../glossary.rst:632
msgid "interpreter shutdown"
msgstr "остановка интерпретатора"

#: ../../glossary.rst:634
msgid ""
"When asked to shut down, the Python interpreter enters a special phase where "
"it gradually releases all allocated resources, such as modules and various "
"critical internal structures.  It also makes several calls to the :term:"
"`garbage collector <garbage collection>`. This can trigger the execution of "
"code in user-defined destructors or weakref callbacks. Code executed during "
"the shutdown phase can encounter various exceptions as the resources it "
"relies on may not function anymore (common examples are library modules or "
"the warnings machinery)."
msgstr ""
"Когда интерпретатор Python получает запрос на выключение, он переходит в "
"специальную фазу, в которой он постепенно освобождает все выделенные "
"ресурсы, такие как модули и различные важные внутренние структуры. Он также "
"выполняет несколько вызовов :term:`сборщика мусора <сборка мусора>`. Это "
"может вызвать выполнение кода в пользовательских деструкторах или обратных "
"вызовах слабых ссылок. Код, выполняемый на этапе завершения работы, может "
"столкнуться с различными исключениями, поскольку ресурсы, на которые он "
"опирается, могут больше не функционировать (обычными примерами являются "
"библиотечные модули или механизмы предупреждений)."

#: ../../glossary.rst:643
msgid ""
"The main reason for interpreter shutdown is that the ``__main__`` module or "
"the script being run has finished executing."
msgstr ""
"Основная причина завершения работы интерпретатора заключается в том, что "
"модуль ``__main__`` или выполняемый скрипт завершили выполнение."

#: ../../glossary.rst:645
msgid "iterable"
msgstr "итерируемый объект"

#: ../../glossary.rst:647
msgid ""
"An object capable of returning its members one at a time. Examples of "
"iterables include all sequence types (such as :class:`list`, :class:`str`, "
"and :class:`tuple`) and some non-sequence types like :class:`dict`, :term:"
"`file objects <file object>`, and objects of any classes you define with an :"
"meth:`~iterator.__iter__` method or with a :meth:`~object.__getitem__` "
"method that implements :term:`sequence` semantics."
msgstr ""
"Объект, способный возвращать свои члены по одному. Примеры итераций включают "
"все типы последовательностей (такие как :class:`list`, :class:`str` и :class:"
"`tuple`) и некоторые не-последовательные типы, такие как :class:`dict`, :"
"term:` файловые объекты <file object>` и объекты любых классов, которые вы "
"определяете с помощью метода :meth:`~iterator.__iter__` или с помощью "
"метода :meth:`~object.__getitem__`, который реализует семантику :term:"
"`sequence`."

#: ../../glossary.rst:655
msgid ""
"Iterables can be used in a :keyword:`for` loop and in many other places "
"where a sequence is needed (:func:`zip`, :func:`map`, ...).  When an "
"iterable object is passed as an argument to the built-in function :func:"
"`iter`, it returns an iterator for the object.  This iterator is good for "
"one pass over the set of values.  When using iterables, it is usually not "
"necessary to call :func:`iter` or deal with iterator objects yourself.  The :"
"keyword:`for` statement does that automatically for you, creating a "
"temporary unnamed variable to hold the iterator for the duration of the "
"loop.  See also :term:`iterator`, :term:`sequence`, and :term:`generator`."
msgstr ""
"Итерации можно использовать в цикле :keyword:`for` и во многих других "
"местах, где необходима последовательность (:func:`zip`, :func:`map`, ...). "
"Когда итерируемый объект передается в качестве аргумента встроенной функции :"
"func:`iter`, она возвращает итератор для объекта. Этот итератор хорош для "
"одного прохода по набору значений. При использовании итераторов обычно нет "
"необходимости вызывать :func:`iter` или самостоятельно работать с объектами-"
"итераторами. Оператор :keyword:`for` делает это автоматически, создавая "
"временную безымянную переменную для хранения итератора на протяжении всего "
"цикла. См. также :term:`iterator`, :term:`sequence` и :term:`generator`."

#: ../../glossary.rst:665
msgid "iterator"
msgstr "итератор"

#: ../../glossary.rst:667
msgid ""
"An object representing a stream of data.  Repeated calls to the iterator's :"
"meth:`~iterator.__next__` method (or passing it to the built-in function :"
"func:`next`) return successive items in the stream.  When no more data are "
"available a :exc:`StopIteration` exception is raised instead.  At this "
"point, the iterator object is exhausted and any further calls to its :meth:`!"
"__next__` method just raise :exc:`StopIteration` again.  Iterators are "
"required to have an :meth:`~iterator.__iter__` method that returns the "
"iterator object itself so every iterator is also iterable and may be used in "
"most places where other iterables are accepted.  One notable exception is "
"code which attempts multiple iteration passes.  A container object (such as "
"a :class:`list`) produces a fresh new iterator each time you pass it to the :"
"func:`iter` function or use it in a :keyword:`for` loop.  Attempting this "
"with an iterator will just return the same exhausted iterator object used in "
"the previous iteration pass, making it appear like an empty container."
msgstr ""
"Объект, представляющий поток данных. Повторные вызовы метода итератора :meth:"
"`~iterator.__next__` (или передача его встроенной функции :func:`next`) "
"возвращают последовательные элементы в потоке. Когда больше нет доступных "
"данных, вместо этого возникает исключение :exc:`StopIteration`. На этом "
"этапе объект итератора исчерпан, и любые дальнейшие вызовы его метода :meth:"
"`!__next__` просто снова вызовут :exc:`StopIteration`. Итераторы должны "
"иметь метод :meth:`~iterator.__iter__`, который возвращает сам объект "
"итератора, поэтому каждый итератор также является итерируемым и может "
"использоваться в большинстве мест, где принимаются другие итераторы. Одним "
"заметным исключением является код, который пытается выполнить несколько "
"итераций. Объект-контейнер (например, :class:`list`) создает новый новый "
"итератор каждый раз, когда вы передаете его функции :func:`iter` или "
"используете его в цикле :keyword:`for`. Попытка сделать это с помощью "
"итератора просто вернет тот же самый исчерпанный объект итератора, который "
"использовался на предыдущем проходе итерации, делая его похожим на пустой "
"контейнер."

#: ../../glossary.rst:682
msgid "More information can be found in :ref:`typeiter`."
msgstr "Более подробную информацию можно найти по ссылке :ref:`typeiter`."

#: ../../glossary.rst:686
msgid ""
"CPython does not consistently apply the requirement that an iterator define :"
"meth:`~iterator.__iter__`."
msgstr ""
"CPython не всегда последовательно применяет требование, чтобы итератор "
"определял :meth:`~iterator.__iter__`."

#: ../../glossary.rst:688
msgid "key function"
msgstr "функция ключа"

#: ../../glossary.rst:690
msgid ""
"A key function or collation function is a callable that returns a value used "
"for sorting or ordering.  For example, :func:`locale.strxfrm` is used to "
"produce a sort key that is aware of locale specific sort conventions."
msgstr ""
"Ключевая функция или функция сопоставления — это вызываемый объект, который "
"возвращает значение, используемое для сортировки или упорядочивания. "
"Например, :func:`locale.strxfrm` используется для создания ключа сортировки, "
"который учитывает соглашения о сортировке, специфичные для локали."

#: ../../glossary.rst:695
msgid ""
"A number of tools in Python accept key functions to control how elements are "
"ordered or grouped.  They include :func:`min`, :func:`max`, :func:`sorted`, :"
"meth:`list.sort`, :func:`heapq.merge`, :func:`heapq.nsmallest`, :func:`heapq."
"nlargest`, and :func:`itertools.groupby`."
msgstr ""
"Ряд инструментов Python поддерживают ключевые функции для управления "
"упорядочением или группировкой элементов. К ним относятся :func:`min`, :func:"
"`max`, :func:`sorted`, :meth:`list.sort`, :func:`heapq.merge`, :func:`heapq."
"nsmallest`, :func:`heapq.nlargest` и :func:`itertools.groupby`."

#: ../../glossary.rst:701
msgid ""
"There are several ways to create a key function.  For example. the :meth:"
"`str.lower` method can serve as a key function for case insensitive sorts.  "
"Alternatively, a key function can be built from a :keyword:`lambda` "
"expression such as ``lambda r: (r[0], r[2])``.  Also, :func:`operator."
"attrgetter`, :func:`operator.itemgetter`, and :func:`operator.methodcaller` "
"are three key function constructors.  See the :ref:`Sorting HOW TO "
"<sortinghowto>` for examples of how to create and use key functions."
msgstr ""
"Существует несколько способов создания ключевой функции. Например. метод :"
"meth:`str.lower` может служить ключевой функцией для сортировок без учета "
"регистра. Альтернативно, ключевая функция может быть построена из выражения :"
"keyword:`lambda`, например ``lambda r: (r[0], r[2])``. Кроме того, :func:"
"`operator.attrgetter`, :func:`operator.itemgetter` и :func:`operator."
"methodcaller` являются тремя ключевыми конструкторами функций. См. :ref:"
"`Sorting HOW TO <sortinghowto>` для примеров того, как создавать и "
"использовать ключевые функции."

#: ../../glossary.rst:708
msgid "keyword argument"
msgstr "именованный аргумент"

#: ../../glossary.rst:710 ../../glossary.rst:1001
msgid "See :term:`argument`."
msgstr "Смотри :term:`argument`."

#: ../../glossary.rst:711
msgid "lambda"
msgstr "лямбда"

#: ../../glossary.rst:713
msgid ""
"An anonymous inline function consisting of a single :term:`expression` which "
"is evaluated when the function is called.  The syntax to create a lambda "
"function is ``lambda [parameters]: expression``"
msgstr ""
"Анонимная встроенная функция, состоящая из одного :term:`expression`, "
"которое вычисляется при вызове функции. Синтаксис для создания лямбда-"
"функции: ``лямбда [параметры]: выражение``."

#: ../../glossary.rst:716
msgid "LBYL"
msgstr "LBYL"

#: ../../glossary.rst:718
msgid ""
"Look before you leap.  This coding style explicitly tests for pre-conditions "
"before making calls or lookups.  This style contrasts with the :term:`EAFP` "
"approach and is characterized by the presence of many :keyword:`if` "
"statements."
msgstr ""
"Посмотрите, прежде чем прыгнуть. Этот стиль кодирования явно проверяет "
"предварительные условия перед выполнением вызовов или поиска. Этот стиль "
"контрастирует с подходом :term:`EAFP` и характеризуется наличием множества "
"операторов :keyword:`if`."

#: ../../glossary.rst:723
msgid ""
"In a multi-threaded environment, the LBYL approach can risk introducing a "
"race condition between \"the looking\" and \"the leaping\".  For example, "
"the code, ``if key in mapping: return mapping[key]`` can fail if another "
"thread removes *key* from *mapping* after the test, but before the lookup. "
"This issue can be solved with locks or by using the EAFP approach."
msgstr ""
"В многопоточной среде подход LBYL может привести к возникновению состояния "
"гонки между «смотрением» и «прыжком». Например, код ``if key in Mapping: "
"return Mapping[key]`` может привести к сбою, если другой поток удалит *key* "
"из *mapping* после теста, но до поиска. Эту проблему можно решить с помощью "
"блокировок или с помощью подхода EAFP."

#: ../../glossary.rst:728
msgid "list"
msgstr "список"

#: ../../glossary.rst:730
msgid ""
"A built-in Python :term:`sequence`.  Despite its name it is more akin to an "
"array in other languages than to a linked list since access to elements is "
"*O*\\ (1)."
msgstr ""
"Встроенный Python :term:`sequence`. Несмотря на свое название, в других "
"языках он больше похож на массив, чем на связанный список, поскольку доступ "
"к элементам осуществляется через *O*\\ (1)."

#: ../../glossary.rst:733
msgid "list comprehension"
msgstr "списковое включение"

#: ../../glossary.rst:735
msgid ""
"A compact way to process all or part of the elements in a sequence and "
"return a list with the results.  ``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]`` generates a list of strings containing even hex "
"numbers (0x..) in the range from 0 to 255. The :keyword:`if` clause is "
"optional.  If omitted, all elements in ``range(256)`` are processed."
msgstr ""
"Компактный способ обработки всех или части элементов последовательности и "
"возврата списка с результатами. ``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]`` генерирует список строк, содержащих четные "
"шестнадцатеричные числа (0x..) в диапазон от 0 до 255. Предложение :keyword:"
"`if` не является обязательным. Если этот параметр опущен, обрабатываются все "
"элементы в диапазоне (256)."

#: ../../glossary.rst:741
msgid "loader"
msgstr "загрузчик"

#: ../../glossary.rst:743
msgid ""
"An object that loads a module. It must define a method named :meth:"
"`load_module`. A loader is typically returned by a :term:`finder`. See :pep:"
"`302` for details and :class:`importlib.abc.Loader` for an :term:`abstract "
"base class`."
msgstr ""

#: ../../glossary.rst:747
msgid "locale encoding"
msgstr "кодировка локали"

#: ../../glossary.rst:749
msgid ""
"On Unix, it is the encoding of the LC_CTYPE locale. It can be set with :func:"
"`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>`."
msgstr ""
"В Unix это кодировка локали LC_CTYPE. Его можно установить с помощью :func:"
"`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>`."

#: ../../glossary.rst:752
msgid "On Windows, it is the ANSI code page (ex: ``\"cp1252\"``)."
msgstr "В Windows это кодовая страница ANSI (например: ``\"cp1252\"``)."

#: ../../glossary.rst:754
msgid ""
"On Android and VxWorks, Python uses ``\"utf-8\"`` as the locale encoding."
msgstr ""
"В Android и VxWorks Python использует «utf-8» в качестве кодировки локали."

#: ../../glossary.rst:756
msgid ":func:`locale.getencoding` can be used to get the locale encoding."
msgstr ""
":func:`locale.getencoding` можно использовать для получения кодировки локали."

#: ../../glossary.rst:758
msgid "See also the :term:`filesystem encoding and error handler`."
msgstr "См. также :term:`кодирование файловой системы и обработчик ошибок`."

#: ../../glossary.rst:759
msgid "magic method"
msgstr "магический метод"

#: ../../glossary.rst:763
msgid "An informal synonym for :term:`special method`."
msgstr "Неформальный синоним термина «специальный метод»."

#: ../../glossary.rst:764
msgid "mapping"
msgstr "сопоставление"

#: ../../glossary.rst:766
msgid ""
"A container object that supports arbitrary key lookups and implements the "
"methods specified in the :class:`collections.abc.Mapping` or :class:"
"`collections.abc.MutableMapping` :ref:`abstract base classes <collections-"
"abstract-base-classes>`.  Examples include :class:`dict`, :class:"
"`collections.defaultdict`, :class:`collections.OrderedDict` and :class:"
"`collections.Counter`."
msgstr ""
"Объект-контейнер, который поддерживает поиск по произвольным ключам и "
"реализует методы, указанные в :class:`collections.abc.Mapping` или :class:"
"`collections.abc.MutableMapping` :ref:`abstract базовых классах <collections-"
"abstract-base- классы>`. Примеры: :class:`dict`, :class:`collections."
"defaultdict`, :class:`collections.OrderedDict` и :class:`collections."
"Counter`."

#: ../../glossary.rst:772
msgid "meta path finder"
msgstr "искатель в мета-пути"

#: ../../glossary.rst:774
msgid ""
"A :term:`finder` returned by a search of :data:`sys.meta_path`.  Meta path "
"finders are related to, but different from :term:`path entry finders <path "
"entry finder>`."
msgstr ""
"A :term:`finder` r возвращается при поиске  :data:`sys.meta_path`.  Средства "
"поиска метапутей связаны с :term:`path entry finders <path entry finder>`, "
"но отличаются от них. "

#: ../../glossary.rst:778
msgid ""
"See :class:`importlib.abc.MetaPathFinder` for the methods that meta path "
"finders implement."
msgstr ""
"См. :class:`importlib.abc.MetaPathFinder` для получения информации о "
"методах, которые реализуют средства поиска метапутей."

#: ../../glossary.rst:780
msgid "metaclass"
msgstr "метакласс"

#: ../../glossary.rst:782
msgid ""
"The class of a class.  Class definitions create a class name, a class "
"dictionary, and a list of base classes.  The metaclass is responsible for "
"taking those three arguments and creating the class.  Most object oriented "
"programming languages provide a default implementation.  What makes Python "
"special is that it is possible to create custom metaclasses.  Most users "
"never need this tool, but when the need arises, metaclasses can provide "
"powerful, elegant solutions.  They have been used for logging attribute "
"access, adding thread-safety, tracking object creation, implementing "
"singletons, and many other tasks."
msgstr ""
"Класс класса. Определения классов создают имя класса, словарь классов и "
"список базовых классов. Метакласс отвечает за принятие этих трех аргументов "
"и создание класса. Большинство объектно-ориентированных языков "
"программирования предоставляют реализацию по умолчанию. Что делает Python "
"особенным, так это возможность создавать собственные метаклассы. Большинству "
"пользователей этот инструмент никогда не понадобится, но когда возникает "
"необходимость, метаклассы могут предоставить мощные и элегантные решения. "
"Они использовались для регистрации доступа к атрибутам, добавления "
"потокобезопасности, отслеживания создания объектов, реализации синглтонов и "
"многих других задач."

#: ../../glossary.rst:792
msgid "More information can be found in :ref:`metaclasses`."
msgstr "Больше информации можно найти по ссылке :ref:`metaclasses`."

#: ../../glossary.rst:761 ../../glossary.rst:793 ../../glossary.rst:1129
msgid "method"
msgstr "метод"

#: ../../glossary.rst:795
msgid ""
"A function which is defined inside a class body.  If called as an attribute "
"of an instance of that class, the method will get the instance object as its "
"first :term:`argument` (which is usually called ``self``). See :term:"
"`function` and :term:`nested scope`."
msgstr ""
"Функция, определенная внутри тела класса. Если метод вызывается как атрибут "
"экземпляра этого класса, метод получит объект экземпляра в качестве своего "
"первого аргумента (который обычно называется self). См. :term:`function` и :"
"term:`вложенная область видимости`."

#: ../../glossary.rst:799
msgid "method resolution order"
msgstr "порядок разрешения методов"

#: ../../glossary.rst:801
msgid ""
"Method Resolution Order is the order in which base classes are searched for "
"a member during lookup. See `The Python 2.3 Method Resolution Order <https://"
"www.python.org/download/releases/2.3/mro/>`_ for details of the algorithm "
"used by the Python interpreter since the 2.3 release."
msgstr ""

#: ../../glossary.rst:805
msgid "module"
msgstr "модуль"

#: ../../glossary.rst:807
msgid ""
"An object that serves as an organizational unit of Python code.  Modules "
"have a namespace containing arbitrary Python objects.  Modules are loaded "
"into Python by the process of :term:`importing`."
msgstr ""
"Объект, служащий организационной единицей кода Python. Модули имеют "
"пространство имен, содержащее произвольные объекты Python. Модули "
"загружаются в Python в процессе импорта."

#: ../../glossary.rst:811
msgid "See also :term:`package`."
msgstr "см. также :term:`package`."

#: ../../glossary.rst:812
msgid "module spec"
msgstr "спецификация модуля"

#: ../../glossary.rst:814
msgid ""
"A namespace containing the import-related information used to load a module. "
"An instance of :class:`importlib.machinery.ModuleSpec`."
msgstr ""
"Пространство имен, содержащее информацию, связанную с импортом, используемую "
"для загрузки модуля. Экземпляр :class:`importlib.machinery.ModuleSpec`."

#: ../../glossary.rst:816
msgid "MRO"
msgstr "MRO"

#: ../../glossary.rst:818
msgid "See :term:`method resolution order`."
msgstr "Смотри :term:`method resolution order`."

#: ../../glossary.rst:819
msgid "mutable"
msgstr "изменяемый"

#: ../../glossary.rst:821
msgid ""
"Mutable objects can change their value but keep their :func:`id`.  See also :"
"term:`immutable`."
msgstr ""
"Изменяемые объекты могут менять свое значение, но сохраняют свой :func:`id`. "
"См. также :term:`immutable`."

#: ../../glossary.rst:823
msgid "named tuple"
msgstr "именованный кортеж"

#: ../../glossary.rst:825
msgid ""
"The term \"named tuple\" applies to any type or class that inherits from "
"tuple and whose indexable elements are also accessible using named "
"attributes.  The type or class may have other features as well."
msgstr ""
"Термин «именованный кортеж» применяется к любому типу или классу, который "
"наследуется от кортежа и чьи индексируемые элементы также доступны с "
"использованием именованных атрибутов. Тип или класс могут иметь и другие "
"особенности."

#: ../../glossary.rst:829
msgid ""
"Several built-in types are named tuples, including the values returned by :"
"func:`time.localtime` and :func:`os.stat`.  Another example is :data:`sys."
"float_info`::"
msgstr ""
"Несколько встроенных типов называются кортежами, включая значения, "
"возвращаемые :func:`time.localtime` и :func:`os.stat`. Другой пример: :data:"
"`sys.float_info`::"

#: ../../glossary.rst:840
msgid ""
"Some named tuples are built-in types (such as the above examples). "
"Alternatively, a named tuple can be created from a regular class definition "
"that inherits from :class:`tuple` and that defines named fields.  Such a "
"class can be written by hand, or it can be created by inheriting :class:"
"`typing.NamedTuple`, or with the factory function :func:`collections."
"namedtuple`.  The latter techniques also add some extra methods that may not "
"be found in hand-written or built-in named tuples."
msgstr ""
"Некоторые именованные кортежи являются встроенными типами (например, "
"приведенные выше примеры). В качестве альтернативы именованный кортеж можно "
"создать из определения обычного класса, который наследуется от :class:"
"`tuple` и определяет именованные поля. Такой класс можно написать вручную "
"или создать путем наследования :class:`typing.NamedTuple` или с помощью "
"фабричной функции :func:`collections.namedtuple`. Последние методы также "
"добавляют некоторые дополнительные методы, которых нет в рукописных или "
"встроенных именованных кортежах."

#: ../../glossary.rst:848
msgid "namespace"
msgstr "пространство имён"

#: ../../glossary.rst:850
msgid ""
"The place where a variable is stored.  Namespaces are implemented as "
"dictionaries.  There are the local, global and built-in namespaces as well "
"as nested namespaces in objects (in methods).  Namespaces support modularity "
"by preventing naming conflicts.  For instance, the functions :func:`builtins."
"open <.open>` and :func:`os.open` are distinguished by their namespaces.  "
"Namespaces also aid readability and maintainability by making it clear which "
"module implements a function.  For instance, writing :func:`random.seed` or :"
"func:`itertools.islice` makes it clear that those functions are implemented "
"by the :mod:`random` and :mod:`itertools` modules, respectively."
msgstr ""
"Место, где хранится переменная. Пространства имен реализованы как словари. "
"Существуют локальные, глобальные и встроенные пространства имен, а также "
"вложенные пространства имен в объектах (в методах). Пространства имен "
"поддерживают модульность, предотвращая конфликты имен. Например, функции :"
"func:`builtins.open <.open>` и :func:`os.open` различаются своими "
"пространствами имен. Пространства имен также повышают читаемость и удобство "
"обслуживания, поскольку ясно показывают, какой модуль реализует ту или иную "
"функцию. Например, запись :func:`random.seed` или :func:`itertools.islice` "
"дает понять, что эти функции реализуются модулями :mod:`random` и :mod:"
"`itertools` соответственно."

#: ../../glossary.rst:860
msgid "namespace package"
msgstr "пакет пространства имен"

#: ../../glossary.rst:862
msgid ""
"A :pep:`420` :term:`package` which serves only as a container for "
"subpackages.  Namespace packages may have no physical representation, and "
"specifically are not like a :term:`regular package` because they have no "
"``__init__.py`` file."
msgstr ""
":pep:`420` :term:`package`, который служит только контейнером для "
"подпакетов. Пакеты пространства имен могут не иметь физического "
"представления и, в частности, не похожи на :term:`обычный пакет`, поскольку "
"у них нет файла ``__init__.py``."

#: ../../glossary.rst:867
msgid "See also :term:`module`."
msgstr "см. также :term:`module`."

#: ../../glossary.rst:868
msgid "nested scope"
msgstr "вложенная область видимости"

#: ../../glossary.rst:870
msgid ""
"The ability to refer to a variable in an enclosing definition.  For "
"instance, a function defined inside another function can refer to variables "
"in the outer function.  Note that nested scopes by default work only for "
"reference and not for assignment.  Local variables both read and write in "
"the innermost scope.  Likewise, global variables read and write to the "
"global namespace.  The :keyword:`nonlocal` allows writing to outer scopes."
msgstr ""
"Возможность ссылаться на переменную во включающем определении. Например, "
"функция, определенная внутри другой функции, может ссылаться на переменные "
"внешней функции. Обратите внимание, что вложенные области по умолчанию "
"работают только для ссылки, а не для назначения. Локальные переменные читают "
"и записывают в самой внутренней области. Аналогично, глобальные переменные "
"читают и записывают в глобальное пространство имен. :keyword:`nonlocal` "
"позволяет выполнять запись во внешние области."

#: ../../glossary.rst:877
msgid "new-style class"
msgstr "класс нового стиля"

#: ../../glossary.rst:879
msgid ""
"Old name for the flavor of classes now used for all class objects.  In "
"earlier Python versions, only new-style classes could use Python's newer, "
"versatile features like :attr:`~object.__slots__`, descriptors, properties, :"
"meth:`~object.__getattribute__`, class methods, and static methods."
msgstr ""
"Старое название разновидности классов теперь используется для всех объектов "
"классов. В более ранних версиях Python только классы нового стиля могли "
"использовать новые универсальные функции Python, такие как :attr:`~object."
"__slots__`, дескрипторы, свойства, :meth:`~object.__getattribute__`, методы "
"класса и статические методы."

#: ../../glossary.rst:884
msgid "object"
msgstr "объект"

#: ../../glossary.rst:886
msgid ""
"Any data with state (attributes or value) and defined behavior (methods).  "
"Also the ultimate base class of any :term:`new-style class`."
msgstr ""
"Любые данные с состоянием (атрибутами или значением) и определенным "
"поведением (методами). Также окончательный базовый класс любого класса "
"нового стиля."

#: ../../glossary.rst:889
msgid "package"
msgstr "пакет"

#: ../../glossary.rst:891
msgid ""
"A Python :term:`module` which can contain submodules or recursively, "
"subpackages.  Technically, a package is a Python module with a ``__path__`` "
"attribute."
msgstr ""
"Python :term:`module`, который может содержать подмодули или рекурсивно "
"подпакеты. Технически пакет представляет собой модуль Python с атрибутом "
"``__path__``."

#: ../../glossary.rst:895
msgid "See also :term:`regular package` and :term:`namespace package`."
msgstr "см. также :term:`regular package` и :term:`namespace package`."

#: ../../glossary.rst:896
msgid "parameter"
msgstr "параметр"

#: ../../glossary.rst:898
msgid ""
"A named entity in a :term:`function` (or method) definition that specifies "
"an :term:`argument` (or in some cases, arguments) that the function can "
"accept.  There are five kinds of parameter:"
msgstr ""
"Именованный объект в определении :term:`функции` (или метода), который "
"определяет :term:`аргумент` (или, в некоторых случаях, аргументы), которые "
"может принимать функция. Существует пять типов параметров:"

#: ../../glossary.rst:902
msgid ""
":dfn:`positional-or-keyword`: specifies an argument that can be passed "
"either :term:`positionally <argument>` or as a :term:`keyword argument "
"<argument>`.  This is the default kind of parameter, for example *foo* and "
"*bar* in the following::"
msgstr ""
":dfn:`positional-or-keyword`: определяет аргумент, который может быть "
"передан либо :term:`позиционно <аргумент>`, либо как :term:`ключевой "
"аргумент <аргумент>`. Это параметр по умолчанию, например *foo* и *bar* в "
"следующем::"

#: ../../glossary.rst:911
msgid ""
":dfn:`positional-only`: specifies an argument that can be supplied only by "
"position. Positional-only parameters can be defined by including a ``/`` "
"character in the parameter list of the function definition after them, for "
"example *posonly1* and *posonly2* in the following::"
msgstr ""
":dfn:`positional-only`: указывает аргумент, который может быть передан "
"только по позиции. Параметры, предназначенные только для позиции, можно "
"определить, включив символ ``/`` в список параметров определения функции "
"после них, например *posonly1* и *posonly2* в следующем:"

#: ../../glossary.rst:920
msgid ""
":dfn:`keyword-only`: specifies an argument that can be supplied only by "
"keyword.  Keyword-only parameters can be defined by including a single var-"
"positional parameter or bare ``*`` in the parameter list of the function "
"definition before them, for example *kw_only1* and *kw_only2* in the "
"following::"
msgstr ""
":dfn:`keyword-only`: указывает аргумент, который может быть передан только "
"по ключевому слову. Параметры только по ключевому слову могут быть "
"определены путем включения одного позиционного параметра или пустого ``*`` в "
"список параметров определения функции перед ними, например *kw_only1* и "
"*kw_only2* в следующем::"

#: ../../glossary.rst:928
msgid ""
":dfn:`var-positional`: specifies that an arbitrary sequence of positional "
"arguments can be provided (in addition to any positional arguments already "
"accepted by other parameters).  Such a parameter can be defined by "
"prepending the parameter name with ``*``, for example *args* in the "
"following::"
msgstr ""
":dfn:`var-positional`: указывает, что может быть предоставлена ​​произвольная "
"последовательность позиционных аргументов (в дополнение к любым позиционным "
"аргументам, уже принятым другими параметрами). Такой параметр можно "
"определить, добавив к имени параметра ``*``, например *args*, в следующем:"

#: ../../glossary.rst:936
msgid ""
":dfn:`var-keyword`: specifies that arbitrarily many keyword arguments can be "
"provided (in addition to any keyword arguments already accepted by other "
"parameters).  Such a parameter can be defined by prepending the parameter "
"name with ``**``, for example *kwargs* in the example above."
msgstr ""
":dfn:`var-keyword`: указывает, что может быть предоставлено произвольное "
"количество аргументов ключевого слова (в дополнение к любым аргументам "
"ключевого слова, уже принятым другими параметрами). Такой параметр можно "
"определить, добавив к имени параметра ``**``, например *kwargs* в "
"приведенном выше примере."

#: ../../glossary.rst:942
msgid ""
"Parameters can specify both optional and required arguments, as well as "
"default values for some optional arguments."
msgstr ""
"Параметры могут указывать как необязательные, так и обязательные аргументы, "
"а также значения по умолчанию для некоторых необязательных аргументов."

#: ../../glossary.rst:945
msgid ""
"See also the :term:`argument` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"the :class:`inspect.Parameter` class, the :ref:`function` section, and :pep:"
"`362`."
msgstr ""
"См. также статью глоссария :term:`argument`, вопрос часто задаваемых "
"вопросов по :ref:`разнице между аргументами и параметрами <faq-argument-vs-"
"parameter>`, класс :class:`inspect.Parameter`, класс : раздел ref:`function` "
"и :pep:`362`."

#: ../../glossary.rst:949
msgid "path entry"
msgstr "элемент пути"

#: ../../glossary.rst:951
msgid ""
"A single location on the :term:`import path` which the :term:`path based "
"finder` consults to find modules for importing."
msgstr ""
"Единственное место на пути импорта, к которому обращается средство поиска на "
"основе пути, чтобы найти модули для импорта."

#: ../../glossary.rst:953
msgid "path entry finder"
msgstr "искатель в элементе пути"

#: ../../glossary.rst:955
msgid ""
"A :term:`finder` returned by a callable on :data:`sys.path_hooks` (i.e. a :"
"term:`path entry hook`) which knows how to locate modules given a :term:"
"`path entry`."
msgstr ""
"A :term:`finder` , возвращаемый вызываемым объектом :data:`sys.path_hooks` "
"(i.e. a :term:`path entry hook`)  который знает, как найти модули по :term:"
"`path входу`. "

#: ../../glossary.rst:959
msgid ""
"See :class:`importlib.abc.PathEntryFinder` for the methods that path entry "
"finders implement."
msgstr ""
"См. :class:`importlib.abc.PathEntryFinder` для получения информации о "
"методах, которые реализуют средства поиска записей пути."

#: ../../glossary.rst:961
msgid "path entry hook"
msgstr "перехватчик элемента пути"

#: ../../glossary.rst:963
msgid ""
"A callable on the :data:`sys.path_hooks` list which returns a :term:`path "
"entry finder` if it knows how to find modules on a specific :term:`path "
"entry`."
msgstr ""
"Вызываемая функция в списке :data:`sys.path_hooks``, которая возвращает :"
"term:`path entry finder` если он знает, как найти модули по определенной :"
"term:`записи пути`. "

#: ../../glossary.rst:966
msgid "path based finder"
msgstr "искатель в путях"

#: ../../glossary.rst:968
msgid ""
"One of the default :term:`meta path finders <meta path finder>` which "
"searches an :term:`import path` for modules."
msgstr ""
"Один из средств поиска метапутей :term:`meta path finders <meta path "
"finder>`, который ищет модули по пути импорта."

#: ../../glossary.rst:970
msgid "path-like object"
msgstr "путеподобный объект"

#: ../../glossary.rst:972
msgid ""
"An object representing a file system path. A path-like object is either a :"
"class:`str` or :class:`bytes` object representing a path, or an object "
"implementing the :class:`os.PathLike` protocol. An object that supports the :"
"class:`os.PathLike` protocol can be converted to a :class:`str` or :class:"
"`bytes` file system path by calling the :func:`os.fspath` function; :func:"
"`os.fsdecode` and :func:`os.fsencode` can be used to guarantee a :class:"
"`str` or :class:`bytes` result instead, respectively. Introduced by :pep:"
"`519`."
msgstr ""
"Объект, представляющий путь к файловой системе. Объект, подобный пути, — это "
"либо объект :class:`str` или :class:`bytes`, представляющий путь, либо "
"объект, реализующий протокол :class:`os.PathLike`. Объект, поддерживающий "
"протокол :class:`os.PathLike`, можно преобразовать в путь файловой системы :"
"class:`str` или :class:`bytes`, вызвав функцию :func:`os.fspath`; Вместо "
"этого можно использовать :func:`os.fsdecode` и :func:`os.fsencode`, чтобы "
"гарантировать результат :class:`str` или :class:`bytes` соответственно. "
"Представлено :pep:`519`."

#: ../../glossary.rst:980
msgid "PEP"
msgstr "PEP"

#: ../../glossary.rst:982
msgid ""
"Python Enhancement Proposal. A PEP is a design document providing "
"information to the Python community, or describing a new feature for Python "
"or its processes or environment. PEPs should provide a concise technical "
"specification and a rationale for proposed features."
msgstr ""
"Предложение по улучшению Python. PEP — это проектный документ, "
"предоставляющий информацию сообществу Python или описывающий новую функцию "
"Python, его процессов или среды. Политические деятели должны предоставить "
"краткую техническую спецификацию и обоснование предлагаемых функций."

#: ../../glossary.rst:988
msgid ""
"PEPs are intended to be the primary mechanisms for proposing major new "
"features, for collecting community input on an issue, and for documenting "
"the design decisions that have gone into Python. The PEP author is "
"responsible for building consensus within the community and documenting "
"dissenting opinions."
msgstr ""
"PEP призваны стать основными механизмами предложения крупных новых функций, "
"сбора мнений сообщества по проблеме и документирования проектных решений, "
"вошедших в Python. Автор PEP отвечает за достижение консенсуса внутри "
"сообщества и документирование несогласных мнений."

#: ../../glossary.rst:994
msgid "See :pep:`1`."
msgstr "Смотри :pep:`1`."

#: ../../glossary.rst:995
msgid "portion"
msgstr "порция"

#: ../../glossary.rst:997
msgid ""
"A set of files in a single directory (possibly stored in a zip file) that "
"contribute to a namespace package, as defined in :pep:`420`."
msgstr ""
"Набор файлов в одном каталоге (возможно, хранящихся в zip-файле), которые "
"составляют пакет пространства имен, как определено в :pep:`420`."

#: ../../glossary.rst:999
msgid "positional argument"
msgstr "позиционный аргумент"

#: ../../glossary.rst:1002
msgid "provisional API"
msgstr "предварительный API"

#: ../../glossary.rst:1004
msgid ""
"A provisional API is one which has been deliberately excluded from the "
"standard library's backwards compatibility guarantees.  While major changes "
"to such interfaces are not expected, as long as they are marked provisional, "
"backwards incompatible changes (up to and including removal of the "
"interface) may occur if deemed necessary by core developers.  Such changes "
"will not be made gratuitously -- they will occur only if serious fundamental "
"flaws are uncovered that were missed prior to the inclusion of the API."
msgstr ""
"Временный API — это API, который был намеренно исключен из гарантий обратной "
"совместимости стандартной библиотеки. Хотя серьезных изменений в таких "
"интерфейсах не ожидается, пока они помечены как временные, могут произойти "
"обратно несовместимые изменения (вплоть до удаления интерфейса), если "
"основные разработчики сочтут это необходимым. Такие изменения не будут "
"вноситься безвозмездно — они произойдут только в том случае, если будут "
"обнаружены серьезные фундаментальные недостатки, которые были упущены до "
"включения API."

#: ../../glossary.rst:1013
msgid ""
"Even for provisional APIs, backwards incompatible changes are seen as a "
"\"solution of last resort\" - every attempt will still be made to find a "
"backwards compatible resolution to any identified problems."
msgstr ""
"Даже для предварительных API изменения, несовместимые с предыдущими "
"версиями, рассматриваются как «решение последней инстанции» — все равно "
"будут предприняты все попытки найти обратно совместимое решение для любых "
"выявленных проблем."

#: ../../glossary.rst:1017
msgid ""
"This process allows the standard library to continue to evolve over time, "
"without locking in problematic design errors for extended periods of time.  "
"See :pep:`411` for more details."
msgstr ""
"Этот процесс позволяет стандартной библиотеке продолжать развиваться с "
"течением времени, не допуская проблемных ошибок проектирования на длительные "
"периоды времени. См. :pep:`411` для более подробной информации."

#: ../../glossary.rst:1020
msgid "provisional package"
msgstr "предварительный пакет"

#: ../../glossary.rst:1022
msgid "See :term:`provisional API`."
msgstr "Смотри :term:`provisional API`."

#: ../../glossary.rst:1023
msgid "Python 3000"
msgstr "Python 3000"

#: ../../glossary.rst:1025
msgid ""
"Nickname for the Python 3.x release line (coined long ago when the release "
"of version 3 was something in the distant future.)  This is also abbreviated "
"\"Py3k\"."
msgstr ""
"Псевдоним для линейки выпуска Python 3.x (придуман давно, когда выпуск "
"версии 3 был чем-то отдаленным). Это также сокращенно «Py3k»."

#: ../../glossary.rst:1028
msgid "Pythonic"
msgstr "идиоматический"

#: ../../glossary.rst:1030
msgid ""
"An idea or piece of code which closely follows the most common idioms of the "
"Python language, rather than implementing code using concepts common to "
"other languages.  For example, a common idiom in Python is to loop over all "
"elements of an iterable using a :keyword:`for` statement.  Many other "
"languages don't have this type of construct, so people unfamiliar with "
"Python sometimes use a numerical counter instead::"
msgstr ""
"Идея или фрагмент кода, который точно соответствует наиболее "
"распространенным идиомам языка Python, а не реализует код с использованием "
"концепций, общих для других языков. Например, распространенной идиомой в "
"Python является цикл по всем элементам итерируемого объекта с использованием "
"оператора :keyword:`for`. Многие другие языки не имеют конструкции такого "
"типа, поэтому люди, незнакомые с Python, иногда вместо этого используют "
"числовой счетчик:"

#: ../../glossary.rst:1040
msgid "As opposed to the cleaner, Pythonic method::"
msgstr "В отличие от более чистого, идиоматического метода::"

#: ../../glossary.rst:1044
msgid "qualified name"
msgstr "полное имя"

#: ../../glossary.rst:1046
msgid ""
"A dotted name showing the \"path\" from a module's global scope to a class, "
"function or method defined in that module, as defined in :pep:`3155`.  For "
"top-level functions and classes, the qualified name is the same as the "
"object's name::"
msgstr ""
"Имя с точками, показывающее «путь» от глобальной области видимости модуля к "
"классу, функции или методу, определенному в этом модуле, как определено в :"
"pep:`3155`. Для функций и классов верхнего уровня полное имя совпадает с "
"именем объекта::"

#: ../../glossary.rst:1063
msgid ""
"When used to refer to modules, the *fully qualified name* means the entire "
"dotted path to the module, including any parent packages, e.g. ``email.mime."
"text``::"
msgstr ""
"При использовании для ссылки на модули *полное имя* означает полный путь к "
"модулю, включая все родительские пакеты, например ``email.mime.text``::"

#: ../../glossary.rst:1070
msgid "reference count"
msgstr "счётчик ссылок"

#: ../../glossary.rst:1072
msgid ""
"The number of references to an object.  When the reference count of an "
"object drops to zero, it is deallocated.  Reference counting is generally "
"not visible to Python code, but it is a key element of the :term:`CPython` "
"implementation.  Programmers can call the :func:`sys.getrefcount` function "
"to return the reference count for a particular object."
msgstr ""

#: ../../glossary.rst:1078
msgid "regular package"
msgstr "обычный пакет"

#: ../../glossary.rst:1080
msgid ""
"A traditional :term:`package`, such as a directory containing an ``__init__."
"py`` file."
msgstr ""
"Традиционный :term:`пакет`, например каталог, содержащий файл __init__.py``."

#: ../../glossary.rst:1083
msgid "See also :term:`namespace package`."
msgstr "см. также :term:`namespace package`."

#: ../../glossary.rst:1084
msgid "__slots__"
msgstr "__slots__"

#: ../../glossary.rst:1086
msgid ""
"A declaration inside a class that saves memory by pre-declaring space for "
"instance attributes and eliminating instance dictionaries.  Though popular, "
"the technique is somewhat tricky to get right and is best reserved for rare "
"cases where there are large numbers of instances in a memory-critical "
"application."
msgstr ""
"Объявление внутри класса, которое экономит память за счет предварительного "
"объявления места для атрибутов экземпляра и исключения словарей экземпляра. "
"Несмотря на свою популярность, этот метод несколько сложен в освоении, и его "
"лучше использовать в редких случаях, когда в приложении, критически важном к "
"памяти, имеется большое количество экземпляров."

#: ../../glossary.rst:1091
msgid "sequence"
msgstr "последовательность"

#: ../../glossary.rst:1093
msgid ""
"An :term:`iterable` which supports efficient element access using integer "
"indices via the :meth:`~object.__getitem__` special method and defines a :"
"meth:`~object.__len__` method that returns the length of the sequence. Some "
"built-in sequence types are :class:`list`, :class:`str`, :class:`tuple`, "
"and :class:`bytes`. Note that :class:`dict` also supports :meth:`~object."
"__getitem__` and :meth:`!__len__`, but is considered a mapping rather than a "
"sequence because the lookups use arbitrary :term:`immutable` keys rather "
"than integers."
msgstr ""

#: ../../glossary.rst:1102
msgid ""
"The :class:`collections.abc.Sequence` abstract base class defines a much "
"richer interface that goes beyond just :meth:`~object.__getitem__` and :meth:"
"`~object.__len__`, adding :meth:`!count`, :meth:`!index`, :meth:`~object."
"__contains__`, and :meth:`~object.__reversed__`. Types that implement this "
"expanded interface can be registered explicitly using :func:`~abc.ABCMeta."
"register`. For more documentation on sequence methods generally, see :ref:"
"`Common Sequence Operations <typesseq-common>`."
msgstr ""
"Абстрактный базовый класс :class:`collections.abc.Sequence` определяет "
"гораздо более богатый интерфейс, который выходит за рамки просто :meth:"
"`~object.__getitem__` и :meth:`~object.__len__`, добавляя :meth:`!count `, :"
"meth:`!index`, :meth:`~object.__contains__` и :meth:`~object.__reversed__`. "
"Типы, реализующие этот расширенный интерфейс, могут быть зарегистрированы "
"явно с помощью :func:`~abc.ABCMeta.register`. Дополнительную документацию по "
"методам последовательности см. в разделе «Общие операции с "
"последовательностями <typesseq-common>»."

#: ../../glossary.rst:1111
msgid "set comprehension"
msgstr "установленное включение"

#: ../../glossary.rst:1113
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a set with the results. ``results = {c for c in 'abracadabra' if c "
"not in 'abc'}`` generates the set of strings ``{'r', 'd'}``.  See :ref:"
"`comprehensions`."
msgstr ""
"Компактный способ обработки всех или части элементов в итерации и возврата "
"набора с результатами. ``results = {c for c в 'abracadabra', если c не в "
"'abc'}`` генерирует набор строк ``{'r', 'd'}``. См. :ref:`понимания`."

#: ../../glossary.rst:1117
msgid "single dispatch"
msgstr "одиночная диспетчеризация"

#: ../../glossary.rst:1119
msgid ""
"A form of :term:`generic function` dispatch where the implementation is "
"chosen based on the type of a single argument."
msgstr ""
"Форма отправки :term:`generic function`, где реализация выбирается на основе "
"типа одного аргумента."

#: ../../glossary.rst:1121
msgid "slice"
msgstr "срез"

#: ../../glossary.rst:1123
msgid ""
"An object usually containing a portion of a :term:`sequence`.  A slice is "
"created using the subscript notation, ``[]`` with colons between numbers "
"when several are given, such as in ``variable_name[1:3:5]``.  The bracket "
"(subscript) notation uses :class:`slice` objects internally."
msgstr ""
"Объект, обычно содержащий часть :term:`последовательности`. Срез создается с "
"использованием индексной записи ``[]`` с двоеточиями между числами, если их "
"несколько, например, в ``имя_переменной[1:3:5]``. В скобках (индексе) внутри "
"используются объекты :class:`slice`."

#: ../../glossary.rst:1127
msgid "special method"
msgstr "специальный метод"

#: ../../glossary.rst:1131
msgid ""
"A method that is called implicitly by Python to execute a certain operation "
"on a type, such as addition.  Such methods have names starting and ending "
"with double underscores.  Special methods are documented in :ref:"
"`specialnames`."
msgstr ""
"Метод, который Python неявно вызывает для выполнения определенной операции "
"над типом, например сложения. Такие методы имеют имена, начинающиеся и "
"заканчивающиеся двойным подчеркиванием. Специальные методы описаны в :ref:"
"`specialnames`."

#: ../../glossary.rst:1135
msgid "statement"
msgstr "инструкция"

#: ../../glossary.rst:1137
msgid ""
"A statement is part of a suite (a \"block\" of code).  A statement is either "
"an :term:`expression` or one of several constructs with a keyword, such as :"
"keyword:`if`, :keyword:`while` or :keyword:`for`."
msgstr ""
"Оператор является частью пакета («блока» кода). Оператор представляет собой "
"либо :term:`expression`, либо одну из нескольких конструкций с ключевым "
"словом, например :keyword:`if`, :keyword:` while` или :keyword:`for`."

#: ../../glossary.rst:1140
msgid "static type checker"
msgstr "проверка статического типа"

#: ../../glossary.rst:1142
msgid ""
"An external tool that reads Python code and analyzes it, looking for issues "
"such as incorrect types. See also :term:`type hints <type hint>` and the :"
"mod:`typing` module."
msgstr ""
"Внешний инструмент, который читает код Python и анализирует его, выявляя "
"такие проблемы, как неправильные типы. См. также :term:`typehints "
"<typehint>` и модуль :mod:`typing`."

#: ../../glossary.rst:1145
msgid "strong reference"
msgstr "сильная ссылка"

#: ../../glossary.rst:1147
msgid ""
"In Python's C API, a strong reference is a reference to an object which is "
"owned by the code holding the reference.  The strong reference is taken by "
"calling :c:func:`Py_INCREF` when the reference is created and released with :"
"c:func:`Py_DECREF` when the reference is deleted."
msgstr ""
"В API C Python сильная ссылка — это ссылка на объект, владельцем которого "
"является код, содержащий ссылку. Сильная ссылка берется путем вызова :c:func:"
"`Py_INCREF` при создании ссылки и освобождается с помощью :c:func:"
"`Py_DECREF` при удалении ссылки."

#: ../../glossary.rst:1153
msgid ""
"The :c:func:`Py_NewRef` function can be used to create a strong reference to "
"an object. Usually, the :c:func:`Py_DECREF` function must be called on the "
"strong reference before exiting the scope of the strong reference, to avoid "
"leaking one reference."
msgstr ""
"Функцию :c:func:`Py_NewRef` можно использовать для создания сильной ссылки "
"на объект. Обычно функцию :c:func:`Py_DECREF` необходимо вызывать для "
"сильной ссылки перед выходом из области действия сильной ссылки, чтобы "
"избежать утечки одной ссылки."

#: ../../glossary.rst:1158
msgid "See also :term:`borrowed reference`."
msgstr "См. также :term:`borrowed reference`."

#: ../../glossary.rst:1159
msgid "text encoding"
msgstr "кодировка текста"

#: ../../glossary.rst:1161
msgid ""
"A string in Python is a sequence of Unicode code points (in range "
"``U+0000``--``U+10FFFF``). To store or transfer a string, it needs to be "
"serialized as a sequence of bytes."
msgstr ""
"Строка в Python представляет собой последовательность кодовых точек Unicode "
"(в диапазоне ``U+0000``--``U+10FFFF``). Чтобы сохранить или передать строку, "
"ее необходимо сериализовать как последовательность байтов."

#: ../../glossary.rst:1165
msgid ""
"Serializing a string into a sequence of bytes is known as \"encoding\", and "
"recreating the string from the sequence of bytes is known as \"decoding\"."
msgstr ""
"Сериализация строки в последовательность байтов называется «кодированием», а "
"воссоздание строки из последовательности байтов называется «декодированием»."

#: ../../glossary.rst:1168
msgid ""
"There are a variety of different text serialization :ref:`codecs <standard-"
"encodings>`, which are collectively referred to as \"text encodings\"."
msgstr ""
"Существует множество различных сериализаций текста :ref:`кодеков <standard-"
"encodings>`, которые в совокупности называются «текстовыми кодировками»."

#: ../../glossary.rst:1171
msgid "text file"
msgstr "текстовый файл"

#: ../../glossary.rst:1173
msgid ""
"A :term:`file object` able to read and write :class:`str` objects. Often, a "
"text file actually accesses a byte-oriented datastream and handles the :term:"
"`text encoding` automatically. Examples of text files are files opened in "
"text mode (``'r'`` or ``'w'``), :data:`sys.stdin`, :data:`sys.stdout`, and "
"instances of :class:`io.StringIO`."
msgstr ""
"Объект :term:`file`, способный читать и записывать объекты :class:`str`. "
"Часто текстовый файл фактически обращается к байтовому потоку данных и "
"автоматически обрабатывает кодировку текста. Примерами текстовых файлов "
"являются файлы, открытые в текстовом режиме (``'r'`` или ``'w'``), :data:"
"`sys.stdin`, :data:`sys.stdout` и экземпляры: класс:`io.StringIO`."

#: ../../glossary.rst:1180
msgid ""
"See also :term:`binary file` for a file object able to read and write :term:"
"`bytes-like objects <bytes-like object>`."
msgstr ""
"См. также :term:`двоичный файл` для описания файлового объекта, способного "
"читать и записывать :term:`байтоподобные объекты <байтоподобный объект>`."

#: ../../glossary.rst:1182
msgid "triple-quoted string"
msgstr "строка в тройных кавычках"

#: ../../glossary.rst:1184
msgid ""
"A string which is bound by three instances of either a quotation mark (\") "
"or an apostrophe (').  While they don't provide any functionality not "
"available with single-quoted strings, they are useful for a number of "
"reasons.  They allow you to include unescaped single and double quotes "
"within a string and they can span multiple lines without the use of the "
"continuation character, making them especially useful when writing "
"docstrings."
msgstr ""
"Строка, которая связана тремя экземплярами кавычки (\") или апострофа ('). "
"Хотя они не предоставляют каких-либо функций, недоступных для строк в "
"одинарных кавычках, они полезны по ряду причин. Они позволяют вы можете "
"включать в строку неэкранированные одинарные и двойные кавычки, и они могут "
"охватывать несколько строк без использования символа продолжения, что делает "
"их особенно полезными при написании строк документации."

#: ../../glossary.rst:1191
msgid "type"
msgstr "тип"

#: ../../glossary.rst:1193
msgid ""
"The type of a Python object determines what kind of object it is; every "
"object has a type.  An object's type is accessible as its :attr:`~instance."
"__class__` attribute or can be retrieved with ``type(obj)``."
msgstr ""

#: ../../glossary.rst:1197
msgid "type alias"
msgstr "псевдоним типа"

#: ../../glossary.rst:1199
msgid "A synonym for a type, created by assigning the type to an identifier."
msgstr "Синоним типа, созданный путем присвоения этому типу идентификатора."

#: ../../glossary.rst:1201
msgid ""
"Type aliases are useful for simplifying :term:`type hints <type hint>`. For "
"example::"
msgstr ""
"Псевдонимы типов полезны для упрощения :term:`typehints <typehint>`. "
"Например::"

#: ../../glossary.rst:1208
msgid "could be made more readable like this::"
msgstr "можно было бы сделать более читабельным вот так::"

#: ../../glossary.rst:1215 ../../glossary.rst:1229
msgid "See :mod:`typing` and :pep:`484`, which describe this functionality."
msgstr "See :mod:`typing` and :pep:`484`, which describe this functionality."

#: ../../glossary.rst:1216
msgid "type hint"
msgstr "введите подсказку"

#: ../../glossary.rst:1218
msgid ""
"An :term:`annotation` that specifies the expected type for a variable, a "
"class attribute, or a function parameter or return value."
msgstr ""
":term:`annotation`, указывающая ожидаемый тип переменной, атрибута класса "
"или параметра функции или возвращаемого значения."

#: ../../glossary.rst:1221
msgid ""
"Type hints are optional and are not enforced by Python but they are useful "
"to :term:`static type checkers <static type checker>`. They can also aid "
"IDEs with code completion and refactoring."
msgstr ""
"Type hints are optional and are not enforced by Python but they are useful "
"to :term:`static type checkers <static type checker>`. They can also aid "
"IDEs with code completion and refactoring.\n"
"Подсказки типов не являются обязательными и не применяются Python, но они "
"полезны для  :term:`static type checkers <static type checker>``. Они также "
"могут помочь IDE в дополнении кода и рефакторинге."

#: ../../glossary.rst:1225
msgid ""
"Type hints of global variables, class attributes, and functions, but not "
"local variables, can be accessed using :func:`typing.get_type_hints`."
msgstr ""
"Доступ к подсказкам типов глобальных переменных, атрибутов классов и "
"функций, но не локальных переменных, можно получить с помощью :func:`typing."
"get_type_hints`."

#: ../../glossary.rst:1230
msgid "universal newlines"
msgstr "универсальные переводы строк"

#: ../../glossary.rst:1232
msgid ""
"A manner of interpreting text streams in which all of the following are "
"recognized as ending a line: the Unix end-of-line convention ``'\\n'``, the "
"Windows convention ``'\\r\\n'``, and the old Macintosh convention "
"``'\\r'``.  See :pep:`278` and :pep:`3116`, as well as :func:`bytes."
"splitlines` for an additional use."
msgstr ""
"Способ интерпретации текстовых потоков, при котором все следующее "
"распознается как завершение строки: соглашение Unix о конце строки "
"``'\\n'``, соглашение Windows ``'\\r\\n'``, и старое соглашение Macintosh "
"``'\\r'``. См. :pep:`278` и :pep:`3116`, а также :func:`bytes.splitlines` "
"для дополнительного использования."

#: ../../glossary.rst:1237
msgid "variable annotation"
msgstr "переменная аннотация"

#: ../../glossary.rst:1239
msgid "An :term:`annotation` of a variable or a class attribute."
msgstr ":term:`annotation` к переменной или атрибуту класса."

#: ../../glossary.rst:1241
msgid ""
"When annotating a variable or a class attribute, assignment is optional::"
msgstr ""
"При аннотации переменной или атрибута класса присвоение не является "
"обязательным::"

#: ../../glossary.rst:1246
msgid ""
"Variable annotations are usually used for :term:`type hints <type hint>`: "
"for example this variable is expected to take :class:`int` values::"
msgstr ""
"Аннотации переменных обычно используются для :term:`typehints <typehint>`: "
"например, ожидается, что эта переменная будет принимать значения :class:"
"`int`::"

#: ../../glossary.rst:1252
msgid "Variable annotation syntax is explained in section :ref:`annassign`."
msgstr "Синтаксис аннотаций переменных описан в разделе :ref:`annassign`."

#: ../../glossary.rst:1254
msgid ""
"See :term:`function annotation`, :pep:`484` and :pep:`526`, which describe "
"this functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"См. :term:`function annotation`, :pep:`484` и :pep:`526`, которые описывают "
"эту функциональность. Также см. :ref:`annotations-howto` для получения "
"рекомендаций по работе с аннотациями."

#: ../../glossary.rst:1258
msgid "virtual environment"
msgstr "виртуальное окружение"

#: ../../glossary.rst:1260
msgid ""
"A cooperatively isolated runtime environment that allows Python users and "
"applications to install and upgrade Python distribution packages without "
"interfering with the behaviour of other Python applications running on the "
"same system."
msgstr ""
"См. :term:`function annotation`, :pep:`484` и :pep:`526`, которые описывают "
"эту функциональность. Также см. :ref:`annotations-howto` для получения "
"рекомендаций по работе с аннотациями."

#: ../../glossary.rst:1265
msgid "See also :mod:`venv`."
msgstr "см. также :mod:`venv`."

#: ../../glossary.rst:1266
msgid "virtual machine"
msgstr "виртуальная машина"

#: ../../glossary.rst:1268
msgid ""
"A computer defined entirely in software.  Python's virtual machine executes "
"the :term:`bytecode` emitted by the bytecode compiler."
msgstr ""
"Компьютер полностью определяется программным обеспечением. Виртуальная "
"машина Python выполняет :term:`байт-код`, созданный компилятором байт-кода."

#: ../../glossary.rst:1270
msgid "Zen of Python"
msgstr "Дзен Python"

#: ../../glossary.rst:1272
msgid ""
"Listing of Python design principles and philosophies that are helpful in "
"understanding and using the language.  The listing can be found by typing "
"\"``import this``\" at the interactive prompt."
msgstr ""
"Список принципов и философий проектирования Python, которые помогут понять и "
"использовать язык. Список можно найти, набрав «``import this``» в "
"интерактивной подсказке."

#: ../../glossary.rst:264
msgid "C-contiguous"
msgstr "С-непрерывный"

#: ../../glossary.rst:264
msgid "Fortran contiguous"
msgstr "Непрерывность Fortran"

#: ../../glossary.rst:761
msgid "magic"
msgstr "магия"

#: ../../glossary.rst:1129
msgid "special"
msgstr "особенный"
